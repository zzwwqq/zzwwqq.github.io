<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于HTTP]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EHTTP.html</url>
    <content type="text"><![CDATA[一、区分URI,URL,URN:URI 包含 URL 和 URN。 二、关于HTTP协议:2.1 是什么?是一个基于(客户端/服务器)请求与响应模式的、无连接, 无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 2.2 HTTP协议的主要特点?①: 无连接： 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 ②: 无状态： HTTP协议是无状态协议, 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 ③: 传输数据类型灵活： HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 ④: 传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2.3 HTTP请求报文:请求行,请求头,请求空行,请求体 2.4 HTTP响应报文:状态行,响应头,响应空行,响应体 2.5 HTTP方法:客户端发送的 请求报文 第一行为请求行，包含了方法字段。 有九种方法: get,post,put,delete,head,patch,options,connect,trace HEAD:①: 作用: 获取报文首部②: 和 GET 方法类似，但是不返回报文实体主体部分。③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST: 作用: 传输实体主体POST 主要用来传输数据，而 GET 主要用来获取资源。 PUT:①: 作用: 上传文件②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PATCH:①: 作用: 对资源进行部分修改②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 OPTIONS:①: 作用: 查询支持的方法②: 查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT:①: 要求在与代理服务器通信时建立隧道②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 TRACE:①: 追踪路径②: 服务器会将通信路径返回给客户端。③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 2.6 关于HTTP状态码:服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理100 ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应 2XX Success（成功状态码） 请求正常处理完毕200 OK 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求301 ：永久性重定向302：临时性重定向 4XX Client Error（客户端错误状态码） 服务器无法处理请求403 Forbidden ：请求被拒绝。404 Not Found 5XX Server Error（服务器错误状态码） 服务器处理请求出错500 Internal Server Error ：服务器正在执行请求时发生错误。503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 2.7 : 连接管理:2.7.1 短连接与长连接:①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2.7.2 流水线:①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。 2.7.3 Cookie:①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 ②: Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 ③: Cookie有什么用途? 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） ④: Cookie的创建过程: 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry ⑤: Cookie的分类: 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; ⑥: HttpOnly: 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。 跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly ⑦: Secure: 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 2.7.4 Session:①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 ③: 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 ④: 浏览器禁用 Cookie: 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 2.7.5 Cookie 与 Session 选择: Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 2.8 常见端口:Http端口80, HTTPS端口443 DNS端口 53 FTP 端口21 SMTP端口 25 三、HTTP/1.1 新特性:①: 默认是长连接②: 支持流水线③: 支持同时打开多个 TCP 连接④: 支持虚拟主机⑤: 新增状态码 100⑥: 支持分块传输编码⑦: 新增缓存处理指令 max-age 四、GET 和 POST 比较:从作用上来说: GET 用于获取资源，而 POST 用于传输实体主体。 从参数来说:GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 从缓存来说: 如果要对响应进行缓存，需要满足以下条件： ①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest: 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 ①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。②: 而 GET 方法 Header 和 Data 会一起发送。 五: 关于HTTPS:5.1 HTTP 有以下安全性问题：①: 使用明文进行通信，内容可能会被窃听；②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；③: 无法证明报文的完整性，报文有可能遭篡改。 5.2 什么是HTTPS?HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改） 5.3 什么是SSL?SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 5.4 什么是TLS?TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 5.5 HTTPS的缺点: ①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐②: HTTPS 降低用户访问速度（多次握手）③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密） 六、关于加密:6.1 对称密钥加密:(Symmetric-Key Encryption)①: 有流式、分组两种，加密和解密都是使用的同一个密钥。例如：DES、AES-GCM、ChaCha20-Poly1305等 优点：运算速度快；缺点：无法安全地将密钥传输给通信方。 6.2 非对称密钥加密:①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、DH、ECDHE ②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(发消息: 公钥加密,私钥解密)③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(签名: 私钥加密,公钥解密) 优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。 6.3 哈希算法:将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 6.4 数字签名:签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP 6.3 HTTPS 采用的加密方式:HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率. 七、关于认证:通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 签名: 签名者的私钥加密, 认证: 使用签名者公钥解密 八、完整性保护:①: SSL 提供报文摘要功能来进行完整性保护。②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 九、关于代理:9.1 代理服务器接受客户端的请求，并且转发给其它服务器。9.2 使用代理的主要目的是：①: 缓存②: 负载均衡③: 网络访问控制④: 访问日志记录 9.3 代理服务器分为正向代理和反向代理两种：举例: 十、关于缓存:10.1 优点:①: 缓解服务器压力；②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 10.2 实现方法①: 让代理服务器进行缓存；②: 让客户端浏览器进行缓存。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>关于HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串]]></title>
    <url>%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[一、字符串的特性:String 被声明为 final，因此它不可被继承。 二、不同JDK版本中String的区别:①: 在 Java 8 中，String 内部使用 char 数组存储数据。 ②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 三、String 与StringBuffer,StringBuilder的区别：3.1 可变性:String的长度是不可变的，而StringBuffer和StringBuilder长度是可变的. 也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中. 3.2 线程安全:String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StringBuffer的常用方法: StringBuffer和StringBuilder和String的效率比较: 1234567891011121314151617181920212223242526272829@Testpublic void test2() &#123; long startTime = 0L; long endTime = 0L; String text = ""; StringBuffer buffer = new StringBuffer(""); StringBuilder builder = new StringBuilder(""); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuffer的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuilder的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println("String的执行时间：" + (endTime - startTime));&#125; 四、字符串与其他数据类型的转换: 4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)A ———&gt; B: 调用B的方法:①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法 4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)字符串———&gt;数组 调用字符串的方法数组————&gt;字符串 调用字符串的构造器 ③: 字符串——-&gt;字节数组 调用字符串的getBytes()④: 字符串——-&gt;字符数组 调用字符串的toCharArray() ⑤: 字节数组——&gt;字符串 调用字符串的构造器⑥: 字符数组——&gt;字符串 调用字符串的构造器 五、字符串常量池（String Pool）:①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 ②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 ③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 六、字符串字面量 和字符串对象:字面量指的是能够使用简单结构和符号创建对象的表达式。如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。 七、new String(“abc”)创建了几个对象?使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 12345public class NewStringTest &#123; public static void main(String[] args) &#123; String s = new String("abc"); &#125;&#125; 五个关于字符串的算法题: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 * 1. 模拟一个trim方法，去除字符串两端的空格 。 * 2. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 * 3. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。 * 4. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = "abcwercvhelloobnm"。 * 5.对字符串中字符进行自然排序 // 1. 模拟trim方法，去除字符串两端的空格 public static String myTrim(String str) &#123; int start = 0; int end = str.length() - 1; // 判断字符串str前面是否有空格 while (start &lt;= end &amp;&amp; str.charAt(start) == ' ') &#123; start++; &#125; System.out.println(start); // 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常 while (start &lt;= end &amp;&amp; str.charAt(end) == ' ') &#123; end--; &#125; System.out.println(end); // 方法一： char[]a = new char[end-start+1]; int j = 0; for (int i = start; i &lt;= end; i++,j++) &#123; System.out.print(i+" "); a[j] = str.charAt(i); &#125; System.out.println(); //将字符数组转换为字符串 String str1 = new String(a); return str1; // // 方法二：// return str.substring(start, end + 1); &#125; // 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一) public static String myReverseString(String str, int start, int end) &#123; //字符串转换为字符数组 char[] c = str.toCharArray(); return myreverseArray(c, start, end); &#125; public static String myreverseArray(char[] c, int start, int end)&#123; for (int i = start,j = end; i &lt; j; i++,j--) &#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; &#125; //字符数组转换为字符串 return new String(c); &#125;&#125; // 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二） public static String reverseString2(String str, int start, int end) &#123; String str1 = str.substring(0,start); for (int i = end; i &gt;= start; i--) &#123; char c = str.charAt(i); str1 += c; &#125; str1 += str.substring(end + 1); return str1; &#125; // 3. 获取一个字符串在另一个字符串中出现的次数. // 判断str2 在 str1 中出现的次数 // 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取 public static int getTime(String str1, String str2) &#123; int count = 0; int length; while ((length = str1.indexOf(str2)) != -1) &#123; count++; str1 = str1.substring(length + str2.length()); &#125; return count; &#125; // 4. 获取两个字符串中最大相同字串。 public static List&lt;String&gt; getMaxSubString(String str1, String str2) &#123; String maxStr = (str1.length() &gt; str2.length())? str1:str2; String minStr = (str1.length() &lt; str2.length())? str1:str2; int length = minStr.length(); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; length; i++) &#123; for (int x = 0,y = length - i; y &lt;= length; x++,y++) &#123; String str = minStr.substring(x,y); if (maxStr.contains(str)) &#123; list.add(str); &#125; &#125; if (list.size() != 0) &#123; return list; &#125; &#125; return null; &#125; //5.对字符串中字符进行自然排序 public static String mySort(String str) &#123; char[]c = str.toCharArray(); Arrays.sort(c); return new String(c); &#125; public class StringDemo &#123; public static void main(String[] args) &#123; // @Test-myTrim String testString1 = " abc d "; // 特殊情况 String testString2 = " "; String str1 = StringDemo.myTrim(testString1); String str2 = StringDemo.myTrim(testString2); System.out.println("----" + str1 + "----"); System.out.println("----" + str2 + "----"); // 验证 String str3 = str1.trim(); String str4 = str2.trim(); System.out.println("----" + str3 + "----"); System.out.println("----" + str4 + "----"); // @Test-myReverseString and myReverseArray String str5 = "abcdefg"; String str6 = myReverseString(str5, 2, 5); System.out.println("原字符串：" + str5); System.out.println("指定部分反转-法一：" + str6); String str7 = "abcdefg"; String str8 = reverseString2(str7, 2, 5); System.out.println("指定部分反转-法二：" + str8); int count = getTime("abkkcadkabkebfkabkskab", "abk"); System.out.println("出现次数为：" + count); List&lt;String&gt; str9 = getMaxSubString("abcwerathelloyuiodef", "abcwercvhellobnm"); System.out.println(str9); String str10 = "aediewfn"; String str11 = mySort(str10); System.out.println(str11); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2Fjava%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[一、先来看两张图: 二、集合的分类:2.1 Collection接口:List接口：存储有序，可重复的元素 ,遍历出来的顺序与添加顺序相同 Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的位置无序))，不可重复的元素(不可 重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都 是Collection下定义的 2.2 Map接口:注：Map接口不是Collection接口的子接口, 两者是并列关系 三、关于List接口:3.1 List接口：存储有序，可重复的元素 遍历出来的顺序与添加顺序相同 3.2 具体的实现类:①: ArrayList(主要的实现类)②: LinkedList(对于频繁的插入，删除操作 较适用)③: Vector(古老的实现类，线程安全的，但效率低于ArrayList) 四、关于Set接口:4.1 需要注意的是:①: 通常说的” Set是无序的, 不可重复的 “ 这句话中的无序是指的存储无序. ②: 无论是HashSet,还是LinkedHashSet 存储都是无序, 且不可重复的元素((指的是元素在底层存放的位置无序))③: 遍历是分为有序和无序的 , HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历. 4.2 如何保证set中元素不可重复?要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),重写hashCode（）方法让同一个对象能算出相同的hashCode值,, 进而保证Set中元素的不可重复性,, 注意:List只用重写equals方法就可以了 4.3 Set中元素是如何存储的呢？使用了哈希算法当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复). 要求：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false; ) 万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此） 4.4 具体的实现类:①: HashSet(主要的实现类)②: LinkedHashSet(HashSet的子类)③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口) 注: 一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer 又存储String类型) 4.4.1 关于TreeSet:当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）②定制排序：（实现Comparator接口，重写compare方法） 两种排序的区别: 前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法. 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 注: 只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 compareTo()与hashCode()以及equals()三者保持一致！ 五、关于Map接口:5.1 Map接口元素的存储原理: Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，需要重写hashCode和equals方法, 进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复 例如:向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(后面的会覆盖前面的,这个与HashSet不同,HashSet是后面的那个不能添加进来)。 5.2 遍历Map:有三类，分别是遍历key，遍历value，遍历key-value对 1234567891011121314151617181920//1.遍历key集Set set = map.keySet();//2.遍历value集Collection values = map.values();//3.遍历key-value对Set set2 = map.entrySet(); //所有entry的集合就是entrySetfor (Object obj:set2) &#123; //遍历entrySet得到entryMap.Entry entry = (Map.Entry)obj; //获取entry//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键 和 值 System.out.println(entry);&#125; 5.3 Map的初始化:不能初始化为: Map&lt;String,List&gt;map=null;而要用new对象的方式：Map&lt;String,List&gt;map=newHashMap&lt;String,List&gt;();否则会报错 5.4 从map中取值:正确方法: 123456方法一: String str = String.valueOf(map.get("键名"));方法二: String str = (String) map.get("ACCEPT_CHANNEL");if (null != str &amp;&amp; !"".equals(str)) &#123;…………&#125; 错误的取值方法： 1String str = map.get("键名").toString; //如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常 注: Map中的Key value可以是任何引用类型的数据 5.5 Map接口的具体实现类:①: HashTable : 古老的实现类，线程安全，不建议使用②: HashMap:③: LinkedHashMap(是HashMap的子类)④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口) 5.5.1 Properties介绍:Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的 123456789101112131415读取属性文件jdbc.properties: Properties pros = new Properties();FileInputStream fi = new FileInputStream(new File("jdbc.properties"));pros.load(fi);读取xml配置文件config.xml: Properties properties = new Properties();InputStream configInputStream = new FileInputStream("config/config.xml");properties.loadFromXML(configInputStream); 六、关于Collections 工具类:6.1 作用: 操作Collection以及Map 6.2 注意: 区分Collection与Collections 6.3 实现list的复制: 12345678910//错误的方式：出现java.lang.indexOutOfBoundsException//List list1=new ArrayList();//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1//System.out.println(list1); //正确的方式List list2 = Arrays.asList(newObject[list.size()]);Collections.copy(list2,list);System.out.println(list2);//[123,456,12,78,456] 6.4 考虑线程安全问题: List 是线程不安全的, synchronizedList方法可以保证List线程安全 123//通过如下的方法保证list的线程安全List list3=Collections.synchronizedList(list);System.out.println(list3); 6.5常用函数: 123456reverse(List)：反转List中元素的顺序shuffle(List)：对List集合元素进行随机排序sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序swap(List,int,int)：将指定list集合中的i处元素和j处元素进行交换void copy(List dest,List src)://将src中的内容复制到dest中 七、集合的遍历方法：四种①使用Iterator迭代器 ②增强型for循环 ③普通for循环 ④Iterator迭代器的”古老版本”Enumeration 接口 123456789//Enumeration 接口是Iterator迭代器的"古老版本"public class TestEnumeration &#123; public static void main(String[] args) &#123; Enumeration enu = new StringTokenizer("ab-c*-df-g", "-"); while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement()); &#125; &#125;&#125; 12345678910111213//面试题@Testpublic void test5()&#123; //结果: 输出MM MM MM AA BB DD String[]str=new String[]&#123;"AA","BB","DD"&#125;; //表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值 for(String s:str)&#123; //每循环一次, s都是一个新的局部变量 s="MM"; System.out.println(s); &#125; for(int i=0;i&lt;str.length;i++)&#123; System.out.println(str[i]); &#125;&#125; 八、关于数组:存储对象可以考虑：①数组，②集合数组存储对象的特点：Student[] stu = new Student[20]; stu[0]=new Student();…..弊端：①一旦创建，其长度不可变. ②真实的数组存放的对象的个数是不可知的 九、总结:①: 单类型: 一个TreeSet对象必须存储同一种数据类型,例如: 不能既存储Integer 又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型. ②: 一致性: 使用TreeSet时: compareTo()与hashCode()以及equals()三者保持一致！ ③: 执行流程： 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 ④: 顺序性: Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)Set而言: 遍历是分为有序和无序的 , 其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[一、数据类型:1.1 基本数据类型：1.1.1 整数类型：byte（1个字节） -128（-2^7）——– 127 (2^7-1)short（2） -32768(-2^15)——- 32767(2^15-1)int（4） （-2)^31 —— 2^31-1long(8) （-2)^63 —— 2^63-1 整数有三种表示形式： 八进制：以0开头，如012，-027 十进制： 十六进制：以0x 或0X开头，如0x123,-0X12 1.1.2 浮点类型：float（4） 6或7位有效数字double（8） 15位有效数字带小数点的数默认为：双精度浮点型（double），数字后带“d 或 D”，如“2.3d”，“d 或 D”可以省略注意：要表示单精度浮点型（float），必须在数字后面加“f 或 F”，如“13.23f”,“f 或 F”不可省略 1.1.3 字符类型：char（2） 1.1.4 布尔类型boolean：false（4）必须小写true（4）必须小写 JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 1.2 引用数据类型：①: 类(class) 如String类②: 接口(interface)③: 数组④: 枚举（enum） 1.3 包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 二、常量与变量①: 常量：由final修饰的 ②: 变量： 局部变量（位于方法（一般方法，构造方法，程序入口方法）中） 全局变量（１.实例变量（无static修饰），２.类变量也称静态变量（有static修饰）） 三、强制类型转换:3.1 小的转换为大的，系统会自动完成强制类型转换如：short i = 10; int j; j=i; (系统自动完成j = (int)i )3.2 大的转换为小的，必须进行手动完成强制类型转换如：int i = 10; short j; j = (short)i; 四、构造方法:4.1 特点：①: 构造方法只能由new操作符调用，即建立对象时自动调用；②: 构造方法可以重载，即在同一个类中可以有多个构造方法③: 构造方法没有返回类型，甚至连void也没有④: 构造方法与类同名 注: 如果没有在类中写构造方法，系统会生成一个默认的无参构造方法，并使用默认值初始化对象的属性（int变量初始化为0，boolean 变量初始化为false）,如果写了有参构造方法,那么系统不会再自动生成无参构造方法,如果此时我们要用无参构造方法,需要我们手动写无参构造方法. 4.2 作用：初始化对象，如给数据成员赋值注意：一旦创建了一个有参数的构造方法，系统就不会自动添加默认的无参构造方法，要想用无参构造方法，需要人为的去创建一个无参构造方法 五、注释:①: 文件注释：在包名之上，“/*……*/”，描述文件名(java工程名)，版权信息②: 类注释：“/**……*/”，描述类的作用，版本version ，日期，作者③: 私有成员：“/*……*/” 或“//”；如局部变量，某一个语句的功能作用 * @param 描述方法的参数 * @return 描述返回值，对于无返回值的方法或构造方法，@return可以省略 * @throws 描述在什么情况下抛出什么类型的异常 * @author 描述作者 * @version 描述版本 * @since 描述该类可以运行的JDK版本 * @see 参考转向，也就是相关主题 * @link 转向成员的超链接。label为链接文字。package.class#member将被自动转换为指向package.class的member文件的URL ④: 共有成员：“/**……..*/”；如构造方法 六、继承（extends）6.1 含义:其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正每次调子类的时候都会“自动运行”它父类的构造函数，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”。 6.2 java中子类能不能继承父类构造方法？答案是不能*理由：其实每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。所以父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法 注意“调用”和继承不是一个含义，实质上是“自动运行”。 七、关于JavaBean:符合如下标准的Java类：①: 实现serializable接口（这个不是必须的）②: 必须有一个无参的公共的构造器（public修饰）③: 必须属性用private修饰，且有get，set方法 八、权限修饰符： 九、抽象类：特点：必须含抽象方法，其他的和一般类一样抽象方法：只有声明没有实现的方法 十、接口：10.1 特点：只含常量和抽象方法①: 接口中的常量都是public static final 类型(可以省略)，这是系统默认的②: 接口中的方法都是public abstract类型(可以省略)，这是系统默认的③: 接口 作为一种引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的该接口中的方法一个类要实现接口，必须实现这个接口中的所有方法 注意：通过一个接口变量只能调用该接口所声明的方法。 十一、重载和重写区别:方法重载（Overload）：一个类中有多个方法，名字相同，参数不同（如参数个数，种类，参数顺序不同），与返回值无关；方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同 十二、面向对象编程的四个基本特征:①：抽象:②：封装：把对象的数据和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节③：继承：④：多态性：多态的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。 多态的举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态的作用：消除类型之间的耦合关系 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 重载和重写都是多态的体现. 十三、异常与错误:12.1 异常:12.1.1 编译异常： 由于程序语法不合规范，编译不通过 12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）： 编译通过，运行时出现异常。如数组下标越界，除数为零，数字格式错误，空指针异常 12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）： 如类没找到，IO操作错误 12.1.4 逻辑异常： 输出的结果不符合预期的要求 12.1.5 try ,catch ,finally只有三种组合：​ a. try…catch…finally ​ b. try…catch ​ c. try…finally ①: 异常发生时，如果匹配的catch语句中抛出（有throw关键字）了异常，则finally之外的语句将不能被执行 ②: finally中的语句无论什么情况都会执行 ③: 得到有关异常信息：getMessage() ④: 用来跟踪异常事件发生时执行堆栈的内容：printStackTrace（） 12.1.6 throws 和 throw 的区别：throws 关键字用于方法的声明部分，说明方法可能抛出的异常类型throw 关键字用来抛出异常，如果抛出了检查性异常（非运行时异常），还必须在方法头部声明方法可能抛出的异常类，该方法的调用者还必须捕获处理抛出的异常,如果抛出非检查性异常（运行时异常），该方法的调用者可捕获可不捕获异常 12.2 错误（Error）：①：虚拟机错误（Virtual Machine Error）②：连接错误（LinkageError）③：图形界面错误（AWTError） 十四、日期与时间:13.1 java中主要使用三个类来处理日期和时间:①: java.util.Date(日期) , ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的毫秒数 ②: java.util.Calendar（日历） , ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分 ③: java.text.DateFormat（日期格式化）————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写有要求 13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 150658200000013.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 201713.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识java]]></title>
    <url>%2F%E5%88%9D%E8%AF%86java.html</url>
    <content type="text"><![CDATA[一、发展历史①: java语言前身是oak（橡树）语言②: java于1995年诞生于sun公司③: 1996第一个JDK诞生④: 1999 Sun发布J2SE，J2EE ,J2ME 二、语言特点①: 面向对象②: 分布式多线程③: 健壮性(异常处理)④: 安全⑤: 可移植性 三、Java技术体系分四个平台:①: Java Card: java小程序运行在小内存设备(智能卡)上的平台.②: Java ME: 移动终端(手机)③: JavaSE: 桌面级(Windows下的应用程序)④: JavaEE : 以前称J2EE ,企业级 四、JDK和JREJDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器) JDK目录结构:①: bin目录：包含编译器（javac.exe（c是compile（编译）的缩写）），解释器（java.exe），帮助文档生成器（javadoc.exe），打包工具（jar.exe），小应用程序浏览工具（appletviewer.exe） ②: lib目录：包含类库文件 ③: demo目录：包含各种演示例子 ④: include目录：包含C语言头文件，支持java本地接口 ⑤: jre目录：包含java虚拟机，java应用启动器，运行时的类包 ⑥: sample目录：sun配带的帮助学习者学习的java例子 ⑦: src.zip:源码压缩文件 JDK: Java程序设计语言 + Java 虚拟机 + JavaAPI类库 JRE : JavaAPI中的Java SE API + Java虚拟机 因此 JDK包含JRE 五、java虚拟机是什么？(Java Virtual Machine) 简称JVM Java语言写的代码是.java文件，它会被特定程序编译(javac.exe，它会被Eclipse之类的IDE调用)成字节码(bytecode)，字节码不能直接在CPU上运行，需要另一个程序读取并执行，这个部件就是java虚拟机，它像机器一样运行编译好的java字节码，就像机器直接执行机器码一样……java虚拟机的外部接口在windows下主要是jvm.dll这个文件……简言之：jvm是Java开发语言中，用来运行Java字节码文件的平台；提供对Java字节码的解释及运行，位于JRE中JRE: java运行环境,包含java虚拟机和java程序所需的核心类库(javaSE API) 。如果只是想跑java程序，那么只需安装JRE，如果要写java程序，那就需要JDK了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之内存分配和回收]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6.html</url>
    <content type="text"><![CDATA[一、内存分配策略:1. 对象优先在 Eden 分配:大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 2. 大对象直接进入老年代:①: 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。②: 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。⑤: -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 3. 长期存活的对象进入老年代:①: 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。②: -XX:MaxTenuringThreshold 用来定义年龄的阈值。 4. 动态对象年龄判定:虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保:在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Minor GC 的触发条件: 当 Eden 空间满时，就将触发一次 Minor GCFull GC 的触发条件:①: 老年代空间不足: 解决方案： ①：尽量不要创建过大的对象以及数组 ②：通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 ③：通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 ②: 空间分配担保失败 ③: 调用 System.gc(): 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 ④：JDK 1.7 及以前的永久代空间不足 解决方案： ①：可采用的方法为增大永久代空间 ②：转为使用 CMS GC。 二、内存回收：2.1 GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。2.1.1 Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。 2.1.2 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-3无重复字符的最长子串]]></title>
    <url>%2FLeetCode-3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    <content type="text"><![CDATA[题目:给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "kew"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 分析:给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。 我们先不考虑代码怎么实现，如果给一个例子中的例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉第一次出现的b，以此类推，最终发现最长的长度为3。 所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。 进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。 参考链接:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之垃圾收集]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[一、垃圾收集:1.1哪些区域需要垃圾收集:①: 垃圾收集主要是针对堆和方法区进行。②: 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 二、判断一个对象是否可被回收:2.1 引用计数算法:为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011121314public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); &#125;&#125; 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。 2.2 可达性分析算法:以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： ①: 虚拟机栈中局部变量表中引用的对象 ②: 本地方法栈中 JNI 中引用的对象 ③: 方法区中类静态属性引用的对象 ④: 方法区中的常量引用的对象 2.3 方法区的回收①: 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 ②: 主要是对常量池的回收和对类的卸载。 ③: 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 ④: 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 2.4. finalize()类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 三、引用类型:无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型:3.1 强引用被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 3.2 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.3 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的: 是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 四、垃圾收集算法:4.1 标记 - 清除: 标记要回收的对象，然后清除。不足：标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 4.2 标记 - 整理:让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 4.3 复制: 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足: 是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 4.4 分代收集:现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 五、垃圾收集器:HotSpot 虚拟机中的 7 个垃圾收集器: 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 5.1 Serial 收集器:Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 5.2ParNew 收集器:它是 Serial 收集器的多线程版本。 它是Server场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 5.3 Parallel Scavenge 收集器:与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值 5.4 Serial Old 收集器:是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5.5 Parallel Old 收集器:是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 5.6 CMS 收集器:CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 具有以下缺点：①: 吞吐量低：②: 无法处理浮动垃圾: 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。③: 标记 - 清除算法导致空间碎片 5.7 G1 收集器:G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA.html</url>
    <content type="text"><![CDATA[一、JVM是什么?JVM是Java Virtual Machine（Java虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 二、JVM的作用?JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码字节码，就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 三、从进程的角度解释JVM我们知道，虚拟机是运行在操作系统之中的，那么什么东西才能在操作系统中运行呢？当然是进程，因为进程是操作系统中的执行单位。可以这样理解，当它在运行的时候，它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放于文件系统中），可以把它叫做程序。 对命令行比较熟悉的同学，都知道其实一个命令对应一个可执行的二进制文件，当敲下这个命令并且回车后，就会创建一个进程，加载对应的可执行文件到进程的地址空间中，并且执行其中的指令。 四、Java版HelloWord程序的编译和执行形式:①: 首先编写源文件HelloWord.java ： 12345 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; ②: 编译Java版的HelloWorld程序：$ javac HelloWorld.java ③: 运行Java版的HelloWorld程序：$ java -classpath . HelloWorld 4.1 从上面的过程可以看到， 我们在运行Java版的HelloWorld程序的时候， 敲入的命令并不是 ./HelloWorld.class 。 因为class文件并不是可以直接被操作系统识别的二进制可执行文件 。 我们敲入的是java这个命令。 这个命令说明， 我们首先启动的是一个叫做java的程序， 这个java程序在运行起来之后就是一个JVM进程实例. 4.2 上面的命令执行流程是这样的： java命令首先启动虚拟机进程，虚拟机进程成功启动后，读取参数“HelloWorld”，把他作为初始类加载到内存，对这个类进行初始化和动态链接，然后从这个类的main方法开始执行。 也就是说我们的.class文件不是直接被系统加载后直接在cpu上执行的，而是被一个叫做虚拟机的进程托管的。首先必须虚拟机进程启动就绪，然后由虚拟机中的类加载器加载必要的class文件，包括jdk中的基础类（如String和Object等），然后由虚拟机进程解释class字节码指令，把这些字节码指令翻译成本机cpu能够识别的指令，才能在cpu上运行. 4.3 从这个层面上来看，在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。 五、JVM体系结构简介: 根据上图表达的内容，我们编译之后的class文件是作为Java虚拟机的原料被输入到Java虚拟机的内部的，那么具体由谁来做这一部分工作呢？其实在Java虚拟机内部，有一个叫做类加载器的子系统，这个子系统用来在运行时根据需要加载类。注意上面一句话中的“根据需要”四个字。在Java虚拟机执行过程中，只有他需要一个类的时候，才会调用类加载器来加载这个类，并不会在开始运行时加载所有的类。就像一个人，只有饿的时候才去吃饭，而不是一次把一年的饭都吃到肚子里。一般来说，虚拟机加载类的时机，在第一次使用一个新的类的时候。 由虚拟机加载的类，被加载到Java虚拟机内存中之后，虚拟机会读取并执行它里面存在的字节码指令。虚拟机中执行字节码指令的部分叫做执行引擎。就像一个人，不是把饭吃下去就完事了，还要进行消化，执行引擎就相当于人的肠胃系统。在执行的过程中还会把各个class文件动态的连接起来。 Java虚拟机会进行自动内存管理。具体说来就是自动释放没有用的对象，而不需要程序员编写代码来释放分配的内存。这部分工作由垃圾收集子系统负责。 一个Java虚拟机实例在运行过程中有三个子系统来保障它的正常运行，分别是类加载器子系统， 执行引擎子系统和垃圾收集子系统。 如下图所示： 虚拟机的运行，必须加载class文件，并且执行class文件中的字节码指令。它做这么多事情，必须需要自己的空间。就像人吃下去的东西首先要放在胃中。虚拟机也需要空间来存放个中数据。首先，加载的字节码，需要一个单独的内存空间来存放；一个线程的执行，也需要内存空间来维护方法的调用关系，存放方法中的数据和中间计算结果；在执行的过程中，无法避免的要创建对象，创建的对象需要一个专门的内存空间来存放。 5.1 Java虚拟机 运行时数据区: 5.1.1程序计数器:①: 是一块较小的内存空间, 当前线程执行的字节码的行号指示器(记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。)②: 指向下一条需要执行的指令③: 每条线程都需要一个独立的程序计数器,彼此互不干扰(线程私有的内存) 5.1.2Java虚拟机栈:①: 线程私有的,生命周期与线程相同②: 描述java方法执行的内存模型,每个方法执行时都会创建一个栈帧,用来存放局部变量表,操作数栈,常量池引用等信息.③: 每个方法从调用到执行完成 就对应着栈帧在虚拟机栈帧中入栈和出栈.④: 两种异常: StackOverFlow异常 : 线程所请求的栈深度大于虚拟机允许的则抛出 OutOffMemoryError异常: 扩展时无法申请到足够的内存则抛出⑤: 我们常说的栈 和堆 中的栈就是Java虚拟机栈,更具体来说是Java虚拟机栈中的局部变量表部分.⑥: 局部变量表: 存放编译期可知的各种基本数据类型,对象引用类型 所需要的内存空间在编译期完成分配, 在方法运行期间不会改变其大小 64位长度的long 和 double 类型数据会占用2个局部变量空间(Slot) ,其余占一个. ⑦: 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：java -Xss512M HackTheJava 5.1.3本地方法栈:本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 上面三个区域随线程而生, 随线程而灭; 5.1.4Java堆( Java Heap) : 也称GC堆(Garbage Collected Heap )①: 是Java虚拟机管理的内存中最大的一块②: 被所有线程共享,的一块内存空间, 在虚拟机启动时候创建,③: 唯一目的: 存放对象实例, 几乎所有的对象实例 和 数组 都在这里这里分配内存.④: 是垃圾收集器管理的主要区域 ,所以也称GC堆⑤: 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M HackTheJava⑥: 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。 5.1.5方法区(永久代):①: 被所有线程共享,的一块内存空间②: 用来存储Class的相关信息如已经被Java虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。③: 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。④: 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。⑤: HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 5.1.5运行时常量池①: 运行时常量池是方法区的一部分。②: Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。③: 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 参考链接:https://baike.baidu.com/item/JVMhttps://blog.csdn.net/zhangjg_blog/article/details/20380971https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.mdhttps://blog.csdn.net/gyqjn/article/details/49848473]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是策略模式?定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp;让算法可在不影响客户端的情况下发生变化简单来说：准备一组算法 &amp; 将每一个算法封装起来，让外部按需调用 &amp; 使得互换 二、如何使用?使用步骤?步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员步骤4：客户端调用-让销售员进行促销活动的落地 三、优点:①: 策略类之间可以自由切换,由于策略类都实现同一个接口，所以使它们之间可以自由切换②: 易于扩展,增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码③: 符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。 四、缺点:①: 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。②: 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 五、应用场景:动态选择多种复杂行为 六、实例:背景：小成有一家百货公司，最近在定年度的促销活动冲突：每个节日用同一个促销活动太枯燥，没吸引力解决方案：针对不同节目使用不同促销活动进行促销 123456789101112131415161718192021222324252627282930313233343536373839404142434445//步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口abstract class Strategy &#123; public abstract void show();&#125;//步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动//为春节准备的促销活动Aclass StrategyA extends Strategy &#123; @Override public void show() &#123; System.out.println("为春节准备的促销活动A"); &#125;&#125;//为中秋节准备的促销活动Bclass StrategyB extends Strategy &#123; @Override public void show() &#123; System.out.println("为中秋准备的促销活动A"); &#125;&#125;//为国庆准备的促销活动Cclass StrategyC extends Strategy &#123; @Override public void show() &#123; System.out.println("为国庆准备的促销活动C"); &#125;&#125;//步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员class Context_SaleMan &#123; //持有抽象策略角色的引用 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * * @param strategy 具体策略对象 */ public Context_SaleMan(Strategy strategy) &#123; this.strategy = strategy; &#125; //向客户展示促销活动 public void Sale_ManShow() &#123; strategy.show(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//步骤4：客户端调用-让销售员进行促销活动的落地public class StrategyPattern &#123; //程序入口 public static void main(String[] args) &#123; Context_SaleMan saleMan; // 选择并创建需要使用的策略对象 // 例如现在要做春节的活动 Strategy strategyA = new StrategyA(); System.out.println("对于春节："); // 创建环境 saleMan = new Context_SaleMan(strategyA); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做中秋节的活动 Strategy strategyB = new StrategyB(); System.out.println("对于中秋节："); // 创建环境 saleMan = new Context_SaleMan(strategyB); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做国庆节的活动 Strategy strategyC = new StrategyC(); System.out.println("对于国庆节："); // 创建环境 saleMan = new Context_SaleMan(strategyC); saleMan.Sale_ManShow(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[什么是抽象工厂模式?抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。 抽象工厂模式与工厂方法模式最大的区别?抽象工厂中每个工厂可以创建多种类的产品, 而工厂方法每个工厂只能创建一类. 使用步骤:(根据下图来理解:)步骤1： 创建抽象工厂类，定义具体工厂的公共接口；步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；步骤4： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例 优点:①: 降低耦合: 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来， 可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；②: 更符合开-闭原则: 新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 而简单工厂模式需要修改工厂类的判断逻辑 ③: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品， 而简单工厂中的工厂类存在复杂的switch逻辑判断④: 不使用静态工厂方法，可以形成基于继承的等级结构， 而简单工厂模式的工厂类使用静态工厂方法 缺点:①: 抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。②: 对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。 应用场景:①: 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。②: 这个系统有多个系列产品，而系统中只消费其中某一系列产品③: 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。 实例:背景： 小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂所在地的客户 也需要模具类产品，B厂所在地的客户也需要容器类产品；冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂.解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。 1234567//步骤1： 创建抽象工厂类，定义具体工厂的公共接口abstract class Factory &#123; public abstract Product ManufactureContainer();//容器 public abstract Product ManufactureMould();//模型&#125; 123public class Product &#123; public void show()&#123;&#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//步骤2： 创建抽象产品族类 ，定义具体产品的公共接口；abstract class AbstractProduct extends Product&#123; public abstract void show();&#125;//步骤3： 创建抽象产品类 ，定义具体产品的公共接口；//容器产品抽象类abstract class ContainerProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//模型产品抽象类abstract class MouldProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//步骤4： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；//容器产品Aclass ContainerProductA extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品A"); &#125;&#125;//容器产品Bclass ContainerProductB extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品B"); &#125;&#125;//模具产品Aclass MouldProductA extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品A"); &#125;&#125;//模具产品Bclass MouldProductB extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品B"); &#125;&#125;//步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//A厂 - 生产模具+容器产品class FactoryA extends Factory &#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductA(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductA(); &#125;&#125;//B厂 - 生产模具+容器产品class FactoryB extends Factory&#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductB(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductB(); &#125;&#125; 12345678910111213141516//步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例public class AbstractFactoryPattern &#123; public static void main(String[] args) &#123; Factory myfactoryA = new FactoryA(); Factory myfactoryB = new FactoryB(); //A厂当地客户需要容器产品A myfactoryA.ManufactureContainer().show(); //A厂当地客户需要模具产品A myfactoryA.ManufactureMould().show(); //B厂当地客户需要容器产品B myfactoryB.ManufactureContainer().show(); //B厂当地客户需要模具产品B myfactoryB.ManufactureMould().show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-2两数相加]]></title>
    <url>%2FLeetCode-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html</url>
    <content type="text"><![CDATA[题目:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例: 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析:建立一个新链表，然后把输入的两个链表从头往后遍历，每两个相加，添加一个新节点到新链表后面。为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后，由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点。好，可以开始让两个链表相加了，这道题好就好在最低位在链表的开头，所以我们可以在遍历链表的同时按从低到高的顺序直接相加。while循环的条件两个链表中只要有一个不为空行，由于链表可能为空，所以我们在取当前结点值的时候，先判断一下，若为空则取0，否则取结点值。然后把两个结点值相加，同时还要加上进位carry。然后更新carry，直接 sum/10 即可，然后以 sum%10 为值建立一个新结点，连到cur后面，然后cur移动到下一个结点。之后再更新两个结点，若存在，则指向下一个位置。while循环退出之后，最高位的进位问题要最后特殊处理一下，若carry为1，则再建一个值为1的结点，代码如下： 123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //l1,l2相当于指向两个链表表头的指针 //为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后 ListNode dummy = new ListNode(-1); //由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点 ListNode cur = dummy; //进位 int carry = 0; //至少有一个结点不为空 while (l1 != null || l2 != null) &#123; //结点为空,那么值就设置为0,不为空取出结点所存放的值 int d1 = l1 == null ? 0 : l1.val; int d2 = l2 == null ? 0 : l2.val; //两个链表中对应结点的值求和 int sum = d1 + d2 + carry; carry = sum &gt;= 10 ? 1 : 0; //sum不会超过二十,所以最多进1位 cur.next = new ListNode(sum % 10);//造一个新结点,将两个链表对应结点的两数之和,存到新链表的新结点 cur = cur.next;//移动cur指针,指向下一个结点 if (l1 != null) &#123; l1 = l1.next;//移动l1指针 &#125; if (l2 != null) &#123; l2 = l2.next;//移动l2指针 &#125; &#125;//循环结束 //如果最高位相加,产生进位,需要再造一个结点 if (carry == 1) &#123; cur.next = new ListNode(1); &#125; return dummy.next;&#125; 12345678910111213141516171819202122232425public class addTwoNumbers &#123; //程序入口函数 public static void main(String[] args) &#123; //建立第一个链表 ListNode listNode1 = new ListNode(2); ListNode listNode2 = new ListNode(4); ListNode listNode3 = new ListNode(3); listNode1.next=listNode2; listNode2.next=listNode3; listNode3.next=null; //建立第二个链表 ListNode listNode4 = new ListNode(5); ListNode listNode5 = new ListNode(6); ListNode listNode6 = new ListNode(4); listNode4.next=listNode5; listNode5.next=listNode6; listNode6.next=null; //调用方法 ListNode listNode = new addTwoNumbers().addTwoNumbers(listNode1,listNode4); //打印结果: ListNode&#123;val=7, next=ListNode&#123;val=0, next=ListNode&#123;val=8, next=null&#125;&#125;&#125; System.out.println(listNode); &#125;&#125; 参考链接:http://www.cnblogs.com/grandyang/p/4129891.htmlhttps://leetcode-cn.com/problems/two-sum/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是工厂方法模式?①: 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口(抽象方法)，而子类重写接口(抽象方法)则负责生成具体的对象。③: 简言之:工厂里面造对象,对象所属类里面造产品 二、如何使用?使用步骤?步骤1： 创建抽象工厂类，定义具体工厂的公共接口(抽象方法)；步骤2： 创建抽象产品类 ，定义具体产品的公共接口(抽象方法)；步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤4： 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例(对象)的方法；步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 三、优点:①: 更符合开-闭原则: 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可, 而简单工厂模式需要修改工厂类的判断逻辑②: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品, 而简单工厂中的工厂类存在复杂的switch逻辑判断, 它不使用静态工厂方法，可以形成基于继承的等级结构。 而简单工厂模式的工厂类使用静态工厂方法 四、缺点:①: 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；②: 同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；③: 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。④: 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；⑤: 一个具体工厂只能创建一种具体产品 五、应用场景:①: 当一个类不知道它所需要的对象的类时②: 当一个类希望通过其子类来指定创建对象时③: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。④: 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 六、实例:背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；解决方案：小成决定置办塑料分厂B来生产B类产品； //步骤1： 创建抽象工厂类 123abstract class Factory &#123; abstract Product Manufacture();&#125; //步骤2： 创建抽象产品类 ，定义具体产品的公共接口； 123abstract class Product &#123; public abstract void show();&#125; //步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下://步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下: //具体产品A类class ProductA extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品A"); &#125;&#125;//具体产品B类class ProductB extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品B"); &#125;&#125;//步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; @Override Product Manufacture() &#123; return new ProductA(); &#125;&#125;//工厂B类 - 生产B类产品class FactoryB extends Factory&#123; @Override Product Manufacture() &#123; return new ProductB(); &#125;&#125;//生产工作流程public class FactoryPattern &#123; public static void main(String[] args) &#123; //客户要产品A FactoryA myfactoryA = new FactoryA(); myfactoryA.Manufacture().show(); //客户要产品B FactoryB myFactoryB = new FactoryB(); myFactoryB.Manufacture().show(); &#125; 七、总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是简单工厂模式?①: 简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法） ②: 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。 二、如何使用?使用步骤?:①: 创建抽象产品类 &amp; 定义具体产品的公共接口；②: 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；③: 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；④: 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例 三、优点:①: 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；②: 把初始化实例时的工作放到工厂里进行，使代码更容易维护。③: 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。 四、缺点:①: 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；②: 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。③: 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 五、应用场景:①: 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；②: 当工厂类负责创建的对象（具体产品）比较少时。 六、实例:背景：小成有一个塑料生产厂，用来做塑料加工生意目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产 //步骤1. 创建抽象产品类，定义具体产品的公共接口 123abstract class Product &#123; public abstract void show();&#125; //步骤2.创建具体产品类（继承抽象产品类），定义生产的具体产品, 代码如下://步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//具体产品类Aclass ProductA extends Product &#123; @Override public void show() &#123; System.out.println("生产出A产品!"); &#125;&#125;//具体产品类Bclass ProductB extends Product &#123; @Override public void show() &#123; System.out.println("生产出B产品!"); &#125;&#125;//具体产品类Cclass ProductC extends Product &#123; @Override public void show() &#123; System.out.println("生产出C产品!"); &#125;&#125;//步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例public class SimpleFactoryPattern &#123; public static void main(String[] args) &#123; //客户要A产品 try &#123; Factory.Manufacture("A").show(); &#125; catch (NullPointerException e) &#123; System.out.println("没有A产品"); &#125; //客户要B产品 try &#123; Factory.Manufacture("B").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有B产品"); &#125; //客户要C产品 try &#123; Factory.Manufacture("C").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有C产品"); &#125; //客户要D产品 try &#123; Factory.Manufacture("D").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; &#125;&#125; //步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例 12345678910111213141516public class Factory &#123; public static Product Manufacture(String productName) &#123;//工厂类里用switch语句控制生产哪种商品；//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化 switch(productName) &#123; case "A": return new ProductA(); case "B": return new ProductB(); case "C": return new ProductC(); default: return null; &#125; &#125;&#125; 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-三次握手和四次挥手]]></title>
    <url>%2FTCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[一、字段说明: 字段: 含义: SYN,seq 同步报文段 ACK,ack 确认报文段 ack 确认号 seq 序列号 SYN 同步位 FIN 终止位 ACK 确认位 二、三次握手:第一次: 连接请求报文段: SYN=1(请求连接) 初始序号seq=x(客户端初始序号)第二次: 确认报文段(同意连接): SYN =1(请求连接) seq= y(服务器自己的初始序号) ACK = 1(确认收到) ack = x+1(确认号)第三次: 确认报文段:ACK=1(确认收到) seq=x+1 (客户端序号) ack=y+1(确认号) 确认号ack是上一次的序号seq加1 总结: ack的值等于对方上一次发送的报文段中的seq的值加一,​ seq的值等于自己上一次发送的报文段中的seq的值加一(第一次seq值任意取) 简图: B 处于 LISTEN（监听）状态，等待来自 A 的连接请求。 A 向 B 发送连接请求报文 SYN。 B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN ACK。 A 收到 SYN ACK 后，还要向 B 发出确认报文 ACK。 B 收到 ACK 后，连接建立。 应该注意到，接收了 SYN 之后的所有报文都存在 ACK 字段。 三、三次握手的原因:第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四、四次挥手: 简图: 第一次: 连接释放报文段: FIN=1 seq=u(u为前面已经传送过的数据的最后一个字节的序号加一) 第二次: 连接释放确认报文段: 确认只断开A—B ACK= 1(确认收到) ack=u+1(确认号) seq=v(v为为前面已经传送过的数据的最后一个字节的序号加一) 第三次: 连接释放确认报文段: 断开B—-A FIN = 1 ACK =1 ack=u+1 seq=w(seq=v后还发送了数据, w是前面已经传送过的数据的最后一个字节的序号加一) 第四次: 连接释放确认报文段 : 确认断开B—A ACK=1 ack = w+1 seq=u+1 A 发送连接释放报文 FIN。 B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文 FIN。 A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。 B 收到 ACK 后释放连接。 五、四次挥手的原因:客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。 六、为什么还要设置一个Time-WAIT ?客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。 参考文章:https://mp.weixin.qq.com/s/tGlWTrr5KLAv1AflfeAejA]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>TCP-三次握手和四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1两数之和]]></title>
    <url>%2FLeetCode-1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析:这道题给了我们一个数组，还有一个目标数target，让我们找到两个数字，使其和为target，乍一看就感觉可以用暴力搜索(遍历所有的两个数字的组合，然后算其和), 但是时间复杂度是O(n^2)。能否想个O(n)的算法来实现，一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢，我们可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，我们都知道HashMap是常数级的查找效率，这样，我们在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。代码如下： 法一: 暴力搜索(不采用) 123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int i = 0, j = 0, t = 0; int result[] = new int[2]; for (i = 0; i &lt; nums.length - 1; i++) &#123; //0 1 2 for (j = i; j &lt; nums.length - 1; j++) &#123; t = nums[i] + nums[j + 1]; if (t == target) &#123; result[0] = i; result[1] = j + 1; return result; &#125; &#125; &#125; return result; &#125; 法二: 使用HashMap 1234567891011121314151617public class TwoSum &#123; public int[] twoSum(int[] sums,int target) &#123; HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;Integer,Integer&gt;(); int[] result = new int[2]; for(int i = 0;i &lt; sums.length;i++)&#123; hashMap.put(sums[i],i);//把值存到HashMap,数作为键,下标作为值 &#125; for(int i = 0;i &lt; sums.length;i++) &#123; int t = target - sums[i]; if(hashMap.containsKey(t) &amp;&amp; hashMap.get(t) != i) &#123; result[0] = i; result[1] = hashMap.get(t); break;//一旦找到了,就立刻终止循环 &#125; &#125; return result; &#125; 1234567891011public class TwoSum &#123; //程序入口函数 public static void main(String[] args) &#123; int []nums = new int []&#123;2, 7, 11, 15&#125;; int target = 9; int[] result = new int[2]; result = new TwoSum().twoSum(nums,target); //打印结果: [0,1] System.out.println("["+result[0]+","+result[1]+"]"); &#125; 参考链接:https://leetcode-cn.com/problems/two-sum/http://www.cnblogs.com/grandyang/p/4130379.html]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是单例模式? 实现1个类只有1个实例化对象并提供一个全局访问点. 二、工作原理: 保证在内存中只有一个对象存在. 在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的， 要是想实现一个类只有一个实例化对象，就要对类的构造方法下功夫 三、如何去保证内存中只有一个对象存在? ①: 构造函数私有化 ②: 自己创建当前类的对象 ③: 对外提供公共的方法(获取已经创建好的对象) 四、使用步骤: 创建私有变量 OurInstance,（用以记录 Singleton 的唯一实例）,内部进行实例化 把类的构造方法私有化，不让外部调用构造方法实例化(构造方法只能在本类中调用) 定义公有方法提供该类的全局唯一访问点外部通过调用newInstance()方法来返回唯一的实例 五、优点: 提供了对唯一实例的受控访问； 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能； 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式； 六、缺点: 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失。 七、单例模式的实现方式:可分为2大类、6种实现方式: 第一大类: 初始化单例类时 即 创建单例 实现方式1: 饿汉式 实现方式2: 枚举类型 第二大类: 按需,延迟创建单例 实现方式3: 懒汉式的基础实现 实现方式4: 懒汉式的改进—&gt;同步锁 实现方式5: 懒汉式的改进—&gt;双重检验锁 实现方式6: 静态内部类 八、饿汉式和懒汉式的区别: 饿汉式: 随类的加载而创建对象 懒汉式: 上来不创建对象,当调用的时候,再创建对象,以后使用的就是同一个对象了 懒汉式: 懒加载,延迟加载 九、实现方式详解:9.1 实现方式1: 饿汉式 ①: 这是 最简单的单例实现方式 ②: 原理: 依赖 JVM类加载机制，保证单例只会被创建1次，即 线程安全 JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化 ③: 应用场景: 除了初始化单例类时 即 创建单例外，继续延伸出来的是：单例对象 要求初始化速度快 &amp; 占用内存小 ④: 具体实现: 1234567891011121314class Singleton &#123; // 1. 加载该类时，单例就会自动被创建 private static Singleton ourInstance = new Singleton(); // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 通过调用静态方法获得创建的单例 public static Singleton newInstance() &#123; return ourInstance; &#125; &#125; 9.2 实现方式2: 枚举类型 ①: 原理: 根据枚举类型的下述特点，满足单例模式所需的 创建单例、线程安全、实现简洁的需求 ②: 具体实现: 12345678910public enum Singleton&#123; //定义1个枚举的元素，即为单例类的1个实例 INSTANCE; // 隐藏了1个空的、私有的 构造方法 // private Singleton () &#123;&#125; &#125; // 获取单例的方式： Singleton singleton = Singleton.INSTANCE;注：这是 最简洁、易用 的单例实现方式，借用《Effective Java》的话：单元素的枚举类型已经成为实现 Singleton的最佳方法 9.3实现方式3: 懒汉式（基础实现） ①: 原理: 与饿汉式 最大的区别是：单例创建的时机 饿汉式：单例创建时机不可控，即类加载时 自动创建 单例 懒汉式：单例创建时机可控，即有需要时，才 手动创建 单例 ②: 具体实现: 123456789101112131415161718class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 需要时才手动调用 newInstance（） 创建 单例 public static Singleton newInstance() &#123; // 先判断单例是否为空，以避免重复创建 if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; return ourInstance; &#125; &#125; ③: 缺点: 基础实现的懒汉式是线程不安全的，具体原因如下: 可能存在多个线程并发 调用 newInstance ( ),从而重复创建单例对象 ④:具体实例: 一个线程A执行到singleton=new Singleton( ); 但还没有获得对象(因对象初始化需要时间),此时,第2个线程也在执行,执行到if (singleton == null) 判断 (判断为真,于是继续运行,创建单例对象),最终线程A ,B 同时获得了一个单例对象, 在内存中就出现两个单例类的对象,造成单例模式失效. 9.4实现方式4: 懒汉式的改进—&gt;同步锁 ①: 原理: 使用同步锁 synchronized锁住创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建 即，getInstance（）方法块只能运行在1个线程中．若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待，而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下单例对象的唯一性． ②: 具体实现: 12345678910111213141516171819202122232425262728293031323334353637 // 写法1(同步方法)class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 加入同步锁 public static synchronized Singleton getInstance()&#123; // 先判断单例是否为空，以避免重复创建 if ( ourInstance == null ) ourInstance = new Singleton(); return ourInstance; &#125; &#125; // 写法2 (同步代码块) // 该写法的作用与上述写法作用相同，只是写法有所区别 class Singleton&#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; // 加入同步锁 synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; return instance; &#125; &#125; ④: 缺点: 每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能） 注: 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步 9.5 实现方式5: 懒汉式的改进—&gt;双重检验锁 ①: 原理: 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能 ②: 具体实现: 1234567891011121314151617181920212223242526272829303132class Singleton &#123; private static Singleton ourInstance = null； private Singleton() &#123; &#125; public static Singleton newInstance() &#123; // 加入双重校验锁 // 校验锁1：第1个if if( ourInstance == null)&#123; // ① synchronized (Singleton.class)&#123; // ② // 校验锁2：第2个 if if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; &#125; &#125; return ourInstance; &#125; &#125; // 说明 // 校验锁1：第1个if // 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作 // 即直接跳到执行 return ourInstance // 校验锁2：第2个 if // 作用：防止多次创建单例问题 // 原理 // 1. 线程A调用newInstance()方法，当运行到②位置时，此时线程B也调用了newInstance()方法, // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕 // 3. 当线程A释放同步锁时，单例已创建，即instance已非空 // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 为非空（单例已创建），因此也不会创建多余的实例 ③: 缺点: 实现复杂 = 多种判断，易出错 9.6 实现方式6: 静态内部类 ①: 原理: 根据 静态内部类 的特性，同时解决了按需加载、线程安全的问题，同时实现简洁 在静态内部类里创建单例，在装载该内部类时才会去创建单例 线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例 ②: 具体实现: 123456789101112131415161718192021222324class Singleton &#123; // 1. 创建静态内部类 private static class Singleton2 &#123; // 在静态内部类里创建单例 private static Singleton ourInstance = new Singleton()； &#125; // 私有构造函数 private Singleton() &#123; &#125; // 延迟加载、按需创建 public static Singleton newInstance() &#123; return Singleton2.ourInstance; &#125; &#125; // 调用过程说明： // 1. 外部调用类的newInstance() // 2. 自动调用Singleton2.ourInstance // 2.1 此时单例类Singleton2得到初始化 // 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例； // 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性 // 3. 最终只创建1个单例 参考文章:https://www.jianshu.com/p/b8c578b07fbc]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识设计模式]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[前言: 我们学习程序设计语言，有必要学习它的设计模式吗？当然是有必要的，程序里有一些“模式”可以发掘的。因为你可以借鉴以往的经验，避免走很多弯路，更快的构造新的程序，提高开发效率。 一、设计模式是什么？ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 简言之：模式：在某些场景下，针对某类问题的某种通用的解决方案。 二、设计模式历史背景? 埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides，后以“四人帮”（Gang of Four，GoF）著称，简称 GoF ，在 95年的时候整理归纳出 23 种最常用的设计模式，并编写成一本书 Design Patterns: Elements of Reusable Object-Oriented Software 就是：《设计模式：可复用面向对象软件的基础》 。 三、设计模式的六大原则:开闭原则（Open Close Principle)：模块应尽量在不修改原代码(闭)的情况下进行扩展(开)。即在程序需要进行拓展的时候，不能去修改原有的代码（闭），实现一个热插拔的效果。 里氏替换原则（Liskov Substitution Principle）：如果调用的是父类的话，那么换成子类也完全可以运行。 派生类能够在基类的基础上增加新的行为。只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒置原则（Dependence Inversion Principle）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。2、抽象不应该依赖于具体实现，具体实现应该依赖于抽象。要求对抽象/接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 接口隔离原则 (Interface Segregation Principle)：每一个接口应该是一种角色，不干不该干的事，该干的事都要干。降低类之间的耦合度。 合成复用原则 (Composite Reuse Principle)：要尽量使用组合/ 聚合，尽量不要使用继承。只有“Is - A” 关系才符合继承关系，“Has- A” 关系应当使用聚合来描述。 迪米特法则 (Demeter Principle)（也称最少知识原则）：一个对象应对其它对象有尽可能少的了解。即一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。简言之：只与直接的朋友通信 四、设计模式的三大分类:创建型模式：共5种, 对象实例化的模式，创建型模式用于解耦对象的实例化过程。 结构型模式：共7种, 把类或对象结合在一起形成一个更大的结构。 行为型模式：共11种, 类和对象如何交互，及划分责任和算法。 五、23种设计模式:单例模式：某个类只能有一个实例，提供一个全局的访问点。 工厂方法(Factory Method)：定义一个创建对象的接口，让子类决定实例化那个类。 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。 普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象 静态工厂方法模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。 原型模式：通过复制现有的实例来创建新的实例。 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。 组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。 装饰模式：动态的给对象添加新的功能。 代理模式：为其他对象提供一个代理以便控制这个对象的访问。 享元模式：通过共享技术来有效的支持大量细粒度的对象。 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。 观察者模式：对象间的一对多的依赖关系。 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。 中介者模式：用一个中介对象来封装一系列的对象交互。 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。 参考文章: https://zhuanlan.zhihu.com/p/28737945https://www.cnblogs.com/pony1223/p/7608955.htmlhttps://juejin.im/post/59b78dfe5188257e7e115caehttps://www.jianshu.com/p/72764b69d6cf]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子网划分的经典实例]]></title>
    <url>%2F%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[案例:例1:一家集团公司有12家子公司，每家子公司又有4个部门。上级给出一个172.16.0.0/16的网段，让给每家子公司以及子公司的部门分配网段。 例2:某集团公司给下属子公司甲分配了一段IP地址192.168.5.0/24，现在甲公司有两层办公楼（1楼和2楼），统一从1楼的路由器上公网。1楼有100台电脑联网，2楼有53台电脑联网。如果你是该公司的网管，你该怎么去规划这个IP？ 例3:请问 192.168.10.0/26 有多少子网?每个子网有多少主机?有多少合法子网?每个子网的广播地址是多少?哪些是合法主机号? 分析:例1：通过子网数来划分子网，未考虑主机数。 例2：通过计算主机数来划分子网。 例1 思路：既然有12家子公司，那么就要划分12个子网段，但是每家子公司又有4个部门，因此又要在每家子公司所属的网段中划分4个子网分配给各部门。 例1步骤：A. 先划分各子公司的所属网段。 有12家子公司，那么就有2的n次方≥12，n的最小值=4。因此，网络位需要向主机位借4位。那么就可以从172.16.0.0/16这个大网段中划出2的4次方=16个子网。 详细过程： 先将172.16.0.0/16用二进制表示 10101100.00010000.00000000.00000000/16 借4位后（可划分出16个子网）： 1) 10101100. 00010000 . 00000000.00000000/20【172.16.0.0/20】 2) 10101100.00010000.00010000.00000000/20【172.16.16.0/20】 3) 10101100.00010000.00100000.00000000/20【172.16.32.0/20】 4) 10101100.00010000.00110000.00000000/20【172.16.48.0/20】 5) 10101100.00010000.01000000.00000000/20【172.16.64.0/20】 6) 10101100.00010000.01010000.00000000/20【172.16.80.0/20】 7) 10101100.00010000.01100000.00000000/20【172.16.96.0/20】 8) 10101100.00010000.01110000.00000000/20【172.16.112.0/20】 9) 10101100.00010000.10000000.00000000/20【172.16.128.0/20】 10) 10101100.00010000.10010000.00000000/20【172.16.144.0/20】 11) 10101100.00010000.10100000.00000000/20【172.16.160.0/20】 12) 10101100.00010000.10110000.00000000/20【172.16.176.0/20】 13) 10101100.00010000.11000000.00000000/20【172.16.192.0/20】 14) 10101100.00010000.11010000.00000000/20【172.16.208.0/20】 15) 10101100.00010000.11100000.00000000/20【172.16.224.0/20】 16) 10101100.00010000.11110000.00000000/20【172.16.240.0/20】 我们从这16个子网中选择12个即可，就将前12个分给下面的各子公司。每个子公司最多容纳主机数目为2的12次方-2=4094。 B. 再划分子公司各部门的所属网段 以甲公司获得172.16.0.0/20为例，其他子公司的部门网段划分同甲公司。 有4个部门，那么就有2的n次方≥4，n的最小值=2。因此，网络位需要向主机位借2位。那么就可以从172.16.0.0/20这个网段中再划出2的2次方=4个子网，正符合要求。 详细过程： 先将172.16.0.0/20用二进制表示 \10101100. 00010000. 00000000.00000000/20 借2位后（可划分出4个子网）： ① 10101100.00010000.00000000.00000000/22【172.16.0.0/22】 ② 10101100.00010000.00000100.00000000/22【172.16.4.0/22】 ③ 10101100.00010000.00001000.00000000/22【172.16.8.0/22】 ④ 10101100.00010000.00001100.00000000/22【172.16.12.0/22】 将这4个网段分给甲公司的4个部门即可。每个部门最多容纳主机数目为2的10次方-2=1024 例2思路:我们在划分子网时优先考虑最大主机数来划分。在本例中，我们就先使用最大主机数来划分子网。101个可用IP地址，那就要保证至少7位的主机位可用（2的m次方-2≥101，m的最小值=7）。如果保留7位主机位，那就只能划出两个网段，剩下的一个网段就划不出来了。但是我们剩下的一个网段只需要2个IP地址并且2楼的网段只需要54个可用IP，因此，我们可以从第一次划出的两个网段中选择一个网段来继续划分2楼的网段和路由器互联使用的网段。 例2 步骤：根据需求，画出下面这个简单的拓扑。将192.168.5.0/24划成3个网段，1楼一个网段，至少拥有101个可用IP地址；2楼一个网段，至少拥有54个可用IP地址；1楼和2楼的路由器互联用一个网段，需要2个IP地址。 A. 先根据大的主机数需求，划分子网因为要保证1楼网段至少有101个可用IP地址，所以，主机位要保留至少7位。 先将192.168.5.0/24用二进制表示： 11000000.10101000.00000101.00000000/24 主机位保留7位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.00000000/25【192.168.5.0/25】 ② 11000000.10101000.00000101.10000000/25【192.168.5.128/25】 1楼网段从这两个子网段中选择一个即可，我们选择192.168.5.0/25。 2楼网段和路由器互联使用的网段从192.168.5.128/25中再次划分得到。 B. 再划分2楼使用的网段2楼使用的网段从192.168.5.128/25这个子网段中再次划分子网获得。因为2楼至少要有54个可用IP地址，所以，主机位至少要保留6位（2的m次方-2≥54，m的最小值=6）。 先将192.168.5.128/25用二进制表示： 11000000.10101000.00000101.10000000/25 主机位保留6位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.10000000/26【192.168.5.128/26】 ② 11000000.10101000.00000101.11000000/26【192.168.5.192/26】 2楼网段从这两个子网段中选择一个即可，我们选择192.168.5.128/26。 路由器互联使用的网段从192.168.5.192/26中再次划分得到。 C. 最后划分路由器互联使用的网段路由器互联使用的网段从192.168.5.192/26这个子网段中再次划分子网获得。因为只需要2个可用IP地址，所以，主机位只要保留2位即可（2的m次方-2≥2，m的最小值=2）。 先将192.168.5.192/26用二进制表示： 11000000.10101000.00000101.11000000/26 主机位保留2位，即在现有基础上网络位向主机位借4位（可划分出16个子网）： ① 11000000.10101000.00000101.11000000/30【192.168.5.192/30】 ② 11000000.10101000.00000101.11000100/30【192.168.5.196/30】 ③ 11000000.10101000.00000101.11001000/30【192.168.5.200/30】 ………………………………… ④ 11000000.10101000.00000101.11110100/30【192.168.5.244/30】 ⑤ 11000000.10101000.00000101.11111000/30【192.168.5.248/30】 ⑥ 11000000.10101000.00000101.11111100/30【192.168.5.252/30】 路由器互联网段我们从这16个子网中选择一个即可，我们就选择192.168.5.252/30。 D. 整理本例的规划地址1楼：网络地址：【192.168.5.0/25】 最小地址为11000000 10101000 00000101 00000000 即 192.168.5.0 最大地址为11000000 10101000 00000101 01111111 即 192.168.5.127 主机位全0全1的不能作为主机IP，因为主机位全1 的要用来作 广播地址即192.168.5.127 剩下的可以分配作为主机的IP 主机IP地址：【192.168.5.1/25—192.168.5.126/25】 广播地址：【192.168.5.127/25】 2楼：网络地址：【192.168.5.128/26】 主机IP地址：【192.168.5.129/26—192.168.5.190/26】 广播地址：【192.168.5.191/26】 路由器互联： 网络地址：【192.168.5.252/30】 两个IP地址：【192.168.5.253/30、192.168.5.254/30】 广播地址：【192.168.5.255/30】 快速划分子网确定IP: 以例2为例：题目需要我们将192.168.5.0/24这个网络地址划分成能容纳101/54/2个主机的子网。因此我们要先确定主机位，然后根据主机位决定网络位，最后确定详细的IP地址。 ① 确定主机位 将所需要的主机数自大而小的排列出来：101/54/2，然后根据网络拥有的IP数目确定每个子网的主机位：如果2的n次方-2≥该网段的IP数目，那么主机位就等于n。于是，得到：7/6/2。 ② 根据主机位决定网络位 用32减去主机位剩下的数值就是网络位，得到：25/26/30。 ③ 确定详细的IP地址 在二进制中用网络位数值掩盖IP前面相应的位数，然后后面的为IP位。选取每个子网的第一个IP为网络地址，最后一个为广播地址，之间的为有效IP。得到： 【网络地址】 【有效IP】 【广播地址】 【192.168.5.0/25】【192.168.5.1/25-192.168.5.126/25】【192.168.5.127/25】 【192.168.5.128/26】【192.168.5.129/26-192.168.5.190/26】【192.168.5.191/26】 【192.168.5.192/30】【192.168.5.193/30-192.168.5.194/30】【192.168.5.195/30】 例3: 分析首先就是要理解/26的意思。首先一看就是个C类地址，所以其默认子网掩码是255.255.255.0。这个子网掩码是由3个.来分隔的，而且这是10进制表示出来的，把它化为2进制=11111111.11111111.11111111.00000000前面是24个1。所以默认的C类子网掩码被写成/24。 这道题是/26，也就是有26个1，写出来就是11111111.11111111.11111111.11000000。把它划成10进制就是255.255.255.192, 现在知道了子网掩码就可以回答那5个问题了 1.有多少个子网？ 这有个公式的。子网数目=2的X次方，这里的X是指掩码位数，掩码为数可以用我们现在的子网掩码的1的为数减去默认的1的位数。这道题有子网掩码有26个1，而C类默认有24个1，所以就是26-24=2。子网数=2的2次方=4 2.每个子网的主机数？ 这还是由公式的。子网主机数=2的Y次方-2，这里的Y是非掩码位的位数，即子网掩码中0的个数，刚才已经知道有26个1了，那剩下的就都是0了，一共有32位，现在有26个1剩下的就只有6个0。所以子网主机数=2的6次方-2=62 3.哪些是合法子网？ 这里牵扯了块这个概念，块=256 - 子网掩码。这里就是 - 192 ，所以这道题块=64 ，知道了块就把块从0开始加，一直加到256，这之间的数就是合法子网。0+64=64 64+64=128 128+62=192 192+64=256 所以合法子网就是0 64 128 192 4.每个子网的广播地址是多少？ 广播地址=下一个子网号-1 所以0子网的广播地址是63；64子网的广播地址是127；128子网的广播地址是191；192子网的广播地址是255 5.哪些是合法主机号？ 合法主机号是那些介于个子网之间的取值，并要减去全0和全1的主机号，例如：64是子网号码，127是广播地址，那么65–126就是合法地址。 所以0子网的合法地址是1–62；64子网的合法地址是65–126；128子网的合法地址是129==190；192子网的合法地址是193–254 总结:子网划分无非涉及到这些内容: 1.有多少子网 2.每个子网有多少主机 3.有多少合法子网 4.每个子网的广播地址是多少: 广播地址下一个子网号-1 5.哪些是合法主机号]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>子网划分实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识计算机网络]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[前言: 计算机网络可以说是连通世界的桥梁，推动发展的催化剂，正是计算机网络技术让信息传播速度更快，让我们能随时随地在线看视频、听音乐、查资料、看新闻、分享资源,试想一下如果没有计算机网络这门学科，我们的世界还会有今天这么繁荣吗？ 计算机网络是什么？ 计算机网络技术是通信技术与计算机技术相结合的产物。计算机网络是按照网络协议，将地球上分散的、独立的计算机相互连接的集合。连接介质可以是电缆、双绞线、光纤、微波、载波或通信卫星。计算机网络具有共享硬件、软件和数据资源的功能，具有对共享数据资源集中处理及管理和维护的能力． 发展历史：其发展经历了四个阶段: ①:20世纪50~60年代，出现以单个计算机为中心的远程连机系统，构成面向终端的计算机网络； ②:20世纪60~70年代，出现了多个主计算机通过通信线路互连的计算机网络。ARPANET投入使用； ③:20世纪70~80年代，出现具有统一的网络体系结构，遵循国际标准化协议的计算机网络。 ④:从90年代算起，网络互联与高速网络。 我国在1980年开始进行计算机联网实验，1989年，我国第一个分组交换网CNPAC建成运行. 特点：①: 连通性 ②: 共享 分类：按作用范围分类:①: WAN（Wide Area Network）广域网：几十到几千KM ②: MAN（Metropolitan Area Network）城域网：一个城市（5~50KM） ③: LAN（Local Area Network）局域网：1KM左右 ④: PAN（Personal Area Network）个人区域网：10m左右 按传输介质分类:①: 有线网：是采用同轴电缆或双绞线连接的计算机网络。同轴电缆网是常见的一种连网方式，它比较经济，安装较为便利，传输率和抗干扰能力一般，传输距离较短。双绞线网是目前最常见的连网方式。它价格便宜，安装方便，但易受干扰，传输率较低，传输距离比同轴电缆要短。 ②: 光纤网：也是有线网的一种，但由于其特殊性而单独列出。光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。但其成本较高，且需要高水平的安装技术。 ③: 无线网：用电磁波作为载体来传输数据，目前无线网联网费用较高，还不太普及。但由于联网方式灵活方便，是一种很有前途的连网方式。 局域网通常采用单一的传输介质，而城域网和广域网采用多种传输介质。 按通信方式分类:①: 点对点传输网络：数据以点到点的方式在计算机或通信设备中传输。星型网、环形网采用这种传输方式。 ②: 广播式传输网络：数据在公用介质中传输。无线网和总线型网络属于这种类型。 应用:①: 通信服务: 如在线聊天（飞信,MSN、QQ等）、E-mail 、IP 电话等服务 ②: 多媒体信息服务: 包括网上娱乐、网络电视、电视会议、WWW服务、远程教育和音乐点播等。 ④: 办公自动化: 将一个单位的其它办公设备与办公用计算机连接成网络, 加强了外部和单位内部的沟通与联系，加快单位内部的信息流动，提高工作效率，并有利于减少日常开支。 ⑤: 网上交易: 在线购物,转账等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、初始化配置:1.1 指定客户端用户名和邮箱，为了标记是谁向远程库传送数据 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 1.2查看用户名：$ git config user.name 1.3查看邮箱： $ git config user.email 1.4修改用户名：$ git config --global user.name &quot;cyx&quot; 1.5修改邮箱： $ git config --global user.email &quot;328978553@qq.com&quot; 1.6查看配置是否生效： $ git config --list 二、目录文件相关:2.1创建目录： $ mkdir /d/softwear/Program （“mkdir” 是“make Directory”; “/d/softwear/”是要创建目录的位置 “Program” 是新创建的目录） 2.2定位到Program指定目录： $ cd /d/软件/Program 2.3输出当前目录地址： $ pwd 2.4让之前创建的目录作为git可操作的仓库，此时再去刚才创建的program目录下会发现多了一个.git目录： $ git init 2.5查看当前仓库的隐藏目录，以及文件： $ ls –ah 2.6查看当前仓库的文件： $ ls 三、本地仓库关联远程库:3.1关联Github远程库：$ git remote add origin git@server-name(服务器名即github用户名)/repo-name.git(远程仓库名.git) 如：$ git remote add origin git@zzwwqq/blog.git； 3.2关联码云远程库：$ git remote add origin git@gitee.com:zwqzeq/Login_Register.git 四、操作远程仓库:4.1显示远程库的详细信息： $git remote -v 4.2本地master分支内容推送到远程库的master分支： 第一次$ git push -u origin master 以后 直接$ git push origin master 4.3删除远程库： $ git remote rm origin (origin远程库默认名称，建议不改) 4.4从远程库克隆： $ git clone git@github.com:zwqzeq/gitskills.git 4.5将本地仓库指定分支合并到远程仓库指定分支： $ git push origin dev_branch : dev_branch 4.6强行让本地分支覆盖远程分支： $ git push 远程库名 远程库的分支名 -f 4.7将远程仓库的某个分支合并到当前本地分支： $ git pull 远程仓库名 远程仓库的分支名 五、文件保存和提交:5.1将文件从工作区添加到暂存区： $ git add &lt;file&gt; 5.2将文件从暂存区提交到版本库： $ git commit -m “提交说明” 5.3随时查看当前仓库的状态： $ git status 5.4查看修改了具体修改了那些内容： $ git diff &lt;file&gt; 六、日志相关：6.1查看提交历史（只有commit过的才能查到），以便确定要回退到哪个版本： $ git log 6.2如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline 6.3如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline --abbrev-commit 6.4查看命令历史（包括reset，commit，checkout），以便确定要回到未来的哪个版本（不包括从工作区添加（add）到暂存区的命令）： $ git reflog 七、版本回退:7.1退回到上一个版本： $ git reset --hard HEAD^ //针对版本库 7.2退回到上上个版本： $ git reset --hard HEAD^^ 7.3退回到上100个版本： $ git reset --hard HEAD~100 7.4退回到指定版本： $ git reset --hard commit_ID 7.5只丢弃暂存区修改： $ git reset HEAD &lt;file&gt; //针对暂存区，让暂存区恢复之前的状态 7.6只丢弃工作区的修改： $ git checkout --&lt;file&gt; //针对工作区，让工作区恢复之前的状态，即让工作区和暂存区一致，如果没有暂存区，则让工作区和版本库一致，如果该文件既没有添加到暂存区也没有提交到版本库，则工作区中该文件的修改不能被丢弃 八、分支相关:8.1查看分支： $ git branch 8.2创建分支： $ git branch &lt;name&gt; 8.3切换分支： $ git checkout &lt;name&gt;（注意与恢复文件的区别，此处checkout后面没有“–”） 8.4创建+切换分支： $ git checkout -b &lt;name&gt; 8.5合并某分支到当前分支： $ git merge &lt;name&gt; 8.6删除分支： $ git branch -d &lt;name&gt; 8.7重命名分支： $ git branch -m old_branch new_branch 8.8看到分支合并情况： $ git log --graph --pretty=oneline --abbrev-commit 8.9可以禁用快速合并dev方式： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev 8.10删除一般的分支： $ git branch -d &lt;name&gt; 8.11丢弃一个没有被合并过的分支，可以通过： $ git branch -D &lt;name&gt; //强行删除 九、标签相关：9.1默认标签是打在当前分支最新提交的commit上: $ git tag &lt;name&gt; 9.2指定一个commit id，给其打上标签，即以后标签可代表commit id: $ git tag &lt;name&gt; commit_id 9.3查看所有标签名： $ git tag 9.4查看标签信息： $ git show &lt;tagname&gt; 9.5指定标签信息： $ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; commit_ID 9.6删除本地标签： $ git tag -d v0.1 9.7推送某个标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin &lt;tagname&gt; 9.8推送所有标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin --tags 9.9删除远程标签：如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除： $ git tag -d v0.9 $ git push origin :refs/tags/v0.9 十、临时保存工作现场：10.1前工作现场“储藏（或称隐藏）”起来，等以后恢复现场后继续工作： $ git stash 10.2查看某个分支上隐藏工作区： $ git stash list 10.3恢复工作现场：两种方式： 方式一：用$ git stash apply恢复,但是恢复后,stash内容并不删除,你需要用$ git stash drop来删除； 方式二：用$ git stash pop,恢复的同时把stash内容也删了]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Git]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Git.html</url>
    <content type="text"><![CDATA[前言: 你是否有这样的经历：写word文档时,想删除一部分内容，又怕将来想恢复找不回来怎么办？常见办法就是先把当前文件“另存为”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件.改到最后你自己都分不清,哪个文件里面是修改了什么. 如果有，那么恭喜你，以后不会再有这种事情发生了，git能帮你管理文件. git是什么?Git是目前世界上最先进的分布式版本控制系统（没有之一）. GIT的历史背景: 很多人都知道，Linus（李纳斯）在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。直到2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 分布式的git和集中式的CVS/SVN对比:联网： 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式版本控制系统最大的毛病就是必须联网才能工作． 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。 安全性： 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 如何安装？在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，(或者鼠标右键,可以找到git Bash)蹦出一个类似命令行窗口的东西，就说明Git安装成功.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>初识Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[前言:​ 为了方便查阅,这里将常用指令汇总. 简写指令:hexo n &quot;我的博客&quot; 等价于 hexo new &quot;我的博客&quot; 还等价于 hexo new post &quot;我的博客&quot; #新建一篇文章hexo p 等价于 hexo publishhexo g 等价于 hexo generatehexo s等价于 hexo serverhexo d 等价于 hexo deployhexo deploy -g 等价于 hexo deploy --generatehexo generate -d等价于hexo generate --deploy 注: hexo clean 没有 简写, git –version 没有简写 指令说明:hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。hexo server -s #以静态模式启动hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)hexo d #将本地数据部署到远端服务器(如github)hexo init 文件夹名称 #初始化XX文件夹名称npm update hexo -g#升级npm install hexo -g#安装node-v #查看node.js版本号npm -v #查看npm版本号git --version #查看git版本号hexo -v #查看hexo版本号 hexo publish [layout] &lt;title&gt; #通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 hexo new aaa &quot;bbb&quot; # 新建一篇文章,文章名称和标题分别为bbb.md 和 bbb. 文章采用aaa布局, 此时会在站点根目录下的—-&gt;source—–&gt;_post文件夹下生成bbb.md文件, bbb.md文件的顶部(—–分割线上方区域,也称作Front matter区),生成 layout: aaatitle:date:]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化配置]]></title>
    <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[前言: 如果你觉得我的博客界面不错，你可以参考这篇文章，在这篇文章中总结了几十个个性化配置，并不是都要安装，取你所需即可． 一、常用的个性化配置汇总： １．更换主题 ２．设置语言 ３．字数统计和阅读时长(网站底部/文章内) ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量） ５．本站已安全运行 XX天 XX小时XX分XX秒 ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例 ７．添加热度（文章阅读次数） ８．为博客加上宠物 ９．鼠标点击出现桃心效果 １０．网页底部的动态桃心图像 １１．添加顶部加载条 １２．设置网站的图标Favicon １３．DaoVoice 在线联系 １４．添加AddThis分享 １５．添加打赏 １６．文章加密访问 １７．在文章底部增加版权信息 １８．修改文章底部的那个带#号的标签 １９．在每篇文章末尾添加“本文结束”标记 ２０．修改作者头像并旋转 ２１．隐藏网页底部powered By Hexo / 强力驱动 ２２．在右上角或者左上角实现fork me on github ２３．修改代码块自定义样式（设置代码高亮主题） ２４．开启代码块复制 ２５．侧边栏社交链接 ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２７．修改背景图,以及侧边栏顶部颜色 ２８．侧边栏添加网易云音乐 ２９．底部添加公网安备 ３０．取消“文章目录”的自动编号 ３１．封面模式 １．更换主题: (以next主题为例)注: next 主题的 github仓库地址迁移了 １．１ 下载主题:旧版本next主题地址: 5以下的版本包含5: 旧版本5以下 安装指令: 首先打开git bash进入根目录即 “ /blog/“ 执行命令:git clone https://github.com/iissnan/hexo-theme-next themes/next 此时会从next主题的作者的github仓库克隆next主题到 我们本地的 /blog/theme/next文件夹下 最新版在这里下载: 新版本6开始 安装指令: 同上 git clone https://github.com/theme-next/hexo-theme-next themes/next 安装完成后，打开 站点配置文件,找到 theme 字段，并将其值更改为 next, 一定要保存 依次执行git clean，git g,git s 然后查看运行结果: nexT主题有四种选择，上面这个只是最简洁的一种，我选择的是Gemini布局。 １．２ 修改主题配置文件： 然后重新git clean，git g，git s查看效果: ２．设置语言：在站点配置文件中设置语言: 12language: zh-Hans next5以下版本(包含)language: zh-CN next6以上版本(包含) ３．字数统计和阅读时长(网站底部/文章内):３．１ 首先安装插件: $ npm install hexo-symbols-count-time --save ３．２ 然后修改主题配置文件如下: 123456symbols_count_time: separated_meta: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_post: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true ＃底部footer是否显示字数统计属性文字(如站点总字数,站点阅读时长 ≈ 1 分钟) awl: 4 ＃计算字数的一个设置,没设置过 wpm: 275 ＃一分钟阅读的字数 ３．３ 站点配置文件中添加： 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 注意: 配置文件中的空格** ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量）打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站总访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;| &lt;/span&gt;&lt;span id="busuanzi_container_site_pv"&gt; &amp;nbsp;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; ５．本站已安全运行 XX天 XX小时XX分XX秒打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910111213141516&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250);&lt;/script&gt; ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例:先注册leancloud账号,获取自己的appid,appkey 打开主题配置文件,修改如下: 1234567891011valine: enable: true # 为true时启用评论 appid: # 这里填写上面得到的APP ID 注意空一格再输入ID和key, appkey: # 这里填写上面得到的APP KEY notify: false # 邮件通知 verify: false # 验证码 placeholder: #评论框中预设的文字,随意填写 avatar: mm # gravatar style 头像,采用gravatar头像,到http://cn.gravatar.com/了解 guest_info: nick,mail,link # custom comment header 访客信息,显示在评论框上面,三者可随意选择或全选 pageSize: 10 # pagination size 评论分页大小 visitor: false # ７．添加热度（文章阅读次数）修改主题配置文件 1234leancloud_visitors: enable: true app_id: #填入你leancloud账号的appid app_key: #填入你leancloud账号的appkey 打开/blog/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/blog/themes/next/languages/zh-Hans.yml,将画红框的改为热度就OK了 ８．为博客加上宠物８．１ 在hexo根目录下安装插件: $ npm install -save hexo-helper-live2d ８．２ 安装需要的宠物插件:宠物样式 源码地址 $ npm install {packagename} 其中{packagename} 替换为你要安装的宠物名,如live2d-widget-model-shizuku 具体指令: $ npm install live2d-widget-model-shizuku ８．３ 在站点配置文件中加上如下代码: 1234567891011live2d: enable: true #开启宠物 scriptFrom: local model: use: live2d-widget-model-shizuku display: position: right #指定宠物显示的位置 width: 70 #指定宠物显示的宽度 height: 120 #指定宠物显示的高度 mobile: show: true #是否在手机上显示 ９．鼠标点击出现桃心效果并且将代码复制进去，然后保存 在/themes/next/source/js/src里面 新建click-love.js文件: 粘贴如下代码: 12&lt;!-- 页面点击小桃心--&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 然后打开\themes\next\layout\_layout.swig文件,在末尾添加以下代码： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); １０．网页底部的动态桃心图像修改主题配置文件: 1234icon: name: heart #如果name的值为heart表示引用fontawesome网站上的心形图标 animated: true #如果想用动态图标应该将animated的值设为true color: "#ff0000" #图标的色--用16进制数 １１．添加顶部加载条在根目录打开git bash执行以下指令: 1git clone https://github.com/theme-next/theme-next-pace source /lib/pace 修改主题配置文件: 12pace: true #启用顶部加载条pace_theme: pace-theme-flash #指定顶部加载条样式 １２．设置网站的图标Favicon１２．１ 下载一个32*32的图片，并改名为favicon.ico, 然后放到/blog/themes/next/source/images目录 １２．２ 修改主题配置文件 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg １３． DaoVoice 在线联系１３．１ 注册地址: ,获取app_id １３．２ /blog/themes/next/layout/_partials/head/head.swig 添加下面的代码: 123456789101112131415&#123;% if theme.custom_file_path.head %&#125; &#123;% set custom_head = '../../../../../' + theme.custom_file_path.head %&#125;&#123;% else %&#125; &#123;% set custom_head = '../../_custom/head.swig' %&#125;&#123;% endif %&#125;&#123;% include custom_head %&#125;&#123;% if theme.daovoice %&#125; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0eeeae6f.js","daovoice") daovoice('init', &#123; app_id: "06289ecd"&#125;);daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; １３．３ 修改主题的配置文件 12daovoice: truedaovoice_app_id: 我们注册获取的id １４．添加AddThis分享１４．１ 在网站 AddThis 上注册账号。 可以使用 Google/Facebook/Twitter 账号进行第三方登陆 １４．２ 设置分享按钮的样式:(显示位置, 显示样式为扩展式,悬浮式等) １４．３ 修改主题配置文件 你Addthis账号ID ```123456789## １５．添加打赏:```javascript reward: enable: true ＃开启 comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ ＃图片上方显示的文本 wechatpay: ＃图片地址 alipay: ＃图片地址 １６．文章加密访问１６．１ 在 /blog/themes/next/layout/_partials/head/head.swig 文件中添加： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; １６．２ 在需要加密的文章的页面顶部(Front matter区域)加入 “password : 设置密码值” １７．在文章底部增加版权信息１７．１ 在/blog/themes/next/layout/_macro/ 下添加 my-copyright.swig文件： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;版权声明:&lt;/span&gt;本博客所有文章除特别声明外，均采用 &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt;BY-NC-SA &lt;/a&gt;许可协议。转载请注明出处!&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; １７．２ 在目录/blog/themes/next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; １７．３ 修改/blog/themes/next/layout/_macro/post.swig，在下面位置添加: 代码如下: 12345 &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １７．４ 修改/blog/themes/next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： @import &quot;my-post-copyright 保存重新生成即可。１７．５ 如果要在文章下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: hexo个性化配置date: 2017-05-22 22:53:53tags: hexo美化categories: Hexocopyright: true--- 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： １８．修改文章底部的那个带#号的标签修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; １９．在每篇文章末尾添加“本文结束”标记１９．１ 在路径 /blog/themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; １９．２ 接着打开/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer之前添加,即在如下位置添加 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １９．３ 然后打开主题配置文件（_config.yml),在末尾添加： 123#文章末尾添加“本文结束”标记passage_end_tag: enabled: true ２０．修改侧边栏作者头像并旋转：２０．１ 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; ２１．隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： ２2．在右上角或者左上角实现fork me on github点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 /blog/themes/next/layout/_layout.swig文件中进行配置. next表示的是当前你使用的主题的样式. 注意的是: href 后面是自己的github的地址,记得修改哦! ２３．修改代码块自定义样式修改主题配置文件 highlight_theme: night bright #可选值: normal | night | night eighties | night blue | night bright ２４．开启代码块复制123codeblock: enable: true show_result: true ２５．侧边栏社交链接修改主题配置文件: 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址 123456789101112131415161718#设置侧边栏社交链social: GitHub: https://github.com/zzwwqq || github E-Mail: mailto:zwq13264860490@gmail.com || envelope Weibo: https://weibo.com/u/5564810309/home?wvr=5 || weibo 知乎: https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities || snapchat#这里键的值必须和上面social中的 "||" 后面指定的名称一致，在fontawesome官网找喜欢的小图标，将名字复制在如下位置，如E-Mail:对应的图标名称为envelope。social_icons: enable: true # `enable` 选项用于控制是否显示图标 icons_only: false transition: false #图标 GitHub: github E-Mail: envelope Weibo: weibo 知乎: snapchat ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２６．１ 七牛是什么? 七牛 是一个云存储服务商，注册并实名认证之后1后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。七牛的定位不是像百度云一样的 网盘 ，也不是同坚果云一般的 同步云 ，而是 CDN 2 ，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源。对于个人博主来说，你可以把博客中的图片、音频、视频等媒体上传到七牛，在博客中引用；也可以将站点需要加载的CSS、JS等文件上传到七牛，以加速网站。 ２６．２ 与其他上传站点相比： 更稳定：七牛毕竟是老牌服务商，数据的安全性和稳定性都较有保证。如果上传到什么小网站，哪天发现图片都打不开了才是人间惨剧~ 更灵活：配合 hexo-qiniu-sync 插件4，就算是七牛以后更改了空间域名，也不用一篇一篇地去改外链地址，只要在配置文件中修改外链前缀即可。 更方便：配合 hexo-qiniu-sync 插件，不必”上传→复制链接→引用外链“，直接按照本地路径引用，然后键入一条命令同步到七牛就好。会自动识别哪些是新增、修改的文件需要上传，哪些是原有的文件不需改动，十分方便。 ２６．３ 七牛并非尽善尽美： 在线文件管理不支持目录 本地删除文件，云端不能同步删除文件 ２６．４ 开始安装： １．点击 这里 申请七牛账户 ２．创建存储空间（七牛叫作”Bucket“），注意添加的空间为”对象存储“，访问控制选择”公开空间“： ３．点击页面右上角头像→进入”密钥管理“→复制当前使用中的AK和SK，待会设置插件时会用到。 ４．安装插件：在hexo主目录下运行以下命令： npm install hexo-qiniu-sync --save ５．站点配置文件中添加下面内容: 1234567891011121314151617181920qiniu: offline: false #是否离线. 离线状态将使用本地地址渲染 sync: true #是否同步 bucket: blog #这里替换为你存储空间的名称 #secret_file: sec/qn.json or C: access_key: 2rRw0dG-jQYCoqs9rvsltVQqzSBVpwS #上传密钥AccessKey,替换为你自己的 secret_key: OCBcCU3tqKiBdOza9PlLoR6AcA-fV_u #上传密钥SecretKey,替换为你自己的 dirPrefix: static #上传的资源子目录前缀.如设置为static，那么urlPrefix后面也要加static urlPrefix: http://cdn.zzwwqq.xyz/static/ #这里替换为你自己的外链域名,如何获取,查看下面图示 up_host: http://upload.qiniu.com #这里不用改 local_dir: static #本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的static 文件夹（也就是与 source 目录平级）中。 update_exist: true #是否更新已经上传过的文件 #运行程序后,会自动在本地根目录生成static目录,static目录下生成三个文件夹,js,css,images image: folder: images extend: js: folder: js css: folder: css ６．如何引用七牛上的图片? 引用地址：urlPrefix＋dirPrefix＋images+ 相对于/blog/static/images/ 的文件路径 例如: http://cdn.zzwwqq.xyz/static/images/hexo/hexo-1.jpg ２７．修改背景图,以及侧边栏顶部颜色，主／副标题颜色效果图： 123456789101112131415161718192021//添加背景图片body &#123; background:url(http://cdn.zzwwqq.xyz/%E6%98%9F%E7%A9%BA.jpg)&#125;//改掉题头颜色.site-meta &#123;background:url(http://cdn.zzwwqq.xyz/static/images/hexo/hexo-0-site-meta.jpg) &#125;//主标题颜色.brand&#123; color: #4dfc23 &#125;//副标题颜色.site-subtitle&#123; color: #4dfc23&#125;.footer&#123; font-size: 14px; color: #ededed;&#125; ２８．侧边栏添加网易云音乐效果图: 打开网易云音乐官网，进入想插入的音乐的界面 点击“生成外链播放器” 复制代码 ##２９．底部添加公网安备 12345 &lt;div class="BbeiAn-info" style="color:#4dfc23"&gt; &#123;&#123; __('鄂ICP备') &#125;&#125; - &lt;a target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#4dfc23;" rel="nofollow"&gt;18025394&lt;/a&gt; &lt;!--a标签中增加nofollow属性，避免爬虫出站。--&gt;| &lt;a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42090202000295" style="text-decoration:none;color:#4dfc23;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow"&gt;&#123;&#123; __('鄂公网安备 42090202000295') &#125;&#125;&lt;/a&gt; &lt;!--这里将图标作为了背景，以使得能和后面的文字在同一行--&gt;&lt;/div&gt; ３０．取消“文章目录”的自动编号 修改如下 修改后: ３１．封面模式需要安装一个小插件是：hexo-less，安装指令: $ npm install --save hexo-less 该插件解决了什么问题呢？ 手动设置文章概要，但不影响章内䆟。只需在文章中写 &lt;!-- less --&gt; 作为分割线， &lt;!-- less --&gt; 上面的内容会作为摘要，但不作为文章内容的一部分。 举例，我想让这篇文章在主页列表中，只显示一张美图。 效果图： 文章中代码如下: 二、说明:修改hexo的站点配置文件,需要重启服务器(即执行 $ hexo s命令),才能生效. 修改其他文件如主题配置文件,不必重启服务器(即执行 $ hexo s命令), 直接刷新页面即可生效. 参考链接: http://theme-next.iissnan.com/getting-started.html https://www.jianshu.com/p/f054333ac9e6 https://www.jianshu.com/p/d0fe52c73950 https://xian6ge.cn/posts/40ba2cba/ https://me.idealli.com/post/e8d13fc.html http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/ https://www.jianshu.com/p/805bd0b65d98]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo发布文章]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[前言: 经过前面两节的操作，hexo的整个框架以及和github关联已经配置好了,现在我们要考虑的就是 如何用指令去创建一篇文章,然后发布? .我们先来看一下hexo的目录结构,了解每个目录的作用,这将让我们对hexo的运行原理有一个大概的认识,对于我们后面美化主题是有帮助的, 然后再来创建文章,并发布到本地服务器,最后查看效果. 一、Hexo的目录分析: １．.deploy_git: 这个目录是执行 hexo d 命令 后生成的,主要存放部署的信息. ２．node_modules: 这个目录存放的是一些插件包 ３．public : 这个目录是执行 hexo g后生成的, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下 ４．scaffolds: 用来存放模板文件。模板文件的正文部分一般为空，一般在模板文件顶部有一个区域 ( 以 --- 分隔的区域) 称作Front-matter,在这里配置的变量主要有title(即文章标题), date(即文章创建日期),comment(是否开启评论), tags(文章标签), categories(文章所属分类)等. 当你新建文章时，Hexo 会根据 scaffold 来建立文件，也就是说会在你创建的每个文件顶部自动加上模板文件中配置的这些内容. ５．source: 存放你的文章(.md后缀的文件) ６．static: 这个目录是我自己创建的，专门用来存放图片的 ７．themes: 这个目录是存放主题的(默认主题是landscape, 目前使用最多的是next主题) ８．.gitignore: 这个文件和git有关, 在这个文件里面可以配置哪些文件不被提交(例如: 配置 *.log ,那么在hexo d命令的时候, 任何以.log为后缀的文件将不会被提交到github) ９．_admin-config.yml: 这个文件是安装了hexo 后台管理插件后生成的,这里暂时不作介绍,后面再说 １０．_config.yml: 这个文件是hexo的核心配置文件(也称站点配置文件) １１．_config.yml.back.yml: 这个文件是我自己创建的,是站点配置文件的备份. 以防哪一天老眼昏花把内容改错了,到时可以恢复. １２．package.json: 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 １３．db.json： １４．package-lock.json: 二、使用Hexo指令创建一篇文章:​ $ hexo new [layout] &lt;title&gt; 这里有必要对指令作一些说明: 就[layout]即＂布局＂ 而言:Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局: 路径: 说明: post source/_posts 如果你输入的指令中[layout]参数空着,那么默认是post;例如:hexo new 我的第一篇文章;等价于:hexo new post 我的第一篇文章; 产生的作用就是: 在source/_posts路径下生成 “我的第一篇文章.md” 文件,这个就是你要写文章的那个文件. page source draft source/_drafts 你可以通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 就&lt;title&gt;而言:默认是指定文章的标题和.md文件名称, 你可以任意指定一个名称来取代指令中的&lt;title&gt;参数. 注: 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 三、举例: 需求: 我要创建一篇文章,文件名为 “使用hexo发布文章” 文章标题为”使用hexo发布文章” 并且自动在文件顶部(Front-Matter区域),添加文章分类,标签 的键, 键对应的值由我们自己添加.最后发布到本地服务器查看效果. 首先修改模板文件: 打开git bash 执行指令: 查看生成文件所在目录以及文件名: 查看生成的文章, 文章标题,分类,标签等是否自动添加了: 给文章添加分类,和标签: 发布文章到本地服务器: $ hexo clean $ hexo g $ hexo s 查看效果: 四、说明: 通过上面的操作后，你可能会感到奇怪，为什么自己的界面和图示的不一样呢？这里我得解释下，在第一节安装hexo时,hexo默认给我们安装了ｌａｎｄｓｃａｐｅ主题. 这个主题可以在 “/blog/themes” 路径下找到. 而我安装的是next主题,并做了些个性化配置. 所以和你的界面不同. 如果你和我一样对默认主题不满意,喜爱折腾,追求完美,那么请关注下一节内容.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>使用hexo发布文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署到GitHub]]></title>
    <url>%2Fhexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub.html</url>
    <content type="text"><![CDATA[前言: 上一节我们已经将hexo部署到本地了，但是只有在你自己主机上才能查看博客，如果你想让任何人随时随地都能访问到你的博客，那么你可以考虑将hexo部署到github(属于国外,所以访问速度要慢一些)或者codying(国内),如果你是一个程序员,那么推荐你选择github, 你要是不知道GitHub， 那就太说不过去了， 我可能遇到了一个假的程序员！ 步骤: １．注册一个github账号: 注册 ２．回到你的本地机,打开git bash,设置用户名和邮箱:(目的是:上传文件的时候告诉github,是谁向远程仓库上传数据) $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 注: 这里”Your Name” 替换为你的GitHub的用户名,”email@example.com“替换为你的GitHub的邮箱 输入完后,通过以下命令检查你的设置是否正确: (如果你比较懒,那就忽略吧!) $ git config user.name $ git config user.email ３．生成ＳＳＨ密钥并添加到github： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 此时它会告诉你已经生成了.ssh的文件夹, 在你的电脑中找到它,复制id_rsa.pub 文件中的内容. 此时回到GitHub页面 ​ 然后回到gitbash中，输入指令查看是否添加成功: $ ssh -T git@github.com ；如果你看到以下内容，恭喜你配置成功了． ４．创建github仓库: ​ ​ 选择一个主题: (临时测试用,等会会覆盖的) 浏览器地址栏输入用户名.github.io：如果出现下面的界面说明你的域名已经生效 ５．将Hexo部署到github: 经过上面的操作后,此时我们就可以将hexo和GitHub关联起来了,也就是将hexo生成的文章部署到github 打开站点配置文件(/blog/_config.yml), 翻到最后,找到deploy: 修改为:​ 123deploy: type: git repo: github: git@github.com:zzwwqq/zzwwqq.github.io.git,master 说明: master 表示 部署到远程仓库的master分支上 git@github.com:zzwwqq/zzwwqq.github.io.git 改为你的仓库地址, 你可以去github网页上拷贝 安装deploy-git, 也就是部署的命令,这样你才能用命令部署到GitHub. $ npm install hexo-deployer-git --save 然后执行下述命令: hexo clean hexo g hexo d 执行了hexo d后 ,如果最后一行显示如下内容,说明部署成功, 现在你可以去浏览器地址栏输入 你的域名进行访问了.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo部署到GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[１．帮助：(查看指令的详细信息)1.1 xxx --help (xxx -h) 1.2 man xxx ２．查看哪个程序占用了特定端口？占用某个端口的进程是谁?2.1 lsof -i -n -P | grep :80 //查看哪个程序占用了特定端口 2.2 lsof -i//显示所有打开的端口 2.3 lsof -i:80 //显示所有打开80端口的进程 2.4 lsof -n //不将IP转换为hostname，缺省是不加上-n参数 -P //port numbers to port names; ３．查看磁盘使用情况： 查看磁盘中指定目录的使用情况：du -ach --max-depth=1 指定目录的路径 查看系统磁盘占用情况：df -lh ４．进程相关操作： 查看系统执行的进程（不包括父进程）：ps -aux | more (ps -aux | grep xxxx) 查看当前所有进程，包括父进程：ps -ef | more (ps -ef | grep xxxx) 查看系统负载：w 动态查看负载: top 在 top 状态下: 按shift + m，可以按照内存使用大小排序。 按数字 1 可以列出各颗 cpu 的使用状态。 静态查看系统负载：top -bn1 和 top 命令唯一的区别就是，它一次性全部把所有信息输出出来而非动态显示。 查看系统当前剩余多少内存： free -h (-h及human，以方便人阅读方式显示) 杀死进程：kill 进程号 强制杀死进程：kill -9 进程号 按照进程名强制杀死该进程名的所有进程：pkill -9 进程名 按照进程名杀死进程：killall 进程名 ５．查看系统信息： 查看内核版本号：uname -r 查看系统内核版本，gcc编译器版本详细信息： cat /proc/version 查看系统信息：cat /etc/redhat-release 查看操作系统版本所有信息: lsb_release -a 查看内存信息 cat /proc/meminfo 查看网卡信息 dmesg | grep -i eth 查看机器型号 dmidecode | grep &quot;Product Name&quot; 查看硬盘信息命令 : fdisk -l 查看主板信息 dmidecode |grep -A16 &quot;System Information$&quot; 查看CPU信息（型号) cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看CPU的主频 cat /proc/cpuinfo |grep MHz|uniq 查看当前CPU运行在32bit还是64bit模式下 getconf LONG_BIT 查看是否支持64bit cat /proc/cpuinfo | grep flags | grep &#39;lm&#39; | wc -l (如果结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit) 查看CPU是几核: cat /proc/cpuinfo |grep &quot;cores&quot;|uniq 逻辑CPU个数：cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l 物理CPU个数： cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l 每个物理CPU中Core的个数： cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l ６．查看网络： 查看当前主机的ip地址和网卡信息: ifconfig （附加网卡的启用ifup eth0与停用stop eth0命令） 查看IP地址信息：ip addr (注：安装minimal版的CentOS系统时，ifconfig等网络相关的指令用不了，暂时可以用ip addr) 测试网络的连通性 : ping (网络统计)命令显示连接信息,路由表信息等: netstat 通常配合使用参数，这里只演示一个参数。netstat -? 打印网络连接状况：netstat -anp （-p表示显示进程名和进程ID） 当前系统启动哪些端口：netstat -lnp （-l表示显示正在监听的端口)netstat指令无效时：使用yum install net-tools安装 路由跟踪命令: traceroute 可以查看到你从源到目的的所经过的路由 查询DNS相关信息记录,CNAME,MX记录等等: dig 这个命令主要用于解决相关DNS查询； ​ nslookup 也具备查询DNS的功能，还可以显示一个ip地址的记录！ 查找到IP的名称或IP的名字在IPv4和IPv6 DNS记录和查询: host IP地址 例如host www.baidu.com 查看主机名: hostname 或者你可以到/etc/sysconfig/network中修改主机名。 查看路由表信息: route 增加和删除路由条目: root add -net 192.168.199.129/24 gw 192.168.199.1 查看默认的表使用: arp 为地址解析协议 查看网络模式和网络速度等信息: ethtool 有关配置可以到/etc/sysconfig/network-scripts/ifcfg-eth0下进行修改。 ７．任务调度： 编辑定时任务：crontab -e 删除：crontab -r 查询：crontab -l 重启：service crond restart ８．压缩/解压缩： 解压到当前目录：tar -zxvf xxx.tar.gz 解压到指定目录：tar -zxvf xxx.tar.gz -C 目标目录 压缩：tar -zcvf 打包后的文件名（以.tar.gz为后缀） 要压缩的文件名 tar里面没有针对xz格式的参数比如 -z是针对 gzip，-j是针对 bzip2） 解压tar.xz文件： 先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。 创建tar.xz文件： 先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件， 然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz ９．rpm：安装/查询/删除rpm包： 安装本地的rpm包：rpm -ivh rpm包全路径名 查询是否安装了某个rpm包：rpm -qa | grep 软件名 删除rpm方法安装的某个rpm包： rpm -e 软件包名 升级某个rpm包：rpm -Uvh 软件包名 １０．yum：安装/查询/删除rpm包： 查询公网的yum服务器中是否有我们要安装的某个软件源：yum list | grep 软件名 (或者用yum search 软件名) 安装最新版的某个软件（默认）：yum -y install 软件名 安装指定版本的某个软件：yum -y install 软件名-版本号 升级某个rpm包： yum update -y 软件名 （查看是否有新版本及版本号 yum update |grep 软件名） 删除yum方式安装的rpm包：yum remove 软件名 当要使用一个指令，系统提示不存在，于是用yum安装它但又不知道它属于哪个rpm包时：yum provides 指令名（以ifconfig为例：yum provides ifconfig） 查看包的关系：repoquery --nvr --whatprovides 包名 （ repoquery是yum扩展工具包yum-utils中的一个工具，所有如果你没有repoquery命令的话，可以先 sudo yum install yum-utils 安装yum-utils包） １１．防火墙： CentOS7查看防火墙状态：systemctl status firewalld (CentOS6查看防火墙状态:service iptables status) 临时关闭防火墙：systemctl stop firewalld 启动防火墙：systemctl start firewalld １２．关机/重启/注销linux： 关机：halt （或者shutdown -h 1 表示一分钟后关机；shutdown -h now立刻关机） 重启：reboot 注销：logout １３．文件/目录操作： 创建目录（父目录不存在时创建父目录，即级联创建目录）：mkdir -pv 目录名（目录名如./aaa/bbb/ccc/ddd） 创建文件：touch 文件名 递归且强制删除目录/文件：rm -rf 目录名 显示目录下的文件/目录：ls -a (-a 表示列出所有文件，包括隐藏文件) ls -d (-d表示针对目录的，只列出目录本身) 浏览小文件并显示行号：cat -n 文件名 （浏览大文件：cat -n 文件名 | more） 浏览大文件 并显示行号，百分比：less -mN 文件名 追加：向文件的内容后面追加内容：echo &quot;内容&quot; &gt;&gt; 文件名 覆盖：用文件1的内容覆盖文件2里面的内容 ： cat 文件1 &gt; 文件2 控制台打印内容：echo “xxxx” 查看文件后5行：tail -n 5 文件名 （查看前5行：head -n 文件名） 创建快捷方式（软链接）：ln -s 原文件 快捷方式名称 文件重命名 ： mv 原文件名/目录名 新文件名/目录名 剪切（移动）：mv 原文件名/目录 新的路径 复制：cp -r 原文件/目录 目标文件/目录 （注意：复制目录必须加-r，表递归复制） １４．搜索文件/目录： 按照名称查询某个目录下是否有某个文件：find 搜索的目录 -name 要搜索的文件名 查询某个目录下属于某个用户的所有文件： find 搜索的目录 -user 用户名 １５．用户操作： 切换为某个用户：su -用户名 切换为管理员用户即root用户：su - 以管理员权限执行一条命令 ：sudo 要执行的命令 创建用户/组：useradd/groupadd useradd -g 所属的组名 用户名（注意：指定用户所属的组（前提：组存在）） 改变文件所属用户/组：chown/chgrp 改变用户所属组：usermod 改权限：chmod 改运行级别：chkconfig --level 0到6的数字 服务名 on （on 表开启，off表关闭） 查看用户所属组：id 用户名 查看有哪些用户：cat /etc/passwd 查看有哪些组：cat /etc/group 设置密码 passwd 用户名 １６．查看以前敲过的所有命令：history （常与管道连用，history | more）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的安装]]></title>
    <url>%2FLinux%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[前言: 上一节我们了解了Linux的一些基本概念,这一节我们将开始安装Linux系统,Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习. 什么是虚拟机? 安装虚拟机软件VMware:Vmware 下载地址 VMWare10 创建虚拟机空间:安装好 vmware 后，就可以创建虚拟机空间了: 点击新建虚拟机 安装CentOS系统:安装系统之前，需要先去下载一个镜像文件: CentOS下载地址： ​ 网易镜像：网易镜像​ 搜狐镜像：搜狐镜像 ​ 阿里云CentOS7镜像: 可以选择第一个：CentOS-7-x86_64-DVD-1708.iso 进行下载即可。 这里找到Ｌｉｎｕｘ系统的iso镜像(即.iso后缀)文件 这里如果选择OK,此时会联网检查系统的完整性,会等待很久,所以这里选择skip.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux的安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Linux.html</url>
    <content type="text"><![CDATA[前言: 根据JoblabXTM整理，使用Linux操作系统占据了整个操作系统的绝大数量，已经接近99%！立志于互联网行业的工程师们掌握Linux这门技术对自身的职业发展，一定会起到事半功倍之效果,所有我们有必要学习Linux操作系统. 一、Linux是什么,怎么读? linux是一个开源、免费的类Unix操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目都会部署到Linux/unix系统上。 Linux 读作[里纽克斯, 利尼克斯,里纳克斯] 二、Linux 的历史背景: 最初是由芬兰赫尔辛基大学学生Linus Torvalds (林纳斯-托瓦斯)由于自己不满意教学中使用的MINIX操作系统,所有在1990年底由于个人爱好设计出了LINUX系统核心,后来发布于芬兰最大的ftp服务器上,用户可以免费下载,所有它的周边的程序越来越多,Linux本身也逐渐壮大起来,之后Linux在不到三年的时间里成为了一个功能完善,稳定可靠的操作系统. 三、Linux的版本和分类:3.1 Linux 版本分两种: 内核版本 和发行版本: 内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号. 发行版本是一些组织和公司根据自己发行版的不同而自定. 3.2 一般来说著名的linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等 Debian系列：Debian、Ubuntu(乌班图)等 RedHat(红帽)系列 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 包管理工具 yum 支持tar包 Debian(蝶变)系列 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 包管理工具 apt-get 支持tar包 四、Unix简介: Unix是一个强大的多用户、多任务操作系统.于1969年在AT&amp;T(美国电话电报公司)的贝尔实验室开发. UNIX的商标权由国际开放标准组织所拥有. UNIX操作系统是商业版,需要收费,价格比Windows正版要贵一些. 五、Linux和Unix的关系: 六、Linux和Windows的比较: 比较 Window Linux 免费与收费 收费且很贵 Linux 免费或少许费用 软件与支持 数量和质量的优势，不过大部分为收费软件；由微软官方提供支持和服务； 开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。 安全性 三天两头打补丁安装系统安全更新，还是会中病毒木马； 要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比Windows 平台要更加安全 使用习惯 普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易入门简单； 兼具图形界面操作和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高。 可定制性 封闭的，系统可定制性很差； 开源，可定制化非常强。 应用场景 桌面操作系统主要使用的是window。 支撑百度，谷歌，淘宝等应用软件和服务的，是后台成千上万的Linux服务器主机。世界上大部分软件和服务都是运行在Linux之上的。 七、Linux 在计算机中的位置: 八、Linux的目录结构: 目录 说明 / 根目录: 一般根目录下只存放目录,不存放文件 /bin (binaries) 存放二进制可执行文件，常用命令一般都在这里(如: ls,cat,mkdir等)。 /boot 存放用于系统启动时使用的各种文件 /dev (devices) 类似Windows的设备管理器, 把所有的硬件用文件的形式存储。 /etc (etcetera) 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /usr 用于存放系统应用程序，比较重要的目录 /usr/local [重点] : 一般通过编译源码方式安装的程序就存放在这里 /usr/sbin 超级用户的一些管理程序 /usr/share/man 帮助文档 /usr/bin 众多的应用程序 /var [重点] 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 /tmp 用于存放各种临时文件，是公用的临时文件存储点。 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统。 /opt 下载的未安装的软件一般放到这里 /media linux会自动识别一些设备,例如U盘,光驱等,当识别后会把识别的设备挂载到这个目录下 /lost+found 这个目录平时是空的，系统非正常关机会留下一些文件（windows下叫什么.chk）就存放在这里 ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>初识Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建Hexo基本框架]]></title>
    <url>%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[前言: 之前自己敲代码纯手工打造了一个博客,并成功部署到了阿里云服务器上,虽然界面不忍直视吧,但还是有一丝小小的成就感.最近看到朋友用Hexo框架搭建的一个博客,界面看起来很美观,于是乎爱折腾的我心动了,决定放手干,好了废话不多说,进入正题,先说一下我的思路:个人认为无论学习什么技术,首先要做的就是要了解这个技术是什么?然后为什么要用它,它有什么优势,特点?最后就是我该怎么用? 一、Hexo是什么? Hexo 是一款基于Node.js的静态博客生成程序，作者是中国台湾tommy351。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容． 二、Hexo有什么用,优势在哪? 如果你一直想拥有一个界面美观的,能在上面记录一些学习心得,个人日记,一些内容公开发布,一些内容私密访问,属于自己的博客平台,但是又愁于自己没有一定的编程能力难以实现这个想法,那么Hexo将会给你带来福音, 即使你没有一定的编程基础,你也可以快速使用Hexo打造一个你自己喜欢的博客,因为不需要你敲大量的代码,你要做的仅仅是不断的Ctrl+C,Ctrl+V改一改配置文件. 简单吧! 是不是有点心动了,心动就行动吧! ​ 三、如何安装?以Windows机为例:１．首先要安装的就是Git和Node.js这两个工具：（如果之前安装过,那么跳过这一步） Git下载地址: Git Node.js下载地址: Node.js ２．安装hexo: 打开git软件,通过node.js工具的npm命令来安装hexo: $ npm install -g hexo-cli ３．检测上述工具是否安装成功,如果成功会显示版本号：(如果你嫌麻烦可以忽略) node-v npm -v git --version hexo -v ４．在任意位置创建一个文件夹,例如:blog, 并进入该目录: 我这里是创建在E盘 $ cd /e/blog ５．运行下面的命令,hexo 将会在blog文件夹中生成所需要的文件 $ hexo init 会生成以下目录内容: ​ 注意: 将来自定义博客样式的时候别把站点配置文件和主题配置文件弄混淆了. ５．生成静态文件(hexo会将/blog/source/ 下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下): $ hexo g ６．启动服务器: $ hexo s 默认情况下，访问网址为： http://localhost:4000/ 在浏览器地址栏输入上面的地址: 如果看到下面这个界面，那么恭喜你安装成功了，这个就是hexo默认的博客主题,如果你不喜欢还有更酷炫的主题，如何操作，下节我们继续．现在你已经可以在这个主题下写博客了。 四、说明: $ hexo g 是 $ hexo generate 的简写形式,产生的作用是一样的 $ hexo s是 $ hexo server的简写, 表示启动本地服务器,让hexo在本地运行 $ hexo d 是 $ hexo deployed的简写, (这个指令是部署到远程服务器的,后面会讲到) $ hexo clean 没有简写,别写成了$ hexo c $ hexo server -p 5000 #更改端口 参考文档： Hexo]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo的安装</tag>
      </tags>
  </entry>
</search>
