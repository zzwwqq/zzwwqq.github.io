<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android之UI]]></title>
    <url>%2FAndroid%E4%B9%8BUI.html</url>
    <content type="text"><![CDATA[一、如何编写程序界面:Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局. 二、常见控件的使用方法2.1 TextView主要用于在界面上显示一段文本信息,设置颜色,文本居中 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ....&gt; &lt;TextView //给当前控件定义了一个唯一标识符 android:id="@+id/text_view" //所有的控件都具有这两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content android:layout_width="match_parent" android:layout_height="wrap_content" //文本居中对齐 android:gravity="center" //设置字体大小 android:textSize="24sp" //设置字体颜色 android:textColor="#00ff00" android:text="This is TextView" /&gt;&lt;/LinearLayout&gt;//match_parent 由父布局来决定当前控件的大小//wrap_content 由控件内容决定当前控件的大小 2.2 Button:activity_main.xml 中添加代码: 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ....&gt; .... &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt; 在 MainActivity 中为 Button 的点击事件注册一个监听器 1234567891011121314public class MainActivity extends Activity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... button = (Button) findViewById(R.id.button); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 在此处添加逻辑 &#125; &#125;); &#125;&#125; 2.3 EditText它允许用户在控件里输入和编辑内容 修改 布局文件activity_main.xml 中的代码: 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ...&gt; .... &lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" //输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失 android:hint="Type something here" //通过 android:maxLines 指定了 EditText 的最大行数为两行，这样当输入的内容超过两行时，文本就会向 //上滚动，而 EditText则不会再继续拉伸 android:maxLines="2" /&gt;&lt;/LinearLayout&gt; 通过点击按钮来获取EditText 中输入的内容。修改 MainActivity 中的代码 123456789101112131415161718192021222324public class MainActivity extends Activity implements OnClickListener &#123; private Button button; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: String inputText = editText.getText().toString(); Toast.makeText(MainActivity.this, inputText, Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125; 2.4 ImageView修改 activity_main.xml 123456789101112&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt;.... &lt;ImageView android:id="@+id/image_view" //将 ImageView 的宽和高都设定为wrap_content，这样保证不管图片的尺寸是多少都可以完整地展示出来 android:layout_width="wrap_content" android:layout_height="wrap_content" //使用 android:src 属性给 ImageView指定了一张图片 android:src="@drawable/ic_launcher" /&gt;&lt;/LinearLayout&gt; 通过代码动态地更改 ImageView 中的图片。这里我准备了另外一张图片，jelly_bean.png，将它复制到 res/drawable-hdpi 目录下，然后修改 MainActivity 的代码，如下所示： 123456789101112131415161718192021222324252627public class MainActivity extends Activity implements OnClickListener &#123; private Button button; private EditText editText; // private ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); // imageView = (ImageView) findViewById(R.id.image_view); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: //调用 ImageView 的 setImageResource()方法将显示的图片改成 jelly_bean imageView.setImageResource(R.drawable.jelly_bean); break; default: break; &#125; &#125;&#125; 2.5 ProgressBar用于在界面上显示一个进度条 修改 activity_main.xml 中的代码: 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"... &gt;... &lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:layout_height="wrap_content" //指定成水平进度条 style="?android:attr/progressBarStyleHorizontal" //给进度条设置一个最大值,然后在MainActivity类中动态地更改进度条的进度 android:max="100" /&gt;&lt;/LinearLayout&gt; Android控件的可见属性。可以通过android:visibility进行指定，可选值有三种，visible、invisible 和 gone。visible 表示控件是可见的，这个值是默认值invisible 表示控件不可见，但是它仍然占据着原来的位置和大小gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 三种值。 点击一下按钮让进度条消失，再点击一下按钮让进度条出现的这种效果。修改 MainActivity 中的代码 123456789101112131415161718192021222324public class MainActivity extends Activity implements OnClickListener &#123; .... private ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... progressBar = (ProgressBar) findViewById(R.id.progress_bar); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: if (progressBar.getVisibility() == View.GONE) &#123; progressBar.setVisibility(View.VISIBLE); &#125; else &#123; progressBar.setVisibility(View.GONE); &#125; break; default: break; &#125; &#125;&#125; 12345678910111213141516//通过 activity_main.xml 中添加 android:max 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度public class MainActivity extends Activity implements OnClickListener &#123; ..... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: int progress = progressBar.getProgress(); progress = progress + 10; progressBar.setProgress(progress); break; default: break; &#125; &#125;&#125; 2.6 AlertDialog在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上,用于提示一些非常重要的内容或者警告信息 修改 MainActivity 中的代码 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity implements OnClickListener &#123; .... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: //通过 AlertDialog.Builder 创建出一个 AlertDialog 的实例 AlertDialog.Builder dialog = new AlertDialog.Builder (MainActivity.this); dialog.setTitle("This is Dialog"); dialog.setMessage("Something important."); dialog.setCancelable(false); //调用 setPositiveButton()方法为对话框设置确定按钮的点击事件 dialog.setPositiveButton("OK", new DialogInterface. OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); //调用 setNegativeButton()方法设置取消按钮的点击事件 dialog.setNegativeButton("Cancel", new DialogInterface. OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); //调用 show()方法将对话框显示出来 dialog.show(); break; default: break; &#125; &#125;&#125; 2.7 ProgressDialog在对话框中显示一个进度条,表示当前操作比较耗时，让用户耐心地等待 修改 MainActivity 中的代码: 12345678910111213141516171819public class MainActivity extends Activity implements OnClickListener &#123; …… @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle("This is ProgressDialog"); progressDialog.setMessage("Loading..."); /*注意如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取 消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的 dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。 */ progressDialog.setCancelable(true); progressDialog.show(); break; default: break; &#125; &#125;&#125; 三、详解四种基本布局布局是一种可用于放置很多控件的容器,布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套 新建一个UILayoutTest项目，并让 ADT 自动帮我们创建好活动，活动名和布局名都使用默认值 3.1 LinearLayout:称作线性布局，是一种非常常用的布局,它所包含的控件在线性方向上依次排列 3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐修改activity_main.xml 中的代码: 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" //指定了排列方向是 vertical(垂直方向), orientation(方向；定向；适应；情况介绍) android:orientation="vertical" &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button 1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button 2" /&gt; &lt;/LinearLayout&gt; 垂直对齐: android:gravity 是用于指定文字在控件中的对齐方式 android:layout_gravity 是用于指定控件在布局中的对齐方式 需要注意，当LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式,同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效. 修改 activity_main.xml 中的代码: 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... /*LinearLayout 的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向(即只能指定上,中,下,而不能指定左右)，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_vertical*/ android:orientation="horizontal" &gt; &lt;Button .... android:layout_gravity="top" android:text="Button 1" /&gt; &lt;Button .... android:layout_gravity="center_vertical" android:text="Button 2" /&gt; &lt;/LinearLayout&gt; 3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小编写一个消息发送界面，需要一个文本编辑框和一个发送按钮 修改activity_main.xml 中的代码 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/input_message" /*这里竟然将 EditText 和 Button 的宽度都指定成了 0，这样文本编辑框和按钮还能显示出来吗？不用担 心，由于我们使用了 android:layout_weight 属性，此时控件的宽度,就不应该再android:layout_width 来决定，这里指定成 0 是一种比较规范的写法 */ android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type something" /&gt; &lt;Button android:id="@+id/send" android:layout_width="0dp" android:layout_height="wrap_content" /* EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示EditText 和 Button 将在水平方向平分宽度*/ android:layout_weight="1" android:text="Send" /&gt;&lt;/LinearLayout&gt;/*为什么将 android:layout_weight 属性的值同时指定为 1 就会平分屏幕宽度呢？系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。*/ 修改activity_main.xml 中的代码 1234567891011121314151617181920/*仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服*/&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/input_message" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" ... /&gt; &lt;Button android:id="@+id/send" android:layout_width="wrap_content" .... /&gt;&lt;/LinearLayout&gt; 3.2 RelativeLayout通过相对定位的方式让控件出现在布局的任何位置 3.2.1 每个控件相对于父布局进行定位修改 activity_main.xml 中的代码: 1234567891011121314151617181920212223242526272829303132333435&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" .... &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" //Button 1和父布局的左上角对齐 android:layout_alignParentLeft="true" android:layout_alignParentTop="true" .../&gt; &lt;Button android:id="@+id/button2" .... android:layout_alignParentRight="true" android:layout_alignParentTop="true" ... /&gt; &lt;Button android:id="@+id/button3" .... android:layout_centerInParent="true" .... /&gt; &lt;Button android:id="@+id/button4" .... android:layout_alignParentBottom="true" android:layout_alignParentLeft="true" .... /&gt; &lt;Button android:id="@+id/button5" .... //Button 5 和父布局的右下角对齐 android:layout_alignParentBottom="true" android:layout_alignParentRight="true" .... /&gt;&lt;/RelativeLayout&gt; 3.2.2 控件相对于控件进行定位修改 activity_main.xml 中的代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt; &lt;Button android:id="@+id/button3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 1" /&gt; &lt;Button android:id="@+id/button1" .... //android:layout_above属性让一个控件位于另一个控件的上方 //@id/button3，表示让该控件位于 Button 3 的上方 android:layout_above="@id/button3" android:layout_toLeftOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button2" .... android:layout_above="@id/button3" android:layout_toRightOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button4" .... android:layout_below="@id/button3" android:layout_toLeftOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button5" .... android:layout_below="@id/button3" android:layout_toRightOf="@id/button3" .... /&gt;&lt;/RelativeLayout&gt;/*另外一组相对于控件进行定位的属性 如android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐 */ 3.3 FrameLayout没有任何的定位方式，所有的控件都会摆放在布局的左上角,它的应用场景并不多 修改 activity_main.xml 中的代码 1234567891011121314&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt; //按钮 &lt;Button android:id="@+id/button" .... /&gt; //图片 &lt;ImageView android:id="@+id/image_view" .... android:src="@drawable/ic_launcher" /&gt;&lt;/FrameLayout&gt; 3.4 TableLayout使用表格的方式来排列控件 设计一个登录界面，用户输入账号密码后登录 activity_main.xml 中的代码 123456789101112131415161718192021222324252627282930313233&lt;TableLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; // TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行 &lt;TableRow&gt; //在 TableRow中每加入一个控件，就表示在该行中加入了一列 //TableRow 中的控件是不能指定宽度的 &lt;TextView android:layout_height="wrap_content" android:text="Account:" /&gt; &lt;EditText android:id="@+id/account" android:layout_height="wrap_content" android:hint="Input your account" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;TextView android:layout_height="wrap_content" android:text="Password:" /&gt; &lt;EditText android:id="@+id/password" android:layout_height="wrap_content" android:inputType="textPassword" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;Button android:id="@+id/login" android:layout_height="wrap_content" //对单元格进行合并 android:layout_span="2" android:text="Login" /&gt; &lt;/TableRow&gt;&lt;/TableLayout&gt; android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列进行拉伸，以达到自动适应屏幕宽度的作用 修改 activity_main.xml 中的代码 123456789&lt;TableLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" // android:stretchColumns 的值指定为 1，表示如果表格不能完全占满屏幕宽度，就将第二列进行拉伸 //指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列 android:stretchColumns="1" &gt; ....&lt;/TableLayout&gt; 四、创建自定义控件 所有控件都是直接或间接继承自 View,所有布局都是直接或间接继承自 ViewGroup 创建一个 UICustomViews 项目: 4.1 引入布局1//android:background 用于为布局或控件指定一个背景 修改activity_main.xml 中的代码: 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; //引入标题栏布局 &lt;include layout="@layout/title" /&gt;&lt;/LinearLayout&gt; 别忘了在 MainActivity 中将系统自带的标题栏隐藏掉 修改MainActivity类: 12345678public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... requestWindowFeature(Window.FEATURE_NO_TITLE); .... &#125;&#125; 4.2 创建自定义控件引入布局确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码,这种情况最好是使用自定义控件的方式来解决 新建 TitleLayout类 继承自 LinearLayout，让它成为我们自定义的标题栏控件 123456789101112/*在布局中引入 TitleLayout控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借助 LayoutInflater 来实现了,LayoutInflater 的 from()方法可以构建出一个 LayoutInflater对象，然后调用 inflate()方法就可以动态加载一个布局文件*/public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); //第一个参数是要加载的布局文件的 id,第二个参数是给加载好的布局再添加一个父布局,这里我们想要指定为 TitleLayout，于是直接传入 this LayoutInflater.from(context).inflate(R.layout.title, this); &#125;&#125; 现在自定义控件已经创建好了，然后在布局文件中添加这个自定义控件 修改activity_main.xml 中的代码 123456789//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候我们需要指明控件的完整类名，包名在这里是不可以省略的&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.example.uicustomviews.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/com.example.uicustomviews.TitleLayout&gt;&lt;/LinearLayout&gt; 为标题栏中的按钮注册点击事件 修改 TitleLayout中的代码 123456789101112131415161718192021222324public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); // findViewById()方法得到按钮的实例 Button titleBack = (Button) findViewById(R.id.title_back); Button titleEdit = (Button) findViewById(R.id.title_edit); //分别调用 setOnClickListener()方法给两个按钮注册了点击事件 titleBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; ((Activity) getContext()).finish(); &#125; &#125;); titleEdit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getContext(), "You clicked Edit button", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 五、最常用最难用控件ListViewListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕 5.1 ListView 的简单用法首先新建一个 ListViewTest 项目,都默认 修改activity_main.xml 中的代码 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 修改 MainActivity 中的代码 12345678910111213141516public class MainActivity extends Activity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry","Cherry", "Mango" &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成 //android.R.layout.simple_list_item_1 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1,data); ListView listView = (ListView) findViewById(R.id.list_view); // setAdapter()方法，将构建好的适配器对象传递进去,这样 ListView和数据之间的关联就建立完成了 listView.setAdapter(adapter); &#125;&#125; 5.2 定制 ListView 的界面新建类 Fruit 1234567891011121314public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; layout 目录下新建fruit_item.xml 12345678910111213141516&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; // ImageView 用于显示水果的图片 &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; //TextView用于显示水果的名称 &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" /&gt;&lt;/LinearLayout&gt; 新建类 FruitAdapter 12345678910111213141516171819202122public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; // getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // getItem()方法得到当前项的 Fruit 实例 Fruit fruit = getItem(position); // 获取当前项的Fruit实例 //LayoutInflater 来为这个子项加载我们传入的布局， View view = LayoutInflater.from(getContext()).inflate(resourceId, null); // findViewById()方法分别获取到 ImageView 和 TextView 的实例 ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); // setImageResource()和 setText()方法来设置显示的图片和文字 fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125; &#125; 修改 MainActivity 中的代码 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends Activity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango" &#125;; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits() &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; ....&#125; 5.3 提升 ListView 的运行效率修改 FruitAdapter中的代码 12345678910111213141516171819202122232425/*getView()方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用*/public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; .... @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; //如果 convertView 为空，则使用LayoutInflater 去加载布局，如果不为空则直接对 convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候也可以表现出更好的性能。 if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); &#125; else &#123; view = convertView; &#125; ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125;&#125;/*虽然现在已经不会再重复去加载布局，但是每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个 ViewHolder来对这部分性能进行优化*/ 可以继续优化 修改 FruitAdapter 中的代码: 1234567891011121314151617181920212223242526272829303132333435public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; ... @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder 存储在View 中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; //ViewHolder，用于对控件的实例进行缓存 class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125;&#125;/*当 convertView为空的时候:创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View的 setTag()方法，将 ViewHolder 对象存储在 View 中。当 convertView 不为空的时候:则调用View的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了*/ 5.4 ListView 的点击事件修改 MainActivity 中的代码 123456789101112131415161718public class MainActivity extends Activity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; .... //通过 position 参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来 listView.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; ……&#125; 六、单位和尺寸布局文件中指定宽高的固定大小有以下常用单位可供选择：px、pt、dp 和 sp px 是像素的意思，即屏幕中可以显示的最小元素单元 pt 是磅数的意思，1 磅等于 1/72 英寸，一般 pt 都会作为字体的单位来使用 新建好一个 UISizeTest 项目 修改 activity_main.xml 中的代码 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" // android:layout_width 属性将按钮的宽指定为 200px android:layout_width="200px" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt; 接着创建一个 240*320 像素的低分辨率模拟器，在这个模拟器上重新运行程序 dp 是密度无关像素的意思，也被称作 dip，和 px 相比，它在不同密度的屏幕中的显示比例将保持一致。 sp 是可伸缩像素的意思，它采用了和 dp 同样的设计理念，解决了文字大小的适配问题 什么叫密度？Android 中的密度就是屏幕每英寸所包含的像素数，通常以 dpi为单位 比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果它的分辨率是 320480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640960，那这个屏幕的密度就是 320dpi 如何得知当前屏幕的密度值? 修改 MainActivity 中的代码 1234567891011public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); float xdpi = getResources().getDisplayMetrics().xdpi; float ydpi = getResources().getDisplayMetrics().ydpi; Log.d("MainActivity", "xdpi is " + xdpi); Log.d("MainActivity", "ydpi is " + ydpi); &#125;&#125; 根据 Android 的规定，在 160dpi 的屏幕上，1dp 等于 1px，而在 320dpi 的屏幕上，1dp就等于 2px。因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的显示比例保持一致 修改 activity_main.xml 中的代码 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" android:layout_width="200dp" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt;/*尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。*/ 七、编写界面的最佳实践:创建一个 UIBestPractice 项目 7.1 制作 Nine-Patch 图片Nine-Patch 图片,它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸而哪些区域不可以。 准备一张普通的气泡样式的png图片 message_left.png (google上直接搜索message_left.png就可找到) 将这张图片设置为一个 LinearLayout 的背景图片,修改 activity_main.xml 123456789&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/message_left" &gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差. 这时我们就可以使用 Nine-Patch 图片来进行改善 在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。绘制完成后效果如图: 注意：制作完成后，应该将原始文件删除，否则AS会分不清楚而报错。 重新运行程序 这样当图片需要拉伸的时候，就可以只拉伸指定的区域，程序在外观上也是有了很大的改进 7.2 编写精美的聊天界面再制作一张message_right.9.png作为发出消息的背景图 修改 activity_main.xml 1234567891011121314151617181920212223242526272829303132333435&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#d8e0e8" android:orientation="vertical" &gt;// ListView 用于显示聊天的消息内容 &lt;ListView android:id="@+id/msg_list_view" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"// android:divider属性，它可以指定 ListView分隔线的颜色，这里#0000 表示将分隔线设为透明色 android:divider="#0000" &gt; &lt;/ListView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt;//EditText用于输入消息 &lt;EditText android:id="@+id/input_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type somthing here" android:maxLines="2" /&gt;// Button 用于发送消息 &lt;Button android:id="@+id/send" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Send" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 定义消息的实体类，新建 Msg 1234567891011121314151617181920212223public class Msg &#123; //TYPE_RECEIVED 表示这是一条收到的消息 public static final int TYPE_RECEIVED = 0; //TYPE_SENT 表示这是一条发出的消息 public static final int TYPE_SENT = 1; //content 表示消息的内容 private String content; //type 表示消息的类型 private int type; public Msg(String content, int type) &#123; this.content = content; this.type = type; &#125; public String getContent() &#123; return content; &#125; public int getType() &#123; return type; &#125;&#125; 编写 ListView子项的布局，新建 msg_item.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="10dp" &gt;//让收到的消息居左对齐 &lt;LinearLayout android:id="@+id/left_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:background="@drawable/message_left" &gt; &lt;TextView android:id="@+id/left_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" android:textColor="#fff" /&gt; &lt;/LinearLayout&gt;//发出的消息居右对齐 &lt;LinearLayout android:id="@+id/right_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:background="@drawable/message_right" &gt; &lt;TextView android:id="@+id/right_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 创建 ListView 的适配器类，让它继承自 ArrayAdapter，并将泛型指定为 Msg类。新建类 MsgAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MsgAdapter extends ArrayAdapter&lt;Msg&gt; &#123; private int resourceId; public MsgAdapter(Context context, int textViewResourceId, List&lt;Msg&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Msg msg = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); viewHolder.rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); viewHolder.leftMsg = (TextView) view.findViewById(R.id.left_msg); viewHolder.rightMsg = (TextView) view.findViewById(R.id.right_msg); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; if (msg.getType() == Msg.TYPE_RECEIVED) &#123; // 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏 viewHolder.leftLayout.setVisibility(View.VISIBLE); viewHolder.rightLayout.setVisibility(View.GONE); viewHolder.leftMsg.setText(msg.getContent()); &#125; else if (msg.getType() == Msg.TYPE_SENT) &#123; // 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏 viewHolder.rightLayout.setVisibility(View.VISIBLE); viewHolder.leftLayout.setVisibility(View.GONE); viewHolder.rightMsg.setText(msg.getContent()); &#125; return view; &#125; class ViewHolder &#123; LinearLayout leftLayout; LinearLayout rightLayout; TextView leftMsg; TextView rightMsg; &#125;&#125; 修改 MainActivity 中的代码，来为 ListView初始化一些数据，并给发送按钮加入事件响应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends Activity &#123; private ListView msgListView; private EditText inputText; private Button send; private MsgAdapter adapter; private List&lt;Msg&gt; msgList = new ArrayList&lt;Msg&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); initMsgs(); // 初始化消息数据 adapter = new MsgAdapter(MainActivity.this, R.layout.msg_item, msgList); inputText = (EditText) findViewById(R.id.input_text); send = (Button) findViewById(R.id.send); msgListView = (ListView) findViewById(R.id.msg_list_view); msgListView.setAdapter(adapter); send.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取 EditText 中的内容 String content = inputText.getText().toString(); //如果内容不为空则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去 if (!"".equals(content)) &#123; Msg msg = new Msg(content, Msg.TYPE_SENT); msgList.add(msg); //调用了适配器的 notifyDataSetChanged()方法，用于通知列表的数据发生了变化 adapter.notifyDataSetChanged(); // 当有新消息时，刷新ListView中的显示 // 将ListView定位到最后一行,以保证一定可以看得到最后发出的一条消息 msgListView.setSelection(msgList.size()); inputText.setText(""); // 清空输入框中的内容 &#125; &#125; &#125;); &#125; private void initMsgs() &#123; //初始化几条数据用于在 ListView 中显示 Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED); msgList.add(msg1); Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SENT); msgList.add(msg2); Msg msg3 = new Msg("This is Tom. Nice talking to you. ", Msg.TYPE_RECEIVED); msgList.add(msg3); &#125; ......&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android之UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串]]></title>
    <url>%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[一、字符串的特性:String 被声明为 final，因此它不可被继承。 二、不同JDK版本中String的区别:①: 在 Java 8 中，String 内部使用 char 数组存储数据。 ②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 三、String 与StringBuffer,StringBuilder的区别：3.1 可变性:String的长度是不可变的，而StringBuffer和StringBuilder长度是可变的. 也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中. 3.2 线程安全:String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StringBuffer的常用方法: String常用方法: StringBuffer和StringBuilder和String的效率比较: 1234567891011121314151617181920212223242526272829@Testpublic void test2() &#123; long startTime = 0L; long endTime = 0L; String text = ""; StringBuffer buffer = new StringBuffer(""); StringBuilder builder = new StringBuilder(""); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuffer的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuilder的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println("String的执行时间：" + (endTime - startTime));&#125; 四、字符串与其他数据类型的转换: 4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)A ———&gt; B: 调用B的方法:①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法 4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)字符串———&gt;数组 调用字符串的方法数组————&gt;字符串 调用字符串的构造器 ③: 字符串——-&gt;字节数组 调用字符串的getBytes()④: 字符串——-&gt;字符数组 调用字符串的toCharArray() ⑤: 字节数组——&gt;字符串 调用字符串的构造器⑥: 字符数组——&gt;字符串 调用字符串的构造器 五、字符串常量池（String Pool）:①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 ②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 ③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 六、字符串字面量 和字符串对象:字面量指的是能够使用简单结构和符号创建对象的表达式。如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。 七、new String(“abc”)创建了几个对象?使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 八、关于”==” 和”equals”和String的intern()方法:①: “==”比较的是地址②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.③: String类重写了equals方法④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用； 关于intern(): 1234567891011121314151617String s0= “kvill”; String s1=new String(”kvill”); String s2=new String(“kvill”); System.out.println( s0==s1 ); System.out.println( “**********” ); s1.intern(); s2=s2.intern(); //把常量池中“kvill”的引用赋给s2 System.out.println( s0==s1); System.out.println( s0==s1.intern() ); System.out.println( s0==s2 );结果为： false ********** false //虽然执行了s1.intern(),但它的返回值没有赋给s1 true //说明s1.intern()返回的是常量池中”kvill”的引用 true 几个结论: 直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。 new出来的字符串是存放在堆里面。 对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况： 表达式右边是纯字符串常量，那么存放在常量池里面。 表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面 12345678910111213String str1 = "aaa"; //str1存放的值是字符串常量池中字符串aaa对象的地址.String str2 = "bbb";String str3 = "aaabbb";String str4 = str1 + str2; //str4存放的是堆中字符串aaabbb对象的地址String str5 = "aaa" + "bbb";System.out.println(str3 == str4); // falseSystem.out.println(str3 == str4.intern()); // trueSystem.out.println(str3 == str5);// true//分析:结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。其实Integer这种包装类型的-128 ~ +127也是存放在常量池里面，比如Integer i1 = 10;Integer i2 = 10; i1 == i2结果是true，估计也是为了性能优化。 九、五个关于字符串的算法题:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 * 1. 模拟一个trim方法，去除字符串两端的空格 。 * 2. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 * 3. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。 * 4. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = "abcwercvhelloobnm"。 * 5.对字符串中字符进行自然排序 // 1. 模拟trim方法，去除字符串两端的空格 public static String myTrim(String str) &#123; int start = 0; int end = str.length() - 1; // 判断字符串str前面是否有空格 while (start &lt;= end &amp;&amp; str.charAt(start) == ' ') &#123; start++; &#125; System.out.println(start); // 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常 while (start &lt;= end &amp;&amp; str.charAt(end) == ' ') &#123; end--; &#125; System.out.println(end); // 方法一： char[]a = new char[end-start+1]; int j = 0; for (int i = start; i &lt;= end; i++,j++) &#123; System.out.print(i+" "); a[j] = str.charAt(i); &#125; System.out.println(); //将字符数组转换为字符串 String str1 = new String(a); return str1; // // 方法二：// return str.substring(start, end + 1); &#125; // 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一) public static String myReverseString(String str, int start, int end) &#123; //字符串转换为字符数组 char[] c = str.toCharArray(); return myreverseArray(c, start, end); &#125; public static String myreverseArray(char[] c, int start, int end)&#123; for (int i = start,j = end; i &lt; j; i++,j--) &#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; &#125; //字符数组转换为字符串 return new String(c); &#125;&#125; // 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二） public static String reverseString2(String str, int start, int end) &#123; String str1 = str.substring(0,start); for (int i = end; i &gt;= start; i--) &#123; char c = str.charAt(i); str1 += c; &#125; str1 += str.substring(end + 1); return str1; &#125; // 3. 获取一个字符串在另一个字符串中出现的次数. // 判断str2 在 str1 中出现的次数 // 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取 public static int getTime(String str1, String str2) &#123; int count = 0; int length; while ((length = str1.indexOf(str2)) != -1) &#123; count++; str1 = str1.substring(length + str2.length()); &#125; return count; &#125; // 4. 获取两个字符串中最大相同字串。 public static List&lt;String&gt; getMaxSubString(String str1, String str2) &#123; String maxStr = (str1.length() &gt; str2.length())? str1:str2; String minStr = (str1.length() &lt; str2.length())? str1:str2; int length = minStr.length(); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; length; i++) &#123; for (int x = 0,y = length - i; y &lt;= length; x++,y++) &#123; String str = minStr.substring(x,y); if (maxStr.contains(str)) &#123; list.add(str); &#125; &#125; if (list.size() != 0) &#123; return list; &#125; &#125; return null; &#125; //5.对字符串中字符进行自然排序 public static String mySort(String str) &#123; char[]c = str.toCharArray(); Arrays.sort(c); return new String(c); &#125; public class StringDemo &#123; public static void main(String[] args) &#123; // @Test-myTrim String testString1 = " abc d "; // 特殊情况 String testString2 = " "; String str1 = StringDemo.myTrim(testString1); String str2 = StringDemo.myTrim(testString2); System.out.println("----" + str1 + "----"); System.out.println("----" + str2 + "----"); // 验证 String str3 = str1.trim(); String str4 = str2.trim(); System.out.println("----" + str3 + "----"); System.out.println("----" + str4 + "----"); // @Test-myReverseString and myReverseArray String str5 = "abcdefg"; String str6 = myReverseString(str5, 2, 5); System.out.println("原字符串：" + str5); System.out.println("指定部分反转-法一：" + str6); String str7 = "abcdefg"; String str8 = reverseString2(str7, 2, 5); System.out.println("指定部分反转-法二：" + str8); int count = getTime("abkkcadkabkebfkabkskab", "abk"); System.out.println("出现次数为：" + count); List&lt;String&gt; str9 = getMaxSubString("abcwerathelloyuiodef", "abcwercvhellobnm"); System.out.println(str9); String str10 = "aediewfn"; String str11 = mySort(str10); System.out.println(str11); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、数据链路层设备:①: 网桥或桥接器:②: 交换机: 实质: 是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器 特点: 全双工: 并行性: 即能同时连通多对接口，使多对主机能同时通信 自学习: 即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 优点: 对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s. ③: 网络适配器又称网络接口卡，网卡 网络适配器是什么? 网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。 网络适配器的主要作用： 它是主机与介质的桥梁设备 实现主机与介质之间的电信号匹配 提供数据缓冲能力 控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。) 网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。 二、数据链路层协议:2.1 PPP协议: Point-to-Point Protocal; （点到点）互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 2.1.1 特点:①: 简单②: 只检错,不纠错③: 不使用序号,不进行流量控制 2.1.2 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 2.2 PPPoE协议:是为宽带上网的主机使用的链路层协议 2.3 CSMA/CD协议:CSMA/CD 表示载波监听多点接入 / 碰撞检测。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 2.4 IEEE 802.3/.2协议2.5 ATM协议2.6 HDLC协议三、数据链路层基本单元:帧 四、数据链路层三个基本问题:4.1 封装成帧:将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 4.2 透明传输:透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 4.3 差错检测:循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算 五、数据链路层使用的信道:5.1 点对点信道:一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 5.2 广播信道:①: 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。③: 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用CSMA/CD 协议。 六、数据链路层功能：①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输②: 组帧（Framing）③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端④: 流量控制（Flow control）:避免淹没接收端⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权 七、数据链路层任务: 八、MAC 地址:MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 九、以太网:9.1 以太网是一种星型拓扑结构局域网。早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 9.2 特点:采用的协议: CSMA/CD采用无连接,半双工通信对数据帧不进行编号尽最大努力交付(不可靠)不要求对方确认发送的数据都以曼彻斯特编码收到错帧就丢弃 9.3 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 十、局域网:局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 十一、10BASE-T:10 代表 10Mbit/sBASE : 连接线上的信号为基带信号T: 双绞线 十二、数据链路层功能:将网络层接收到的数据分割成特定的可被物理层传输的帧]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown用法]]></title>
    <url>%2FMarkdown%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、常用操作:1.1 代码块:①: 添加代码块 :一行代码时: 使用一对单引号(ESC键下面的单引号键),代码放在这对单引号之间 效果图: 多行代码: 连按三个单引号(ESC键下面的单引号键) ,然后回车. 效果图: ②: 代码快速排版: 先把光标定位到代码块中, 然后Ctrl+ A选中所有代码, 最后 Shift + tab 拍版前: 排版后:]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown用法指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Android]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Android.html</url>
    <content type="text"><![CDATA[一、Android系统四大组件:1.1 活动（Activity）:凡是在应用中你看得到的东西，都是放在活动中的。 1.2 服务（Service）:你无法看到它，但它会一直在后台默默地运行 1.3 广播接收器（Broadcast Receiver）:接收来自各处的广播消息，比如电话、短信等 1.4 内容提供器（ContentProvider）:为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现 二、创建并运行HelloWorld程序:2.1 创建程序 Application Name 代表应用名称，此应用安装到手机之后会在手机上显示该名称:Project Name 代表项目名称，在项目创建完成后该名称会显示在 Eclipse 中Minimum Required SDK 是指程序最低兼容的版本Target SDK 是指你在该目标版本上已经做过了充分的测试，系统不会再帮你在这个版本上做向前兼容的操作了Compile With是指程序将使用哪个版本的 SDK 进行编译最后一个 Theme是指程序 UI 所使用的主题，我个人比较喜欢选择 None 2.1.1 创建活动:选择一个你想创建的活动类型，这里我们就选择 Blank Activity 了 2.2 启动模拟器:点击 Eclipse 导航栏中的 Window→Open Perspective→DDMS如果你的 Devices 窗口中有一个设备显示是 Online 的，那就说明目前一切正常，你的模拟器是在线的 2.3 执行程序代码:右击 HelloWorld 项目→Run As→Android Application 三、程序的目录结构:3.1 gen自动生成的，主要有一个 R.java 文件,你在项目中添加的任何资源都会在其中生成一个相应的资源 id,永远不要手动去修改它。 3.2 bin存放编译时自动产生的文件, 目录下有HelloWorld.apk，把这个文件拷到手机上就可以直接安装了 3.3 libs存放第三方 Jar包, 会被自动添加到构建路径里去 3.4 assets存放一些随程序打包的文件,所有网页相关的文件也都存放在这个目录下 3.5 res: (resources即资源目录)图片、布局、字符串等资源都要存放在这个目录下图片放在 drawable 目录下布局放在 layout 目录下字符串放在 values 目录下 3.6 AndroidManifest.xml整个 Android 项目的配置文件，四大组件都需要在这个文件里注册,还可以添加权限声明,版本兼容修改 3.7 project.properties指定编译程序时所使用的 SDK 版本 四、程序的运行流程分析:4.1 AndroidManifest.xml 文件:1234567891011//对 HelloWorldActivity 这个活动进行注册,没有在 AndroidManifest.xml 里面注册的活动是不能使用的。&lt;activity android:name="com.test.helloworld.HelloWorldActivity" android:label="@string/app_name" &gt; //主活动，在手机上点击应用图标，首先启动的就是这个活动。 &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 4.2 再来看src/HelloWorldActivity.java文件1234567public class HelloWorldActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 调用了setContentView()方法，给当前的活动引入了一个 hello_world_layout 布局 setContentView(R.layout.hello_world_layout); &#125; Activity 是 Android 系统提供的一个活动基类，项目中所有的活动都必须要继承它才能拥有活动的特性 onCreate()方法是一个活动被创建时必定要执行的方法 Android程序的设计讲究逻辑和视图分离,在布局文件中编写界面，然后在活动中引入进来。 4.3 看 res/layout/hello_world_layout.xml 布局文件:12345678&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"....... &lt;TextView android:layout_width="wrap_content" ...... android:text="@string/hello_world" /&gt;&lt;/RelativeLayout&gt; TextView，这是 Android 系统提供的一个控件，用于在布局中显示文字的hello_world_layout.xml布局文件中就是通过引用了 hello_world这个键，才找到了相应的值 4.4 查看res/values/strings.xml 文件:12345&lt;resources&gt; &lt;string name="app_name"&gt;Hello World&lt;/string&gt; .... &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;&lt;/resources&gt; 一 般 是 把 字 符 串 定 义 在res/values/strings.xml 里，然后可以在布局文件或代码中引用Hello world!字符串就是定义在这个文件里的可以在这里通过修改 app_name 对应的值，来改变此应用程序的名称,在哪儿引用了app_name 这个键呢？在AndroidManifest.xml查找. 五、关于资源目录res:drawable开头的文件夹都是用来放图片的values开头的文件夹都是用来放字符串layout 文件夹是用来放布局文件menu 文件夹是用来放菜单文件 之所以有这么多 drawable开头的文件夹，是为了让程序能够兼容更多的设备, 最好能够给同一张图片提供几个不同分辨率的副本只有一份图片时,所有图片都放在 drawable-hdpi下即可 六、如何引用资源? strings.xml 中的 Hello world!字符串，有两种方式引用它： ①: 代码中通过 R.string.hello_world 可以获得该字符串的引用；②: 在 XML 中通过@string/hello_world可以获得该字符串的引用。 string 部分是可以替换的,如果是引用的图片资源就可以替换成 drawable,如果是引用的布局文件就可以替换成 layout,以此类推 七、日志:7.1 打印日志:打开 HelloWorldActivity，在 onCreate()方法中添加一行打印日志的语句， 1234protected void onCreate(Bundle savedInstanceState) &#123; .... Log.d("HelloWorldActivity", "onCreate execute");&#125; Log.d 第一个参数是 tag，一般传入当前的类名，主要用于对打印信息进行过滤。第二个参数是 msg，即想要打印的具体的内容。 7.2 日志过滤器: 给过滤器起名叫 data，并且让它对名为 data 的 Tag进行过滤 在 onCreate()方法中把打印日志的语句改成 Log.d(“data”,”onCreate execute”)，然后再次运行程序，你就会在 data 过滤器下看到这行日志了。 7.3 日志级别:选中debug级别，这时只有使用 debug 及以上级别方法打印的日志才会显示出来如果你把LogCat 中的级别选中为 info、warn 或者 error 时，我们在 onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是 Log.d()方法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>初识Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PV操作]]></title>
    <url>%2FPV%E6%93%8D%E4%BD%9C%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[一、什么是PV操作?PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：P（S）：①将信号量S的值减1，即S=S-1；②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 V（S）：①将信号量S的值加1，即S=S+1； 二、PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。 三、什么是信号量？信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关: ①: 当信号量的值大于0时，表示当前可用资源的数量②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数注意，信号量的值仅能由PV操作来改变。 四、使用PV操作注意事项：①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。③: 互斥信号量的初值一般为1。 五、PV操作实例:5.1 例题1: 吃苹果问题: 解题过程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344 semaphore empty=2； //定义empty对应盘子的剩余放水果的位置个数初值为2( 空缓冲区个数 ) semaphore apple=0； //定义信号量apple对应盘子里的苹果数量初值为0 semaphore orange=0； //定义信号量orange对于盘子里的橘子数量初值为0 semaphore mutex=1： //定义信号量mutex来保护盘子被互斥地访问 father()&#123; //爸爸进程 while(1)&#123; P(empty)； //盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放苹果 P(mutex)； 在盘子里放一个苹果 V(mutex)； V(apple)；//盘中苹果数加一 &#125;&#125;mother()&#123; //妈妈进程 while(1) &#123; P(empty)； //盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放橘子 P(mutex)； //互斥变量减一，如果&lt;0，则说明有进程在临界区。则当前进程必须等待。 在盘子里放一个橘子 V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。 V(orange)； //盘中橘子数加一 &#125; &#125; son()&#123; //用这段程序产生两个儿子进程 while(1) &#123; P(orange)； //盘中橘子个数减一，如果结果&gt;=0时,说明盘中有橘子，可以取 P(mutex)； 从盘子里拿一个橘子 V(mutex)； V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一 &#125;&#125;daughter()&#123; //用这段程序产生两个女儿进程 while(1 ) &#123; P(apple)； //盘中苹果个数减一，如果结果&gt;=0时,说明盘中有苹果，可以取 P(mutex)； 从盘子里拿出一个苹果 V(mutex)； V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一 &#125; &#125; 5.2 : 和尚打水: 分析: 解题过程: 12345678910111213141516171819202122232425262728293031323334353637Semaphore mutexA = 1; //保护井被互斥地访问 Semaphore mutexB = 1; //保护缸被互斥地访问 Semaphore Count = 3； //桶总数为3Semaphore full = 0; //控制出水，刚开始，缸是空的，能取出0桶水Semaphore empty = 10 ; //控制入水，刚开始，缸是空的，能倒入10桶水//小和尚打水：Progress（小和尚）&#123; while（1）&#123; P（empty） //判断缸是否满了（结果如果&gt;=0,未满），决定是否需要打水 P（count） //拿桶（判断是否有空闲的桶，结果如果&gt;=0,有桶） P（mutexA）&#123; //对井互斥访问 从井中打水； V（mutexA） //互斥 &#125; P（mutexB）&#123; //对缸互斥访问 向缸中倒水； V（mutexB） //互斥 &#125; V（count）//还桶，空闲桶的数量加一 V（full） //缸中水的数量加一，（通知老和尚取水） &#125;&#125;//老和尚取水：progress（老和尚）&#123; while（1）&#123; P（full） //判断缸中是否有水，（结果如果&gt;=0,说明缸中有水，可取水） P（count）//拿桶 P（mutexB) //互斥 从缸中取水； V（mutexB）//互斥 V(count) //还桶 V（empty）//缸中还能容纳的水数量加一，（通知小和尚打水） &#125;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>PV操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F%E6%AD%BB%E9%94%81.html</url>
    <content type="text"><![CDATA[一、什么是死锁:是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去. 二、产生死锁的原因: ①: 因为系统资源不足②: 进程运行推进顺序不合适③: 资源分配不当等 三、产生死锁的必要条件:①: 互斥：一个资源每次只能被一个进程使用②: 占有和等待(请求与保持)：一个进程因请求资源而阻塞时，对已获得的资源保持不放。③: 不剥夺: 进程已获得的资源，在使用完之前，不能强行被抢占,它只能被占有它的进程显式地释放。④: 环路等待: 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 注: 只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 四、处理死锁的方法:主要有以下四种方法： 4.1 鸵鸟策略4.1.1 原理: 把头埋在沙子里，假装根本没发生问题, 也就是忽略死锁4.1.2 什么时候用?当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 4.2 死锁检测与死锁恢复4.2.1 原理: 不试图阻止死锁，而是当检测到死锁发生时，再采取措施进行恢复。4.2.2 死锁检测:4.2.2.1 每种类型一个资源的死锁检测:通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 4.2.2.2 每种类型多个资源的死锁检测:每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。①: 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。②: 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。③: 如果没有这样一个进程，算法终止。 4.2.3 死锁恢复:①: 利用抢占恢复②: 利用回滚恢复③: 通过杀死进程恢复 4.3 死锁预防4.3.1 原理:在程序运行之前预防发生死锁 4.3.2 采取方法:破坏死锁的四个必要条件①: 破坏互斥：②: 破坏占有和等待(请求与保持):一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 ③: 破坏不剥夺:④: 破坏环路等待:给资源统一编号，进程只能按编号顺序来请求资源。 4.4 死锁避免在程序运行时避免发生死锁 五、银行家算法:例题:]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之活动]]></title>
    <url>%2FAndroid%E4%B9%8B%E6%B4%BB%E5%8A%A8.html</url>
    <content type="text"><![CDATA[一、活动的基本用法:项目名可以叫做 ActivityTest ,为了手动创建活动 不再勾选 Create Activity 1.1 手动创建活动:src 目录下先添加一个包,使用的默认包名com.example.activitytest新建FirstActivity 类继承自 Activity任何活动都应该重写 Activity 的 onCreate()方法 1.2 创建布局每一个活动对应一个布局，布局就是用来显示界面内容在res/layout 目录下新建 名为first_layout.xml的文件(菜单中点击Android XMLFile),根元素就默认选择为 LinearLayout 添加一个按钮: 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"&gt;... &lt;Button android:id="@+id/button_1" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; XML 中引用一个 id，就使用@id/id_name 这种语法XML 中定义一个 id，则要使用@+id/id_name 这种语法android:layout_width 指定了当前元素的宽度，match_parent表示让当前元素和父元素一样宽。android:layout_height 指定了高度， wrap_content，表示当前元素的高度只要能刚好包含里面的内容就行。android:text 指定了元素中显示的文字内容 1.3 在活动中加载这个布局:FirstActivity类的 onCreate()方法中加入如下代码： 1234567public class FirstActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... setContentView(R.layout.first_layout); &#125;&#125; 项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id，因此我们刚才创建的 first_layout.xml 布局的 id 现在应该是已经添加到 R 文件中了。在代码中引用布局文件: R.layout.first_layout 注意: 这里我们使用的 R，是com.example.activitytest 包下的 R 文件Android SDK 还会自动提供一个 android 包下的 R 文件，千万别使用错了。 1.4 在 AndroidManifest 文件中注册:所有的活动都要在 AndroidManifest.xml 中进行注册才能生效 在AndroidManifest.xml 来给 FirstActivity 注册: 12345678910111213141516171819202122232425262728&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.activitytest" &gt; .... &lt;/application&gt; .... &lt;activity /*.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity 的 缩写由于最外层的&lt;manifest&gt;标签中已经通过 package 属性指定了程序的包名是 com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity */ android:name=".FirstActivity" android:label="This is FirstActivity" &gt; /* 如果你想让 FirstActivity 作为我们这个程序的主活动，即点击桌面应用程序图标时首先打开的就是这 个活动，那就一定要加入下面这两句声明。 */ &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;/*如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他的应用在内部进行调用的，如支付宝快捷支付服务。*/ 活动的注册声明要放在&lt;application&gt;标签内, 通过&lt;activity&gt;标签来对活动进行注册的android:name 来指定具体注册哪一个活动android:label指定活动中标题栏的内容 1.5 隐藏标题栏FirstActivity类的 onCreate()方法中加入如下代码： 123456protected void onCreate(Bundle savedInstanceState) &#123; ... //注意这句代码一定要在 setContentView()之前执行，不然会报错 requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.first_layout);&#125; 1.6 在活动中使用 Toast:toast是什么?界面弹出短小的信息通知给用户，这些信息会在一段时间后自动消失 首先需要定义一个弹出 Toast 的触发点, 如点击按钮的时候弹出一个 Toast FirstActivity类的 onCreate()方法中加入如下代码： 123456789101112131415161718protected void onCreate(Bundle savedInstanceState) &#123; .... // findViewById()方法获取在布局文件中定义的元素，传入 R.id.button_1，来得到按钮的实例 Button button1 = (Button) findViewById(R.id.button_1);//findViewById返回的是一个 View 对象 //注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法 button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; /* makeText()创建出一个 Toast对象, show()是将 Toast 显示出来 第一个参数是 Context，也就是 Toast 要求的上下文，活动本身就是一个 Context 对象 第二个参数是Toast显示的文本内容 第三个参数是Toast显示的时长 */ Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 1.7 在活动中使用 Menu在 res 目录下新建一个 menu 文件夹新建一个 main.xml 文件(点击Android XML File) 12345678&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt; //&lt;item&gt;标签就是用来创建具体的某一个菜单项 &lt;item //给这个菜单项指定一个唯一标识符， android:id="@+id/add_item" //给这个菜单项指定一个名称 android:title="Add"/&gt;&lt;/menu&gt; 然后打开 FirstActivity类，重写 onCreateOptionsMenu()方法 12345678910public boolean onCreateOptionsMenu(Menu menu) &#123; /* inflate()方法就可以给当前活动创建菜单 第一个参数:通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main 第二个参数:用于指定我们的菜单项将添加到哪一个 Menu对象当中，这里直接使用 onCreateOptionsMenu()方法中传 入的 menu参数 */ getMenuInflater().inflate(R.menu.main, menu); //返回 true，表示允许创建的菜单显示出来 return true;&#125; 定义菜单响应事件: FirstActivity 中重写 onOptionsItemSelected() 12345678910111213public boolean onOptionsItemSelected(MenuItem item) &#123; // item.getItemId()来判断我们点击的是哪一个菜单项 switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125; 1.8 销毁一个活动:Activity 类提供了一个 finish()方法: 打开 FirstActivity类,onCreate方法中, 修改按钮监听器中的代码: 1234567button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125;&#125;);//重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一样的。 二、使用 Intent 在活动之间穿梭:2.1 使用显式 Intent:Intent的“意图”非常明显，因此我们称之为显式 Intent 在 ActivityTest 项目中再创建一个活动。新建一个 second_layout.xml 布局文件 12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" &gt; ... //定义了一个按钮，按钮上显示 Button 2 &lt;Button android:id="@+id/button_2" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 2" /&gt;&lt;/LinearLayout&gt; 新建活动 SecondActivity 继承自Activity 12345678public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); &#125;&#125; 最后在 AndroidManifest.xml 中为 SecondActivity 进行注册。 1234567891011121314&lt;application ...&gt; &lt;activity android:name=".FirstActivity" android:label="This is FirstActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; // SecondActivity 不是主活动，因此不需要配置&lt;intent-filter&gt;标签里的内容 &lt;activity android:name=".SecondActivity" &gt; &lt;/activity&gt;&lt;/application&gt; Intent 一般可被用于启动活动、启动服务、以及发送广播等场景Intent 是 各组件之间进行交互的一种重要方式，它可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据 Intent(Context packageContext, Class&lt;?&gt; cls):这个构造函数接收两个参数，第一个参数: 启动活动的上下文，第二个参数 指定想要启动的目标活动 Activity 类中 startActivity()方法，用于启动活动的，它接收一个Intent参数 修改 FirstActivity 中按钮的点击事件: 12345678button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //在FirstActivity活动的基础上打开 SecondActivity活动,startActivity()方法来执行这个Intent Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125;&#125;); 2.2 使用隐式 Intent:不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 action和 category等信息,由系统去分析Intent，并找出合适的活动(响应隐式 Intent的活动)去启动 AndroidManifest.xml添加如下代码: 123456789&lt;activity android:name=".SecondActivity" &gt; &lt;intent-filter&gt; //指明当前活动可以响应 ACTION_START这个 action &lt;action android:name="com.example.activitytest.ACTION_START" /&gt; // 精确地指明当前的活动能够响应的 Intent 中还可能带有的 category &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;//只有&lt;action&gt;和&lt;category&gt;中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。 修改 FirstActivity 中按钮的点击事件，代码如下所示： 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //使用了Intent 的另一个构造函数,传入action的字符串,表明要启动能够响应ACTION_START这个action的活动 Intent intent = new Intent("com.example.activitytest.ACTION_START"); startActivity(intent); &#125;&#125;);//注: &lt;action&gt;和&lt;category&gt;同时匹配上才能响应,而这里没有指定category,这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中 每个 Intent 中只能指定一个 action，但却能指定多个 category 修改 FirstActivity 中按钮的点击事件,增加一个category 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.activitytest.ACTION_START"); // addCategory()方法来添加一个 category intent.addCategory("com.example.activitytest.MY_CATEGORY"); startActivity(intent); &#125;&#125;); 在AndroidManifest.xml中 SecondActivity的&lt;intent-filter&gt;中再添加一个 category 的声明: 123456&lt;activity android:name=".SecondActivity" &gt; &lt;intent-filter&gt; .... &lt;category android:name="com.example.activitytest.MY_CATEGORY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.3 更多隐式 Intent 的用法修改 FirstActivity 中按钮点击事件的代码，如下所示： 1234567891011//应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器来打开这个网页就行了button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // Intent.ACTION_VIEW，这是一个 Android 系统内置的动作 Intent intent = new Intent(Intent.ACTION_VIEW); // Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象 intent.setData(Uri.parse("http://www.baidu.com")); startActivity(intent); &#125;&#125;); 还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地指定当前活动能够响应什么类型的数据。&lt;data&gt;标签中主要可以配置以下内容: android:scheme用于指定数据的协议部分，如上例中的 http 部分 只有&lt;data&gt;标签中指定的内容和 Intent 中携带的 Data完全一致时，当前活动才能够响应该 Intent。如上面浏览器示例中，其实只需要指定 android:scheme 为 http，就可以响应所有的 http 协议的 Intent 了。 2.4 自己建立一个活动，让它也能响应打开网页的Intent新建 third_layout.xml 布局文件: 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;Button android:id="@+id/button_3" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 3" /&gt;&lt;/LinearLayout&gt; 新建活动 ThirdActivity 类继承自 Activity将布局添加到活动中 12345678public class ThirdActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.third_layout); &#125;&#125; 最后在 AndroidManifest.xml 中为 ThirdActivity 进行注册 12345678&lt;activity android:name=".ThirdActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; //数据的协议必须是 http协议 &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 调用系统拨号界面 除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示拨打电话 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_DIAL); // data部分指定了协议是 tel，号码是 10086 intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;&#125;); 2.5 向下一个活动传递数据: Intent 还可以在启动活动的时候传递数据, putExtra()的重载，可把想要传递的数据暂存在 Intent 中，启动另一个活动后，只需把这些数据从Intent 中取出就可 SecondActivity 类中,修改代码: 1234567891011// FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity中button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String data = "Hello SecondActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //第一个参数是键,用于后面从 Intent中取值，第二个参数才是真正要传递的数据。 intent.putExtra("extra_data", data); startActivity(intent); &#125;&#125;); 123456789101112public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... // getIntent()方法获取到用于启动 SecondActivity 的 Intent Intent intent = getIntent(); //如果传递的是布尔型数据，则使用 getBooleanExtra()方法 //getStringExtra()方法，传入相应的键值，就可以得到传递的数据了 String data = intent.getStringExtra("extra_data"); Log.d("SecondActivity", data); &#125;&#125; 2.6 返回数据给上一个活动:Activity 中 startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 修改 FirstActivity 中按钮的点击事件 12345678button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //第一个参数还是 Intent,第二个参数是请求码，用于在之后的回调中判断数据的来源,请求码只要是一个唯一值就可以了 startActivityForResult(intent, 1); &#125;&#125;); SecondActivity 中给按钮注册点击事件并在点击事件中添加返回数据的逻辑: 123456789101112131415161718192021public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); Button button2 = (Button) findViewById(R.id.button_2); button2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); //setResult()专门用于向上一个活动返回数据的 //第一个参数用于向上一个活动返回处理结果,第二个参数则是把带有数据的 Intent 传递回去 setResult(RESULT_OK, intent); //销毁当前活动 finish(); &#125; &#125;); &#125;&#125; 由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据， 123456789101112131415//第一个参数 requestCode，启动活动时传入的请求码,//第二个参数 resultCode，返回数据时传入的处理结果//第三个参数 data，即携带着返回数据的 Intent@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode == RESULT_OK) &#123; String returnedData = data.getStringExtra("data_return"); Log.d("FirstActivity", returnedData); &#125; break; default: &#125;&#125; 由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到 onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作 如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下Back 键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通过重写 onBackPressed()方法来解决这个问题，代码如下所示： SecondActivity 类中修改代码: 12345678//这样的话，当用户按下 Back 键，就会去执行 onBackPressed()方法中的代码，我们在这里添加返回数据的逻辑就行了@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); setResult(RESULT_OK, intent); finish();&#125; 2.7 活动的生命周期:返回栈Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack） 活动状态每个活动在其生命周期中最多可能会有四种状态。运行状态:位于返回栈的栈顶时暂停状态:不再处于栈顶位置，但仍然可见停止状态:不再处于栈顶位置，并且完全不可见销毁状态:从返回栈中移除后就变成了销毁状态 活动的生存期Activity 类中定义了七个回调方法: onCreate():每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。 onStart():在活动由不可见变为可见的时候调用 onResume():在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。 onPause():准备去启动或者恢复另一个活动的时候调用 onStop():在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。 onDestroy():活动被销毁之前调用 onRestart():活动由停止状态变为运行状态之前调用 2.6 活动被回收了怎么办Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。 onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，第二个参数是真正要保存的内容。在 MainActivity 中添加如下代码就可以将临时数据进行保存： 123456@Overrideprotected void onSaveInstanceState(Bundle outState) &#123;super.onSaveInstanceState(outState);String tempData = "Something you just typed";outState.putString("data_key", tempData);&#125; 数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一直使用的 onCreate()方法其实也有一个 Bundle类型的参数。这个参数在一般情况下都是null，但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。修改 MainActivity 的 onCreate()方法，如下所示： 123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... if (savedInstanceState != null) &#123; String tempData = savedInstanceState.getString("data_key"); Log.d(TAG, tempData); &#125; ……&#125; 2.7 活动的启动模式启动模式一共有四种，分别是 standard、singleTop、singleTask 和 singleInstance​ AndroidManifest.xml 中通 过给&lt;activity&gt; 标签 指定android:launchMode属性来选择启动模式 standard 活动默认的启动模式,系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。 singleTop 在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。 修改 AndroidManifest.xml 中 FirstActivity 的启动模式，如下所示： 123456&lt;activity android:name=".FirstActivity" android:launchMode="singleTop" ... ...&lt;/activity&gt; singleTask 很好地解决重复创建栈顶活动的问题 singleInstance 在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android之活动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是适配器模式?适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 二、 分类:2.1 类的适配器模式:使用步骤:步骤1： 创建Target接口步骤2： 创建源类（Adaptee）步骤3： 创建适配器类Adapter (适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。)步骤4： 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 2.2 对象的适配器模式:原理:与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。步骤:①: 创建Target接口②: 创建源类（Adaptee）③: 创建适配器类（Adapter）（不适用继承而是委派）④: 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 2.3 对象的适配器模式与类的适配器模式比较:与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 2.4 什么时候用类的适配器模式? ①: 仅仅希望使用方便时对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。对于对象适配器，需要额外的引用来间接得到Adaptee。②: 需要重新定义Adaptee的部分行为对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 2.5 什么时候用对象的适配器模式?①: 灵活使用时类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。②: 需要同时配源类和其子类对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了； 2.6 总结:建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。 三、主要作用:把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。 三、优点:①: 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。②: 解耦性: 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码③: 符合开放-关闭原则: 同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类④: 更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。⑤: 透明、简单: 客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接, 过多的使用适配器，会让系统非常零乱，不易整体进行把握 四、应用场景:系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 五、实例:背景：小成买了一个进口的电视机冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容解决方案：设置一个适配器将插头输出的220V转变成110V 使用类的适配器模式解题: 12345//步骤1： 创建Target接口；public interface Target &#123; //将220V转换输出110V（原有插头（Adaptee）没有的） void Convert_110V();&#125; 123456//步骤2： 创建源类（Adaptee）public class PowerPort220V &#123; //原有的插口只能输出220V void OutPut_220V()&#123; &#125;&#125; 12345678910111213//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter220V extends PowerPort220V implements Target &#123; //期待的插头要求调用Convert_110v()，但原有插头没有 //因此适配器补充上这个方法名 //但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容 //所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已 @Override public void Convert_110V() &#123; this.OutPut_220V(); &#125;&#125; 1234567891011121314151617181920//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标//通过Adapter类从而调用所需要的方法public class AdapterPattern &#123; public static void main(String[] args) &#123; //用户拿着进口机器插上适配器（调用Convert_110v()方法） //再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V） //适配器只是个外壳，对外提供110V，但本质还是220V进行供电 Target target = new Adapter220V(); target.Convert_110V(); ImportMachine importMachine = new ImportMachine(); importMachine.work(); &#125;&#125;//进口机器类class ImportMachine &#123; void work()&#123; System.out.println("进口机器正常工作!"); &#125;&#125; 类的适配器模式: 12345//步骤1： 创建Target接口；public interface Target &#123; //源类Adapteree没有的方法 void Request();&#125; 12345//步骤2： 创建源类（Adaptee） ；public class Adapteree &#123; public void specificRequest() &#123; &#125;&#125; 12345678910111213//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）//适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。public class Adapter extends Adapteree implements Target &#123; //目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request() //因此适配器补充上这个方法名 //但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容 //所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已 @Override public void Request() &#123; this.specificRequest(); &#125;&#125; 12345678//Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标public class AdapterPattern &#123; public static void main(String[] args) &#123; Target adapter = new Adapter(); adapter.Request(); &#125;&#125; 对象的适配器模式: 1234public interface Target &#123; //这是源类Adapteee没有的方法 void request();&#125; 1234public class Adapteree &#123; void specificRequest()&#123; &#125;&#125; 123456789101112131415public class Adapter implements Target&#123; private Adapteree adapteree; //直接关联被适配类Adapteree // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter(Adapteree adapteree)&#123; this.adapteree = adapteree; &#125; @Override public void request() &#123; //这里是使用委托的方式完成特殊功能 this.adapteree.specificRequest(); &#125;&#125; 123456public class AdapterPattern &#123; public static void main(String[] args) &#123; Target target = new Adapter(new Adapteree()); target.request(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层]]></title>
    <url>%2F%E5%BA%94%E7%94%A8%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、应用层协议:应用层的许多协议是基于客户服务器方式的 1.1 DNS:1.1.1 是什么? DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 1.1.2 作用:用于域名解析服务,将域名(机器名) 转换为 IP地址1.1.3 原理: 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。1.1.4 特点:基于UDP服务，该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。端口号53DNS 可以使用 UDP 或者 TCP 进行传输，大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性1.1.5 在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 1.2 : HTTP:1.2.1 是什么? 这是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页1.2.2 特点: 本身是无连接，无状态的,使用TCP连接进行可靠的传送 1.3 : FTP:1.3.1 是什么? 文件传输协议1.3.2 特点: 提供交互式的访问 ,基于客户服务器模式，面向连接 ,使用TCP可靠的运输服务 ,使用21端口1.3.3 主要功能:减少/消除不同操作系统下文件的不兼容性 1.3.4 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。端口号20 1.3.5 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 1.4 : 简单文件传送协议TFTP:1.4.1 特点: 客户服务器模式 ,使用UDP数据报 ,只支持文件传输，不支持交互 ,TFTP代码占内存小 1.5 : TELNET:1.5.1 作用:用于远程登陆1.5.2 特点:客户服务器模式 使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务,TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 1.6 : 简单网络管理协议（SNMP）:1.6.1 SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议1.6.2 SNMP代理：运行SNMP管理进程的被管理结点对象：描述设备的变量管理信息库（MIB）：保存所有对象的数据结构 1.7 : DHCP:1.7.1 什么是DHCP? 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。1.7.2 DHCP 工作过程如下： ①: 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。②: DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。③: 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。④: DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 1.8 :电子邮件协议:一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1.8.1 : SMTP:1.8.1.1 是什么? 简单邮件传输协议1.8.1.2 作用: 用于发送邮件。1.8.1.3 特点: Client/Server模式，面向连接 ,服务器开放的是25号端口。SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。1.8.1.4 基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件 1.8.2 : POP3:1.8.2.1 是什么? 它是和SMTP对应1.8.2.2 作用: 用于接收邮件1.8.2.3 特点: ①: 只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。②：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”。POP3协议所用的是110端口。 1.8.3 : IMAP:1.8.3.1 作用: 读取邮件1.8.3.2 特点: IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信。 二、关于域名:2.1 域名规范:DNS规定:①: 域名中标号必须是英文或数字②: 不区分大小写③: 除连字符外不能用其他标点④: 级别最低的域名写在最左边⑤: 域名总长度不超过255个字符. 2.2 域名分类:顶级域名(TLD: TOP Level Domain):①: 国家顶级域名: cn代表中国 ,US代表美国②:通用顶级域名: com(公司,企业) net(网络服务机构) edu(教育机构) mail.cctv.com: 其中com为一级域名(即顶级域名), cctv是二级域名,mail是三级域名.域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 2.3 域名管理:①: 在国家顶级域名下注册的二级域名均由该国家自由确定.②: 各级域名由其上一级域名管理机构管理③: 最高的顶级域名由ICANN管理注: 域名中的点与点分十进制IP地址中的点无一一对应的关系 2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?原因: IP地址长度固定(32位)而域名长度不固定,机器处理起来困难. 三、关于域名服务器:一个域名服务器所负责管理的范围叫做区,每个区 设置相应的权限域名服务器为了减轻根域名服务器的压力,域名服务器中广泛使用高速缓存. 3.1 域名服务器分类:①: 根域名服务器: 所有根域名服务器都知道所有顶级域名服务器的域名和IP地址②: 顶级域名服务器: 管理在该顶级域名服务器下注册的所有二级域名,当收到查询请求,就给出查询结果,或者下一步应当找的域名服务器地址③: 权限域名服务器: 负责一个区的域名服务器,当它不能给出最后的查询结果时,就告诉客户下一步应当查找哪个权限域名服务器④: 本地域名服务器: 离用户较近,一般不超过几个路由器的距离 迭代查询: 递归查询: 四、常用端口: 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP HTTPS 443 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP 五、Web 页面请求过程:5.1 DHCP 配置主机信息:假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。①: 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。②: 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。③: 该数据报则被放置在MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。④: 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。⑤: 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。⑥: 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 5.2 ARP 解析 MAC 地址①: 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。②: 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。③: 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中④: 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。⑤: DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。⑥: 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。⑦: 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 5.3 DNS 解析域名:①: 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。②: 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。③: 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。④: 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。⑤: 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 5.4 HTTP 请求页面:①: 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。②: 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。③: HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。④: 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。⑤: HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。⑥: 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 六、应用层功能:负责对软件提供接口以使程序能使用网络服务]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层]]></title>
    <url>%2F%E4%BC%A0%E8%BE%93%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、传输层协议:TCP协议,UDP协议,SPX协议 10.1 关于TCP协议:特点:①: 面向连接②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点 使用场合: 一般用于传输数据量少,且对可靠性要求高的场合. 注: 这2个端点并不是主机,也不是主机的IP地址,不是应用进程,也不是运输层协议端口, 而是指 套接字 ③: 提供可靠交付服务: 无差错 , 不丢失 , 不重复 , 按序到达④: 全双工⑤: 拥塞控制,流量控制⑥: 检错, 分用复用⑦: 面向字节流: (把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)套接字socket = IP地址 ：端口号 10.2 使用TCP协议的各种应用层协议：SMTP: 简单邮件传送协议TELNET: 远程终端协议HTTP: 超文本传输协议FTP: 文件传送协议 10.3 TCP首部格式: 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 10.4 关于UDP协议:特点: ①: 无连接: 发数据前不需要建立连接(即不需要使用套接字(即 IP: 端口号)来建立连接)②: 交互通信: 一对多,一对一,多对一,多对多等③: 尽最大努力交付(不可靠)④: 首部开销小,8字节 而TCP是20字节⑤: 无拥塞控制⑥: 检错, 分用复用⑦: 面向报文: UDP一次交付一个完整报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部) 10.5 UDP首部格式: 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 使用场合: 一般用于传输数据量大,且对可靠性要求不是很高,但要求速度快的场合. 二、传输层数据单元:数据段 三、关于端口:运输层用16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口 四、传输层功能:①: 负责源-目的（端-端）（进程间）完整报文传输②: 分段与重组③: SAP寻址: 确保将完整报文提交给正确进程，如端口号④: 连接控制⑤: 流量控制⑥: 差错控制⑦: 确保数据可靠,顺序,无错地从A点传输到B点 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 五、TCP 可靠传输:TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。 六、TCP 滑动窗口:窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 七、TCP 流量控制:流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 八、TCP 拥塞控制:如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。拥塞窗口的大小取决于网络的拥塞程度判断网络拥塞的依据是出现了超时.发送方的发送窗口 = 拥塞窗口. TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 8.1 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 8.2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 拥塞控制的具体流程: ①: 初始拥塞窗口 cwnd = 1 ②: 发送方每收到一个确认就使cwnd = cwnd + 1;如果按照传输轮次考虑就是指数增长: 第一轮: cwnd = 1, 第二轮: cwnd = 2, 第三轮: cwnd = 4, …….第N轮: cwnd = 2^N cwnd &lt; ssthresh 时,使用慢开始 cwnd = ssthresh 时,既可以使用慢开始,也可以使用拥塞避免算法 cwnd &gt;= ssthresh 时,使用拥塞避免算法 ③: 网络超时时: 使ssthresh = cwnd / 2然后令 cwnd = 1 然后进入慢开始阶段,步骤同上④: 直到连续接收到三个重复确认,启动快重传(立即重传) ⑤: 启动快恢复算法 ssthresh = cwnd / 2 和cwnd=ssthresh 拥塞避免: 拥塞窗口控制为按照线性增长(每个传输轮次结束时,cwnd就增加1) 快重传优点: 可以使整个网络的吞吐量提高20%尽早让发送方知道发生了个别报文段的丢失 规定: 发送方只要一连收到3个重复确认,就知道接收方确实未收到某个报文,应当立即重传(即快重传),这样就不会出现超时,发送方也就不会误认为出现了网络拥塞. 快恢复: 调整ssthresh = cwnd / 2同时设置cwnd = ssthresh;然后执行拥塞避免.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换机的基本配置]]></title>
    <url>%2F%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[一、交换机的基本配置与管理：10.1 交换机的管理方式：基本分为两种: 带内管理和带外管理。带外管理: 通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置带内管理: 通过远程Telnet，拨号等方式属于带内管理 二、交换机的命令行操作模式分类：①: 用户模式: Switch&gt;②: 特权模式: Switch#③: 全局配置模式: Switch(config)#④: 端口模式: Switch(config-if)# 三、交换机命令行:进入特权模式: en命令自动补齐: Tab进入全局配置模式: configure terminal命令简写：conf t进入交换机端口视图模式: int f 0/1返回上一级操作模式: exit从全局以下级别直接返回到特权模式: end帮助信息: ？，co? ,copy ?修改交换机名称: hostname X配置交换机端口参数: speed，duplex查看交换机版本信息: show version查看当前生效的配置信息: show run 四、换机的Telnet远程登录配置: 新建packet tracer 拓扑图 配置交换机管理IP地址 switch&gt; enable 回车 switch#configuration terminal 回车 switch（config）#interface vlan 1 回车 默认情况下交换机所有端口都处于VLAN1中 switch(config-if) ip address xxxx.xxxx.xxxx.xxxx 回车 switch(config-if) no shutdown 回车 开启interface vlan 1的工作状态 switch(config-if)# exit 返回上一级 配置用户登录密码 Switch(config)# enable password xxxx 设置进入特权模式的密码 Switch(config)# line vty 0 4 Switch(config-line)# password xxxxxxx 设置远程登录密码 Switch(config-line)# end Switch# show run]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>交换机的配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、网络层协议:1.1 什么是协议（protocol）?通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”. 1.2 什么是实体（entity）?表示任何可发送或接收消息的硬件或软件进程 1.3 通信协议的三要素：语法,语义,时序语义 :语义是指对协议中各协议元素的含义的解释，例如：在HDLC协议中，标志Flag(7EH)表示报文的开始和结束；在BSC协议中，SOH(01H)表示报文的开始，STX(02H)表示报文正文的开始，ETX(03H)表示报文正文的结束。语法 :语法是指协议元素与数据的组合格式，也就是 报文格式，如下图所示：时序 :时序是指在通信过程中，通信双方操作的执行顺序与规则，如本节开头的图示。总的来说，语法是语义的载体，而时序又是对语义的有序组织。正是基于这种关系，计算机在通信时才得以保持高度默契。 1.4 通信模型: 我们在网络中的任何一个系统都是按照上图中的层次结构模型来组织的，该模型具有以下特点：①: 同一网络中，任意两个端系统必须具有相同的层次；②: 每层使用其下层提供的服务，并向其上层提供服务；③: 通信只在对等层间进行，当然这里所指的通信是间接的、逻辑的、虚拟的，非对等层之间不能互相“通信”；④: 实际的物理通信只在最底层完成；⑤: Pn代表第n层的协议，即第n层对等实体间通信时必须遵循的规则或约定。 1.5 网络层有哪些协议?①: IP协议: 这种不可靠的、无连接的传送机制称为Internet协议(网际协议)与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protcol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP协议三个定义： IP定义了在TCP/IP互联网上数据传送的基本单元和数据格式。IP软件完成路由选择功能，选择数据传送的路径。IP包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。 ②: ICMP协议: 网际控制报文协议作用：用于在IP主机、路由器之间传递控制消息,更有效的转发IP数据报和提高交付成功的机会,应用: ICMP的一个重要应用就是分组网间探测PING（Package Internet Grouper）用来测试两台主机的连通性,,Ping是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP详解见下文 ③: IGMP:网际组管理协议 ④: ARP协议:地址解析协议自动把IP地址解析为数据链路层所需要的硬件地址(MAC地址)IP —–&gt;MAC 地址工作原理: 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据,如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 ⑤: RARP协议:逆地址解析协议, 与ARP相反:MAC地址——&gt;IP地址作用: 是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP 地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 ⑥: RIP协议:内部网关协议基于距离向量的路由选择协议, 距离是指跳数，直接相连的路由器跳数为 1,跳数最多为 15(即允许一条路径最多包含15个路由器)，超过 15 表示不可达。可见RIP只适用于小型互联网 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 优点:实现简单，开销小。缺点:①: RIP 能使用的最大距离为 15，限制了网络的规模。②: 并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。③: 路由器间交换的信息是完整的路由表,随着网络规模的增大,开销也增大. ⑦: OSPF协议: 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示, 而RIP只包含距离,和下一跳路由器地址. 只有当链路状态发生变化时，路由器才会发送信息, 而 RIP不管有无变化,总是定期更新. 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 ⑧: BGP：外部网关协议: BGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息 1.6 网络层特点:向上只提供 :①: 无连接的②: 尽最大努力交付③: 不提供服务质量的保证(不保证分组交付的时限,所传送的分组有可能出错丢失,重复失序)⑤: 进程间通信可靠性由传输层负责 二、网络层设备:①: 路由器 三、网络层基本单元:3.1 什么是协议数据单元?协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。 3.2 每一层协议数据单元分别是什么?从下层到上层:物理层的 PDU是数据位,又称比特（bit），数据链路层的 PDU是数据帧,又称帧（frame），网络层的PDU是数据包又称IP数据报（packet/datagram），传输层的 PDU是数据段（segment），在报文中加一个运输层的头其他更高层次(即会话层,表现层,应用层)的PDU是报文（message）。 从下层往上层是拆封. 四、网络层功能:①: 负责源主机到目的主机数据分组（Packet）交付(可能穿越多个网络)逻辑寻址（Logical addressing ）②: 全局唯一的逻辑地址，确保数据分组被送到目的主机，如IP地址③: 路由（Routing）:路由器（或网关）互连网络，并路由分组至最终目的主机路径选择④: 分组转发⑤: 网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 ⑥: 将网络地址(例如IP地址)翻译为对应的物理地址(例如,网卡地址),并决定如何将数据从发送方路由到接收方 4.1 核心功能:分组转发 与 路由选择（forwarding) 4.1 什么是转发?将分组从路由器的输入端口转移到合适的输出端口转发表确定在本路由器如何转发分组 4.2 转发表是怎么得到的呢？路由算法（协议）确定通过网络的端到端路径 4.3 什么叫路由呢？路由（routing）：确定分组从源到目的经过的路径 五、网络层任务: 六、为什么需要数据封装?增加控制信息—构造协议数据单元（PDU—protocol Data Unit）控制信息主要包括：地址：标志发送端/接收端差错检测编码（error-detecting code）：用于差错检测或纠正协议控制（Protocol control）：实现协议功能的附加信息，如优先级（priority），服务质量（QoS）和安全控制等 七、IP 数据报格式: 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 八、地址解析协议 ARP:ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 九、网际控制报文协议 ICMP:ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 9.1 ICMP协议的应用:PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理: 是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute:用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。Traceroute的工作原理: 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 十、IP 地址编址方式:10.1 IP 地址的编址方式经历了三个历史阶段：①: 分类②: 子网划分③: 无分类 分类: 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 网络号:用于识别主机所在的网络；主机号: 用于识别该网络中的主机IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} IP地址分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。 IP地址类别: 高八位 占总IP地址数的比例: A类：前一位固定为0 第一个八位的范围是0-127目的: 保证了最小为0,最大为127 即255(全一)-128(最高位为1,其他为0)=127 (127-0+1）/ 256=50% B类：前两位固定为10 第一个八位的范围是：128-191前两位固定为10的目的是：为了让前八位表示的数最小为128 (191-128+1) / 256=25% C类：前三位固定为110 第一个八位的范围是：192-223前两位固定为110的目的是：保证最小192 (223-192+1) / 256=12.5% D类：前四位固定为1110 不分网络地址和主机地址 第一个八位的范围是：224-239 (239-224+1) / 256=6.25% E类：前四位固定为1111 不区分网络地址和主机地址 第一个八位的范围是：240-255 (255-240+1) / 256=6.25% A类地址:1）A类地址第1字节为网络地址，其它3个字节为主机地址。它的第1个字节的第一位固定为0，因此只有7位可供使用.可指派的网络号为126个（即2^7-2=126），减2 的原因：第一： IP地址中的全0表示“这个（或者本）”，全1表示所有的。 网络号字段全0 的IP地址是个保留地址， 意思是本网络第二： 网络号为127（即01111111）保留作为本地软件环回测试（loop back test）本主机的进程之间的通信之用。2）A类地址可指派网络号范围：1—1263）A类地址中的私有地址和保留地址：① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址),且范围是（10.0.0.0—10.255.255.255）② 127.X.X.X是保留地址，用做循环测试用的。A类地址主机号占三个字节，因此每个A类网络中最大主机数： 2^24-2=16777214这里减2 的原因： 全0的主机号字段， 表示该IP地址 是”本主机“所连结到的单个网络地址，（例如： 一主机的IP地址为5.6.7.8 ，则该主机所在的网络地址就是5.0.0.0）， 而全1表示”所有的“ ，因此主机号全1表示该网络上的所有主机，4）IP地址空间共2^32 个地址，整个A类地址2^31,占整个IP地址空间的50%. 关于全0全1 还可以再举两个例子：例如： B类地址： 128.7.255.255 表示在网络128.7.0.0 上的所有主机， 而A类地址0.0.0.35 则表示 在这个网络上主机号为35 的主机； B类地址: B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。它的第1个字节的前两位固定为10，只剩下16-2=14位可以分配， 因为网络号字段后面的14位无论取什么值， 也不可能出现使整个2字节的网络号字段成为全0或全1， 所以这里就不存在网络总数减2的问题。 但是实际上B类网络地址的128.0.0.0 是不指派的，而可以指派的B类最小网络地址是128.1.0.0 ， 因此B类地址可指派的网络数为 2^14-1=16383. B 类地址的每个网络上的最大主机数2^16-2=65534这里减2 的原因： 要扣除主机号全0全1的。 （全0表示该IP地址 是”本主机“所连结到的单个网络地址，全1 作为广播地址）整个B类地址空间2^30, 占整个IP地址空间的25%. 2） B类地址可指派网络号范围：128.1—191.255。 3） B类地址的私有地址和保留地址 ① 172.16.0.0—172.31.255.255是私有地址 ② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。 191.255.255.255是广播地址，不能分配。 C类地址 1）C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110, 还有21位可以分配，C类网络地址192.0.0.0也是不分配的， 可以指派的C类最小网络地址192.0.1.0，因此C类 地址可指派的网络总数 ， 2^21-1=2097151 , 每一个C类网络地址的最大主机数2^8-2=254, 整个C类地址空间2^29 个地址，占整个IP地址空间的12.5%。 2）C类地址网络号范围：192.0.1—223.255.255。 3） C类地址中的私有地址： 192.168.X.X是私有地址。（192.168.0.0—192.168.255.255) 10.2 特殊IP地址： 10.3 私有（Private）IP地址:实体IP:在网络的世界里，为了要辨识每一部计算机的位置，因此有了计算机 IP 位址的定义。一个 IP 就好似一个门牌！例如，你要去微软的网站的话，就要去『 64.4.11.42 』这个 IP 位置！这些可以直接在网际网络上沟通的 IP 就被称为『实体 IP 』了。 虚拟IP:不过，众所皆知的，IP 位址仅为 xxx.xxx.xxx.xxx 的资料型态，其中， xxx 为 1-255 间的整数，由于计算机的成长速度太快，实体的 IP 已经有点不足了，好在早在规划 IP 时就已经预留了三个网段的 IP 做为内部网域的虚拟 IP 之用。这三个预留的 IP 分别为：除去主机段全零/全一: 由于是虚拟 IP ，所以当您使用这些地址的时候﹐当然是有所限制的，限制如下：私有位址的路由信息不能对外散播使用私有位址作为来源或目的地址的封包﹐不能透过Internet来转送关于私有位址的参考纪录（如DNS）﹐只能限于内部网络使用 由于虚拟 IP 的计算机并不能直接连上 Internet ，因此需要特别的功能才能上网。不过，这给我们架设IP网络提供了很大的方便﹐比如﹕您的公司还没有连上Internet﹐但这不保证将来不会。使用公共IP的话﹐如果没经过注册﹐在以后真正连上网络的时候﹐就很可能和别人冲突了。也正如前面所分析的﹐到时候再重新规划IP的话﹐将是件非常头痛的问题。这时候﹐我们可以先利用私有位址来架设网络﹐等到真要连上internet的时候﹐我们可以使用IP转换协定﹐如 NAT (Network Addresss Translation)等技术﹐配合新注册的IP就可以了。 10.4 组播地址注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机， 224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP（Internet路由发现协议，使用组播功能）功能，那么你的主机路由表中应该有这样一条路由: 169.254.x.x 如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Windows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。 10.5 受限广播地址广播通信是一个主机对所有主机的通信方式。若一个IP地址的2进制数全为1，也就是255.255.255.255，则这个地址用于定义整个互联网。如果设备想使IP数据报被整个Internet所接收，就发送这个目的地址全为1的广播包，但这样会给整个互联网带来灾难性的负担。因此网络上的所有路由器都阻止具有这种类型的分组被转发出去，使这样的广播仅限于本地网段。 10.6 直接广播地址一个网络中的最后一个地址为直接广播地址，也就是HostID全为1的地址。主机使用这种地址把一个IP数据报发送到本地网段的所有设备上，路由器会转发这种数据报到特定网络上的所有主机。注意：这个地址在IP数据报中只能作为目的地址。另外，直接广播地址使一个网段中可分配给设备的地址数减少了1个。 10.7 源IP地址:若IP地址全为0，也就是0.0.0.0，则这个IP地址在IP数据报中只能用作源IP地址，这发生在当设备启动时但又不知道自己的IP地址情况下。在使用DHCP分配IP地址的网络环境中，这样的地址是很常见的。用户主机为了获得一个可用的IP地址，就给DHCP服务器发送IP分组，并用这样的地址作为源地址，目的地址为255.255.255.255（因为主机这时还不知道DHCP服务器的IP地址）。 10.8 环回地址:127网段的所有地址都称为环回地址，主要用来测试网络协议是否工作正常的作用。比如使用ping.127.0.0.1就可以测试本地TCP/IP协议是否已正确安装。另外一个用途是当客户进程用环回地址发送报文给位于同一台机器上的服务器进程，比如在浏览器里输入127.1.2.3，这样可以在排除网络路由的情况下用来测试IIS是否正常启动。 10.9 NetID为0的地址:当某个主机向同一网段上的其他主机发送报文时就可以使用这样的地址，分组也不会被路由器转发。比如12.12.12.0/24这个网络中的一台主机12.12.12.2/24在与同一网络中的另一台主机12.12.12.8/24通信时，目的地址可以是0.0.0.8。 10.10: 关于子网掩码:为了标识IP地址的网络部分和主机部分，要和地址掩码（Address Mask）结合，掩码跟IP地址一样也是32 bits，用点分十进制表示。IP地址网络部分对应的掩码部分全为“1”，主机部分对应的掩码全为“0”。 缺省状态下，如果没有进行子网划分，A类网络的子网掩码为255.0.0.0，B类网络的子网掩码为255.255.0.0，C类网络的子网掩码为255.255.255.0。利用子网，网络地址的使用会更加有效。 有了子网掩码后，IP地址的标识方法如下：例：192.168.1.1 255.255.255.0或者标识成192.168.1.1/24（掩码中“1”的个数） 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 无分类 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 十一、虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 共有2的24次方个地址 172.16.0.0 ~ 172.31.255.255 共有2的20次方个地址 192.168.0.0 ~ 192.168.255.255 共有2的16次方个地址 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 十二、网络地址转换 NAT:专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 十三、路由器的结构:13.1 路由器的功能：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 13.2 路由器分组转发流程: 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 13.3 路由选择协议:路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、关于进程:1.1 什么是进程?进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。有挂起状态 1.2 进程的组成部分: 进程由四个部分组成: ①: 程序块②: 数据块: 程序和数据刻画的是静态特征③: 进程控制块 (Process Control Block, PCB) : 每个进程只有一个进程控制块Process Control Block (进程描述符), 包含管理进程所需的全部信息.④: 核心栈: 进程运行过程中产生中断或者执行系统调用时又要运行操作系统内核函数 , 核心栈就是存放内核函数在工作时产生的信息 PCB包含三类信息: ①: 标识信息: 数值型进程号0~32767 是进程存在的唯一标识②: 现场信息: 包括通用寄存器, 控制寄存器, 栈指针, 程序状态字 进程让出处理器时,必须将此时的现场信息保存到PCB③: 控制信息: 用于管理和调度进程 1.3 进程状态的切换:进程的三种基本状态: 运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着 阻塞状态：等待资源; 由于进程等待某种条件（如等待I/O操作的完成，或等待另一个进程发来消息(即进程同步)），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行 就绪状态：等待被调度 ; 进程已获得除CPU外的所需资源，由于其他进程占用CPU而暂时无法运行的一种状态 注意: ①: 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的CPU 时间片用完之后就会转为就绪状态，等待下一次调度。②: 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 1.4 进程的特点:动态性: 程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。共享性: 多个不同的进程,可以执行相同的程序, 进程和程序不是一 一对应的异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进独立性: 每个进程是操作系统中的一个独立的实体, 有独立的虚存空间,程序计数器,内部状态并发性: 在单处理器系统中可并发执行, 多处理器环境中并行执行. 1.5 进程的挂起:目的: 平滑系统负荷什么时候挂起? 当系统资源尤其是内存资源已经不能满足进程运行的要求时,必须把某些进程挂起.特点: 将不参与低级调度, 直到它们被对换到内存, 该进程不能立即执行如何结束挂起状态? 只能由操作系统或者父进程发出 1.6 进程挂起和激活:挂 起 原 语 既 可 以 由 进 程 自 己 也 可 以 由 其 他 进 程 调 用, 激 活 原 语 只 能 由 其 他 进 程 调 用 1.7 进程阻塞和唤醒:阻塞: 进程让出处理器,转而等待一个事件,如等待资源,等待IO操作完成, 等待事件发生.进程通常调用阻塞原语来阻塞自己, 因此阻塞是自主行为唤醒: 等待事件完成时会产生中断,激活操作系统,在操作系统控制下,与其相关的另一个进程调用唤醒原语将阻塞进程唤醒. 二、关于线程:1.1 什么是线程?是进程中能并发执行的实体, 是进程的组成部分,有时被称为轻量级进程(Lightweight Process，LWP）, 是处理器调度和分派的基本单位, 是一条执行路径,有独立的程序计数器 无挂起状态 1.2 线程的重要特征:①: 一个进程中可以有多个线程，它们共享进程资源。②: 线程是轻量级的进程③: 线程是由进程创建的(寄生在进程)④: 线程没有独立的地址空间(内存空间)⑤: 线程是系统独立调度和分配的基本单位⑥: 可并发执行⑦: 线程是一种轻型实体线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息： 线程状态 存放每个线程的局部变量主存区 访问同一个进程中的主存和其它资源 当线程不运行时，被保存的现场资源 1.3 创建线程的不同方式:有4种方式可以用来创建线程：①继承Thread类②实现Runnable接口③应用程序可以使用Executor框架来创建线程池实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。④还有一种方式是实现Callable接口 1.4 进程状态的切换: 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。 阻塞的情况分三种： (一). 等待阻塞： 运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。 (二). 同步阻塞： 运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。 (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 1.4 优点:快速切换 : 同一个进程中的多线程只需要改变堆栈和寄存器, 地址空间不变通信容易: 不必经过内核, 可自由访问全局数据,自动共享进程的内存和文件减少管理开销: 线程的创建和撤销工作比进程少很多,并且无需再分配存储空间,和各种资源并发程度提高: 三、进程与线程的区别:3.1 就资源而言:进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 3.2 就调度而言:线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 3.3 就系统开销而言:由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 3.4 就通信而言:线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。但是进程通信需要借助 IPC。 3.5 就组成而言:进程可分为两部分: 资源集合 和 线程集合进程封装管理信息,线程封装执行信息 四、进程的调度算法:不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 4.1 批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 ①: 先来先服务 first-come first-serverd（FCFS）按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 ②: 短作业优先 shortest job first（SJF）按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 ③: 最短剩余时间优先 shortest remaining time next（SRTN）按估计剩余时间最短的顺序进行调度。 4.2 交互式系统:交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。④: 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 ⑤: 优先级调度 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 ⑥: 多级反馈队列 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 4.3 实时系统实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 五、进程同步:临界区:对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步与互斥:同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量:信号量（Semaphore）是一个整型变量，可以对其执行 P 和 V 操作。 P: 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； V ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P 操作。 P, V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; P(&amp;mutex); // 临界区 V(&amp;mutex);&#125;void P2() &#123; P(&amp;mutex); // 临界区 V(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE) &#123; int item = produce_item(); P(&amp;empty); P(&amp;mutex); insert_item(item); V(&amp;mutex); V(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE) &#123; P(&amp;full); P(&amp;mutex); int item = remove_item(); consume_item(item); V(&amp;mutex); V(&amp;empty); &#125;&#125; 六、关于管程:使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。c 语言不支持管程 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 七、进程的通信:进程同步与进程通信很容易混淆，它们的区别在于：进程同步：控制多个进程按一定顺序执行；进程通信：进程间传输信息 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 八、关于管道:管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 九、同步方法和同步代码块的区别是什么？①: 同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；②: 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰；]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理层]]></title>
    <url>%2F%E7%89%A9%E7%90%86%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、传输模式:单工（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户半双工（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信全双工（full-duplex）:发送的同时也可以接收数据 二、信道复用技术:2.1 频分复用:频分复用的所有主机在相同的时间占用不同的频率带宽资源。 2.2 时分复用:时分复用的所有主机在不同的时间占用相同的频率带宽资源。 2.3 波分复用:光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 2.4 码分复用:广泛应用于无线链路共享（如蜂窝网，卫星通信等）每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示各用户使用相同频率载波，利用各自的码片序列编码数据各用户码片序列相互正交码片序列与编码信号的内积 2.5 统计时分复用:是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 三、物理层的主要任务:确定与传输媒体的接口有关的一些特性(机械,电气,功能,过程特性) 四、物理层设备:转发器:集线器: 它的每个接口,是简单的转发比特,不进行碰撞检测中继器: 是一种简单的增加局域网传输距离的设备，如作为信号放大器，可使实际的网络跨越更大的距离，它工作在物理层 五、物理层基本单元:比特 六、常用编码方式:不归零: 与比特流一致归零: 到了高/低电平后,将回到低电平曼彻斯特: 中心向下为1差分曼彻斯特: 位开始无跳变为1,位中心始终跳变 七、物理层规范:物理层定义的是规范，不能说是协议例如: EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTTP]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EHTTP.html</url>
    <content type="text"><![CDATA[一、区分URI,URL,URN:URI 包含 URL 和 URN。 二、关于HTTP协议:2.1 是什么?是一个基于(客户端/服务器)请求与响应模式的、无连接, 无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 2.2 HTTP协议的主要特点?①: 无连接： 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 ②: 无状态： HTTP协议是无状态协议, 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 ③: 传输数据类型灵活： HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 ④: 传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2.3 HTTP请求报文:请求行,请求头,请求空行,请求体 2.4 HTTP响应报文:状态行,响应头,响应空行,响应体 2.5 HTTP方法:客户端发送的 请求报文 第一行为请求行，包含了方法字段。 有九种方法: get,post,put,delete,head,patch,options,connect,trace HEAD:①: 作用: 获取报文首部②: 和 GET 方法类似，但是不返回报文实体主体部分。③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST: 作用: 传输实体主体POST 主要用来传输数据，而 GET 主要用来获取资源。 PUT:①: 作用: 上传文件②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PATCH:①: 作用: 对资源进行部分修改②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 OPTIONS:①: 作用: 查询支持的方法②: 查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT:①: 要求在与代理服务器通信时建立隧道②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 TRACE:①: 追踪路径②: 服务器会将通信路径返回给客户端。③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 2.6 关于HTTP状态码:服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理100 ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应 2XX Success（成功状态码） 请求正常处理完毕200 OK 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求301 ：永久性重定向302：临时性重定向 4XX Client Error（客户端错误状态码） 服务器无法处理请求403 Forbidden ：请求被拒绝。404 Not Found 5XX Server Error（服务器错误状态码） 服务器处理请求出错500 Internal Server Error ：服务器正在执行请求时发生错误。503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 2.7 : 连接管理:2.7.1 短连接与长连接:①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2.7.2 流水线:①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。 2.7.3 Cookie:①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 ②: Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 ③: Cookie有什么用途? 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） ④: Cookie的创建过程: 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry ⑤: Cookie的分类: 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; ⑥: HttpOnly: 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。 跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly ⑦: Secure: 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 2.7.4 Session:①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 ③: 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 ④: 浏览器禁用 Cookie: 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 2.7.5 Cookie 与 Session 选择: Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 2.8 常见端口:Http端口80, HTTPS端口443 DNS端口 53 FTP 端口21 SMTP端口 25 三、HTTP/1.1 新特性:①: 默认是长连接②: 支持流水线③: 支持同时打开多个 TCP 连接④: 支持虚拟主机⑤: 新增状态码 100⑥: 支持分块传输编码⑦: 新增缓存处理指令 max-age 四、GET 和 POST 比较:从作用上来说: GET 用于获取资源，而 POST 用于传输实体主体。 从参数来说:GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 从缓存来说: 如果要对响应进行缓存，需要满足以下条件： ①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest: 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 ①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。②: 而 GET 方法 Header 和 Data 会一起发送。 五: 关于HTTPS:5.1 HTTP 有以下安全性问题：①: 使用明文进行通信，内容可能会被窃听；②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；③: 无法证明报文的完整性，报文有可能遭篡改。 5.2 什么是HTTPS?HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改） 5.3 什么是SSL?SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 5.4 什么是TLS?TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 5.5 HTTPS的缺点: ①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐②: HTTPS 降低用户访问速度（多次握手）③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密） 六、关于加密:6.1 对称密钥加密:(Symmetric-Key Encryption)①: 有流式、分组两种，加密和解密都是使用的同一个密钥。例如：DES、AES-GCM、ChaCha20-Poly1305等 优点：运算速度快；缺点：无法安全地将密钥传输给通信方。 6.2 非对称密钥加密:①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、DH、ECDHE ②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(发消息: 公钥加密,私钥解密)③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(签名: 私钥加密,公钥解密) 优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。 6.3 哈希算法:将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 6.4 数字签名:签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP 6.3 HTTPS 采用的加密方式:HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率. 七、关于认证:通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 签名: 签名者的私钥加密, 认证: 使用签名者公钥解密 八、完整性保护:①: SSL 提供报文摘要功能来进行完整性保护。②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 九、关于代理:9.1 代理服务器接受客户端的请求，并且转发给其它服务器。9.2 使用代理的主要目的是：①: 缓存②: 负载均衡③: 网络访问控制④: 访问日志记录 9.3 代理服务器分为正向代理和反向代理两种：举例: 十、关于缓存:10.1 优点:①: 缓解服务器压力；②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 10.2 实现方法①: 让代理服务器进行缓存；②: 让客户端浏览器进行缓存。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>关于HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2Fjava%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[一、先来看两张图: 二、集合的分类:2.1 Collection接口:List接口：存储有序，可重复的元素 ,遍历出来的顺序与添加顺序相同 Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的位置无序))，不可重复的元素(不可 重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都 是Collection下定义的 2.2 Map接口:注：Map接口不是Collection接口的子接口, 两者是并列关系 三、关于List接口:3.1 List接口：存储有序，可重复的元素 遍历出来的顺序与添加顺序相同 3.2 具体的实现类:①: ArrayList(主要的实现类)②: LinkedList(对于频繁的插入，删除操作 较适用)③: Vector(古老的实现类，线程安全的，但效率低于ArrayList) 四、关于Set接口:4.1 需要注意的是:①: 通常说的” Set是无序的, 不可重复的 “ 这句话中的无序是指的存储无序. ②: 无论是HashSet,还是LinkedHashSet 存储都是无序, 且不可重复的元素((指的是元素在底层存放的位置无序))③: 遍历是分为有序和无序的 , HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历. 4.2 如何保证set中元素不可重复?要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),重写hashCode（）方法让同一个对象能算出相同的hashCode值,, 进而保证Set中元素的不可重复性,, 注意:List只用重写equals方法就可以了 4.3 Set中元素是如何存储的呢？使用了哈希算法当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复). 要求：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false; ) 万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此） 4.4 具体的实现类:①: HashSet(主要的实现类)②: LinkedHashSet(HashSet的子类)③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口) 注: 一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer 又存储String类型) 4.4.1 关于TreeSet:当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）②定制排序：（实现Comparator接口，重写compare方法） 两种排序的区别: 前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法. 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 注: 只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 compareTo()与hashCode()以及equals()三者保持一致！ 五、关于Map接口:5.1 Map接口元素的存储原理: Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，需要重写hashCode和equals方法, 进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复 例如:向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(后面的会覆盖前面的,这个与HashSet不同,HashSet是后面的那个不能添加进来)。 5.2 遍历Map:有三类，分别是遍历key，遍历value，遍历key-value对 1234567891011121314151617181920//1.遍历key集Set set = map.keySet();//2.遍历value集Collection values = map.values();//3.遍历key-value对Set set2 = map.entrySet(); //所有entry的集合就是entrySetfor (Object obj:set2) &#123; //遍历entrySet得到entryMap.Entry entry = (Map.Entry)obj; //获取entry//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键 和 值 System.out.println(entry);&#125; 5.3 Map的初始化:不能初始化为: Map&lt;String,List&gt;map=null;而要用new对象的方式：Map&lt;String,List&gt;map=newHashMap&lt;String,List&gt;();否则会报错 5.4 从map中取值:正确方法: 123456方法一: String str = String.valueOf(map.get("键名"));方法二: String str = (String) map.get("ACCEPT_CHANNEL");if (null != str &amp;&amp; !"".equals(str)) &#123;…………&#125; 错误的取值方法： 1String str = map.get("键名").toString; //如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常 注: Map中的Key value可以是任何引用类型的数据 5.5 Map接口的具体实现类:①: HashTable : 古老的实现类，线程安全，不建议使用②: HashMap:③: LinkedHashMap(是HashMap的子类)④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口) 5.5.1 Properties介绍:Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的 123456789101112131415读取属性文件jdbc.properties: Properties pros = new Properties();FileInputStream fi = new FileInputStream(new File("jdbc.properties"));pros.load(fi);读取xml配置文件config.xml: Properties properties = new Properties();InputStream configInputStream = new FileInputStream("config/config.xml");properties.loadFromXML(configInputStream); 六、关于Collections 工具类:6.1 作用: 操作Collection以及Map 6.2 注意: 区分Collection与Collections 6.3 实现list的复制: 12345678910//错误的方式：出现java.lang.indexOutOfBoundsException//List list1=new ArrayList();//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1//System.out.println(list1); //正确的方式List list2 = Arrays.asList(newObject[list.size()]);Collections.copy(list2,list);System.out.println(list2);//[123,456,12,78,456] 6.4 考虑线程安全问题: List 是线程不安全的, synchronizedList方法可以保证List线程安全 123//通过如下的方法保证list的线程安全List list3=Collections.synchronizedList(list);System.out.println(list3); 6.5常用函数: 123456reverse(List)：反转List中元素的顺序shuffle(List)：对List集合元素进行随机排序sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序swap(List,int,int)：将指定list集合中的i处元素和j处元素进行交换void copy(List dest,List src)://将src中的内容复制到dest中 七、集合的遍历方法：四种①使用Iterator迭代器 ②增强型for循环 ③普通for循环 ④Iterator迭代器的”古老版本”Enumeration 接口 123456789//Enumeration 接口是Iterator迭代器的"古老版本"public class TestEnumeration &#123; public static void main(String[] args) &#123; Enumeration enu = new StringTokenizer("ab-c*-df-g", "-"); while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement()); &#125; &#125;&#125; 12345678910111213//面试题@Testpublic void test5()&#123; //结果: 输出MM MM MM AA BB DD String[]str=new String[]&#123;"AA","BB","DD"&#125;; //表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值 for(String s:str)&#123; //每循环一次, s都是一个新的局部变量 s="MM"; System.out.println(s); &#125; for(int i=0;i&lt;str.length;i++)&#123; System.out.println(str[i]); &#125;&#125; 八、关于数组:存储对象可以考虑：①数组，②集合数组存储对象的特点：Student[] stu = new Student[20]; stu[0]=new Student();…..弊端：①一旦创建，其长度不可变. ②真实的数组存放的对象的个数是不可知的 九、总结:①: 单类型: 一个TreeSet对象必须存储同一种数据类型,例如: 不能既存储Integer 又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型. ②: 一致性: 使用TreeSet时: compareTo()与hashCode()以及equals()三者保持一致！ ③: 执行流程： 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 ④: 顺序性: Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)Set而言: 遍历是分为有序和无序的 , 其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[一、数据类型:1.1 基本数据类型：1.1.1 整数类型：byte（1个字节） -128（-2^7）——– 127 (2^7-1)short（2） -32768(-2^15)——- 32767(2^15-1)int（4） （-2)^31 —— 2^31-1long(8) （-2)^63 —— 2^63-1 整数有三种表示形式： 八进制：以0开头，如012，-027 十进制： 十六进制：以0x 或0X开头，如0x123,-0X12 1.1.2 浮点类型：float（4） 6或7位有效数字double（8） 15位有效数字带小数点的数默认为：双精度浮点型（double），数字后带“d 或 D”，如“2.3d”，“d 或 D”可以省略注意：要表示单精度浮点型（float），必须在数字后面加“f 或 F”，如“13.23f”,“f 或 F”不可省略 1.1.3 字符类型：char（2） 1.1.4 布尔类型boolean：false（4）必须小写true（4）必须小写 JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 1.2 引用数据类型：①: 类(class) 如String类②: 接口(interface)③: 数组④: 枚举（enum） 1.3 包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 二、常量与变量①: 常量：由final修饰的 ②: 变量： 局部变量（位于方法（一般方法，构造方法，程序入口方法）中） 全局变量（１.实例变量（无static修饰），２.类变量也称静态变量（有static修饰）） 三、强制类型转换:3.1 小的转换为大的，系统会自动完成强制类型转换如：short i = 10; int j; j=i; (系统自动完成j = (int)i )3.2 大的转换为小的，必须进行手动完成强制类型转换如：int i = 10; short j; j = (short)i; 四、构造方法:4.1 特点：①: 构造方法只能由new操作符调用，即建立对象时自动调用；②: 构造方法可以重载，即在同一个类中可以有多个构造方法③: 构造方法没有返回类型，甚至连void也没有④: 构造方法与类同名 注: 如果没有在类中写构造方法，系统会生成一个默认的无参构造方法，并使用默认值初始化对象的属性（int变量初始化为0，boolean 变量初始化为false）,如果写了有参构造方法,那么系统不会再自动生成无参构造方法,如果此时我们要用无参构造方法,需要我们手动写无参构造方法. 4.2 作用：初始化对象，如给数据成员赋值注意：一旦创建了一个有参数的构造方法，系统就不会自动添加默认的无参构造方法，要想用无参构造方法，需要人为的去创建一个无参构造方法 五、注释:①: 文件注释：在包名之上，“/*……*/”，描述文件名(java工程名)，版权信息②: 类注释：“/**……*/”，描述类的作用，版本version ，日期，作者③: 私有成员：“/*……*/” 或“//”；如局部变量，某一个语句的功能作用 * @param 描述方法的参数 * @return 描述返回值，对于无返回值的方法或构造方法，@return可以省略 * @throws 描述在什么情况下抛出什么类型的异常 * @author 描述作者 * @version 描述版本 * @since 描述该类可以运行的JDK版本 * @see 参考转向，也就是相关主题 * @link 转向成员的超链接。label为链接文字。package.class#member将被自动转换为指向package.class的member文件的URL ④: 共有成员：“/**……..*/”；如构造方法 六、继承（extends）6.1 含义:其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正每次调子类的时候都会“自动运行”它父类的构造函数，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”。 6.2 java中子类能不能继承父类构造方法？答案是不能*理由：其实每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。所以父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法 注意“调用”和继承不是一个含义，实质上是“自动运行”。 七、关于JavaBean:符合如下标准的Java类：①: 实现serializable接口（这个不是必须的）②: 必须有一个无参的公共的构造器（public修饰）③: 必须属性用private修饰，且有get，set方法 八、权限修饰符： 九、抽象类：特点：必须含抽象方法，其他的和一般类一样抽象方法：只有声明没有实现的方法 十、接口：10.1 特点：只含常量和抽象方法①: 接口中的常量都是public static final 类型(可以省略)，这是系统默认的②: 接口中的方法都是public abstract类型(可以省略)，这是系统默认的③: 接口 作为一种引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的该接口中的方法一个类要实现接口，必须实现这个接口中的所有方法 注意：通过一个接口变量只能调用该接口所声明的方法。 十一、重载和重写区别:方法重载（Overload）：一个类中有多个方法，名字相同，参数不同（如参数个数，种类，参数顺序不同），与返回值无关；方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同 十二、面向对象编程的四个基本特征:①：抽象:②：封装：把对象的数据和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节③：继承：④：多态性：多态的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。 多态的举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态的作用：消除类型之间的耦合关系 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 重载和重写都是多态的体现. 十三、异常与错误:12.1 异常:12.1.1 编译异常： 由于程序语法不合规范，编译不通过 12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）： 编译通过，运行时出现异常。如数组下标越界，除数为零，数字格式错误，空指针异常 12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）： 如类没找到，IO操作错误 12.1.4 逻辑异常： 输出的结果不符合预期的要求 12.1.5 try ,catch ,finally只有三种组合：​ a. try…catch…finally ​ b. try…catch ​ c. try…finally ①: 异常发生时，如果匹配的catch语句中抛出（有throw关键字）了异常，则finally之外的语句将不能被执行 ②: finally中的语句无论什么情况都会执行 ③: 得到有关异常信息：getMessage() ④: 用来跟踪异常事件发生时执行堆栈的内容：printStackTrace（） 12.1.6 throws 和 throw 的区别：throws 关键字用于方法的声明部分，说明方法可能抛出的异常类型throw 关键字用来抛出异常，如果抛出了检查性异常（非运行时异常），还必须在方法头部声明方法可能抛出的异常类，该方法的调用者还必须捕获处理抛出的异常,如果抛出非检查性异常（运行时异常），该方法的调用者可捕获可不捕获异常 12.2 错误（Error）：①：虚拟机错误（Virtual Machine Error）②：连接错误（LinkageError）③：图形界面错误（AWTError） 十四、日期与时间:13.1 java中主要使用三个类来处理日期和时间:①: java.util.Date(日期) , ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的毫秒数 ②: java.util.Calendar（日历） , ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分 ③: java.text.DateFormat（日期格式化）————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写有要求 13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 150658200000013.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 201713.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识java]]></title>
    <url>%2F%E5%88%9D%E8%AF%86java.html</url>
    <content type="text"><![CDATA[一、发展历史①: java语言前身是oak（橡树）语言②: java于1995年诞生于sun公司③: 1996第一个JDK诞生④: 1999 Sun发布J2SE，J2EE ,J2ME 二、语言特点①: 面向对象②: 分布式多线程③: 健壮性(异常处理)④: 安全⑤: 可移植性 三、Java技术体系分四个平台:①: Java Card: java小程序运行在小内存设备(智能卡)上的平台.②: Java ME: 移动终端(手机)③: JavaSE: 桌面级(Windows下的应用程序)④: JavaEE : 以前称J2EE ,企业级 四、JDK和JREJDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器) JDK目录结构:①: bin目录：包含编译器（javac.exe（c是compile（编译）的缩写）），解释器（java.exe），帮助文档生成器（javadoc.exe），打包工具（jar.exe），小应用程序浏览工具（appletviewer.exe） ②: lib目录：包含类库文件 ③: demo目录：包含各种演示例子 ④: include目录：包含C语言头文件，支持java本地接口 ⑤: jre目录：包含java虚拟机，java应用启动器，运行时的类包 ⑥: sample目录：sun配带的帮助学习者学习的java例子 ⑦: src.zip:源码压缩文件 JDK: Java程序设计语言 + Java 虚拟机 + JavaAPI类库 JRE : JavaAPI中的Java SE API + Java虚拟机 因此 JDK包含JRE 五、java虚拟机是什么？(Java Virtual Machine) 简称JVM Java语言写的代码是.java文件，它会被特定程序编译(javac.exe，它会被Eclipse之类的IDE调用)成字节码(bytecode)，字节码不能直接在CPU上运行，需要另一个程序读取并执行，这个部件就是java虚拟机，它像机器一样运行编译好的java字节码，就像机器直接执行机器码一样……java虚拟机的外部接口在windows下主要是jvm.dll这个文件……简言之：jvm是Java开发语言中，用来运行Java字节码文件的平台；提供对Java字节码的解释及运行，位于JRE中JRE: java运行环境,包含java虚拟机和java程序所需的核心类库(javaSE API) 。如果只是想跑java程序，那么只需安装JRE，如果要写java程序，那就需要JDK了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之内存分配和回收]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6.html</url>
    <content type="text"><![CDATA[一、内存分配策略:1. 对象优先在 Eden 分配:大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 2. 大对象直接进入老年代:①: 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。②: 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。⑤: -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 3. 长期存活的对象进入老年代:①: 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。②: -XX:MaxTenuringThreshold 用来定义年龄的阈值。 4. 动态对象年龄判定:虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保:在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Minor GC 的触发条件: 当 Eden 空间满时，就将触发一次 Minor GCFull GC 的触发条件:①: 老年代空间不足: 解决方案： ①：尽量不要创建过大的对象以及数组 ②：通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 ③：通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 ②: 空间分配担保失败 ③: 调用 System.gc(): 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 ④：JDK 1.7 及以前的永久代空间不足 解决方案： ①：可采用的方法为增大永久代空间 ②：转为使用 CMS GC。 二、内存回收：2.1 GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。2.1.1 Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。 2.1.2 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-3无重复字符的最长子串]]></title>
    <url>%2FLeetCode-3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    <content type="text"><![CDATA[题目:给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "kew"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 分析:给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。 我们先不考虑代码怎么实现，如果给一个例子中的例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉第一次出现的b，以此类推，最终发现最长的长度为3。 所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。 进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。 参考链接:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之垃圾收集]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[一、垃圾收集:1.1哪些区域需要垃圾收集:①: 垃圾收集主要是针对堆和方法区进行。②: 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 二、判断一个对象是否可被回收:2.1 引用计数算法:为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011121314public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); &#125;&#125; 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。 2.2 可达性分析算法:以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： ①: 虚拟机栈中局部变量表中引用的对象 ②: 本地方法栈中 JNI 中引用的对象 ③: 方法区中类静态属性引用的对象 ④: 方法区中的常量引用的对象 2.3 方法区的回收①: 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 ②: 主要是对常量池的回收和对类的卸载。 ③: 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 ④: 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 2.4. finalize()类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 三、引用类型:无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型:3.1 强引用被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 3.2 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.3 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的: 是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 四、垃圾收集算法:4.1 标记 - 清除: 标记要回收的对象，然后清除。不足：标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 4.2 标记 - 整理:让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 4.3 复制: 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足: 是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 4.4 分代收集:现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 五、垃圾收集器:HotSpot 虚拟机中的 7 个垃圾收集器: 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 5.1 Serial 收集器:Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 5.2ParNew 收集器:它是 Serial 收集器的多线程版本。 它是Server场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 5.3 Parallel Scavenge 收集器:与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值 5.4 Serial Old 收集器:是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5.5 Parallel Old 收集器:是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 5.6 CMS 收集器:CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 具有以下缺点：①: 吞吐量低：②: 无法处理浮动垃圾: 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。③: 标记 - 清除算法导致空间碎片 5.7 G1 收集器:G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA.html</url>
    <content type="text"><![CDATA[一、JVM是什么?JVM是Java Virtual Machine（Java虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 二、JVM的作用?JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码字节码，就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 三、从进程的角度解释JVM我们知道，虚拟机是运行在操作系统之中的，那么什么东西才能在操作系统中运行呢？当然是进程，因为进程是操作系统中的执行单位。可以这样理解，当它在运行的时候，它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放于文件系统中），可以把它叫做程序。 对命令行比较熟悉的同学，都知道其实一个命令对应一个可执行的二进制文件，当敲下这个命令并且回车后，就会创建一个进程，加载对应的可执行文件到进程的地址空间中，并且执行其中的指令。 四、Java版HelloWord程序的编译和执行形式:①: 首先编写源文件HelloWord.java ： 12345 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; ②: 编译Java版的HelloWorld程序：$ javac HelloWorld.java ③: 运行Java版的HelloWorld程序：$ java -classpath . HelloWorld 4.1 从上面的过程可以看到， 我们在运行Java版的HelloWorld程序的时候， 敲入的命令并不是 ./HelloWorld.class 。 因为class文件并不是可以直接被操作系统识别的二进制可执行文件 。 我们敲入的是java这个命令。 这个命令说明， 我们首先启动的是一个叫做java的程序， 这个java程序在运行起来之后就是一个JVM进程实例. 4.2 上面的命令执行流程是这样的： java命令首先启动虚拟机进程，虚拟机进程成功启动后，读取参数“HelloWorld”，把他作为初始类加载到内存，对这个类进行初始化和动态链接，然后从这个类的main方法开始执行。 也就是说我们的.class文件不是直接被系统加载后直接在cpu上执行的，而是被一个叫做虚拟机的进程托管的。首先必须虚拟机进程启动就绪，然后由虚拟机中的类加载器加载必要的class文件，包括jdk中的基础类（如String和Object等），然后由虚拟机进程解释class字节码指令，把这些字节码指令翻译成本机cpu能够识别的指令，才能在cpu上运行. 4.3 从这个层面上来看，在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。 五、JVM体系结构简介: 根据上图表达的内容，我们编译之后的class文件是作为Java虚拟机的原料被输入到Java虚拟机的内部的，那么具体由谁来做这一部分工作呢？其实在Java虚拟机内部，有一个叫做类加载器的子系统，这个子系统用来在运行时根据需要加载类。注意上面一句话中的“根据需要”四个字。在Java虚拟机执行过程中，只有他需要一个类的时候，才会调用类加载器来加载这个类，并不会在开始运行时加载所有的类。就像一个人，只有饿的时候才去吃饭，而不是一次把一年的饭都吃到肚子里。一般来说，虚拟机加载类的时机，在第一次使用一个新的类的时候。 由虚拟机加载的类，被加载到Java虚拟机内存中之后，虚拟机会读取并执行它里面存在的字节码指令。虚拟机中执行字节码指令的部分叫做执行引擎。就像一个人，不是把饭吃下去就完事了，还要进行消化，执行引擎就相当于人的肠胃系统。在执行的过程中还会把各个class文件动态的连接起来。 Java虚拟机会进行自动内存管理。具体说来就是自动释放没有用的对象，而不需要程序员编写代码来释放分配的内存。这部分工作由垃圾收集子系统负责。 一个Java虚拟机实例在运行过程中有三个子系统来保障它的正常运行，分别是类加载器子系统， 执行引擎子系统和垃圾收集子系统。 如下图所示： 虚拟机的运行，必须加载class文件，并且执行class文件中的字节码指令。它做这么多事情，必须需要自己的空间。就像人吃下去的东西首先要放在胃中。虚拟机也需要空间来存放个中数据。首先，加载的字节码，需要一个单独的内存空间来存放；一个线程的执行，也需要内存空间来维护方法的调用关系，存放方法中的数据和中间计算结果；在执行的过程中，无法避免的要创建对象，创建的对象需要一个专门的内存空间来存放。 5.1 Java虚拟机 运行时数据区: 5.1.1程序计数器:①: 是一块较小的内存空间, 当前线程执行的字节码的行号指示器(记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。)②: 指向下一条需要执行的指令③: 每条线程都需要一个独立的程序计数器,彼此互不干扰(线程私有的内存) 5.1.2Java虚拟机栈:①: 线程私有的,生命周期与线程相同②: 描述java方法执行的内存模型,每个方法执行时都会创建一个栈帧,用来存放局部变量表,操作数栈,常量池引用等信息.③: 每个方法从调用到执行完成 就对应着栈帧在虚拟机栈帧中入栈和出栈.④: 两种异常: StackOverFlow异常 : 线程所请求的栈深度大于虚拟机允许的则抛出 OutOffMemoryError异常: 扩展时无法申请到足够的内存则抛出⑤: 我们常说的栈 和堆 中的栈就是Java虚拟机栈,更具体来说是Java虚拟机栈中的局部变量表部分.⑥: 局部变量表: 存放编译期可知的各种基本数据类型,对象引用类型 所需要的内存空间在编译期完成分配, 在方法运行期间不会改变其大小 64位长度的long 和 double 类型数据会占用2个局部变量空间(Slot) ,其余占一个. ⑦: 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：java -Xss512M HackTheJava 5.1.3本地方法栈:本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 上面三个区域随线程而生, 随线程而灭; 5.1.4Java堆( Java Heap) : 也称GC堆(Garbage Collected Heap )①: 是Java虚拟机管理的内存中最大的一块②: 被所有线程共享,的一块内存空间, 在虚拟机启动时候创建,③: 唯一目的: 存放对象实例, 几乎所有的对象实例 和 数组 都在这里这里分配内存.④: 是垃圾收集器管理的主要区域 ,所以也称GC堆⑤: 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M HackTheJava⑥: 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。 5.1.5方法区(永久代):①: 被所有线程共享,的一块内存空间②: 用来存储Class的相关信息如已经被Java虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。③: 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。④: 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。⑤: HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 5.1.5运行时常量池①: 运行时常量池是方法区的一部分。②: .Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。③: 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。④: 常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 参考链接:https://baike.baidu.com/item/JVMhttps://blog.csdn.net/zhangjg_blog/article/details/20380971https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.mdhttps://blog.csdn.net/gyqjn/article/details/49848473]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是策略模式?定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp;让算法可在不影响客户端的情况下发生变化简单来说：准备一组算法 &amp; 将每一个算法封装起来，让外部按需调用 &amp; 使得互换 二、如何使用?使用步骤?步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员步骤4：客户端调用-让销售员进行促销活动的落地 三、优点:①: 策略类之间可以自由切换,由于策略类都实现同一个接口，所以使它们之间可以自由切换②: 易于扩展,增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码③: 符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。 四、缺点:①: 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。②: 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 五、应用场景:动态选择多种复杂行为 六、实例:背景：小成有一家百货公司，最近在定年度的促销活动冲突：每个节日用同一个促销活动太枯燥，没吸引力解决方案：针对不同节目使用不同促销活动进行促销 123456789101112131415161718192021222324252627282930313233343536373839404142434445//步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口abstract class Strategy &#123; public abstract void show();&#125;//步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动//为春节准备的促销活动Aclass StrategyA extends Strategy &#123; @Override public void show() &#123; System.out.println("为春节准备的促销活动A"); &#125;&#125;//为中秋节准备的促销活动Bclass StrategyB extends Strategy &#123; @Override public void show() &#123; System.out.println("为中秋准备的促销活动A"); &#125;&#125;//为国庆准备的促销活动Cclass StrategyC extends Strategy &#123; @Override public void show() &#123; System.out.println("为国庆准备的促销活动C"); &#125;&#125;//步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员class Context_SaleMan &#123; //持有抽象策略角色的引用 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * * @param strategy 具体策略对象 */ public Context_SaleMan(Strategy strategy) &#123; this.strategy = strategy; &#125; //向客户展示促销活动 public void Sale_ManShow() &#123; strategy.show(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//步骤4：客户端调用-让销售员进行促销活动的落地public class StrategyPattern &#123; //程序入口 public static void main(String[] args) &#123; Context_SaleMan saleMan; // 选择并创建需要使用的策略对象 // 例如现在要做春节的活动 Strategy strategyA = new StrategyA(); System.out.println("对于春节："); // 创建环境 saleMan = new Context_SaleMan(strategyA); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做中秋节的活动 Strategy strategyB = new StrategyB(); System.out.println("对于中秋节："); // 创建环境 saleMan = new Context_SaleMan(strategyB); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做国庆节的活动 Strategy strategyC = new StrategyC(); System.out.println("对于国庆节："); // 创建环境 saleMan = new Context_SaleMan(strategyC); saleMan.Sale_ManShow(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[什么是抽象工厂模式?抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。 抽象工厂模式与工厂方法模式最大的区别?抽象工厂中每个工厂可以创建多种类的产品, 而工厂方法每个工厂只能创建一类. 使用步骤:(根据下图来理解:)步骤1： 创建抽象工厂类，定义具体工厂的公共接口；步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；步骤4： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例 优点:①: 降低耦合: 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来， 可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；②: 更符合开-闭原则: 新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 而简单工厂模式需要修改工厂类的判断逻辑 ③: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品， 而简单工厂中的工厂类存在复杂的switch逻辑判断④: 不使用静态工厂方法，可以形成基于继承的等级结构， 而简单工厂模式的工厂类使用静态工厂方法 缺点:①: 抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。②: 对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。 应用场景:①: 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。②: 这个系统有多个系列产品，而系统中只消费其中某一系列产品③: 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。 实例:背景： 小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂所在地的客户 也需要模具类产品，B厂所在地的客户也需要容器类产品；冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂.解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。 1234567//步骤1： 创建抽象工厂类，定义具体工厂的公共接口abstract class Factory &#123; public abstract Product ManufactureContainer();//容器 public abstract Product ManufactureMould();//模型&#125; 123public class Product &#123; public void show()&#123;&#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//步骤2： 创建抽象产品族类 ，定义具体产品的公共接口；abstract class AbstractProduct extends Product&#123; public abstract void show();&#125;//步骤3： 创建抽象产品类 ，定义具体产品的公共接口；//容器产品抽象类abstract class ContainerProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//模型产品抽象类abstract class MouldProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//步骤4： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；//容器产品Aclass ContainerProductA extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品A"); &#125;&#125;//容器产品Bclass ContainerProductB extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品B"); &#125;&#125;//模具产品Aclass MouldProductA extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品A"); &#125;&#125;//模具产品Bclass MouldProductB extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品B"); &#125;&#125;//步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//A厂 - 生产模具+容器产品class FactoryA extends Factory &#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductA(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductA(); &#125;&#125;//B厂 - 生产模具+容器产品class FactoryB extends Factory&#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductB(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductB(); &#125;&#125; 12345678910111213141516//步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例public class AbstractFactoryPattern &#123; public static void main(String[] args) &#123; Factory myfactoryA = new FactoryA(); Factory myfactoryB = new FactoryB(); //A厂当地客户需要容器产品A myfactoryA.ManufactureContainer().show(); //A厂当地客户需要模具产品A myfactoryA.ManufactureMould().show(); //B厂当地客户需要容器产品B myfactoryB.ManufactureContainer().show(); //B厂当地客户需要模具产品B myfactoryB.ManufactureMould().show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-2两数相加]]></title>
    <url>%2FLeetCode-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html</url>
    <content type="text"><![CDATA[题目:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例: 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析:建立一个新链表，然后把输入的两个链表从头往后遍历，每两个相加，添加一个新节点到新链表后面。为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后，由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点。好，可以开始让两个链表相加了，这道题好就好在最低位在链表的开头，所以我们可以在遍历链表的同时按从低到高的顺序直接相加。while循环的条件两个链表中只要有一个不为空行，由于链表可能为空，所以我们在取当前结点值的时候，先判断一下，若为空则取0，否则取结点值。然后把两个结点值相加，同时还要加上进位carry。然后更新carry，直接 sum/10 即可，然后以 sum%10 为值建立一个新结点，连到cur后面，然后cur移动到下一个结点。之后再更新两个结点，若存在，则指向下一个位置。while循环退出之后，最高位的进位问题要最后特殊处理一下，若carry为1，则再建一个值为1的结点，代码如下： 123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //l1,l2相当于指向两个链表表头的指针 //为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后 ListNode dummy = new ListNode(-1); //由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点 ListNode cur = dummy; //进位 int carry = 0; //至少有一个结点不为空 while (l1 != null || l2 != null) &#123; //结点为空,那么值就设置为0,不为空取出结点所存放的值 int d1 = l1 == null ? 0 : l1.val; int d2 = l2 == null ? 0 : l2.val; //两个链表中对应结点的值求和 int sum = d1 + d2 + carry; carry = sum &gt;= 10 ? 1 : 0; //sum不会超过二十,所以最多进1位 cur.next = new ListNode(sum % 10);//造一个新结点,将两个链表对应结点的两数之和,存到新链表的新结点 cur = cur.next;//移动cur指针,指向下一个结点 if (l1 != null) &#123; l1 = l1.next;//移动l1指针 &#125; if (l2 != null) &#123; l2 = l2.next;//移动l2指针 &#125; &#125;//循环结束 //如果最高位相加,产生进位,需要再造一个结点 if (carry == 1) &#123; cur.next = new ListNode(1); &#125; return dummy.next;&#125; 12345678910111213141516171819202122232425public class addTwoNumbers &#123; //程序入口函数 public static void main(String[] args) &#123; //建立第一个链表 ListNode listNode1 = new ListNode(2); ListNode listNode2 = new ListNode(4); ListNode listNode3 = new ListNode(3); listNode1.next=listNode2; listNode2.next=listNode3; listNode3.next=null; //建立第二个链表 ListNode listNode4 = new ListNode(5); ListNode listNode5 = new ListNode(6); ListNode listNode6 = new ListNode(4); listNode4.next=listNode5; listNode5.next=listNode6; listNode6.next=null; //调用方法 ListNode listNode = new addTwoNumbers().addTwoNumbers(listNode1,listNode4); //打印结果: ListNode&#123;val=7, next=ListNode&#123;val=0, next=ListNode&#123;val=8, next=null&#125;&#125;&#125; System.out.println(listNode); &#125;&#125; 参考链接:http://www.cnblogs.com/grandyang/p/4129891.htmlhttps://leetcode-cn.com/problems/two-sum/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是工厂方法模式?①: 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口(抽象方法)，而子类重写接口(抽象方法)则负责生成具体的对象。③: 简言之:工厂里面造对象,对象所属类里面造产品 二、如何使用?使用步骤?步骤1： 创建抽象工厂类，定义具体工厂的公共接口(抽象方法)；步骤2： 创建抽象产品类 ，定义具体产品的公共接口(抽象方法)；步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤4： 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例(对象)的方法；步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 三、优点:①: 更符合开-闭原则: 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可, 而简单工厂模式需要修改工厂类的判断逻辑②: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品, 而简单工厂中的工厂类存在复杂的switch逻辑判断, 它不使用静态工厂方法，可以形成基于继承的等级结构。 而简单工厂模式的工厂类使用静态工厂方法 四、缺点:①: 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；②: 同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；③: 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。④: 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；⑤: 一个具体工厂只能创建一种具体产品 五、应用场景:①: 当一个类不知道它所需要的对象的类时②: 当一个类希望通过其子类来指定创建对象时③: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。④: 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 六、实例:背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；解决方案：小成决定置办塑料分厂B来生产B类产品； //步骤1： 创建抽象工厂类 123abstract class Factory &#123; abstract Product Manufacture();&#125; //步骤2： 创建抽象产品类 ，定义具体产品的公共接口； 123abstract class Product &#123; public abstract void show();&#125; //步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下://步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下: //具体产品A类class ProductA extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品A"); &#125;&#125;//具体产品B类class ProductB extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品B"); &#125;&#125;//步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; @Override Product Manufacture() &#123; return new ProductA(); &#125;&#125;//工厂B类 - 生产B类产品class FactoryB extends Factory&#123; @Override Product Manufacture() &#123; return new ProductB(); &#125;&#125;//生产工作流程public class FactoryPattern &#123; public static void main(String[] args) &#123; //客户要产品A FactoryA myfactoryA = new FactoryA(); myfactoryA.Manufacture().show(); //客户要产品B FactoryB myFactoryB = new FactoryB(); myFactoryB.Manufacture().show(); &#125; 七、总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是简单工厂模式?①: 简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法） ②: 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。 二、如何使用?使用步骤?:①: 创建抽象产品类 &amp; 定义具体产品的公共接口；②: 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；③: 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；④: 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例 三、优点:①: 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；②: 把初始化实例时的工作放到工厂里进行，使代码更容易维护。③: 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。 四、缺点:①: 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；②: 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。③: 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 五、应用场景:①: 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；②: 当工厂类负责创建的对象（具体产品）比较少时。 六、实例:背景：小成有一个塑料生产厂，用来做塑料加工生意目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产 //步骤1. 创建抽象产品类，定义具体产品的公共接口 123abstract class Product &#123; public abstract void show();&#125; //步骤2.创建具体产品类（继承抽象产品类），定义生产的具体产品, 代码如下://步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//具体产品类Aclass ProductA extends Product &#123; @Override public void show() &#123; System.out.println("生产出A产品!"); &#125;&#125;//具体产品类Bclass ProductB extends Product &#123; @Override public void show() &#123; System.out.println("生产出B产品!"); &#125;&#125;//具体产品类Cclass ProductC extends Product &#123; @Override public void show() &#123; System.out.println("生产出C产品!"); &#125;&#125;//步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例public class SimpleFactoryPattern &#123; public static void main(String[] args) &#123; //客户要A产品 try &#123; Factory.Manufacture("A").show(); &#125; catch (NullPointerException e) &#123; System.out.println("没有A产品"); &#125; //客户要B产品 try &#123; Factory.Manufacture("B").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有B产品"); &#125; //客户要C产品 try &#123; Factory.Manufacture("C").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有C产品"); &#125; //客户要D产品 try &#123; Factory.Manufacture("D").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; &#125;&#125; //步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例 12345678910111213141516public class Factory &#123; public static Product Manufacture(String productName) &#123;//工厂类里用switch语句控制生产哪种商品；//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化 switch(productName) &#123; case "A": return new ProductA(); case "B": return new ProductB(); case "C": return new ProductC(); default: return null; &#125; &#125;&#125; 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-三次握手和四次挥手]]></title>
    <url>%2FTCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[一、字段说明: 字段: 含义: SYN,seq 同步报文段 ACK,ack 确认报文段 ack 确认号 seq 序列号 SYN 同步位 FIN 终止位 ACK 确认位 二、三次握手:第一次: 连接请求报文段: SYN=1(请求连接) 初始序号seq=x(客户端初始序号)第二次: 确认报文段(同意连接): SYN =1(请求连接) seq= y(服务器自己的初始序号) ACK = 1(确认收到) ack = x+1(确认号)第三次: 确认报文段:ACK=1(确认收到) seq=x+1 (客户端序号) ack=y+1(确认号) 确认号ack是上一次的序号seq加1 总结: ack的值等于对方上一次发送的报文段中的seq的值加一,​ seq的值等于自己上一次发送的报文段中的seq的值加一(第一次seq值任意取) 简图: B 处于 LISTEN（监听）状态，等待来自 A 的连接请求。 A 向 B 发送连接请求报文 SYN。 B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN ACK。 A 收到 SYN ACK 后，还要向 B 发出确认报文 ACK。 B 收到 ACK 后，连接建立。 应该注意到，接收了 SYN 之后的所有报文都存在 ACK 字段。 三、三次握手的原因:第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四、四次挥手: 简图: 第一次: 连接释放报文段: FIN=1 seq=u(u为前面已经传送过的数据的最后一个字节的序号加一) 第二次: 连接释放确认报文段: 确认只断开A—B ACK= 1(确认收到) ack=u+1(确认号) seq=v(v为为前面已经传送过的数据的最后一个字节的序号加一) 第三次: 连接释放确认报文段: 断开B—-A FIN = 1 ACK =1 ack=u+1 seq=w(seq=v后还发送了数据, w是前面已经传送过的数据的最后一个字节的序号加一) 第四次: 连接释放确认报文段 : 确认断开B—A ACK=1 ack = w+1 seq=u+1 A 发送连接释放报文 FIN。 B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文 FIN。 A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。 B 收到 ACK 后释放连接。 五、四次挥手的原因:客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。 六、为什么还要设置一个Time-WAIT ?客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。 参考文章:https://mp.weixin.qq.com/s/tGlWTrr5KLAv1AflfeAejA]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP-三次握手和四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1两数之和]]></title>
    <url>%2FLeetCode-1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析:这道题给了我们一个数组，还有一个目标数target，让我们找到两个数字，使其和为target，乍一看就感觉可以用暴力搜索(遍历所有的两个数字的组合，然后算其和), 但是时间复杂度是O(n^2)。能否想个O(n)的算法来实现，一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢，我们可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，我们都知道HashMap是常数级的查找效率，这样，我们在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。代码如下： 法一: 暴力搜索(不采用) 123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int i = 0, j = 0, t = 0; int result[] = new int[2]; for (i = 0; i &lt; nums.length - 1; i++) &#123; //0 1 2 for (j = i; j &lt; nums.length - 1; j++) &#123; t = nums[i] + nums[j + 1]; if (t == target) &#123; result[0] = i; result[1] = j + 1; return result; &#125; &#125; &#125; return result; &#125; 法二: 使用HashMap 1234567891011121314151617public class TwoSum &#123; public int[] twoSum(int[] sums,int target) &#123; HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;Integer,Integer&gt;(); int[] result = new int[2]; for(int i = 0;i &lt; sums.length;i++)&#123; hashMap.put(sums[i],i);//把值存到HashMap,数作为键,下标作为值 &#125; for(int i = 0;i &lt; sums.length;i++) &#123; int t = target - sums[i]; if(hashMap.containsKey(t) &amp;&amp; hashMap.get(t) != i) &#123; result[0] = i; result[1] = hashMap.get(t); break;//一旦找到了,就立刻终止循环 &#125; &#125; return result; &#125; 1234567891011public class TwoSum &#123; //程序入口函数 public static void main(String[] args) &#123; int []nums = new int []&#123;2, 7, 11, 15&#125;; int target = 9; int[] result = new int[2]; result = new TwoSum().twoSum(nums,target); //打印结果: [0,1] System.out.println("["+result[0]+","+result[1]+"]"); &#125; 参考链接:https://leetcode-cn.com/problems/two-sum/http://www.cnblogs.com/grandyang/p/4130379.html]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是单例模式? 实现1个类只有1个实例化对象并提供一个全局访问点. 二、工作原理: 保证在内存中只有一个对象存在. 在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的， 要是想实现一个类只有一个实例化对象，就要对类的构造方法下功夫 三、如何去保证内存中只有一个对象存在? ①: 构造函数私有化 ②: 自己创建当前类的对象 ③: 对外提供公共的方法(获取已经创建好的对象) 四、使用步骤: 创建私有变量 OurInstance,（用以记录 Singleton 的唯一实例）,内部进行实例化 把类的构造方法私有化，不让外部调用构造方法实例化(构造方法只能在本类中调用) 定义公有方法提供该类的全局唯一访问点外部通过调用newInstance()方法来返回唯一的实例 五、优点: 提供了对唯一实例的受控访问； 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能； 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式； 六、缺点: 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失。 七、单例模式的实现方式:可分为2大类、6种实现方式: 第一大类: 初始化单例类时 即 创建单例 实现方式1: 饿汉式 实现方式2: 枚举类型 第二大类: 按需,延迟创建单例 实现方式3: 懒汉式的基础实现 实现方式4: 懒汉式的改进—&gt;同步锁 实现方式5: 懒汉式的改进—&gt;双重检验锁 实现方式6: 静态内部类 八、饿汉式和懒汉式的区别: 饿汉式: 随类的加载而创建对象 懒汉式: 上来不创建对象,当调用的时候,再创建对象,以后使用的就是同一个对象了 懒汉式: 懒加载,延迟加载 九、实现方式详解:9.1 实现方式1: 饿汉式 ①: 这是 最简单的单例实现方式 ②: 原理: 依赖 JVM类加载机制，保证单例只会被创建1次，即 线程安全 JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化 ③: 应用场景: 除了初始化单例类时 即 创建单例外，继续延伸出来的是：单例对象 要求初始化速度快 &amp; 占用内存小 ④: 具体实现: 1234567891011121314class Singleton &#123; // 1. 加载该类时，单例就会自动被创建 private static Singleton ourInstance = new Singleton(); // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 通过调用静态方法获得创建的单例 public static Singleton newInstance() &#123; return ourInstance; &#125; &#125; 9.2 实现方式2: 枚举类型 ①: 原理: 根据枚举类型的下述特点，满足单例模式所需的 创建单例、线程安全、实现简洁的需求 ②: 具体实现: 12345678910public enum Singleton&#123; //定义1个枚举的元素，即为单例类的1个实例 INSTANCE; // 隐藏了1个空的、私有的 构造方法 // private Singleton () &#123;&#125; &#125; // 获取单例的方式： Singleton singleton = Singleton.INSTANCE;注：这是 最简洁、易用 的单例实现方式，借用《Effective Java》的话：单元素的枚举类型已经成为实现 Singleton的最佳方法 9.3实现方式3: 懒汉式（基础实现） ①: 原理: 与饿汉式 最大的区别是：单例创建的时机 饿汉式：单例创建时机不可控，即类加载时 自动创建 单例 懒汉式：单例创建时机可控，即有需要时，才 手动创建 单例 ②: 具体实现: 123456789101112131415161718class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 需要时才手动调用 newInstance（） 创建 单例 public static Singleton newInstance() &#123; // 先判断单例是否为空，以避免重复创建 if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; return ourInstance; &#125; &#125; ③: 缺点: 基础实现的懒汉式是线程不安全的，具体原因如下: 可能存在多个线程并发 调用 newInstance ( ),从而重复创建单例对象 ④:具体实例: 一个线程A执行到singleton=new Singleton( ); 但还没有获得对象(因对象初始化需要时间),此时,第2个线程也在执行,执行到if (singleton == null) 判断 (判断为真,于是继续运行,创建单例对象),最终线程A ,B 同时获得了一个单例对象, 在内存中就出现两个单例类的对象,造成单例模式失效. 9.4实现方式4: 懒汉式的改进—&gt;同步锁 ①: 原理: 使用同步锁 synchronized锁住创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建 即，getInstance（）方法块只能运行在1个线程中．若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待，而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下单例对象的唯一性． ②: 具体实现: 12345678910111213141516171819202122232425262728293031323334353637 // 写法1(同步方法)class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 加入同步锁 public static synchronized Singleton getInstance()&#123; // 先判断单例是否为空，以避免重复创建 if ( ourInstance == null ) ourInstance = new Singleton(); return ourInstance; &#125; &#125; // 写法2 (同步代码块) // 该写法的作用与上述写法作用相同，只是写法有所区别 class Singleton&#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; // 加入同步锁 synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; return instance; &#125; &#125; ④: 缺点: 每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能） 注: 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步 9.5 实现方式5: 懒汉式的改进—&gt;双重检验锁 ①: 原理: 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能 ②: 具体实现: 1234567891011121314151617181920212223242526272829303132class Singleton &#123; private static Singleton ourInstance = null； private Singleton() &#123; &#125; public static Singleton newInstance() &#123; // 加入双重校验锁 // 校验锁1：第1个if if( ourInstance == null)&#123; // ① synchronized (Singleton.class)&#123; // ② // 校验锁2：第2个 if if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; &#125; &#125; return ourInstance; &#125; &#125; // 说明 // 校验锁1：第1个if // 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作 // 即直接跳到执行 return ourInstance // 校验锁2：第2个 if // 作用：防止多次创建单例问题 // 原理 // 1. 线程A调用newInstance()方法，当运行到②位置时，此时线程B也调用了newInstance()方法, // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕 // 3. 当线程A释放同步锁时，单例已创建，即instance已非空 // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 为非空（单例已创建），因此也不会创建多余的实例 ③: 缺点: 实现复杂 = 多种判断，易出错 9.6 实现方式6: 静态内部类 ①: 原理: 根据 静态内部类 的特性，同时解决了按需加载、线程安全的问题，同时实现简洁 在静态内部类里创建单例，在装载该内部类时才会去创建单例 线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例 ②: 具体实现: 123456789101112131415161718192021222324class Singleton &#123; // 1. 创建静态内部类 private static class Singleton2 &#123; // 在静态内部类里创建单例 private static Singleton ourInstance = new Singleton()； &#125; // 私有构造函数 private Singleton() &#123; &#125; // 延迟加载、按需创建 public static Singleton newInstance() &#123; return Singleton2.ourInstance; &#125; &#125; // 调用过程说明： // 1. 外部调用类的newInstance() // 2. 自动调用Singleton2.ourInstance // 2.1 此时单例类Singleton2得到初始化 // 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例； // 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性 // 3. 最终只创建1个单例 参考文章:https://www.jianshu.com/p/b8c578b07fbc]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识设计模式]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[前言: 我们学习程序设计语言，有必要学习它的设计模式吗？当然是有必要的，程序里有一些“模式”可以发掘的。因为你可以借鉴以往的经验，避免走很多弯路，更快的构造新的程序，提高开发效率。 一、设计模式是什么？ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 简言之：模式：在某些场景下，针对某类问题的某种通用的解决方案。 二、设计模式历史背景? 埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides，后以“四人帮”（Gang of Four，GoF）著称，简称 GoF ，在 95年的时候整理归纳出 23 种最常用的设计模式，并编写成一本书 Design Patterns: Elements of Reusable Object-Oriented Software 就是：《设计模式：可复用面向对象软件的基础》 。 三、设计模式的六大原则:开闭原则（Open Close Principle)：模块应尽量在不修改原代码(闭)的情况下进行扩展(开)。即在程序需要进行拓展的时候，不能去修改原有的代码（闭），实现一个热插拔的效果。 里氏替换原则（Liskov Substitution Principle）：如果调用的是父类的话，那么换成子类也完全可以运行。 派生类能够在基类的基础上增加新的行为。只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒置原则（Dependence Inversion Principle）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。2、抽象不应该依赖于具体实现，具体实现应该依赖于抽象。要求对抽象/接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 接口隔离原则 (Interface Segregation Principle)：每一个接口应该是一种角色，不干不该干的事，该干的事都要干。降低类之间的耦合度。 合成复用原则 (Composite Reuse Principle)：要尽量使用组合/ 聚合，尽量不要使用继承。只有“Is - A” 关系才符合继承关系，“Has- A” 关系应当使用聚合来描述。 迪米特法则 (Demeter Principle)（也称最少知识原则）：一个对象应对其它对象有尽可能少的了解。即一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。简言之：只与直接的朋友通信 四、设计模式的三大分类:创建型模式：共5种, 对象实例化的模式，创建型模式用于解耦对象的实例化过程。 结构型模式：共7种, 把类或对象结合在一起形成一个更大的结构。 行为型模式：共11种, 类和对象如何交互，及划分责任和算法。 五、23种设计模式:单例模式：某个类只能有一个实例，提供一个全局的访问点。 工厂方法(Factory Method)：定义一个创建对象的接口，让子类决定实例化那个类。 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。 普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象 静态工厂方法模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。 原型模式：通过复制现有的实例来创建新的实例。 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。 组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。 装饰模式：动态的给对象添加新的功能。 代理模式：为其他对象提供一个代理以便控制这个对象的访问。 享元模式：通过共享技术来有效的支持大量细粒度的对象。 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。 观察者模式：对象间的一对多的依赖关系。 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。 中介者模式：用一个中介对象来封装一系列的对象交互。 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。 参考文章: https://zhuanlan.zhihu.com/p/28737945https://www.cnblogs.com/pony1223/p/7608955.htmlhttps://juejin.im/post/59b78dfe5188257e7e115caehttps://www.jianshu.com/p/72764b69d6cf]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子网划分的经典实例]]></title>
    <url>%2F%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[案例:例1:一家集团公司有12家子公司，每家子公司又有4个部门。上级给出一个172.16.0.0/16的网段，让给每家子公司以及子公司的部门分配网段。 例2:某集团公司给下属子公司甲分配了一段IP地址192.168.5.0/24，现在甲公司有两层办公楼（1楼和2楼），统一从1楼的路由器上公网。1楼有100台电脑联网，2楼有53台电脑联网。如果你是该公司的网管，你该怎么去规划这个IP？ 例3:请问 192.168.10.0/26 有多少子网?每个子网有多少主机?有多少合法子网?每个子网的广播地址是多少?哪些是合法主机号? 分析:例1：通过子网数来划分子网，未考虑主机数。 例2：通过计算主机数来划分子网。 例1 思路：既然有12家子公司，那么就要划分12个子网段，但是每家子公司又有4个部门，因此又要在每家子公司所属的网段中划分4个子网分配给各部门。 例1步骤：A. 先划分各子公司的所属网段。 有12家子公司，那么就有2的n次方≥12，n的最小值=4。因此，网络位需要向主机位借4位。那么就可以从172.16.0.0/16这个大网段中划出2的4次方=16个子网。 详细过程： 先将172.16.0.0/16用二进制表示 10101100.00010000.00000000.00000000/16 借4位后（可划分出16个子网）： 1) 10101100. 00010000 . 00000000.00000000/20【172.16.0.0/20】 2) 10101100.00010000.00010000.00000000/20【172.16.16.0/20】 3) 10101100.00010000.00100000.00000000/20【172.16.32.0/20】 4) 10101100.00010000.00110000.00000000/20【172.16.48.0/20】 5) 10101100.00010000.01000000.00000000/20【172.16.64.0/20】 6) 10101100.00010000.01010000.00000000/20【172.16.80.0/20】 7) 10101100.00010000.01100000.00000000/20【172.16.96.0/20】 8) 10101100.00010000.01110000.00000000/20【172.16.112.0/20】 9) 10101100.00010000.10000000.00000000/20【172.16.128.0/20】 10) 10101100.00010000.10010000.00000000/20【172.16.144.0/20】 11) 10101100.00010000.10100000.00000000/20【172.16.160.0/20】 12) 10101100.00010000.10110000.00000000/20【172.16.176.0/20】 13) 10101100.00010000.11000000.00000000/20【172.16.192.0/20】 14) 10101100.00010000.11010000.00000000/20【172.16.208.0/20】 15) 10101100.00010000.11100000.00000000/20【172.16.224.0/20】 16) 10101100.00010000.11110000.00000000/20【172.16.240.0/20】 我们从这16个子网中选择12个即可，就将前12个分给下面的各子公司。每个子公司最多容纳主机数目为2的12次方-2=4094。 B. 再划分子公司各部门的所属网段 以甲公司获得172.16.0.0/20为例，其他子公司的部门网段划分同甲公司。 有4个部门，那么就有2的n次方≥4，n的最小值=2。因此，网络位需要向主机位借2位。那么就可以从172.16.0.0/20这个网段中再划出2的2次方=4个子网，正符合要求。 详细过程： 先将172.16.0.0/20用二进制表示 \10101100. 00010000. 00000000.00000000/20 借2位后（可划分出4个子网）： ① 10101100.00010000.00000000.00000000/22【172.16.0.0/22】 ② 10101100.00010000.00000100.00000000/22【172.16.4.0/22】 ③ 10101100.00010000.00001000.00000000/22【172.16.8.0/22】 ④ 10101100.00010000.00001100.00000000/22【172.16.12.0/22】 将这4个网段分给甲公司的4个部门即可。每个部门最多容纳主机数目为2的10次方-2=1024 例2思路:我们在划分子网时优先考虑最大主机数来划分。在本例中，我们就先使用最大主机数来划分子网。101个可用IP地址，那就要保证至少7位的主机位可用（2的m次方-2≥101，m的最小值=7）。如果保留7位主机位，那就只能划出两个网段，剩下的一个网段就划不出来了。但是我们剩下的一个网段只需要2个IP地址并且2楼的网段只需要54个可用IP，因此，我们可以从第一次划出的两个网段中选择一个网段来继续划分2楼的网段和路由器互联使用的网段。 例2 步骤：根据需求，画出下面这个简单的拓扑。将192.168.5.0/24划成3个网段，1楼一个网段，至少拥有101个可用IP地址；2楼一个网段，至少拥有54个可用IP地址；1楼和2楼的路由器互联用一个网段，需要2个IP地址。 A. 先根据大的主机数需求，划分子网因为要保证1楼网段至少有101个可用IP地址，所以，主机位要保留至少7位。 先将192.168.5.0/24用二进制表示： 11000000.10101000.00000101.00000000/24 主机位保留7位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.00000000/25【192.168.5.0/25】 ② 11000000.10101000.00000101.10000000/25【192.168.5.128/25】 1楼网段从这两个子网段中选择一个即可，我们选择192.168.5.0/25。 2楼网段和路由器互联使用的网段从192.168.5.128/25中再次划分得到。 B. 再划分2楼使用的网段2楼使用的网段从192.168.5.128/25这个子网段中再次划分子网获得。因为2楼至少要有54个可用IP地址，所以，主机位至少要保留6位（2的m次方-2≥54，m的最小值=6）。 先将192.168.5.128/25用二进制表示： 11000000.10101000.00000101.10000000/25 主机位保留6位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.10000000/26【192.168.5.128/26】 ② 11000000.10101000.00000101.11000000/26【192.168.5.192/26】 2楼网段从这两个子网段中选择一个即可，我们选择192.168.5.128/26。 路由器互联使用的网段从192.168.5.192/26中再次划分得到。 C. 最后划分路由器互联使用的网段路由器互联使用的网段从192.168.5.192/26这个子网段中再次划分子网获得。因为只需要2个可用IP地址，所以，主机位只要保留2位即可（2的m次方-2≥2，m的最小值=2）。 先将192.168.5.192/26用二进制表示： 11000000.10101000.00000101.11000000/26 主机位保留2位，即在现有基础上网络位向主机位借4位（可划分出16个子网）： ① 11000000.10101000.00000101.11000000/30【192.168.5.192/30】 ② 11000000.10101000.00000101.11000100/30【192.168.5.196/30】 ③ 11000000.10101000.00000101.11001000/30【192.168.5.200/30】 ………………………………… ④ 11000000.10101000.00000101.11110100/30【192.168.5.244/30】 ⑤ 11000000.10101000.00000101.11111000/30【192.168.5.248/30】 ⑥ 11000000.10101000.00000101.11111100/30【192.168.5.252/30】 路由器互联网段我们从这16个子网中选择一个即可，我们就选择192.168.5.252/30。 D. 整理本例的规划地址1楼：网络地址：【192.168.5.0/25】 最小地址为11000000 10101000 00000101 00000000 即 192.168.5.0 最大地址为11000000 10101000 00000101 01111111 即 192.168.5.127 主机位全0全1的不能作为主机IP，因为主机位全1 的要用来作 广播地址即192.168.5.127 剩下的可以分配作为主机的IP 主机IP地址：【192.168.5.1/25—192.168.5.126/25】 广播地址：【192.168.5.127/25】 2楼：网络地址：【192.168.5.128/26】 主机IP地址：【192.168.5.129/26—192.168.5.190/26】 广播地址：【192.168.5.191/26】 路由器互联： 网络地址：【192.168.5.252/30】 两个IP地址：【192.168.5.253/30、192.168.5.254/30】 广播地址：【192.168.5.255/30】 快速划分子网确定IP: 以例2为例：题目需要我们将192.168.5.0/24这个网络地址划分成能容纳101/54/2个主机的子网。因此我们要先确定主机位，然后根据主机位决定网络位，最后确定详细的IP地址。 ① 确定主机位 将所需要的主机数自大而小的排列出来：101/54/2，然后根据网络拥有的IP数目确定每个子网的主机位：如果2的n次方-2≥该网段的IP数目，那么主机位就等于n。于是，得到：7/6/2。 ② 根据主机位决定网络位 用32减去主机位剩下的数值就是网络位，得到：25/26/30。 ③ 确定详细的IP地址 在二进制中用网络位数值掩盖IP前面相应的位数，然后后面的为IP位。选取每个子网的第一个IP为网络地址，最后一个为广播地址，之间的为有效IP。得到： 【网络地址】 【有效IP】 【广播地址】 【192.168.5.0/25】【192.168.5.1/25-192.168.5.126/25】【192.168.5.127/25】 【192.168.5.128/26】【192.168.5.129/26-192.168.5.190/26】【192.168.5.191/26】 【192.168.5.192/30】【192.168.5.193/30-192.168.5.194/30】【192.168.5.195/30】 例3: 分析首先就是要理解/26的意思。首先一看就是个C类地址，所以其默认子网掩码是255.255.255.0。这个子网掩码是由3个.来分隔的，而且这是10进制表示出来的，把它化为2进制=11111111.11111111.11111111.00000000前面是24个1。所以默认的C类子网掩码被写成/24。 这道题是/26，也就是有26个1，写出来就是11111111.11111111.11111111.11000000。把它划成10进制就是255.255.255.192, 现在知道了子网掩码就可以回答那5个问题了 1.有多少个子网？ 这有个公式的。子网数目=2的X次方，这里的X是指掩码位数，掩码为数可以用我们现在的子网掩码的1的为数减去默认的1的位数。这道题有子网掩码有26个1，而C类默认有24个1，所以就是26-24=2。子网数=2的2次方=4 2.每个子网的主机数？ 这还是由公式的。子网主机数=2的Y次方-2，这里的Y是非掩码位的位数，即子网掩码中0的个数，刚才已经知道有26个1了，那剩下的就都是0了，一共有32位，现在有26个1剩下的就只有6个0。所以子网主机数=2的6次方-2=62 3.哪些是合法子网？ 这里牵扯了块这个概念，块=256 - 子网掩码。这里就是 - 192 ，所以这道题块=64 ，知道了块就把块从0开始加，一直加到256，这之间的数就是合法子网。0+64=64 64+64=128 128+62=192 192+64=256 所以合法子网就是0 64 128 192 4.每个子网的广播地址是多少？ 广播地址=下一个子网号-1 所以0子网的广播地址是63；64子网的广播地址是127；128子网的广播地址是191；192子网的广播地址是255 5.哪些是合法主机号？ 合法主机号是那些介于个子网之间的取值，并要减去全0和全1的主机号，例如：64是子网号码，127是广播地址，那么65–126就是合法地址。 所以0子网的合法地址是1–62；64子网的合法地址是65–126；128子网的合法地址是129==190；192子网的合法地址是193–254 总结:子网划分无非涉及到这些内容: 1.有多少子网 2.每个子网有多少主机 3.有多少合法子网 4.每个子网的广播地址是多少: 广播地址下一个子网号-1 5.哪些是合法主机号]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>子网划分实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识计算机网络]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[前言: 计算机网络可以说是连通世界的桥梁，推动发展的催化剂，正是计算机网络技术让信息传播速度更快，让我们能随时随地在线看视频、听音乐、查资料、看新闻、分享资源,试想一下如果没有计算机网络这门学科，我们的世界还会有今天这么繁荣吗？ 一、计算机网络是什么？ 计算机网络技术是通信技术与计算机技术相结合的产物。计算机网络是按照网络协议，将地球上分散的、独立的计算机相互连接的集合。连接介质可以是电缆、双绞线、光纤、微波、载波或通信卫星。计算机网络具有共享硬件、软件和数据资源的功能，具有对共享数据资源集中处理及管理和维护的能力． 二、发展历史：其发展经历了四个阶段: ①:20世纪50~60年代，出现以单个计算机为中心的远程连机系统，构成面向终端的计算机网络； ②:20世纪60~70年代，出现了多个主计算机通过通信线路互连的计算机网络。ARPANET投入使用； ③:20世纪70~80年代，出现具有统一的网络体系结构，遵循国际标准化协议的计算机网络。 ④:从90年代算起，网络互联与高速网络。 我国在1980年开始进行计算机联网实验，1989年，我国第一个分组交换网CNPAC建成运行. 三、特点：①: 连通性 ②: 共享 四、分类：4.1 按作用范围分类:①: WAN（Wide Area Network）广域网：几十到几千KM ②: MAN（Metropolitan Area Network）城域网：一个城市（5~50KM） ③: LAN（Local Area Network）局域网：1KM左右 ④: PAN（Personal Area Network）个人区域网：10m左右 4.2 按传输介质分类:①: 有线网：是采用同轴电缆或双绞线连接的计算机网络。同轴电缆网是常见的一种连网方式，它比较经济，安装较为便利，传输率和抗干扰能力一般，传输距离较短。双绞线网是目前最常见的连网方式。它价格便宜，安装方便，但易受干扰，传输率较低，传输距离比同轴电缆要短。 ②: 光纤网：也是有线网的一种，但由于其特殊性而单独列出。光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。但其成本较高，且需要高水平的安装技术。 ③: 无线网：用电磁波作为载体来传输数据，目前无线网联网费用较高，还不太普及。但由于联网方式灵活方便，是一种很有前途的连网方式。 局域网通常采用单一的传输介质，而城域网和广域网采用多种传输介质。 4.3 按通信方式分类:①: 点对点传输网络：数据以点到点的方式在计算机或通信设备中传输。星型网、环形网采用这种传输方式。 ②: 广播式传输网络：数据在公用介质中传输。无线网和总线型网络属于这种类型。 五、应用:①: 通信服务: 如在线聊天（飞信,MSN、QQ等）、E-mail 、IP 电话等服务 ②: 多媒体信息服务: 包括网上娱乐、网络电视、电视会议、WWW服务、远程教育和音乐点播等。 ④: 办公自动化: 将一个单位的其它办公设备与办公用计算机连接成网络, 加强了外部和单位内部的沟通与联系，加快单位内部的信息流动，提高工作效率，并有利于减少日常开支。 ⑤: 网上交易: 在线购物,转账等 六、什么是ISP:ISP(互联网服务提供商) 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。如中国移动,中国联通,中国电信就是ISP 七、主机之间的通信方式:7.1 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 7.2 对等（P2P）： ①：不区分客户和服务器。这里使用数字2，是因为英文的2是two，读音与to相同，所以to缩写为2②：任意端系统/节点之间可以直接通讯③：节点可能改变IP地址节点间歇性接入网络没有永远在线的服务器 八、电路交换与分组交换,报文交换:8.1 电路交换:①: 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 ②: 复用：时分多路复用：频分多路复用：在不同的频带（载波）上传输不同频道码分多路复用：广泛应用于无线链路共享（如蜂窝网，卫星通信等）每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示各用户使用相同频率载波，利用各自的码片序列编码数据各用户码片序列相互正交码片序列与编码信号的内积 8.2 分组交换:每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。报文分拆出来的一系列相对较小的数据包需要报文的拆分与重组会产生额外开销又称统计多路复用(按需共享链路) 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 8.3 报文交换:报文：源发送信息整体，比如一个文件 九、时延:总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 9.1 排队时延:分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 9.2 处理时延:主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 9.3 传输时延: 主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 9.4 传播时延:其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。 十、计算机网络体系结构 10.1 OSI模型:其中表示层和会话层用途如下：表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。会话层 ：建立及管理会话 10.2 五层协议模型:应用层 ： 为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ： 为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ： 负责源主机到目的主机数据分组（Packet）交付,可能穿越多个网络 功能: 分组转发,路由 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ： 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ： 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 10.3 TCP/IP模型: 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 十一、数据在各层之间的传递过程:在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、初始化配置:1.1 指定客户端用户名和邮箱，为了标记是谁向远程库传送数据 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 1.2查看用户名：$ git config user.name 1.3查看邮箱： $ git config user.email 1.4修改用户名：$ git config --global user.name &quot;cyx&quot; 1.5修改邮箱： $ git config --global user.email &quot;328978553@qq.com&quot; 1.6查看配置是否生效： $ git config --list 二、目录文件相关:2.1创建目录： $ mkdir /d/softwear/Program （“mkdir” 是“make Directory”; “/d/softwear/”是要创建目录的位置 “Program” 是新创建的目录） 2.2定位到Program指定目录： $ cd /d/软件/Program 2.3输出当前目录地址： $ pwd 2.4让之前创建的目录作为git可操作的仓库，此时再去刚才创建的program目录下会发现多了一个.git目录： $ git init 2.5查看当前仓库的隐藏目录，以及文件： $ ls –ah 2.6查看当前仓库的文件： $ ls 三、本地仓库关联远程库:3.1关联Github远程库：$ git remote add origin git@server-name(服务器名即github用户名)/repo-name.git(远程仓库名.git) 如：$ git remote add origin git@zzwwqq/blog.git； 3.2关联码云远程库：$ git remote add origin git@gitee.com:zwqzeq/Login_Register.git 四、操作远程仓库:4.1显示远程库的详细信息： $git remote -v 4.2本地master分支内容推送到远程库的master分支： 第一次$ git push -u origin master 以后 直接$ git push origin master 4.3删除远程库： $ git remote rm origin (origin远程库默认名称，建议不改) 4.4从远程库克隆： $ git clone git@github.com:zwqzeq/gitskills.git 4.5将本地仓库指定分支合并到远程仓库指定分支： $ git push origin dev_branch : dev_branch 4.6强行让本地分支覆盖远程分支： $ git push 远程库名 远程库的分支名 -f 4.7将远程仓库的某个分支合并到当前本地分支： $ git pull 远程仓库名 远程仓库的分支名 五、文件保存和提交:5.1将文件从工作区添加到暂存区： $ git add &lt;file&gt; 将所有文件从工作区添加到暂存区：$ git add . 5.2将文件从暂存区提交到版本库： $ git commit -m “提交说明” 5.3随时查看当前仓库的状态： $ git status 5.4查看修改了具体修改了那些内容： $ git diff &lt;file&gt; 六、日志相关：6.1查看提交历史（只有commit过的才能查到），以便确定要回退到哪个版本： $ git log 6.2如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline 6.3如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline --abbrev-commit 6.4查看命令历史（包括reset，commit，checkout），以便确定要回到未来的哪个版本（不包括从工作区添加（add）到暂存区的命令）： $ git reflog 七、版本回退:7.1退回到上一个版本： $ git reset --hard HEAD^ //针对版本库 7.2退回到上上个版本： $ git reset --hard HEAD^^ 7.3退回到上100个版本： $ git reset --hard HEAD~100 7.4退回到指定版本： $ git reset --hard commit_ID 7.5只丢弃暂存区修改： $ git reset HEAD &lt;file&gt; //针对暂存区，让暂存区恢复之前的状态 7.6只丢弃工作区的修改： $ git checkout --&lt;file&gt; //针对工作区，让工作区恢复之前的状态，即让工作区和暂存区一致，如果没有暂存区，则让工作区和版本库一致，如果该文件既没有添加到暂存区也没有提交到版本库，则工作区中该文件的修改不能被丢弃 八、分支相关:8.1查看分支： $ git branch 8.2创建分支： $ git branch &lt;name&gt; 8.3切换分支： $ git checkout &lt;name&gt;（注意与恢复文件的区别，此处checkout后面没有“–”） 8.4创建+切换分支： $ git checkout -b &lt;name&gt; 8.5合并某分支到当前分支： $ git merge &lt;name&gt; 8.6删除分支： $ git branch -d &lt;name&gt; 8.7重命名分支： $ git branch -m old_branch new_branch 8.8看到分支合并情况： $ git log --graph --pretty=oneline --abbrev-commit 8.9可以禁用快速合并dev方式： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev 8.10删除一般的分支： $ git branch -d &lt;name&gt; 8.11丢弃一个没有被合并过的分支，可以通过： $ git branch -D &lt;name&gt; //强行删除 九、标签相关：9.1默认标签是打在当前分支最新提交的commit上: $ git tag &lt;name&gt; 9.2指定一个commit id，给其打上标签，即以后标签可代表commit id: $ git tag &lt;name&gt; commit_id 9.3查看所有标签名： $ git tag 9.4查看标签信息： $ git show &lt;tagname&gt; 9.5指定标签信息： $ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; commit_ID 9.6删除本地标签： $ git tag -d v0.1 9.7推送某个标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin &lt;tagname&gt; 9.8推送所有标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin --tags 9.9删除远程标签：如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除： $ git tag -d v0.9 $ git push origin :refs/tags/v0.9 十、临时保存工作现场：10.1前工作现场“储藏（或称隐藏）”起来，等以后恢复现场后继续工作： $ git stash 10.2查看某个分支上隐藏工作区： $ git stash list 10.3恢复工作现场：两种方式： 方式一：用$ git stash apply恢复,但是恢复后,stash内容并不删除,你需要用$ git stash drop来删除； 方式二：用$ git stash pop,恢复的同时把stash内容也删了 10.4 何时需要使用git stash临时保存工作现场? 在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。 可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。 该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Git]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Git.html</url>
    <content type="text"><![CDATA[前言: 你是否有这样的经历：写word文档时,想删除一部分内容，又怕将来想恢复找不回来怎么办？常见办法就是先把当前文件“另存为”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件.改到最后你自己都分不清,哪个文件里面是修改了什么. 如果有，那么恭喜你，以后不会再有这种事情发生了，git能帮你管理文件. 一、git是什么?Git是目前世界上最先进的分布式版本控制系统（没有之一）. 二、git的历史背景: 很多人都知道，Linus（李纳斯）在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。直到2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 三、分布式的git和集中式的CVS/SVN对比: 3.1 联网： 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式版本控制系统最大的毛病就是必须联网才能工作． 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。 3.2 安全性： 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 四、如何安装？在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，(或者鼠标右键,可以找到git Bash)蹦出一个类似命令行窗口的东西，就说明Git安装成功. 五、工作流:新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。 Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 中存有所有分支，使用一个 HEAD 指针指向当前分支。 git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset – files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。 git commit -a 直接把所有文件的修改添加到暂存区然后执行提交 git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作 六、冲突:当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。 Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 七、Fast forward:“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。 可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。 1$ git merge --no-ff -m "merge with no-ff" dev 八、分支管理策略:master 分支应该是非常稳定的，只用来发布新版本； 日常开发在开发分支 dev 上进行。 九、.gitignore 文件:忽略以下文件： 操作系统自动生成的文件，比如缩略图； 编译生成的中间文件，比如 Java 编译产生的 .class 文件； 自己的敏感信息，比如存放口令的配置文件。 不需要全部自己编写，可以到 https://github.com/github/gitignore 中进行查询。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>初识Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[前言:​ 为了方便查阅,这里将常用指令汇总. 简写指令:hexo n &quot;我的博客&quot; 等价于 hexo new &quot;我的博客&quot; 还等价于 hexo new post &quot;我的博客&quot; #新建一篇文章hexo p 等价于 hexo publishhexo g 等价于 hexo generatehexo s等价于 hexo serverhexo d 等价于 hexo deployhexo deploy -g 等价于 hexo deploy --generatehexo generate -d等价于hexo generate --deploy 注: hexo clean 没有 简写, git –version 没有简写 指令说明:hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。hexo server -s #以静态模式启动hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)hexo d #将本地数据部署到远端服务器(如github)hexo init 文件夹名称 #初始化XX文件夹名称npm update hexo -g#升级npm install hexo -g#安装node-v #查看node.js版本号npm -v #查看npm版本号git --version #查看git版本号hexo -v #查看hexo版本号 hexo publish [layout] &lt;title&gt; #通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 hexo new aaa &quot;bbb&quot; # 新建一篇文章,文章名称和标题分别为bbb.md 和 bbb. 文章采用aaa布局, 此时会在站点根目录下的—-&gt;source—–&gt;_post文件夹下生成bbb.md文件, bbb.md文件的顶部(—–分割线上方区域,也称作Front matter区),生成 layout: aaatitle:date:]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化配置]]></title>
    <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[前言: 如果你觉得我的博客界面不错，你可以参考这篇文章，在这篇文章中总结了几十个个性化配置，并不是都要安装，取你所需即可． 一、常用的个性化配置汇总： １．更换主题 ２．设置语言 ３．字数统计和阅读时长(网站底部/文章内) ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量） ５．本站已安全运行 XX天 XX小时XX分XX秒 ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例 ７．添加热度（文章阅读次数） ８．为博客加上宠物 ９．鼠标点击出现桃心效果 １０．网页底部的动态桃心图像 １１．添加顶部加载条 １２．设置网站的图标Favicon １３．DaoVoice 在线联系 １４．添加AddThis分享 １５．添加打赏 １６．文章加密访问 １７．在文章底部增加版权信息 １８．修改文章底部的那个带#号的标签 １９．在每篇文章末尾添加“本文结束”标记 ２０．修改作者头像并旋转 ２１．隐藏网页底部powered By Hexo / 强力驱动 ２２．在右上角或者左上角实现fork me on github ２３．修改代码块自定义样式（设置代码高亮主题） ２４．开启代码块复制 ２５．侧边栏社交链接 ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２７．修改背景图,以及侧边栏顶部颜色 ２８．侧边栏添加网易云音乐 ２９．底部添加公网安备 ３０．取消“文章目录”的自动编号 ３１．封面模式 １．更换主题: (以next主题为例)注: next 主题的 github仓库地址迁移了 １．１ 下载主题:旧版本next主题地址: 5以下的版本包含5: 旧版本5以下 安装指令: 首先打开git bash进入根目录即 “ /blog/“ 执行命令:git clone https://github.com/iissnan/hexo-theme-next themes/next 此时会从next主题的作者的github仓库克隆next主题到 我们本地的 /blog/theme/next文件夹下 最新版在这里下载: 新版本6开始 安装指令: 同上 git clone https://github.com/theme-next/hexo-theme-next themes/next 安装完成后，打开 站点配置文件,找到 theme 字段，并将其值更改为 next, 一定要保存 依次执行git clean，git g,git s 然后查看运行结果: nexT主题有四种选择，上面这个只是最简洁的一种，我选择的是Gemini布局。 １．２ 修改主题配置文件： 然后重新git clean，git g，git s查看效果: ２．设置语言：在站点配置文件中设置语言: 12language: zh-Hans next5以下版本(包含)language: zh-CN next6以上版本(包含) ３．字数统计和阅读时长(网站底部/文章内):３．１ 首先安装插件: $ npm install hexo-symbols-count-time --save ３．２ 然后修改主题配置文件如下: 123456symbols_count_time: separated_meta: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_post: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true ＃底部footer是否显示字数统计属性文字(如站点总字数,站点阅读时长 ≈ 1 分钟) awl: 4 ＃计算字数的一个设置,没设置过 wpm: 275 ＃一分钟阅读的字数 ３．３ 站点配置文件中添加： 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 注意: 配置文件中的空格** ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量）打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站总访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;| &lt;/span&gt;&lt;span id="busuanzi_container_site_pv"&gt; &amp;nbsp;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; ５．本站已安全运行 XX天 XX小时XX分XX秒打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910111213141516&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250);&lt;/script&gt; ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例:先注册leancloud账号,获取自己的appid,appkey 打开主题配置文件,修改如下: 1234567891011valine: enable: true # 为true时启用评论 appid: # 这里填写上面得到的APP ID 注意空一格再输入ID和key, appkey: # 这里填写上面得到的APP KEY notify: false # 邮件通知 verify: false # 验证码 placeholder: #评论框中预设的文字,随意填写 avatar: mm # gravatar style 头像,采用gravatar头像,到http://cn.gravatar.com/了解 guest_info: nick,mail,link # custom comment header 访客信息,显示在评论框上面,三者可随意选择或全选 pageSize: 10 # pagination size 评论分页大小 visitor: false # ７．添加热度（文章阅读次数）修改主题配置文件 1234leancloud_visitors: enable: true app_id: #填入你leancloud账号的appid app_key: #填入你leancloud账号的appkey 打开/blog/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/blog/themes/next/languages/zh-Hans.yml,将画红框的改为热度就OK了 ８．为博客加上宠物８．１ 在hexo根目录下安装插件: $ npm install -save hexo-helper-live2d ８．２ 安装需要的宠物插件:宠物样式 源码地址 $ npm install {packagename} 其中{packagename} 替换为你要安装的宠物名,如live2d-widget-model-shizuku 具体指令: $ npm install live2d-widget-model-shizuku ８．３ 在站点配置文件中加上如下代码: 1234567891011live2d: enable: true #开启宠物 scriptFrom: local model: use: live2d-widget-model-shizuku display: position: right #指定宠物显示的位置 width: 70 #指定宠物显示的宽度 height: 120 #指定宠物显示的高度 mobile: show: true #是否在手机上显示 ９．鼠标点击出现桃心效果并且将代码复制进去，然后保存 在/themes/next/source/js/src里面 新建click-love.js文件: 粘贴如下代码: 12&lt;!-- 页面点击小桃心--&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 然后打开\themes\next\layout\_layout.swig文件,在末尾添加以下代码： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); １０．网页底部的动态桃心图像修改主题配置文件: 1234icon: name: heart #如果name的值为heart表示引用fontawesome网站上的心形图标 animated: true #如果想用动态图标应该将animated的值设为true color: "#ff0000" #图标的色--用16进制数 １１．添加顶部加载条在根目录打开git bash执行以下指令: 1git clone https://github.com/theme-next/theme-next-pace source /lib/pace 修改主题配置文件: 12pace: true #启用顶部加载条pace_theme: pace-theme-flash #指定顶部加载条样式 １２．设置网站的图标Favicon１２．１ 下载一个32*32的图片，并改名为favicon.ico, 然后放到/blog/themes/next/source/images目录 １２．２ 修改主题配置文件 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg １３． DaoVoice 在线联系１３．１ 注册地址: ,获取app_id １３．２ /blog/themes/next/layout/_partials/head/head.swig 添加下面的代码: 123456789101112131415&#123;% if theme.custom_file_path.head %&#125; &#123;% set custom_head = '../../../../../' + theme.custom_file_path.head %&#125;&#123;% else %&#125; &#123;% set custom_head = '../../_custom/head.swig' %&#125;&#123;% endif %&#125;&#123;% include custom_head %&#125;&#123;% if theme.daovoice %&#125; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0eeeae6f.js","daovoice") daovoice('init', &#123; app_id: "06289ecd"&#125;);daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; １３．３ 修改主题的配置文件 12daovoice: truedaovoice_app_id: 我们注册获取的id １４．添加AddThis分享１４．１ 在网站 AddThis 上注册账号。 可以使用 Google/Facebook/Twitter 账号进行第三方登陆 １４．２ 设置分享按钮的样式:(显示位置, 显示样式为扩展式,悬浮式等) １４．３ 修改主题配置文件 你Addthis账号ID ```123456789## １５．添加打赏:```javascript reward: enable: true ＃开启 comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ ＃图片上方显示的文本 wechatpay: ＃图片地址 alipay: ＃图片地址 １６．文章加密访问１６．１ 在 /blog/themes/next/layout/_partials/head/head.swig 文件中添加： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; １６．２ 在需要加密的文章的页面顶部(Front matter区域)加入 “password : 设置密码值” １７．在文章底部增加版权信息１７．１ 在/blog/themes/next/layout/_macro/ 下添加 my-copyright.swig文件： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;版权声明:&lt;/span&gt;本博客所有文章除特别声明外，均采用 &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt;BY-NC-SA &lt;/a&gt;许可协议。转载请注明出处!&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; １７．２ 在目录/blog/themes/next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; １７．３ 修改/blog/themes/next/layout/_macro/post.swig，在下面位置添加: 代码如下: 12345 &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １７．４ 修改/blog/themes/next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： @import &quot;my-post-copyright 保存重新生成即可。１７．５ 如果要在文章下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: hexo个性化配置date: 2017-05-22 22:53:53tags: hexo美化categories: Hexocopyright: true--- 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： １８．修改文章底部的那个带#号的标签修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; １９．在每篇文章末尾添加“本文结束”标记１９．１ 在路径 /blog/themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; １９．２ 接着打开/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer之前添加,即在如下位置添加 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １９．３ 然后打开主题配置文件（_config.yml),在末尾添加： 123#文章末尾添加“本文结束”标记passage_end_tag: enabled: true ２０．修改侧边栏作者头像并旋转：２０．１ 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; ２１．隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： ２2．在右上角或者左上角实现fork me on github点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 /blog/themes/next/layout/_layout.swig文件中进行配置. next表示的是当前你使用的主题的样式. 注意的是: href 后面是自己的github的地址,记得修改哦! ２３．修改代码块自定义样式修改主题配置文件 highlight_theme: night bright #可选值: normal | night | night eighties | night blue | night bright ２４．开启代码块复制123codeblock: enable: true show_result: true ２５．侧边栏社交链接修改主题配置文件: 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址 123456789101112131415161718#设置侧边栏社交链social: GitHub: https://github.com/zzwwqq || github E-Mail: mailto:zwq13264860490@gmail.com || envelope Weibo: https://weibo.com/u/5564810309/home?wvr=5 || weibo 知乎: https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities || snapchat#这里键的值必须和上面social中的 "||" 后面指定的名称一致，在fontawesome官网找喜欢的小图标，将名字复制在如下位置，如E-Mail:对应的图标名称为envelope。social_icons: enable: true # `enable` 选项用于控制是否显示图标 icons_only: false transition: false #图标 GitHub: github E-Mail: envelope Weibo: weibo 知乎: snapchat ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２６．１ 七牛是什么? 七牛 是一个云存储服务商，注册并实名认证之后1后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。七牛的定位不是像百度云一样的 网盘 ，也不是同坚果云一般的 同步云 ，而是 CDN 2 ，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源。对于个人博主来说，你可以把博客中的图片、音频、视频等媒体上传到七牛，在博客中引用；也可以将站点需要加载的CSS、JS等文件上传到七牛，以加速网站。 ２６．２ 与其他上传站点相比： 更稳定：七牛毕竟是老牌服务商，数据的安全性和稳定性都较有保证。如果上传到什么小网站，哪天发现图片都打不开了才是人间惨剧~ 更灵活：配合 hexo-qiniu-sync 插件4，就算是七牛以后更改了空间域名，也不用一篇一篇地去改外链地址，只要在配置文件中修改外链前缀即可。 更方便：配合 hexo-qiniu-sync 插件，不必”上传→复制链接→引用外链“，直接按照本地路径引用，然后键入一条命令同步到七牛就好。会自动识别哪些是新增、修改的文件需要上传，哪些是原有的文件不需改动，十分方便。 ２６．３ 七牛并非尽善尽美： 在线文件管理不支持目录 本地删除文件，云端不能同步删除文件 ２６．４ 开始安装： １．点击 这里 申请七牛账户 ２．创建存储空间（七牛叫作”Bucket“），注意添加的空间为”对象存储“，访问控制选择”公开空间“： ３．点击页面右上角头像→进入”密钥管理“→复制当前使用中的AK和SK，待会设置插件时会用到。 ４．安装插件：在hexo主目录下运行以下命令： npm install hexo-qiniu-sync --save ５．站点配置文件中添加下面内容: 1234567891011121314151617181920qiniu: offline: false #是否离线. 离线状态将使用本地地址渲染 sync: true #是否同步 bucket: blog #这里替换为你存储空间的名称 #secret_file: sec/qn.json or C: access_key: 2rRw0dG-jQYCoqs9rvsltVQqzSBVpwS #上传密钥AccessKey,替换为你自己的 secret_key: OCBcCU3tqKiBdOza9PlLoR6AcA-fV_u #上传密钥SecretKey,替换为你自己的 dirPrefix: static #上传的资源子目录前缀.如设置为static，那么urlPrefix后面也要加static urlPrefix: http://cdn.zzwwqq.xyz/static/ #这里替换为你自己的外链域名,如何获取,查看下面图示 up_host: http://upload.qiniu.com #这里不用改 local_dir: static #本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的static 文件夹（也就是与 source 目录平级）中。 update_exist: true #是否更新已经上传过的文件 #运行程序后,会自动在本地根目录生成static目录,static目录下生成三个文件夹,js,css,images image: folder: images extend: js: folder: js css: folder: css ６．如何引用七牛上的图片? 引用地址：urlPrefix＋dirPrefix＋images+ 相对于/blog/static/images/ 的文件路径 例如: http://cdn.zzwwqq.xyz/static/images/hexo/hexo-1.jpg ２７．修改背景图,以及侧边栏顶部颜色，主／副标题颜色效果图： 123456789101112131415161718192021//添加背景图片body &#123; background:url(http://cdn.zzwwqq.xyz/%E6%98%9F%E7%A9%BA.jpg)&#125;//改掉题头颜色.site-meta &#123;background:url(http://cdn.zzwwqq.xyz/static/images/hexo/hexo-0-site-meta.jpg) &#125;//主标题颜色.brand&#123; color: #4dfc23 &#125;//副标题颜色.site-subtitle&#123; color: #4dfc23&#125;.footer&#123; font-size: 14px; color: #ededed;&#125; ２８．侧边栏添加网易云音乐效果图: 打开网易云音乐官网，进入想插入的音乐的界面 点击“生成外链播放器” 复制代码 ##２９．底部添加公网安备 12345 &lt;div class="BbeiAn-info" style="color:#4dfc23"&gt; &#123;&#123; __('鄂ICP备') &#125;&#125; - &lt;a target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#4dfc23;" rel="nofollow"&gt;18025394&lt;/a&gt; &lt;!--a标签中增加nofollow属性，避免爬虫出站。--&gt;| &lt;a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42090202000295" style="text-decoration:none;color:#4dfc23;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow"&gt;&#123;&#123; __('鄂公网安备 42090202000295') &#125;&#125;&lt;/a&gt; &lt;!--这里将图标作为了背景，以使得能和后面的文字在同一行--&gt;&lt;/div&gt; ３０．取消“文章目录”的自动编号 修改如下 修改后: ３１．封面模式需要安装一个小插件是：hexo-less，安装指令: $ npm install --save hexo-less 该插件解决了什么问题呢？ 手动设置文章概要，但不影响章内䆟。只需在文章中写 &lt;!-- less --&gt; 作为分割线， &lt;!-- less --&gt; 上面的内容会作为摘要，但不作为文章内容的一部分。 举例，我想让这篇文章在主页列表中，只显示一张美图。 效果图： 文章中代码如下: 二、说明:修改hexo的站点配置文件,需要重启服务器(即执行 $ hexo s命令),才能生效. 修改其他文件如主题配置文件,不必重启服务器(即执行 $ hexo s命令), 直接刷新页面即可生效. 参考链接: http://theme-next.iissnan.com/getting-started.html https://www.jianshu.com/p/f054333ac9e6 https://www.jianshu.com/p/d0fe52c73950 https://xian6ge.cn/posts/40ba2cba/ https://me.idealli.com/post/e8d13fc.html http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/ https://www.jianshu.com/p/805bd0b65d98]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo发布文章]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[前言: 经过前面两节的操作，hexo的整个框架以及和github关联已经配置好了,现在我们要考虑的就是 如何用指令去创建一篇文章,然后发布? .我们先来看一下hexo的目录结构,了解每个目录的作用,这将让我们对hexo的运行原理有一个大概的认识,对于我们后面美化主题是有帮助的, 然后再来创建文章,并发布到本地服务器,最后查看效果. 一、Hexo的目录分析: １．.deploy_git: 这个目录是执行 hexo d 命令 后生成的,主要存放部署的信息. ２．node_modules: 这个目录存放的是一些插件包 ３．public : 这个目录是执行 hexo g后生成的, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下 ４．scaffolds: 用来存放模板文件。模板文件的正文部分一般为空，一般在模板文件顶部有一个区域 ( 以 --- 分隔的区域) 称作Front-matter,在这里配置的变量主要有title(即文章标题), date(即文章创建日期),comment(是否开启评论), tags(文章标签), categories(文章所属分类)等. 当你新建文章时，Hexo 会根据 scaffold 来建立文件，也就是说会在你创建的每个文件顶部自动加上模板文件中配置的这些内容. ５．source: 存放你的文章(.md后缀的文件) ６．static: 这个目录是我自己创建的，专门用来存放图片的 ７．themes: 这个目录是存放主题的(默认主题是landscape, 目前使用最多的是next主题) ８．.gitignore: 这个文件和git有关, 在这个文件里面可以配置哪些文件不被提交(例如: 配置 *.log ,那么在hexo d命令的时候, 任何以.log为后缀的文件将不会被提交到github) ９．_admin-config.yml: 这个文件是安装了hexo 后台管理插件后生成的,这里暂时不作介绍,后面再说 １０．_config.yml: 这个文件是hexo的核心配置文件(也称站点配置文件) １１．_config.yml.back.yml: 这个文件是我自己创建的,是站点配置文件的备份. 以防哪一天老眼昏花把内容改错了,到时可以恢复. １２．package.json: 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 １３．db.json： １４．package-lock.json: 二、使用Hexo指令创建一篇文章:​ $ hexo new [layout] &lt;title&gt; 这里有必要对指令作一些说明: 就[layout]即＂布局＂ 而言:Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局: 路径: 说明: post source/_posts 如果你输入的指令中[layout]参数空着,那么默认是post;例如:hexo new 我的第一篇文章;等价于:hexo new post 我的第一篇文章; 产生的作用就是: 在source/_posts路径下生成 “我的第一篇文章.md” 文件,这个就是你要写文章的那个文件. page source draft source/_drafts 你可以通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 就&lt;title&gt;而言:默认是指定文章的标题和.md文件名称, 你可以任意指定一个名称来取代指令中的&lt;title&gt;参数. 注: 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 三、举例: 需求: 我要创建一篇文章,文件名为 “使用hexo发布文章” 文章标题为”使用hexo发布文章” 并且自动在文件顶部(Front-Matter区域),添加文章分类,标签 的键, 键对应的值由我们自己添加.最后发布到本地服务器查看效果. 首先修改模板文件: 打开git bash 执行指令: 查看生成文件所在目录以及文件名: 查看生成的文章, 文章标题,分类,标签等是否自动添加了: 给文章添加分类,和标签: 发布文章到本地服务器: $ hexo clean $ hexo g $ hexo s 查看效果: 四、说明: 通过上面的操作后，你可能会感到奇怪，为什么自己的界面和图示的不一样呢？这里我得解释下，在第一节安装hexo时,hexo默认给我们安装了ｌａｎｄｓｃａｐｅ主题. 这个主题可以在 “/blog/themes” 路径下找到. 而我安装的是next主题,并做了些个性化配置. 所以和你的界面不同. 如果你和我一样对默认主题不满意,喜爱折腾,追求完美,那么请关注下一节内容.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>使用hexo发布文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署到GitHub]]></title>
    <url>%2Fhexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub.html</url>
    <content type="text"><![CDATA[前言: 上一节我们已经将hexo部署到本地了，但是只有在你自己主机上才能查看博客，如果你想让任何人随时随地都能访问到你的博客，那么你可以考虑将hexo部署到github(属于国外,所以访问速度要慢一些)或者codying(国内),如果你是一个程序员,那么推荐你选择github, 你要是不知道GitHub， 那就太说不过去了， 我可能遇到了一个假的程序员！ 步骤: １．注册一个github账号: 注册 ２．回到你的本地机,打开git bash,设置用户名和邮箱:(目的是:上传文件的时候告诉github,是谁向远程仓库上传数据) $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 注: 这里”Your Name” 替换为你的GitHub的用户名,”email@example.com“替换为你的GitHub的邮箱 输入完后,通过以下命令检查你的设置是否正确: (如果你比较懒,那就忽略吧!) $ git config user.name $ git config user.email ３．生成ＳＳＨ密钥并添加到github： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 此时它会告诉你已经生成了.ssh的文件夹, 在你的电脑中找到它,复制id_rsa.pub 文件中的内容. 此时回到GitHub页面 ​ 然后回到gitbash中，输入指令查看是否添加成功: $ ssh -T git@github.com ；如果你看到以下内容，恭喜你配置成功了． ４．创建github仓库: ​ ​ 选择一个主题: (临时测试用,等会会覆盖的) 浏览器地址栏输入用户名.github.io：如果出现下面的界面说明你的域名已经生效 ５．将Hexo部署到github: 经过上面的操作后,此时我们就可以将hexo和GitHub关联起来了,也就是将hexo生成的文章部署到github 打开站点配置文件(/blog/_config.yml), 翻到最后,找到deploy: 修改为:​ 123deploy: type: git repo: github: git@github.com:zzwwqq/zzwwqq.github.io.git,master 说明: master 表示 部署到远程仓库的master分支上 git@github.com:zzwwqq/zzwwqq.github.io.git 改为你的仓库地址, 你可以去github网页上拷贝 安装deploy-git, 也就是部署的命令,这样你才能用命令部署到GitHub. $ npm install hexo-deployer-git --save 然后执行下述命令: hexo clean hexo g hexo d 执行了hexo d后 ,如果最后一行显示如下内容,说明部署成功, 现在你可以去浏览器地址栏输入 你的域名进行访问了.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo部署到GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[１．帮助：(查看指令的详细信息)1.1 xxx --help (xxx -h) 1.2 man xxx ２．查看哪个程序占用了特定端口？占用某个端口的进程是谁?2.1 lsof -i -n -P | grep :80 //查看哪个程序占用了特定端口 2.2 lsof -i//显示所有打开的端口 2.3 lsof -i:80 //显示所有打开80端口的进程 2.4 lsof -n //不将IP转换为hostname，缺省是不加上-n参数 -P //port numbers to port names; ３．查看磁盘使用情况： 查看磁盘中指定目录的使用情况：du -ach --max-depth=1 指定目录的路径 查看系统磁盘占用情况：df -lh ４．进程相关操作： 查看系统执行的进程（不包括父进程）：ps -aux | more (ps -aux | grep xxxx) 查看当前所有进程，包括父进程：ps -ef | more (ps -ef | grep xxxx) 查看系统负载：w 动态查看负载: top 在 top 状态下: 按shift + m，可以按照内存使用大小排序。 按数字 1 可以列出各颗 cpu 的使用状态。 静态查看系统负载：top -bn1 和 top 命令唯一的区别就是，它一次性全部把所有信息输出出来而非动态显示。 查看系统当前剩余多少内存： free -h (-h及human，以方便人阅读方式显示) 杀死进程：kill 进程号 强制杀死进程：kill -9 进程号 按照进程名强制杀死该进程名的所有进程：pkill -9 进程名 按照进程名杀死进程：killall 进程名 ５．查看系统信息： 查看内核版本号：uname -r 查看系统内核版本，gcc编译器版本详细信息： cat /proc/version 查看系统信息：cat /etc/redhat-release 查看操作系统版本所有信息: lsb_release -a 查看内存信息 cat /proc/meminfo 查看网卡信息 dmesg | grep -i eth 查看机器型号 dmidecode | grep &quot;Product Name&quot; 查看硬盘信息命令 : fdisk -l 查看主板信息 dmidecode |grep -A16 &quot;System Information$&quot; 查看CPU信息（型号) cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看CPU的主频 cat /proc/cpuinfo |grep MHz|uniq 查看当前CPU运行在32bit还是64bit模式下 getconf LONG_BIT 查看是否支持64bit cat /proc/cpuinfo | grep flags | grep &#39;lm&#39; | wc -l (如果结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit) 查看CPU是几核: cat /proc/cpuinfo |grep &quot;cores&quot;|uniq 逻辑CPU个数：cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l 物理CPU个数： cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l 每个物理CPU中Core的个数： cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l ６．查看网络： 查看当前主机的ip地址和网卡信息: ifconfig （附加网卡的启用ifup eth0与停用stop eth0命令） 查看IP地址信息：ip addr (注：安装minimal版的CentOS系统时，ifconfig等网络相关的指令用不了，暂时可以用ip addr) 测试网络的连通性 : ping (网络统计)命令显示连接信息,路由表信息等: netstat 通常配合使用参数，这里只演示一个参数。netstat -? 打印网络连接状况：netstat -anp （-p表示显示进程名和进程ID） 当前系统启动哪些端口：netstat -lnp （-l表示显示正在监听的端口)netstat指令无效时：使用yum install net-tools安装 路由跟踪命令: traceroute 可以查看到你从源到目的的所经过的路由 查询DNS相关信息记录,CNAME,MX记录等等: dig 这个命令主要用于解决相关DNS查询； ​ nslookup 也具备查询DNS的功能，还可以显示一个ip地址的记录！ 查找到IP的名称或IP的名字在IPv4和IPv6 DNS记录和查询: host IP地址 例如host www.baidu.com 查看主机名: hostname 或者你可以到/etc/sysconfig/network中修改主机名。 查看路由表信息: route 增加和删除路由条目: root add -net 192.168.199.129/24 gw 192.168.199.1 查看默认的表使用: arp 为地址解析协议 查看网络模式和网络速度等信息: ethtool 有关配置可以到/etc/sysconfig/network-scripts/ifcfg-eth0下进行修改。 ７．任务调度： 编辑定时任务：crontab -e 删除：crontab -r 查询：crontab -l 重启：service crond restart ８．压缩/解压缩： 解压到当前目录：tar -zxvf xxx.tar.gz 解压到指定目录：tar -zxvf xxx.tar.gz -C 目标目录 压缩：tar -zcvf 打包后的文件名（以.tar.gz为后缀） 要压缩的文件名 tar里面没有针对xz格式的参数比如 -z是针对 gzip，-j是针对 bzip2） 解压tar.xz文件： 先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。 创建tar.xz文件： 先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件， 然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz ９．rpm：安装/查询/删除rpm包： 安装本地的rpm包：rpm -ivh rpm包全路径名 查询是否安装了某个rpm包：rpm -qa | grep 软件名 删除rpm方法安装的某个rpm包： rpm -e 软件包名 升级某个rpm包：rpm -Uvh 软件包名 １０．yum：安装/查询/删除rpm包： 查询公网的yum服务器中是否有我们要安装的某个软件源：yum list | grep 软件名 (或者用yum search 软件名) 安装最新版的某个软件（默认）：yum -y install 软件名 安装指定版本的某个软件：yum -y install 软件名-版本号 升级某个rpm包： yum update -y 软件名 （查看是否有新版本及版本号 yum update |grep 软件名） 删除yum方式安装的rpm包：yum remove 软件名 当要使用一个指令，系统提示不存在，于是用yum安装它但又不知道它属于哪个rpm包时：yum provides 指令名（以ifconfig为例：yum provides ifconfig） 查看包的关系：repoquery --nvr --whatprovides 包名 （ repoquery是yum扩展工具包yum-utils中的一个工具，所有如果你没有repoquery命令的话，可以先 sudo yum install yum-utils 安装yum-utils包） １１．防火墙： CentOS7查看防火墙状态：systemctl status firewalld (CentOS6查看防火墙状态:service iptables status) 临时关闭防火墙：systemctl stop firewalld 启动防火墙：systemctl start firewalld １２．关机/重启/注销linux： 关机：halt （或者shutdown -h 1 表示一分钟后关机；shutdown -h now立刻关机） 重启：reboot 注销：logout １３．文件/目录操作： 创建目录（父目录不存在时创建父目录，即级联创建目录）：mkdir -pv 目录名（目录名如./aaa/bbb/ccc/ddd） 创建文件：touch 文件名 递归且强制删除目录/文件：rm -rf 目录名 显示目录下的文件/目录：ls -a (-a 表示列出所有文件，包括隐藏文件) ls -d (-d表示针对目录的，只列出目录本身) 浏览小文件并显示行号：cat -n 文件名 （浏览大文件：cat -n 文件名 | more） 浏览大文件 并显示行号，百分比：less -mN 文件名 追加：向文件的内容后面追加内容：echo &quot;内容&quot; &gt;&gt; 文件名 覆盖：用文件1的内容覆盖文件2里面的内容 ： cat 文件1 &gt; 文件2 控制台打印内容：echo “xxxx” 查看文件后5行：tail -n 5 文件名 （查看前5行：head -n 文件名） 创建快捷方式（软链接）：ln -s 原文件 快捷方式名称 文件重命名 ： mv 原文件名/目录名 新文件名/目录名 剪切（移动）：mv 原文件名/目录 新的路径 复制：cp -r 原文件/目录 目标文件/目录 （注意：复制目录必须加-r，表递归复制） １４．搜索文件/目录： 按照名称查询某个目录下是否有某个文件：find 搜索的目录 -name 要搜索的文件名 查询某个目录下属于某个用户的所有文件： find 搜索的目录 -user 用户名 １５．用户操作： 切换为某个用户：su -用户名 切换为管理员用户即root用户：su - 以管理员权限执行一条命令 ：sudo 要执行的命令 创建用户/组：useradd/groupadd useradd -g 所属的组名 用户名（注意：指定用户所属的组（前提：组存在）） 改变文件所属用户/组：chown/chgrp 改变用户所属组：usermod 改权限：chmod 改运行级别：chkconfig --level 0到6的数字 服务名 on （on 表开启，off表关闭） 查看用户所属组：id 用户名 查看有哪些用户：cat /etc/passwd 查看有哪些组：cat /etc/group 设置密码 passwd 用户名 １６．查看以前敲过的所有命令：history （常与管道连用，history | more）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的安装]]></title>
    <url>%2FLinux%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[前言: 上一节我们了解了Linux的一些基本概念,这一节我们将开始安装Linux系统,Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习. 什么是虚拟机? 安装虚拟机软件VMware:Vmware 下载地址 VMWare10 创建虚拟机空间:安装好 vmware 后，就可以创建虚拟机空间了: 点击新建虚拟机 安装CentOS系统:安装系统之前，需要先去下载一个镜像文件: CentOS下载地址： ​ 网易镜像：网易镜像​ 搜狐镜像：搜狐镜像 ​ 阿里云CentOS7镜像: 可以选择第一个：CentOS-7-x86_64-DVD-1708.iso 进行下载即可。 这里找到Ｌｉｎｕｘ系统的iso镜像(即.iso后缀)文件 这里如果选择OK,此时会联网检查系统的完整性,会等待很久,所以这里选择skip.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux的安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Linux.html</url>
    <content type="text"><![CDATA[前言: 根据JoblabXTM整理，使用Linux操作系统占据了整个操作系统的绝大数量，已经接近99%！立志于互联网行业的工程师们掌握Linux这门技术对自身的职业发展，一定会起到事半功倍之效果,所有我们有必要学习Linux操作系统. 一、Linux是什么,怎么读? linux是一个开源、免费的类Unix操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目都会部署到Linux/unix系统上。 Linux 读作[里纽克斯, 利尼克斯,里纳克斯] 二、Linux 的历史背景: 最初是由芬兰赫尔辛基大学学生Linus Torvalds (林纳斯-托瓦斯)由于自己不满意教学中使用的MINIX操作系统,所有在1990年底由于个人爱好设计出了LINUX系统核心,后来发布于芬兰最大的ftp服务器上,用户可以免费下载,所有它的周边的程序越来越多,Linux本身也逐渐壮大起来,之后Linux在不到三年的时间里成为了一个功能完善,稳定可靠的操作系统. 三、Linux的版本和分类:3.1 Linux 版本分两种: 内核版本 和发行版本: 内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号. 发行版本是一些组织和公司根据自己发行版的不同而自定. 3.2 一般来说著名的linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等 Debian系列：Debian、Ubuntu(乌班图)等 RedHat(红帽)系列 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 包管理工具 yum 支持tar包 Debian(蝶变)系列 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 包管理工具 apt-get 支持tar包 四、Unix简介: Unix是一个强大的多用户、多任务操作系统.于1969年在AT&amp;T(美国电话电报公司)的贝尔实验室开发. UNIX的商标权由国际开放标准组织所拥有. UNIX操作系统是商业版,需要收费,价格比Windows正版要贵一些. 五、Linux和Unix的关系: 六、Linux和Windows的比较: 比较 Window Linux 免费与收费 收费且很贵 Linux 免费或少许费用 软件与支持 数量和质量的优势，不过大部分为收费软件；由微软官方提供支持和服务； 开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。 安全性 三天两头打补丁安装系统安全更新，还是会中病毒木马； 要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比Windows 平台要更加安全 使用习惯 普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易入门简单； 兼具图形界面操作和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高。 可定制性 封闭的，系统可定制性很差； 开源，可定制化非常强。 应用场景 桌面操作系统主要使用的是window。 支撑百度，谷歌，淘宝等应用软件和服务的，是后台成千上万的Linux服务器主机。世界上大部分软件和服务都是运行在Linux之上的。 七、Linux 在计算机中的位置: 八、Linux的目录结构: 目录 说明 / 根目录: 一般根目录下只存放目录,不存放文件 /bin (binaries) 存放二进制可执行文件，常用命令一般都在这里(如: ls,cat,mkdir等)。 /boot 存放用于系统启动时使用的各种文件 /dev (devices) 类似Windows的设备管理器, 把所有的硬件用文件的形式存储。 /etc (etcetera) 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /usr 用于存放系统应用程序，比较重要的目录 /usr/local [重点] : 一般通过编译源码方式安装的程序就存放在这里 /usr/sbin 超级用户的一些管理程序 /usr/share/man 帮助文档 /usr/bin 众多的应用程序 /var [重点] 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 /tmp 用于存放各种临时文件，是公用的临时文件存储点。 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统。 /opt 下载的未安装的软件一般放到这里 /media linux会自动识别一些设备,例如U盘,光驱等,当识别后会把识别的设备挂载到这个目录下 /lost+found 这个目录平时是空的，系统非正常关机会留下一些文件（windows下叫什么.chk）就存放在这里 ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>初识Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建Hexo基本框架]]></title>
    <url>%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[前言: 之前自己敲代码纯手工打造了一个博客,并成功部署到了阿里云服务器上,虽然界面不忍直视吧,但还是有一丝小小的成就感.最近看到朋友用Hexo框架搭建的一个博客,界面看起来很美观,于是乎爱折腾的我心动了,决定放手干,好了废话不多说,进入正题,先说一下我的思路:个人认为无论学习什么技术,首先要做的就是要了解这个技术是什么?然后为什么要用它,它有什么优势,特点?最后就是我该怎么用? 一、Hexo是什么? Hexo 是一款基于Node.js的静态博客生成程序，作者是中国台湾tommy351。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容． 二、Hexo有什么用,优势在哪? 如果你一直想拥有一个界面美观的,能在上面记录一些学习心得,个人日记,一些内容公开发布,一些内容私密访问,属于自己的博客平台,但是又愁于自己没有一定的编程能力难以实现这个想法,那么Hexo将会给你带来福音, 即使你没有一定的编程基础,你也可以快速使用Hexo打造一个你自己喜欢的博客,因为不需要你敲大量的代码,你要做的仅仅是不断的Ctrl+C,Ctrl+V改一改配置文件. 简单吧! 是不是有点心动了,心动就行动吧! ​ 三、如何安装?以Windows机为例:１．首先要安装的就是Git和Node.js这两个工具：（如果之前安装过,那么跳过这一步） Git下载地址: Git Node.js下载地址: Node.js ２．安装hexo: 打开git软件,通过node.js工具的npm命令来安装hexo: $ npm install -g hexo-cli ３．检测上述工具是否安装成功,如果成功会显示版本号：(如果你嫌麻烦可以忽略) node-v npm -v git --version hexo -v ４．在任意位置创建一个文件夹,例如:blog, 并进入该目录: 我这里是创建在E盘 $ cd /e/blog ５．运行下面的命令,hexo 将会在blog文件夹中生成所需要的文件 $ hexo init 会生成以下目录内容: ​ 注意: 将来自定义博客样式的时候别把站点配置文件和主题配置文件弄混淆了. ５．生成静态文件(hexo会将/blog/source/ 下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下): $ hexo g ６．启动服务器: $ hexo s 默认情况下，访问网址为： http://localhost:4000/ 在浏览器地址栏输入上面的地址: 如果看到下面这个界面，那么恭喜你安装成功了，这个就是hexo默认的博客主题,如果你不喜欢还有更酷炫的主题，如何操作，下节我们继续．现在你已经可以在这个主题下写博客了。 四、说明: $ hexo g 是 $ hexo generate 的简写形式,产生的作用是一样的 $ hexo s是 $ hexo server的简写, 表示启动本地服务器,让hexo在本地运行 $ hexo d 是 $ hexo deployed的简写, (这个指令是部署到远程服务器的,后面会讲到) $ hexo clean 没有简写,别写成了$ hexo c $ hexo server -p 5000 #更改端口 参考文档： Hexo]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo的安装</tag>
      </tags>
  </entry>
</search>
