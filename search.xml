<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解java虚拟机]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA.html</url>
    <content type="text"><![CDATA[深入理解 Java 虚拟机——JVM 高级特性与最佳实践要点总结本书基于 JDK 1.6 讲述，并不完全适用于之后的 JDK 版本。本笔记适当对原文进行扩展，例如介绍了 JDK 1.8 的内存局域，Tomcat 8.x 的类加载架构，以及部分关键知识的原理扩展，面试题扩展。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、递归算法:1.1 算法说明递归来源于数学中的归纳法，归纳法是数学里的一种证明方法，它通常有以下两个步骤： 证明当 n 等于某一个值（通常是限定范围内的第一个值）时命题成立； 假设当 n = m 时命题成立，证明当 n = m + 1 时命题也成立。 数学中的归纳法由已知推向未知由前推向后，而在编程中通常是给定 n 的值（如 n = m）求结果，这与数学中的归纳法在过程上有些不同，多了一个回推的过程，通常是先由后向前，再由前向后（并不都是这样）。假定 n &gt;= 1，并且 n = 1 时的结果已知，步骤如下： 要想求得 n = m 时的结果，必须知道 n = m - 1 时的结果，要想知道 n = m - 1 时的结果，必须知道 n = m - 2 时的结果，如此反复直到 n = 1（此时结果已知），此过程即由后向前； 已知 n = 1 的结果就可得到 n = 2 时的结果，得到 n = 2 时的结果就可得到 n = 3 时的结果，如此反复直到得出 n = m 的结果，此过程即由前向后。 1.2 如何去理解递归，想到递归，运用递归?1.2.1 递归的优缺点: 1.2.2 递归需要的两个条件：①: 要有边界，也就是出口 ②: 有递推关系 最后记住用到递归的要领： 利用A函数实现功能时， A函数体需要用到同样的功能，这时候就要用到递归 1.2.3 递归的运用①: 求1+2+…+n要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C）。这道题递归一般的求解是：先找递推关系：如果想求1+2+…..+n：步骤1：1+2+….+n-1步骤2：n+步骤1的值————这就是递推关系，求值1+2++……+n，需要逆求1+2+…..+n-1 !!!那边界条件呢？当n小于等于0时，和为0;这就是边界条件. 1234567long getSumofN (int n)&#123; if(n&lt;=0) return 0; else return ( n+getSumofN(n-1) );&#125; 这里出现if else，不满足题意的，因此需要解决两个问题，如何判断边界条件，以及如何存储每次计算所得值解决方法：执行—逻辑判断–语句 12345int getSumofN(int n, int *result)&#123; n&amp;&amp;getSumofN(n-1,result); //前者用来判断边界，后者存储，执行步骤1 return (*resulet +=n); //执行步骤2&#125; 进一步： 1234int getSumofN(int n, int *result)&#123; return n&amp;&amp;getSumofN(n-1,result)&amp;&amp;(*resulet +=n); //一步到位！&#125; ②: 递归的运用: ③: 通用树遍历显示文本的方式显示一颗树 A———B———————-E———————-F———C———D———————-H———————-I———————-J A有子树节点B C DB有子树节点E FD有子树节点H I J 整个输出打印过程：打印A结点|打印A结点的—孩子结点（具体：打印第一个孩子结点B，再打印B–的–孩子结点，接着同样的工作-打印孩子结点 C D…….） 单独拿出来，打印B孩子的结点分为：打印B结点|打印B结点的孩子结点对A，对B，打印执行的功能，是一样的 这就是一个递归！ 先找递推关系: 步骤1：找到根节点，输出 步骤2：找到孩子结点，输出 ————这就是递推关系，函数的功能是，先打印父结点，再打印孩子结点。而我们打印孩子结点时，需要同样的功能。 12345678910111213141516171819202122232425262728293031static int recurse_display(GTreeNode * node,int format)&#123; int i; if(NULL!=node) &#123; //1.打印根结点 //1.1先打印占格符 for(i=0;i&lt;format;i++) &#123; printf("%c",'-'); &#125; //1.2.打印父节点 printf("%c",(int)(node-&gt;data)); //1.3.换行 printf("\n"); //2.打印子节点 for(i=0;i&lt;LinkList_Length(node-&gt;child);i++) &#123; //2.1获取子结点 TLNode* trnode=(TLNode*)LinkList_Get(node-&gt;child,i+1); //2.2打印子节点的孩子结点 recurse_display(trnode-&gt;node,format+4); &#125; &#125;&#125; ④: 汉诺塔问题: 先找递推关系: 如果想将初始时放在A的n个盘子，利用B，原样的放在C： 步骤1：将A的最上方n-1个盘子，通过C，放在B中 步骤2：将A上面剩下的那个盘子，通过B，放在C中 步骤3：将B中那n-1个盘子，通过A，放在C中​ ————这就是递推关系，函数的功能是，将A中的盘子，通过B，放在C中，而我们移动的每一个步骤，都是需要同样的功能。进一步得知，函数的参数，应该有A、B、C 那边界条件呢： 边界条件就是，只有一个盘子时，移动一次就够了。代码里表示，也就是输出，从哪移动到哪 分析好了，代码自然就出来了： 123456789101112131415161718192021222324252627282930313233343536373839// 将 n 个盘从 A 塔移到 C 塔void hanoi(int n,char A,char B, char C)&#123; //边界条件 if(1==n) &#123; printf("%c-------%c\n",A,C); &#125; else &#123; hanoi(n-1,A,C,B);//步骤1 hanoi(1,A,B,C); //步骤2 hanoi(n-1,B,A,C);//步骤3 &#125;&#125;==================================================================================================//Java代码: public class Hanoi &#123; public static void main(String[] args) &#123; char A = 'A';char B = 'B'; char C='C'; hanoi(2,A,B,C); &#125; static void hanoi(int n,char A,char B, char C) &#123; //边界条件 if(1==n) &#123; System.out.println(A+"----移动到-----&gt;"+C); &#125; else &#123; hanoi(n-1,A,C,B); //步骤1 hanoi(1,A,B,C); //步骤2 hanoi(n-1,B,A,C); //步骤3 &#125; &#125; &#125; ⑤: 利用递归求斐波那契(Fibonacci)数列 斐波那契数列指的是1、1、2、3、5、8……这样的数列，用公式表示就是： F(n) = F(n-1) + F(n-2) 代码如下： 1234567891011121314151617public class Main &#123; // 以下仅作演示用，采用整型且未对数值范围进行限定与校验，特此提醒 public static void main(String[] args) &#123; int m = 11; System.out.printf("斐波那契数列第%d个数：%d%n", m, fibonacci(m)); &#125; // 求斐波那契数列第 n 个数的值 private static int fibonacci(int n) &#123; if (n &lt; 3) &#123; return 1; // 递归终止条件 &#125; return fibonacci(n - 1) + fibonacci(n - 2); // 第n项为第(n-1)项与第(n-2)项之和 &#125;&#125; 以上两例仅作递归演示，实际上并不适合使用递归，因为其需要回推使得效率大大降低，对于这种明显可以使用循环解决而递归又需要回推导致效率低下的情况更适合使用循环： 123456789101112131415161718192021222324252627282930313233343536373839401. 使用循环求阶乘public class Main &#123; // 以下仅作演示用，采用整型且未对数值范围进行限定与校验，特此提醒 public static void main(String[] args) &#123; int m = 10; System.out.printf("%d! = %d%n", m, factorial(m)); &#125; // 求 m 的阶乘 private static int factorial(int m) &#123; int product = 1; for (int i = 2; i &lt;= m; i++) &#123; product *= i; &#125; return product; &#125;2.使用循环求斐波那契数列public class Main &#123; // 以下仅作演示用，采用整型且未对数值范围进行限定与校验，特此提醒 public static void main(String[] args) &#123; int m = 10; System.out.printf("斐波那契数列第%d个数：%d%n", m, fibonacci(m)); &#125; // 求斐波那契数列第 n 个数的值 private static int fibonacci(int n) &#123; int a = 1; // 第1个斐波那契数 int b = 1; // 第2个斐波那契数 for (int i = 3; i &lt;= n; i++) &#123; b += a; // 第i个斐波那契数 a = b - a; // 第(i-1)个斐波那契类 &#125; return b; &#125;&#125; ⑥: 快速排序 快速排序法采用的是“分而治之”的思想，比较适合使用递归而且效率也相当不错。相对前面的两个例子，它不需要回推，节省了大量时间： 123456789101112131415161718192021222324252627public static void quickSort(int[] arr, int left, int right)&#123; if (left &lt; right) &#123; int mark = arr[left]; int i = left; int j = right; while (i &lt; j) &#123; // 从后向前查找 while (j &gt; i &amp;&amp; arr[j] &gt;= mark) &#123; j--; &#125; if (j &gt; i) &#123; arr[i++] = arr[j]; &#125; // 从前向后查找 while (i &lt; j &amp;&amp; arr[i] &lt; mark) &#123; i++; &#125; if (i &lt; j) &#123; arr[j--] = arr[i]; &#125; &#125; arr[i] = mark; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right); &#125;&#125; ⑦: 递归实现字符串逆序 比如：s=“abcdef”，逆序后变为“fedcba” 先找递推关系：如果想逆序abcdef：步骤1：将a和f进行交换步骤2：对bcde进行逆序——-（需要同样的功能，所以必须用递归）————这就是递推关系，逆序“abcdef”，需要逆序“bcde”!!! 进一步可知，此递归函数得输入参数上标和下标 那边界条件呢？当s里边无字符，也即为NULL情况下，不用排序当s里边只有一个元素时，也不用排序，这就是边界条件 分析好了，代码自然就出来了： 12345678910111213141516char * Reverse_Str(char *s, int first ,int last)&#123; //边界条件：利用上标下标判定 if(last&lt;=first) return s; else &#123; //交换首尾字符 char temp=s[first]; s[first]=s[last]; s[last]=temp; //逆序中间部分 Reverse_Str(s,first+1,last+1); //注意这里千万，不要first++，和last--，为什么，自己琢磨吧！ &#125;&#125; ⑧: strlen递归解法 先找递推关系：如果想char s=”abcdefg”,求strlen(s)：步骤1：求strlen(“bcdefg”),也就是strlen(s+1)步骤2：将步骤1的结果加1返回即可————这就是递推关系，求s长度，需要求s+1长度 !!!那边界条件呢：当char s=NULL或者char *s=‘\0’时，直接得到结果，而不用继续递归下去，这就是边界条件 分析好了，代码自然就出来了 1234567891011int strlen(const char * s)&#123; //处理边界条件 if(NULL==s) return -1; else if('\0'==*s) return 0; //递推关系 else return (strlen(s+1)+1);&#125; 总结:对于阶乘和斐波那契数列这样的问题实际上并不适合使用递归，首先它需要回推会导致计算量大大增加，其次这种问题使用循环本身很容易解决，而且代码也并不复杂。而对于快速排序这种“分而治之”的情况，并不存在回推的过程使用递归可以简化代码增强代码的可读性，对于汉诺塔使用递规不仅大大简化了代码也更易理解。 总而言之，不管使用什么方法，其目的无非就是提高程序运行效率，减化代码增强代码的可读性。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关面试题及答案]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[1. 请列出Java常见的开源数据连接池，并对参数做出简单的说明答：在Java中开源的常用的数据库连接池有以下几种 ： （1）DBCP DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。 （2）c3p0 c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。 （3）Druid 阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。 2. 下列属于关系型数据库的是（）（选择两项） A. Oracle B. MySql C. IMS D. MongoDB 答案：AB分析： IMS 是IP Mulitimedia Subsystem的缩写，是IP多媒体系统 MongoDB分布式文档存储数据库 3. 视图是一个“虚表”，视图的构造基于（） A. 基本表或视图 B. 视图 C. 数据字典 D. 基本表 答案：A 4. 什么是存储过程？它有什么优点？答：存储过程是一组预编译的SQL语句， 它的优点有： 允许模块化程序设计，就是说只需要创建一次过程，以后在程序中就可以调用该过程任意次。 允许更快执行，如果某操作需要执行大量SQL语句或重复执行，存储过程比SQL语句执行的要快。 减少网络流量，例如一个需要数百行的SQL代码的操作有一条执行语句完成，不需要在网络中发送数百行代码。 更好的安全机制，对于没有权限执行存储过程的用户，也可授权他们执行存储过程。 5. 存储过程和函数有什么区别？5.1 Oracle中的函数与存储过程的区别:A:函数必须有返回值,而过程没有. B:函数可以单独执行.而过程必须通过execute执行. C:函数可以嵌入到SQL语句中执行.而过程不行. 其实我们可以将比较复杂的查询写成函数.然后到存储过程中去调用这些函数. 5.2 Oracle中的函数与存储过程的特点:A. 一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。 B.对于存储过程来说可以返回参数，而函数只能返回值或者表对象。 C.存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 6. 什么是索引？它有什么优点？答：索引与书的目录类似，索引使数据库程序无需扫描整个表，就可以在其中找到所需要的数据，索引包含了一个表中包含值的列表，其中包含了各个值的行所存储的位置，索引可以是单个或一组列，索引提供的表中数据的逻辑位置，合理划分索引能够大大提高数据库性能。 7. 什么是触发器，它有哪些优点？答：触发器是一种特殊类型的存储过程，触发器主要通过事件触发而被执行的， 触发器的优点： 1.强化约束，触发器能够提供比CHECK约束。 2.跟踪变化，触发器可以跟踪数据库内的操作，从而不允许未经允许许可的更新和变化。 3.联级运算，比如某个表上的触发器中包含对另一个表的数据操作，而该操作又导致该表上的触发器被触发。 8. 触发器分为事前触发和事后触发的区别。语句级触发和行级触发有何区别？事前触发器运行于触发事件发生之前，通常可以获取事件之前和新的字段值 事后触发器运行于触发事件发生之后。 语句级触发器可以在语句执行前或后执行， 行级触发在触发器所影响的每一行触发一次 9. 视图是什么？游标是什么？答：视图是一种虚拟表，虚拟表具有和物理表相同的功能，可以对虚拟表进行增该查操作，视图通常是一个或多个表的行或列的子集，视图的结果更容易理解（修改视图对基表不影响），获取数据更容易（相比多表查询更方便），限制数据检索（比如需要隐藏某些行或列），维护更方便。 游标对查询出来的结果集作为一个单元来有效的处理，游标可以定位在结果集的特定行、从结果集的当前位置检索一行或多行、可以对结果集中当前位置进行修改。 10. 什么是事务？答：事务是指一个工作单元，它包含了一组数据操作命令，并且所有的命令作为一个整体一起向系统提交或撤消请求操作，即这组命令要么都执行，要么都不执行。 原子性:事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。 一致性:事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。 隔离性:由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。 持久性:事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。 11. 怎么优化数据库（在数据百万条记录的数据库中 Oracle）？使用索引 建立分区，分区索引 使用存储过程 12. 如何优化SQL语句\1. 对操作符的优化 尽量不采用不利用索引的操作符 如：in ，not in ， is null， is not null，&lt;&gt;等 \2. 对条件字段的一些优化 采用函数处理的字段不能利用索引， 进行了显式或隐式的运算的字段不能进行索引 条件内包括了多个本表的字段运算时不能进行索引 \3. 在业务密集的SQL当中WHERE后面的条件顺序影响 \4. 应用ORACLE的HINT（提示）处理 \5.查询表顺序的影响 13. 说说你知道的一些关于查询优化的方案？①: 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 ②: 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null? 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 ③: 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 ④: 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 ⑤: in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 ⑥: 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ 若要提高效率，可以考虑全文检索。 ⑦: 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num ⑧: 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 ⑨: 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’ –name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30’)=0 –‘2005-11-30’生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’ ⑩:在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 11) 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 12) 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 13) 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 14) 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 15) 任何地方都不要使用 select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 16) 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 17) 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 18) 避免频繁创建和删除临时表，以减少系统表资源的消耗。 19) 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 20) 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 21) 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 22) 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 23) 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 24)尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 25) 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 26) 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 27) 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…) 28) 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 14. 谈谈你对SQL海量数据查询优化性能的一些看法？数据库系统是管理信息系统的核心，基于数据库的联机事务处理（OLTP）以及联机分析处理(OLAP)是银行、企业、政府等部门最为重要的计算机应用之一。从大多数系统的应用实例来看，查询操作在各种数据库操作中所占据的比重最大，而查询操作所基于的SELECT语句在SQL语句中又是代价最大的语句。举例来说，如果数据的量积累到一定的程度，比如一个银行的账户数据库表信息积累到上百万甚至上千万条记录，全表扫描一次往往需要数十分钟，甚至数小时。如果采用比全表扫描更好的查询策略，往往可以使查询时间降为几分钟，由此可见查询优化技术的重要性。 15. 数据库内联与外联的区别？内部联接（inner join）一个联接，返回两表的公共列都匹配的行 外部联接（outer join） 一个联接，该联接还包括那些和联接表中记录不相关的记录。您可以创建一个外部联接的三种变形来指定所包括的不匹配行： 左外部联接、右外部联接和完全外部联接。 ♥ 左外部联接（left outer join） 左边的表是主表，列所有；右表无取null ♥右外部联接（right outer join） 右边的表是主表，列所有；左边表只列匹配的行，没有值置null ♥完全外部联接 列所有，没有值置null 16. 什么是DAO模式？答：DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作。为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 17. 数据库MySQL，Oracle，SqlServer分页时用的语句Mysql:使用limit关键字 Select * from 表名 where 条件 limit 开始位置，结束位置。通过动态的改变开始和结束位置的值来实现分页。 Oracle：通过rownum来实现 select from ( select rownum rn,t. from addressbook where rownum&lt;= 20 ) where rownum &gt; 10 Sqlserver: select top 20 * from addressbook where id not in (select top 10 id from addressbook) 18. Oracle完成分页功能的三层子查询语句及其含义？如：select from (select t.,rownum r from (select * from A) t where rownum &lt; 10) where r &gt;5 select * from A:要查询的数据 select t.,rownum r from (select from A) t where rownum &lt; 10：取前10行 select from (select t.,rownum r from (select * from A) t where rownum &lt; 10) where r &gt;5：取5-10行 19. 问SQL怎么优化执行效率更高答： 1. SQL优化的原则是：将一次操作需要读取的BLOCK数减到最低,即在最短的时间达到最大的数据吞吐量。 调整不良SQL通常可以从以下几点切入： 1) 检查不良的SQL，考虑其写法是否还有可优化内容 2) 检查子查询 考虑SQL子查询是否可以用简单连接的方式进行重新书写 3) 检查优化索引的使用 4) 考虑数据库的优化器 \2. 避免出现SELECT * FROM table 语句，要明确查出的字段。 \3. 在一个SQL语句中，如果一个where条件过滤的数据库记录越多，定位越准确，则该where条件越应该前移。 \4. 查询时尽可能使用索引覆盖。即对SELECT的字段建立复合索引，这样查询时只进行索引扫描，不读取数据块。 \5. 在判断有无符合条件的记录时建议不要用SELECT COUNT （*）和select top 1 语句。 \6. 使用内层限定原则，在拼写SQL语句时，将查询条件分解、分类，并尽量在SQL语句的最里层进行限定，以减少数据的处理量。 \7. 应绝对避免在order by子句中使用表达式。 \9. 小心使用 IN 和 OR，需要注意In集合中的数据量。建议集合中的数据不超过200个。 \10. &lt; &gt; 用 &lt; 、 &gt; 代替，&gt;用&gt;=代替， &lt; 用&lt; =代替，这样可以有效的利用索引。 \11. 在查询时尽量减少对多余数据的读取包括多余的列与多余的行。 \12. 对于复合索引要注意，例如在建立复合索引时列的顺序是F1，F2，F3，则在where或order by子句中这些字段出现的顺序要与建立索引时的字段顺序一致，且必须包含第一列。只能是F1或F1，F2或F1，F2，F3。否则不会用到该索引。 20. 谈谈数据库去空格的情况一、表中字符串带空格的原因 1、空格就是空格。 2、控制符 显示为 空格。 二、解决方法 第一种情况，去空格的处理的比较简单，Replace(column,’ ‘,’’) 就可以解决。第二种情况，解决方法就比较麻烦点：需要先查出相应的ASCII码，再用Replace(column,char(ascii码),’’)解决，以下举个栗子：CREATE TABLE #temp(NAME NVARCHAR(50))INSERT INTO #temp SELECT ‘明天就是国庆了’+CHAR(10) –换行符SELECT * FROM #temp –末尾显示为空格SELECT REPLACE(NAME,’ ‘,’’) FROM #temp –去不掉这个空格SELECT REPLACE(NAME,CHAR(10),’’) FROM #temp –去掉空格SELECT REPLACE(NAME,CHAR(ASCII(RIGHT(NAME,1))),’’) FROM #temp –在不知道是最后一位是什么字符导致空格的情况下，先转ASCII码，在替换DROP TABLE #temp—-下面是查询结果:–’明天就是国庆了 ‘–’明天就是国庆了 ‘–’明天就是国庆了’–’明天就是国庆了’ 21. 根据你以往的经验简单叙述一下MYSQL的优化答：1.数据库的设计尽量把数据库设计的更小的占磁盘空间.1).尽可能使用更小的整数类型.(mediumint就比int更合适).2).尽可能的定义字段为not null,除非这个字段需要null.3).如果没有用到变长字段的话比如varchar,那就采用固定大小的纪录格式比如char.4).表的主索引应该尽可能的短.这样的话每条纪录都有名字标志且更高效.5).只创建确实需要的索引。索引有利于检索记录，但是不利于快速保存记录。如果总是要在表的组合字段上做搜索，那么就在这些字段上创建索引。索引的第一部分必须是最常使用的字段.如果总是需要用到很多字段，首先就应该多复制这些字段，使索引更好的压缩。6).所有数据都得在保存到数据库前进行处理。7).所有字段都得有默认值。8).在某些情况下,把一个频繁扫描的表分成两个速度会快好多。在对动态格式表扫描以取得相关记录时，它可能使用更小的静态格式表的情况下更是如此。2.系统的用途1).尽量使用长连接.2).explain 复杂的SQL语句。3).如果两个关联表要做比较话，做比较的字段必须类型和长度都一致.4).LIMIT语句尽量要跟order by或者 distinct.这样可以避免做一次full table scan.5).如果想要清空表的所有记录,建议用truncate table tablename而不是delete from tablename.6).能使用STORE PROCEDURE 或者 USER FUNCTION的时候.7).在一条insert语句中采用多重纪录插入格式.而且使用load data infile来导入大量数据，这比单纯的indert快好多.8).经常OPTIMIZE TABLE 来整理碎片.9).还有就是date 类型的数据如果频繁要做比较的话尽量保存在unsigned int 类型比较快。3.系统的瓶颈1).磁盘搜索.并行搜索,把数据分开存放到多个磁盘中，这样能加快搜索时间.2).磁盘读写(IO)可以从多个媒介中并行的读取数据。3).CPU周期数据存放在主内存中.这样就得增加CPU的个数来处理这些数据。4).内存带宽当CPU要将更多的数据存放到CPU的缓存中来的话,内存的带宽就成了瓶颈. 21. 说一下数据库的存储过程？一、存储过程与函数的区别： 1.一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。 2.对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。 3.存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 二、存储过程的优点： 1.执行速度更快 – 在数据库中保存的存储过程语句都是编译过的 2.允许模块化程序设计 – 类似方法的复用 3.提高系统安全性 – 防止SQL注入 4.减少网络流通量 – 只要传输存储过程的名称 系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头 22. 数据库创建索引的缺点？缺点： 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>数据库相关面试题及答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专治疑难杂症]]></title>
    <url>%2F%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html</url>
    <content type="text"><![CDATA[一、HTML跳转到的地方 1.1 checked属性值是true还是checked?结论: 都可以,但是不推荐这两种方式,推荐仅设置checked属性不赋值 复选框标签具有checked属性，通过此属性可以设置复选框的选中状态。 非常简单的操作，但是还是有不少朋友存在后面类似的疑问，那就是不确定checked属性值是true还是checked。 因为两个属性值在实际代码中都有出现，并且都是有效的，也是导致出现疑问的主要原因。 下面通过代码实例详细进行一下分析，首先看一段代码实例： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=" utf-8"&gt; &lt;meta name="author" content="http://www.softwhy.com/" /&gt; &lt;title&gt;蚂蚁部落&lt;/title&gt; &lt;style type="text/css"&gt; input&#123; width:20px; height:20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" checked&gt; &lt;input type="checkbox" checked=true&gt; &lt;input type="checkbox" checked="checked"&gt; &lt;/body&gt;&lt;/html&gt; 代码运行效果截图如下: 代码分析如下： （1）.仅设置checked属性不赋值，可以将复选框设置为选中状态。 （2）.将checked属性值设置为true，也可以将复选框设置为选中状态。 （3）.将checked属性值设置为”checked”，也可以将复选框设置为选中状态。 上面三种情况都比较容易接受，因为在代码中比较常见，实际编码中仅推荐第一种方式,第二和第三种方式不被推荐. 具体参阅点击跳转 虽然后两种方式非常符合情理，能够将复选框设置为选中状态，也许这只是一个误会，这两个值并不是专属，有些属性值会让不少朋友匪夷所思，看如下代码实例： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=" utf-8"&gt; &lt;meta name="author" content="http://www.softwhy.com/" /&gt; &lt;title&gt;蚂蚁部落&lt;/title&gt; &lt;style type="text/css"&gt; input&#123; width:20px; height:20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" checked=false&gt; &lt;input type="checkbox" checked=true&gt; &lt;/body&gt;&lt;/html&gt; 代码运行效果截图如下： 是不是感觉很奇怪，按照常理，checked属性值为true是选中状态，那么属性值为false就是未选中状态。 然而事实是，即便属性值为false，复选框依然是选中状态。其实有这样有一个规律，那就是在HTML中，只要设置checked属性，无论是否赋值，或者赋何种值，复选框都是选中状态。但是在通过JavaScript进行操作的时候，并非如此。 看一段代码实例： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=" utf-8"&gt; &lt;meta name="author" content="http://www.softwhy.com/" /&gt; &lt;title&gt;蚂蚁部落&lt;/title&gt; &lt;style type="text/css"&gt; input&#123; width:20px; height:20px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; let inputs=document.getElementsByTagName("input"); inputs[1].checked=true; inputs[2].checked=false; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox"&gt; &lt;input type="checkbox"&gt; &lt;input type="checkbox" checked&gt; &lt;input type="checkbox" checked=false&gt; &lt;/body&gt;&lt;/html&gt; 代码运行效果截图如下： 代码分析如下： （1）.默认状态下，第二个复选框处于非选中状态，第三个处于选中状态。 （2）.通过JavaScript动态两个复选框分别设置为选中和取消选中。 由此可见，在使用JavaScript进行动态操作的时候，设置checked属性值可为true或者false可以复选框设置为选中和非选中状态，经过测试，设置为”checked”也可以设置为选中状态，设置为undefined也可以取消选中，不过我们最好还是标准一些，毕竟MDN将checked属性阐述为布尔型类型，截图如下： 跳转到的地方 1.1.1 HTML 布尔属性值有不少标签属性，无需设置属性值，比如disabled、checked与selected。 下面以复选框为例子做一下说明，看如下代码： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=" utf-8"&gt; &lt;meta name="author" content="http://www.softwhy.com/" /&gt; &lt;title&gt;蚂蚁部落&lt;/title&gt; &lt;style type="text/css"&gt; input&#123; width:20px; height:20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" checked&gt; &lt;input type="checkbox" checked=true&gt; &lt;input type="checkbox" checked="checked"&gt; &lt;/body&gt;&lt;/html&gt; 代码运行效果截图如下： checked属性不需要设置值，只需要添加此属性，复选框就会被选中。 disabled或者selected等属性也是同样的道理，无需设置属性值，可以节省若干代码量，也符合标准。 上述几个属性还有一些地方需要注意，具体参阅点击跳转 1.2 路径问题1.2.1 绝对路径和相对路径及根路径先给出一个网站结构图做实例加深理解:A网站（域名为http://www.a.com）：/include/a-test.html，/img/a-next.jpg；B网站（域名为http://www.b.com）：/include/b-test.html，/img/b-next.jpg。 相对路径是从引用的网页文件本身开始构建的，如果在A网站中的a-test.html中要插入图片a-next.jpg，可以这样做:&lt; img src=&quot;../img/a-next.jpg&quot; /&gt;，重点是img前面的../，表示从html处于的include开始起步，输入一个../表示回到上面一级父文件夹下，然后再接着img/表示又从父级文件夹下的img文件开始了，最后定位img下面的a-next.jpg。 绝对路径 如果是Web项目一般带有网站的域名，例如: 如果在A网站中的a-test.html中要插入图片a-next.jpg，需要这样这样写:&lt; img src=&quot;http://www.a.com/img/a-next.jpg&quot; &gt;，将图片路径上带有了域名信息，再打个比方：如果在A网站中的a-test.html中要插入B网站的图片b-next.jpg，就需要这样写：&lt; img src=&quot;http://www.b.com/img/b-next.jpg&quot; &gt;，这种方法适用与在不同网站之间插入外部网站的图片。如果是在本地电脑上绝对路径应该像这样: F:\pan\Javawebcode\code\goods\WebRoot\jsps\css\user\regist.css,从文件所在的磁盘符开始到该文件名 根路径是从网站的最底层开始起，一般的网站的根目录就是域名下对应的文件夹，就如D盘是一个网站，双击D盘进入到D盘看到的就是网站的根目录，这种路径的链接样式是这样的：如果在A网站中的a-test.html中要插入图片a-next.jpg，可以这样做:&lt; img src=&quot;/img/a-next.jpg&quot; &gt;，以/开头表示从网站根目录算起，找到根目录下面的img文件夹下的next.jpg。 简言之: 相对路径: ../ 或者 ../../ 或者像这种 temp/test/test.html 绝对路径: 盘符开始 或 http 开始 根路径: 一般以/开头 1.2.2 转发和重定向中的/①: 转发时”/“代表当前项目的根路径 ；重定向时”/“代表当前服务器的根路径 比如: 转发：/代表http://localhost:8080/工程名/ 举例: request.getRequestDispatcher(&quot;/jsp/system/index.jsp&quot;).forward(request,response); 重定向：/代表http://localhost:8080/ 另外: 超链接(相当于重定向)中href的/代表http://localhost:8080/ 标签的Src 属性的值中/代表http://localhost:8080/ c标签/代表http://localhost:8080/工程名/ include指令中file的/代表http://localhost:8080/工程名/ 如&lt;%@ include file = &quot;/jsps/header.jsp&quot; %&gt; 1.2.3 Javaweb工程中在写路径时,为什么不包含WebContent(eclipse中默认名)JavaWeb项目中引用的路径其实是编译后的路径: 即下图 右边部分的路径: 例如: target.jsp的绝对路径为: http://localhost:8080/Chicken/good/target.jsp 1.3 中文乱码问题1）设置页面编码， 若是jsp页面: 则&lt;%@page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; %&gt; 若是html页面，在网页头部（&lt; head&gt;&lt; /head&gt;）中添加下面这段代码: &lt; meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; 2）将form表单提交方式变为post方式，即添加method=”post”；）在Servlet类中编写代码request.setCharacterEncoding(&quot;UTF-8&quot;)，而且必须写在第一行。 3）如果是get请求，在Servlet类中编写代码 byte [] bytes = str.getBytes(&quot;iso-8859-1&quot;); String cstr = new String(bytes,&quot;utf-8&quot;); 4) 或者直接修改Tomcat服务器配置文件server.xml增加内容： URIEncoding=&quot;utf-8&quot; 二、Java2.1 集合中List 和 Set 区别,以及 定制排序和选择排序2.1.1 区别:List接口: 存储有序,可重复 Set接口：存储无序,不可重复 2.1.2 值得注意的地方:注: ①: 存储有序/无序: 指的是元素在底层存放的位置有序/无序. 而不是根据遍历出来的顺序与存入的顺序是否一致来说明有序/无序. ②: 不可重复性：当向Set中添加相同的元素的时候，后面的这个不能添加进去 另外Map中与这相似: 判断两个key是否相同，若相同,则只能添加进后添加的那个元素 ③: 一个TreeSet对象必须存储同一种数据类型,不能既存储Integer 又存储String类型, 而HashSet和LinkedHashSet则可以存储不同类型. ④: HashSet 遍历出来的顺序与存入时的顺序不同.但LinkedHashSet是相同的 ⑤: 向TreeSet中添加的元素时，首先按照compareTo()进行比较，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同而不管其他属性是否相同，进而后一个对象不能添加进来 ⑥: 使用TreeSet时, compareTo()与hashCode()以及equals()三者保持一致！ ⑦: 关于HashTable 古老的实现类，线程安全，不建议使用; Properties：Hashtable的子类，常用来处理属性文件。键和值都为String类型的 Vector(古老的实现类，线程安全的，但效率低于ArrayList) ⑧: 如果存入集合中的元素是自定义类的对象。要求：自定义类要重写equals()方法。 2.1.3 选择排序和定制排序当向TreeSet中添加自定义类的对象时，涉及到两种排序方法：①自然排序②定制排序 ①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序） ②定制排序：（实现Comparator接口，重写compare方法）—&gt;也就是按照指定的属性排序(例如: 自定义了一个Person类含有name属性和age属性,我想指定按照age属性的值且从大到小排序) 两者区别: 自然排序要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法 12345678910111213141516171819202122232425262728293031//当向TreeSet中添加Person类的对象时，依据此方法，确定按照哪个属性排列public class Person implements Comparable&lt;Person&gt; &#123; private String name; private Integer age; //private int age; @Override public int compareTo(Object o) &#123; if (o instanceof Person) &#123; Person p = (Person) o; // return this.name.compareTo(p.name);//因为name是String类型，String类重写了compareTo方法，所以按照姓名从小到大排序 // return this.age.compareTo(p.age);//因为age是包装类Integer类型，Integer类重写了compareTo方法，所以按照年龄从小到大排序 // return this.age - p.age; //如果age为基本数据类型int型，int不是类，所以没有compareTo方法，所以只能用减号- //如果想按照年龄从大到小排序,只需在前面加一个负号即可 // return -(this.age.compareTo(p.age));//按照年龄从大到小排序 // return -(this.age - p.age);//按照年龄从大到小排序 int i = this.age.compareTo(p.age); if (i == 0) &#123;//年龄相同 return this.name.compareTo(p.name);//接着比较姓名,按照姓名的首字母根据字典顺序排序 &#125; else &#123;//年龄不相同 return i;//按照年龄排序 &#125; &#125; return 0; &#125;&#125; 选择排序可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Testpublic void testTreeSet2() &#123; // 1.创建一个实现了Comparator接口的类对象 Comparator com = new Comparator() &#123; //向TreeSet中添加Customer类的对象，在此compare()方法中，指明是按照Customer的哪个属性排序的 @Override public int compare(Object o1, Object o2) &#123; // TODO 自动生成的方法存根 if(o1 instanceof Customer &amp;&amp; o2 instanceof Customer) &#123; Customer c1 = (Customer) o1; Customer c2 = (Customer) o2; // return c1.getId().compareTo(c2.getId()); int i = c1.getId().compareTo(c2.getId()); //这种方式，返回结果为[name=CC, id=1001], [name=DD, id=1001], [name=BB, id=1002], [name=AA, id=1003], [name=GG, id=1004] if (i == 0) &#123; //如果id相同 return c1.getName().compareTo(c2.getName());//接着比较姓名 &#125; //id不同 return i; //即return c1.getId().compareTo(c2.getId())且值为-1或者1 &#125; /* // 这种方式，返回结果为 [name=DD, id=1001], [name=BB, id=1002], [name=AA, id=1003], [name=GG, id=1004] if(c1.getId()!=c2.getId()) &#123; return i; //即return c1.getId().compareTo(c2.getId())且值为-1或者1 &#125; else &#123; return c1.getName().compareTo(c2.getName()); &#125; &#125; */ //o1或o2不是Customer类的对象 return 0; &#125; &#125;; //2. 将此对象作为形参传递给TreeSet的构造器 TreeSet set = new TreeSet(com); //3. 向TreeSet中添加Comparator接口中的compare方法中涉及的类的对象。 set.add(new Customer("AA",1003)); set.add(new Customer("BB",1002)); set.add(new Customer("GG",1004)); set.add(new Customer("DD",1001)); set.add(new Customer("CC",1001)); for (Object str:set) &#123; System.out.println(str); &#125;&#125; 或者: 1234567891011121314151617181920212223242526272829class Test02 &#123; public static void main(String[] args) &#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) list.add(new Student("Hao LUO", 33)); list.add(new Student("XJ WANG", 32)); list.add(new Student("Bruce LEE", 60)); list.add(new Student("Bob YANG", 22)); // 通过sort方法的第二个参数传入一个Comparator接口对象 // 相当于是传入一个比较对象大小的算法到sort方法中 // 由于Java中没有函数指针、仿函数、委托这样的概念 // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 Collections.sort(list, new Comparator&lt;Student&gt; () &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getName().compareTo(o2.getName()); // 比较学生姓名 &#125; &#125;); for(Student stu : list) &#123; System.out.println(stu); &#125; // 输出结果: // Student [name=Bob YANG, age=22] // Student [name=Bruce LEE, age=60] // Student [name=Hao LUO, age=33] // Student [name=XJ WANG, age=32] &#125;&#125; 2.1.4 集合的遍历有四种方式 :①使用Iterator迭代器 ②增强型for循环 ③普通for循环 ④Iterator迭代器的”古老版本”Enumeration 接口 1234567891011Public static void main(String[]args)&#123; Enumeration enu=new StringTokenizer("ab-c*-df-g","-"); while(enu.hasMoreElements())&#123; System.out.println(enu.nextElement()); &#125;&#125;//结果: abc*dfg 2.2 字符串总结: 1.直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。 2.new出来的字符串是存放在堆里面。 3.对字符串进行拼接操作，也就是做“+”运算的时候，分2中情况： 表达式右边是纯字符串常量，那么存放在栈里面。 表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面 2.2.1 String的intern()方法1234567891011121314151617String str1 = "aaa";String str2 = "bbb";String str3 = "aaabbb";String str4 = str1 + str2;String str5 = "aaa" + "bbb";System.out.println(str3 == str4); // falseSystem.out.println(str3 == str4.intern()); // trueSystem.out.println(str3 == str5);// true/*intern这个方法会首先检查字符串池中是否有str4指向的字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。*//*结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。其实Integer这种包装类型的-128 ~ +127也是存放在常量池里面，比如Integer i1 = 10;Integer i2 = 10; i1 == i2结果是true，估计也是为了性能优化。*/ 2.2.2 equals 和 == 区别“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值； ①: “==”使用情况如下： a) 基本类型，比较的是值 int i = 15; if( i == 15 ) { } b) 引用类型，比较的是地址 String a = “bbbbb”; if (a == “bbbbb”) c) 不能比较没有父子关系的两个对象 ②: equals()方法使用如下： a) 系统类一般已经覆盖了equals()，比较的是内容。 b) 用户自定义类如果没有覆盖equals()，将调用父类的equals （比如是Object），而Object的equals的比较是地址（return (this == obj);） c) 用户自定义类需要覆盖父类的equals() 注意：Object的==和equals比较的都是地址，作用相同 三、JSP3.1 JSP中括号匹配问题注意：if语句的最后一个括号必须和else被分在同一个java脚本元素中 12345678910111213141516171819202122&lt;% if(session.getAttribute("type3").equals("manager")) &#123;%&gt;&lt;% Date creatTime = new Date(session.getCreationTime()); Date lastAccessedTime = new Date(session.getLastAccessedTime()); session.removeAttribute("name3"); out.println("删除名字为name3的属性后,"); out.println("再获取名为name3的属性："); out.println(session.getAttribute("name3")+"&lt;br&gt;"); %&gt;&lt;%&#125; //这里出过错误；注意：if语句的最后一个括号必须和else被分在同一个java脚本元素中else&#123; %&gt;&lt;a href="user.jsp"&gt;进入使用界面&lt;/a&gt;&lt;%&#125;%&gt; 3.2 空格问题:报错: The JSP specification requires that an attribute name is preceded by whitespace 意思是：JSP规范要求在一个属性的名字之前应该是空格。 3.3 注释问题①: JSP动作标志后面不能有注释 123&lt;jsp:forward page="/False.jsp"&gt; //10 行改为:&lt;jsp:forward page="/False.jsp"&gt; ②: 当标签没有配对参数时，配对标签不能换行 jsp异常: Expecting &quot;jsp:param&quot; standard action with &quot;name&quot; and &quot;value&quot; attributes错误 解决方法如下: 123456789&lt;body&gt;&lt;jsp:include page="include/header.jsp"&gt;&lt;/jsp:include&gt;&lt;/body&gt;改为:&lt;body&gt;&lt;jsp:include page="include/header.jsp"&gt;&lt;/jsp:include&gt;&lt;!-- 此处必须在同一行，不能换行 --&gt;&lt;/body&gt; 3.4 双引号问题.jsp文件在tomcat运行，报错提示Attribute value request.getParameter(&quot;name&quot;) is quoted with &quot;which must be escap 12345678910111213例如:&lt;jsp:include page="action.jsp" flush="true"&gt; &lt;jsp:param name="a1" value="&lt;%=request.getParameter("name") %&gt;" /&gt; &lt;jsp:param name="a2" value="&lt;%=request.getParameter("password") %&gt;"/&gt;&lt;/jsp:include&gt; 会导致报错改为：&lt;jsp:include page="action.jsp" flush="true"&gt; &lt;jsp:param name="a1" value="&lt;%=request.getParameter(\"name\") %&gt;" /&gt; &lt;jsp:param name="a2" value="&lt;%=request.getParameter(\"password\") %&gt;"/&gt;&lt;/jsp:include&gt; 即可解决 四、SpringMVC4.1 什么时候使用@PathVariable 什么时候用@RequestParam，有什么联系和区别?4.1.1 使用@PathVariable 的情形:传参在URL路径部分: 例如请求：/blogs/1 此时URI路径中必須要使用占位符{} ， @RequestMapping（/blogs/{id}） 取值：@PathVariable int id 或者@PathVariable （“id”）int id名称要一致 4.1.2 使用@RequestParam的情形:传参在参数部分: 例如请求：blogs?blogId=1 此时URI路径为@RequestMapping（/blogs/）取值：@RequestParam int id或者@RequestParam（“blogId”） int id 4.1.3 联系 和 区别:@RequestParam和@PathVariable都能够完成类似的功能——因为本质上，它们都是用户的输入，只不过输入的部分不同，一个在URL路径部分，另一个在参数部分。 要访问一篇博客文章，这两种URL设计都是可以的： 通过@PathVariable，例如/blogs/1 通过@RequestParam，例如/blogs?blogId=1 那么究竟应该选择哪一种呢？建议： ①: 当URL指向的是某一具体业务资源（或资源列表），例如博客，用户时，使用@PathVariable ②: 当URL需要对资源或者资源列表进行过滤，筛选时，用@RequestParam 例如我们会这样设计URL： /blogs/{blogId} /blogs?state=publish而不是/blogs/state/publish`来表示处于发布状态的博客文章 4.1.4 一个需要注意的问题:一旦我们在方法中定义了@RequestParam变量，如果访问的URL中不带有相应的参数，就会抛出异常——这是显然的，Spring尝试帮我们进行绑定，然而没有成功。但有的时候，参数确实不一定永远都存在，这时我们可以通过定义required属性： @RequestParam(value = &quot;id&quot;, required = false) 当然，在参数不存在的情况下，可能希望变量有一个默认值： @RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;) 4.2 &lt;mvc:annotation-driven/&gt; /&lt;context:annotation-config/&gt;和&lt;context:component-scan&gt;/&lt;mvc:view-controller/&gt;&lt;mvc:default-servlet-handler/&gt;4.2.1 &lt;mvc:annotation-driven/&gt; 详解:关于这个标签，网上很多资料的信息都过时了，还是基于Spring3.1以前的版本（现在最新的是5.1.2） Spring3.1以前的版本: &lt;mvc:annotation-driven/&gt;会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter,两个bean,分别为HandlerMapping的实现类和HandlerAdapter的实现类,是spring MVC为@Controllers分发请求所必须的, Spring3.1以后的版本: 从3.1.x版本开始对应实现类改为了RequestMappingHandlerMapping和RequestMappingHandlerAdapter. 其对应的实现类：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser 它会向Spring容器中注册14个Bean，而其中主要的是下面几个： 1 RequestMappingHandlerMapping2 BeanNameUrlHandlerMapping 3 RequestMappingHandlerAdapter4 HttpRequestHandlerAdapter5 SimpleControllerHandlerAdapter 6 ExceptionHandlerExceptionResolver7 ResponseStatusExceptionResolver8 DefaultHandlerExceptionResolver 前两个是HandlerMapping接口的实现类，用来处理请求映射的 其中第一个是处理@RequestMapping注解的,并将其注册到请求映射表中 第二个会将controller类的名字映射为请求url 中间三个是用来处理请求的适配器.具体点说就是确定调用哪个controller的哪个方法来处理当前请求 第一个是处理@Controller注解的处理器，支持自定义方法参数和返回值 第二个是处理继承HttpRequestHandler的处理器 第三个是处理继承自Controller接口的处理器 另外还将提供以下支持： ① 支持使用ConversionService实例对表单参数进行类型转换； ② 支持使用@NumberFormatannotation,@DateTimeFormat注解完成数据类型的格式化； ③ 支持使用@Valid注解对Java bean实例进行JSR 303验证； ④ 支持使用@RequestBody和@ResponseBody注解 综上，&lt;mvc:annotation-driven/&gt;标签主要是用来帮助我们处理请求映射，决定是哪个controller的哪个方法来处理当前请求，以及异常处理。 而在最新的spring项目中，如果不配置&lt;mvc:annotation-driven/&gt;，应用也可以正常处理请求。原因是什么呢？ 经过debug DispatcherServlet的源码，发现如果不配置，spring将从DispatcherServlet.properties这个配置文件中加载默认配置，也是可以将上述的所有类注册到容器中的。 因此&lt;mvc:annotation-driven/&gt;这个标签其实是可以省略不写的。 &lt;mvc:annotation-driven /&gt;的可选配置 1234567891011121314&lt;mvc: annotation-driven message-codes-resolver="bean name" validator="bean name" conversion-service="bean name" ignoreDefaultModelOnRedirect="true or false"&gt; &lt;mvc:message-converters&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;mvc:argument-resolvers&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:argument-resolvers&gt; &lt;mvc:return-value-handlers&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:return-value-handlers&gt; &lt;/mvc:annotation-driven&gt; 4.2.2 什么时候需要写&lt;mvc:annotation-driven/&gt;第一种情形: 进行数据格式化/校验 时用到: @DataTimeFormat, @NumberFormatAnnotation,@valid必须加上&lt;mvc:annotation-driven/&gt;因为@DataTimeFormat, @NumberFormatAnnotation,@Valid,@RequestBody,@ResponseBody等注解,是由它实现的 第二种情形: 对表单参数进行自定义数据类型转换时需要装配自定义conversion-service: 需要在它里面加上conversion-service属性 第三种情形: 为了直接响应转发的路径而无需再经过Handler而加入&lt;mvc:view-controller/&gt;导致RequestMapping不起作用 第四种情形: 处理静态资源时加入了&lt;mvc:default-servlet-handler/&gt;,导致RequestMapping不起作用 123456789101112131415161718//注解方式：@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125;//XML方式：&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 4.2.3 &lt;context:annotation-config/&gt;简介:(可以被&lt;context:component-scan&gt;取代)这是一条向Spring容器中注册如下 AutowiredAnnotationBeanPostProcessor CommonAnnotationBeanPostProcessor PersistenceAnnotationBeanPostProcessor RequiredAnnotationBeanPostProcessor 这4个BeanPostProcessor.注册这4个BeanPostProcessor的作用，就是为了你的系统能够识别相应的注解。 那么哪些注释依赖这些Bean呢。 如果想使用 @Resource、@PostConstruct、@PreDestroy等注解就必须声CommonAnnotationBeanPostProcessor。 如果想使用 @PersistenceContext注解，就必须声明PersistenceAnnotationBeanPostProcessor的Bean。 如果想使用 @Autowired注解，那么就必须事先在 Spring 容器中声明 AutowiredAnnotationBeanPostProcessor Bean。 如果想使用 @Required的注解，就必须声明RequiredAnnotationBeanPostProcessor的Bean。 同样，传统的声明方式如下： &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &quot;/&gt; 但是，就一般而言，这些注解我们是经常使用，比如Antowired,Resuource等注解，如果总是按照传统的方式一条一条的配置，感觉比较繁琐和机械。于是Spring给我们提供了&lt;context:annotation-config/&gt;的简化的配置方式。 注意：使用了&lt;context:annotation-config/&gt;注解，仍然还要在xml中手动声明用@Controller,@Service,@Repository等注解修饰的类 以@Autowired为例: 也就是说&lt;context:annotation-config/&gt;只保证你能在程序中写@Autowired等注解,但@Autowired是否发挥作用,它不管; @Authwired要想发挥作用,必须保证spring容器中有一个bean和你使用@Authwired注解的属性类型一致; 而要想将一个java类作为一个被spring容器管理的bean: ①: 要么在xml文件中配置, ②: 要么在类上使用注解(@Component,@Controller,@Service,@Repository等注解)然后通过&lt;context:component-scan base-package=”com.zwq.controller”&gt;的包扫描方式将指定包下使用这些注解的类添加到spring容器; 4.2.4 &lt;context:component-scan&gt;简介:&lt;context:component-scan&gt;首先有和&lt;context:annotation-config/&gt;一样的作用，此外，它还可以扫描指定包下的类，将拥有(@Component,@Controller,@Service,@Repository)注解的它们注册到Spring容器中,而不用我们手动在xml文件中去注册bean。 综上,也就是说,如果用&lt;context:annotation-config/&gt;我们还需要配置Xml注册Bean,而使用&lt;context:component-scan /&gt;的话，注册的步骤都免了，当然前提是我们对需要扫描的类使用的注解（比如@Componet,@Service），而如果同时使用两个配置的话，&lt;context:annotation-config/&gt;会被忽略掉（==如果配置了&lt;context:component-scan&gt;，就可以不配置&lt;context:annotation-config/&gt;了==） 等价于注解方式: @Configuration @ComponentScan(“org.example.web”) public class WebConfig { // … } 4.2.5 &lt;mvc:view-controller/&gt;直接响应转发的路径而无需再经过Handler的方法: Springmvc.xml:中配置直接转发的页面 可以直接响应转发的路径而无需再经过Handler的方法,但是配置了这个后Handler就失效了(即RequestMapping就失效了)，如果要想让两种方式都起作用，需要配置mvc:annotation-driven.即&lt;mvc:view-controller path=&quot;/success&quot;view-name=&quot;success&quot;/&gt; 4.3 导致RequestMapping失效的情况：4.3.1 三种情形:情形一： &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; 情形二： 配置直接转发的页面: 可以直接响应转发的路径而无需再经过Handler的方法,但是配置了这个后Handler就失效了(即RequestMapping就失效了)，如果要想让两种方式都起作用，需要配置mvc:annotation-driven &lt;mvc:view-controller path=&quot;/success&quot;view-name=&quot;success&quot;/&gt; 情形三: &lt;mvc:resources location=&quot;WEB-INF/static/&quot;mapping=&quot;/resources/**&quot;/&gt; 4.3.2 解决方法: 加上下面这句&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 4.3.3 分析:由于只配置&lt;mvc:default-servlet-handler/&gt;,导致AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter都没有,所以无法处理@RequestMapping. 适配器 补充: 处理静态资源的问题： default-servlet-handler将在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler,它会对进DispatcherServlet的请求进行筛查 如果发现是没有经过映射的请求,就将该请求交由WEB应用服务器默认的Servlet处理.(而不会报没有映射的警告) 如果不是静态资源的请求，才由DispatcherServlet继续处理一般WEB应用服务器默认的Servlet的名称都是default. 若所使用的WEB服务器的默认Servlet名称不是default，则需要通过default-servlet-name属性显式指定 ​ 五、Spring5.1 关于 /* 和 /** 和 /的区别5.1.1/*会拦截所有请求(包括.jsp), 拦截所有的文件夹，不包含子文件夹即带后缀的请求(扩展映射,如 /test.html,/a/b/c.jsp等 ), 和不带后缀的请求(对根目录的请求/, 对根目录之后的请求/a,/a/b/c等) Example: http://www/zeyizong.com/funding/test/index.html 如果配置/funding/*是不走拦截器的，配置/funding/**则会走拦截器 5.1.2/** 会拦截所有请求 , 拦截所有的文件夹及里面的子文件夹http://www/zeyizong.com/funding/index.html 配置/funding/*和配置/funding/**都会走拦截器 5.1.3/会拦截除 .jsp的所有请求/会拦截所有路径映射和扩展映射中的.html .txt等请求,但不会拦截扩展映射中的.jsp的请求(如果没有请求的该.jsp文件,那么404错误) 对根目录/的请求,默认会在后面加上如下的后缀的文件名 12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 5.1.4 在SpringMVC中:我们如果把前端控制器的url-pattern配置为&lt;url-pattern&gt;/*&lt;/url-pattern&gt;那么就会发生404错误，为什么呢？？当我们发送请求到Tomcat服务器的时候，/*匹配时，虽然Tomcat会把我们的请求正确交给我们的Servlet执行，但是当SprinMVC的视图解析器转发jsp视图的时候(看源码知道的)，因为url-pattern是/*，所以Tomcat又会拦截我们的请求，把该请求发送给我们配置好的Servlet，导致我们SpringMVC的处理器映射器找不到Handler，最终发生404错误。]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>专治疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关面试题及答案]]></title>
    <url>%2FJVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[1. 简述Java内存管理机制，以及垃圾回收的原理和使用过Java调优工具内存管理的职责为分配内存，回收内存。 没有自动内存管理的语言/平台容易发生错误。 典型的问题包括悬挂指针问题，一个指针引用了一个已经被回收的内存地址，导致程序的运行完全不可知。 另一个典型问题为内存泄露，内存已经分配，但是已经没有了指向该内存的指针，导致内存泄露。 程序员要花费大量时间在调试该类问题上。 2. 描述JVM加载class文件的原理机制JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。 类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 3. 说说JVM原理？内存泄漏与溢出的区别？何时产生内存泄漏？答:JVM原理： JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，所有的Java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件） 4. Java内存区域与内存溢出异常:Java虚拟机 运行时数据区: Java虚拟机在运行Java程序时会将它管理的内存划分为若干个不同的数据区域,他们创建和销毁的时间以及用途是不同的 口诀: 方程堆，虚本栈 5. 程序计数器5.1 什么是程序计数器？ 程序计数器是一块 较小 的内存空间，它可以看做是==当前线程==所执行的字节码的 ==行号指示器== ；在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 ———–摘抄自 周志明版 《深入理解java虚拟机》 P39 简单的理解为，是程序计数器保证了程序的正常执行 ； 5.2 有什么特点? 线程私有的 是java虚拟机规范里面， 唯一 一个 没有规定任何 OutOfMemoryError 情况的区域 生命周期随着线程，线程启动而产生，线程结束而消亡 如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址 如果正在执行的是Native 方法，则这个计数器值为空（Undefined） 5.3 为什么具有这些特点?要想理解什么是程序计数器，以及它的特点，需要理解上文中的一句话 这里重点理解 ：程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码 12345678// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子public void haha()&#123;// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令 0 xxxx .... 2 xxxx .... 4 xx ... 5 xxx ...&#125; 上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的 ； 理解了程序计数器，就好理解它的这些特点了； 我们都知道，java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ； 我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？ 答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）； 那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，==因此，程序计数器的内存空间是线程私有的 ；==这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！ 那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！==因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被创建== 程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；==因此，永远都不可能内存溢出的；因此，jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域；== 为什么执行的是native 方法时，为undefined ==当线程执行的是本地方法的时候，程序计数器中保存的值是空==（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，==根本不会产生字节码文件==，因此，程序计数器也就不会做任何记录 ； 那native 方法的多线程是如何实现的呢？ 答： native 方法是通过调用系统指令来实现的，那系统是如何实现多线程的则 native 就是如何实现的 举例理解程序计数器 说线程恢复等基础功能都需要依赖这个程序计数器来完成，首先我们得知道： 线程是CPU 最小的调度单元Java 虚拟机的多线程是通过切换线程并分配处理器执行时间的方式来实现的，在任何一个确定的时间，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令 如有如下图过程，当A 线程先向处理器发出指令，但当执行到中途一半时，B线程过来执行，且优先级高，此时处理器将A 挂起，B 执行，当B 执行结束需要唤醒A 同时得知道A 的执行位置，就可以查看线程A 中的计数器指令 6. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 补充: java的跨平台不是java源程序的跨平台 ，如果是这样，那么所有语言都是跨平台的， java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。最后解释下机器码和字节码的区别:一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码 意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论哪种硬件，只要你装有jvm,那么他就认识这个JAVA字节码至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码. 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如 处理器 、 堆栈 、 寄存器 等，还具有相应的 指令 系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（ 字节码 ），就可以在多种平台上不加修改地运行。 Java虚拟机其实就是一个进程。Java之所以可以跨平台，也是因为，java源程序被编译成了.class的字节码文件，不管在哪个平台，只要有jvm，都可以认识这个.class文件。这也就是我们，常说的，一次编译，永久运行！]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>JVM相关面试题及答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作相关面试题及答案]]></title>
    <url>%2FLinux%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[1. Linux 文件权限一共10 位长度，分成四段，第三段表示的内容是 （） A. 文件类型 B. 文件所有者的权限 C. 文件所有者所在组的权限 D. 其他用户的权限 答案：C 2. 当使用RMI技术实现远程方法调用时，能为远程对象生成Sub和Skeleton命令的是（） A. Mic B. mid C. mitegistry D. policytool 答案：A 3. 终止一个前台进程可能用到的命令和操作 （） A. kill B. &lt; CTRL &gt;;+C C. shut down D. halt 答案：B 4. 在使用mkdir 命令创建新的目录时，在其父目录不存在时先创建父目录的选项是 （） A. -m B. -d C. -d D. -p 答案：D 5. 下面关于i 节点描述错误的是 （） A. i 节点和文件是一一对应的（每个文件都有唯一一个索引结点号与之对应，而对于一个索引结点号，却可以有多个文件名与之对应） B. i 节点能描述文件占用的块数 C. i 节点描述了文件大小和指向数据块的指针 D. 通过i 节点实现文件的逻辑结构和物理结构的转换 答案：A 6. 一个文件名字为rr.Z，可以用来解压缩的命令是： （） A. tar B. gzip C. compress D. uncompress 答案：D 7. 一台主机要实现通过局域网与另一个局域网通信，需要做的工作是 （） A. 配置域名服务器 B. 定义一条本机指向所在网络的路由 C. 定义一条本机指向所在网络网关的路由 D. 定义一条本机指向目标网络网关的路由 答案：C 8. 建立动态路由需要用到的文件有 （） A. /etc/hosts B. /etc/HOSTNAME C. /etc/resolv.conf D. /etc/gateways 答案：D 9. 局域网的网络地址192.168.1.0/24，局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20 访问172.16.1.0/24 网络时，其路由设置正确的是 （） A. route add –net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1 B. route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1 C. route add –net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0 metric 1 D. route add default 192.168.1.0 netmask 172.168.1.1 metric 1 答案：B 10. 下列提法中，不属于ifconfig 命令作用范围的是 （） A. 配置本地回环地址 B. 配置网卡的IP地址 C. 激活网络适配器 D. 加载网卡到内核中 答案：D 11. 下列关于链接描述，错误的是（） A. 硬链接就是让链接文件的i 节点号指向被链接文件的i 节点 B. 硬链接和符号连接都是产生一个新的i 节点 C 链接分为硬链接和符号链接 D. 硬连接不能链接目录文件 答案：B 链接的方式可以分为两种: 一种是硬链接（Hard Link），另一种是软链接或者也称为符号链接（Symbolic Link） 硬链接是指通过索引节点来进行链接。 软链接类似于windows系统中的快捷方式 软连接和硬链接的特点： 软链接： 1.软链接是存放另一个文件的路径的形式存在—-快捷方式。 2.软链接可以 跨文件系统 ，硬链接不可以。 3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。 4.软链接可以对目录进行链接。 硬链接： \1. 硬链接，以文件副本的形式存在。但不占用实际空间。 \2. 不允许给目录创建硬链接,只可对文件创建； \3. 硬链接只有在同一个文件系统中才能创建。 \4. 删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。 \5只能对已存在的文件进行创建； 12. 在局域网络内的某台主机用ping 命令测试网络连接时发现网络内部的主机都可以连同，而不能与公网连通，问题可能是（） A. 主机IP设置有误 B. 没有设置连接局域网的网关 C. 局域网的网关或主机的网关设置有误 D. 局域网DNS服务器设置有误 答案：C 13. 下列文件中，包含了主机名到IP 地址的映射关系的文件是： A. /etc/HOSTNAME B. /etc/hosts C. /etc/resolv.conf D. /etc/networks 答案：B 14. 不需要编译内核的情况是（） A. 删除系统不用的设备驱动程序时 B. 升级内核时 C. 添加新硬件时 D. 将网卡激活 答案：D 15. 在shell 中变量的赋值有四种方法，其中，采用name=12 的方法称 （） A. 直接赋值 B. 使用read命令 C. 使用命令行参数 D. 使用命令的输出 答案：A 16. （）命令可以从文本文件的每一行中截取指定内容的数据。 A. cp B. dd C. fmt D. cut 答案：D 17. 下列不是Linux 系统进程类型的是（） A. 交互进程 B. 批处理进程 C. 守护进程 D. 就绪进程 答案：D 18. 在安装Linux 的过程中的第五步是让用户选择安装方式，如果用户希望安装部分组件（软件程序），并在选择好后让系统自动安装，应该选择的选项是（） A. full B. expert C. newbie D. menu 答案：D 19. Linux 有三个查看文件的命令，若希望在查看文件内容过程中可以用光标上下移动来查看文件内容，应使用（）命令 A. cat B. more C. less D. menu 答案：C 20.下列信息是某系统用ps –ef 命令列出的正在运行的进程 （）进程是运行Internet 超级服务器，它负责监听Internet sockets 上的连接，并调用合适的服务器来处理接收的信息。 A. root 1 4.0 0.0 344 204? S 17:09 0:00 init B. root 2 0.0 0.1 2916 1520? S 17:09 0:00 /sbin/getty C. root 3 0.0 0.2 1364 632? S 17:09 0:00 /usr/sbin/syslogd D. root 4 0.0 1344 1204? S 17:09 0:10 /usr/sbin/inetd 答案：D 21. 当我们与某远程网络连接不上时，就需要跟踪路由查看，以便了解在网络的什么位置出现了问题，满足该目的的命令是（） A. ping B. ifconfig C. traceroute D. netstat 答案：C 22. 对名为fido 的文件用chmod 551 fido 进行了修改，则它的许可权是（） A. -rwxr-xr-x B. -rwxr–r– C. -r–r–r– D. -r-xr-x—x 答案：D 23. DNS 域名系统主要负责主机名和（）之间的解析。 A. IP地址 B. MAC地址 C. 网络地址 D. 主机别名 答案：A 24. 用ls –al 命令列出下面的文件列表，（）文件是符号连接文件 A. -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello B. -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbey C. drwxr–r– 1 hel users 1024 Sep 10 08:10 zhang D. lrwxr–r– 1 hel users 2024 Sep 12 08:12 cheng 答案：D 25. Linux 系统通过（）命令给其他用户发消息。 A. less B. mesg C. write D. echo to 答案：C 26. NFS 是（）系统。 A. 文件 B. 磁盘 C. 网络文件 D. 操作 答案：C 27. （）命令可以在Linux 的安全系统中完成文件向磁带备份的工作 A. cp B. tr C. dir D. cpio 答案：D 参考地址: &lt;https://www.jianshu.com/p/d222e00faae1&gt; 功能说明：备份文件。 cpio 指令可以将文件复制到 存档包（archives），也可以从存档包（archives）复制出文件。缺省情况下，cpio从标准输入读取输入数据，向标准输出写入输出数据。 归档包（archives）是一种包含其他文件和有关信息的文件。 有关信息包括： 文件名, 属主, 时间戳(timestamp), 和访问权限。 cpio支持下列的归档格式: binary, old ASCII, new ASCII, crc, HPUX binary, HPUX old ASCII, old tar, POSIX.1 tar。 默认情况下，cpio创建二进制格式存档，以便与旧的cpio程序兼容。从档案中提取时，cpio会自动识别正在读取的归档类型，并可以读取在具有不同字节顺序的计算机上创建的归档。 28. Linux 文件系统的文件都按其作用分门别类地放在相关的目录中，对于外部设备文件，一般应将其放在（）目录中 A. /bin B. /etc C. /dev D. /lib 答案：C 29. 在重新启动Linux 系统的同时把内存中的信息写入硬盘，应使用（）命令实现 A. # reboot B. # halt C. # reboot D. # shutdown –r now 答案：D 30. 关闭linux 系统（不重新启动）可使用命令（） A. Ctrl+Alt+Del B. halt C. shutdown -r now D. reboot 答案：B 31. 实现从IP 地址到以太网MAC 地址转换的命令为： （） A. ping B. ifconfig C. arp D. traceroute 答案：C 32. 在vi 编辑器中的命令模式下，重复上一次对编辑的文本进行的操作，可使用（）命令 A. 上箭头 B. 下箭头 C. &lt; .&gt;; D. &lt; *&gt;; 答案：C 33. 在vi 编辑器中的命令模式下，删除当前光标处的字符使用（）命令 A. &lt; x&gt;; B. &lt; d&gt;;&lt; w&gt;; C. &lt; D&gt;; D. &lt; d&gt;;&lt; d&gt;; 答案：A 34. .在vi 编辑器中的命令模式下，键入（）可在光标当前所在行下添加一新行 A. &lt; a&gt;; B. &lt; o&gt;; C. &lt; I&gt;; D. A 答案：B 35. 退出交互模式的shell，应键入（） A. &lt; Esc&gt;; B. ^q C. exit D. quit__ 答案：C]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Linux操作相关面试题及答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架相关面试题]]></title>
    <url>%2F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[一、说说什么是框架：框架(framework)是一个框子–》指约束性，也是一个架子–》指支撑性IT语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，在此结构上可以根据具体问题扩展、按插更多的组成部分，从而更迅速和方便地架构完整的解决问题的方案。 1）框架本身一般不完整到可以解决特定问题，但是可以帮助您快速解决特定问题： 没有框架所有的工作都从零开始做，有了框架，为我们提供了一定的功能。我们就可以在框架的基础上开发，极大的解决了生产力。 不同的框架，是为了解决不同领域的问题，一定要为了解决问题才去学习框架。 2）框架天生就是为了扩展而设计的 3）框架里面可以为后续的组件提供很多辅助性、支撑性的方便易用的实用工具(utilities)，也就是框架时常配套一些帮组解决某类问题的库(libraries）或工具（tools）. 在java中就是一系列的jar包，其本质就是对jdk功能的扩展。 1.1 简单说一下MVC框架？是为了解决传统MVC模式(jsp+servlet+javabean)一些问题而出现的框架 1.1.1 传统MVC模式模式问题：1） 所有的Servlet和Servlet映射都要配置在web.xml中，如果项目太大，web.xml就太庞大并且不能实现模块化管理。 2）Servlet的主要功能就是接受参数、调用逻辑、跳转页面，比如像其他字符编码、文件上传等功能也要写在Servlet中，不能让Servlet主要功能而需要做处理一些特例。 3）接受参数比较麻烦 (String name = request.getParameter(“name”))，不能通过model接受，只能单个接收，接收完成后转换封装model。 4）跳转页面方式比较单一(forward,redirect)，并且当我们的页面名称发生改变时需要改变Servlet源代码。 1.1.2 现在比较常用的MVC框架：webwork Struts Struts2 SpringMVC 1.2 简单讲一下SpringMVC的执行流程？1）用户向服务器发送请求，请求被Spring 前端控制Servlet 即DispatcherServlet捕获； 2）DispatcherServlet 对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象 （包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； 3）DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） 4） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 5）Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 6）根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； 7）ViewResolver 结合Model和View，来渲染视图* 8）将渲染结果返回给客户端。 快速记忆： 核心控制器捕获请求，查找Hander，执行Handler，选择ViewResolver，通过ViewResoler渲染视图并返回 1.3 什么是ORM对象关系映射(Object Relation Mapping，简称ORM)模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术，简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中，那么到底如何实现持久化呢？ ①: 一种简单的方案时采用硬编码方式(jdbc操作sql方式)，为每一种可能的数据库访问操作提供单独的方法。 这种方案存在以下不足： 持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口 持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加软件的维护难度。 ②: ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁，Java典型的ORM框架有：Hibernate，ibatis(mybtis)，speedframework。 ORM框架的方法论基于三个核心原则： 简单：以最基本的形式建模数据 传达性：数据库结构被任何人都能理解的语言文档化 精确性：基于数据模型创建正确标准化了结构 1.4 简单讲一下webservice使用的场景webservice是一个SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过Internet进行基于http协议的网络应用间的交互。 1、异构系统(不同的开发语言)的整合 2、不同客户端的整合 (浏览器、手机端(android\ios)、微信) 3、实实在在的例子： 天气预报：可以通过实现webservice客户端调用远程天气服务实现的 4、单点登录：一个服务实现所有系统的登录 二、Spring2.1什么是 Spring 框架？Spring 框架有哪些主要模块？Spring是J2EE应用程序框架，是轻量级的IOC和AOP的容器框架，主要针对JavaBean的生命周期进行管理的轻量级容器，可以单独使用，也可以和struts框架，ibatis框架等组合使用。 Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 2.2 Spring中的两大核心2.2.1 IOC(Inversion of Control)ioc控制反转，又称为“依赖注入”； IOC的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器负责将这些联系在一起。 其原理是基于OO设计原则的The Hollywood Principle：Don’t call us, we’ll call you（别找我，我会来找你的）。也就是说，所有的组件都是被动的（Passive），所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容 器负责管理。 简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。 在 Java 中依然注入有以下三种实现方式：1.构造器注入2.Setter 方法注入3.接口注入 2.2.2 AOP 面向切面编程核心原理：使用动态代理的设计模式在执行方法前后或出现异常常做加入相关逻辑 我们可以使用AOP来做： 1）事务处理：执行方法前开启事务，执行完成后关闭事务，出现异常后回滚事务 2）权限判断：在执行方法前，判断是否具有权限 3）日志：在执行前进行日志处理 2.3 讲一下Spring的事务的传播特性多个事物存在是怎么处理的策略 1）PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 2）PROPAGATION_SUPPORTS：如果存在一个事务，支持当前事务，如果当前没有事务，就以非事务方式执行。 3）PROPAGATION_MANDATORY：如果存在一个事务，支持当前事务，如果当前没有事务，就抛出异常。 4）PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 5）PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 6）PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 7）PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 2.4 BeanFactory 和 ApplicationContext 有什么区别?BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。==ApplicationContext容器包括 BeanFactory 容器的所有功能== applicationcontext 如同 beanfactory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能:①: 提供了支持国际化的文本消息②: 统一的资源文件读取方式③: 已在监听器中注册的 bean 的事件以下是三种较常见的 ApplicationContext 实现方式：1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。ApplicationContext context = new ClassPathXmlApplicationContext(“application.xml”);2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。ApplicationContext context = new FileSystemXmlApplicationContext(“application.xml”);3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 2.5 Spring 提供几种配置方式来设置元数据？将 Spring 配置到应用开发中有以下三种方式：1.基于 XML 的配置2.基于注解的配置3.基于 Java 的配置 2.6 请解释下 Spring 框架中的 IOC？Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了Spring 框架 IOC 容器的基础。BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的WebApplicationContext。 2.7 如何使用 XML 配置的方式配置 Spring？SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的 Spring 配置类型（比如声明的方式或基于 Java Class 的配置方式）Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 12345678&lt;beans&gt;&lt;!-- JSON Support --&gt;&lt;bean name="viewResolver"class="org.springframework.web.servlet.view.BeanNameViewResolver"/&gt;&lt;bean name="jsonTemplate"class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt;&lt;bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/&gt;&lt;/beans&gt; 2.8 如何用基于 Java 配置的方式配置 Spring？Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。 由@Bean 注解的方法将会实例化、配置和初始化一个新对象，这个对象将由 Spring 的 IOC 容器来管理。@Bean 声明所起到的作用与 元素类似。 被@Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被@Configuration 声明的类可以通过在同一个类的内部调用@bean 方法来设置嵌入 bean 的依赖关系。最简单的@Configuration 声明类请参考下面的代码： 12345678@Configurationpublic class AppConfig&#123; @Bean public MyService myService() &#123; //MyServiceImpl类是MyService接口的实现类 return new MyServiceImpl(); &#125;&#125; 对于上面的@Beans 配置文件相同的 XML 配置文件如下： 123&lt;beans&gt; &lt;bean id="myService" class="com.abc.services.MyServiceImpl"/&gt;&lt;/beans&gt; 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化： 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; 要使用组件组建扫描，仅需用@Configuration 进行注解即可： 12345@Configuration@ComponentScan(basePackages = "com.gupaoedu")public class AppConfig &#123; ....&#125; 在上面的例子中，com.gupaoedu 包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean 定义进行注册。 如果你 要在你的web应用开发中选用上述的配置的方式的话 ,需AnnotationConfigWebApplicationContext 类来读取配置文件,可以用来配置 Spring 的Servlet 监听器 ContrextLoaderListener 或者 Spring MVC DispatcherServlet。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;web-app&gt; &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContextinstead of the default XmlWebApplicationContext --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Configuration locations must consist of one or more comma- or space-delimitedfully-qualified @Configuration classes. Fully-qualified packages may also bespecified for component-scanning --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.gupaoedu.AppConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-cla ss&gt; &lt;/listener&gt; &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContextinstead of the default XmlWebApplicationContext --&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- Again, config locations must consist of one or more comma- or space-delimitedand fully-qualified @Configuration classes --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.gupaoedu.web.MVCConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- map all requests for /web/* to the dispatcher servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/web/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2.9 Spring中为什么要开启注解扫描之前在学spring框架时候一直在疑惑为什么要开启注解扫描,大家都知道spring框架为了降低程序间的耦合性,提出了三大思想之一的IOC,IOC其实就是控制反转,什么是控制反转,就是把创建对象的权力交给别人.我们之前创建对象的时候,直接new,创建对象的主动权在我们手里,而sprig它把这种主动权交给底层的IOC容器,我们需要什么对象直接把它的类配置在bean标签里面,当我们需要使用的时候,直接拿出来用就好,我们在配置bean标签的时候,其实就是把它放在IOC容器里的一个过程.,IOC容器会代替我们完成创建一个对象的操作,而这里注解的作用和bean标签是一样的且更方便,这里我们就要说使用注解要开启注解扫描的作用了,当spring启动时,会根据配置去扫描某些包里面的类,得到类或方法上的注解,不同注解会进行不同的操作,如@Component会把这个类的实例放入IOC容器中,以方便后面使用时直接拿来用.@Autowired会自动把IOC容器内的对象取出来赋值给某个变量,如果没有开启包注解扫描,那么在类或者方法上配置的注解是毫无意义的. 2.10 怎样用注解的方式配置 Spring？Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML方式的 bean 描述，可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 1234&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt;&lt;/beans&gt; 2.11 什么是事务?事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题 2.12 事务并发所可能存在的四大问题：脏读：一个事务读到另一个事务未提交的更新数据。 不可重复读：一个事务两次读同一行数据，可是这两次读到的数据不一样。 幻读：一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。 丢失更新：撤消一个事务时，把其它事务已提交的更新的数据覆盖了。 2.13 事务有四大特性（ACID）事务有四大特性（ACID）: ①: 原子性（Atomicity）: 事务是一个原子操作,是一个不可分割的工作单位，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 ②: 一致性（Consistency）: 事务在完成时，必须是所有的数据都保持一致状态。 ③: 隔离性（Isolation）: 并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性。 ④: 持久性（Durability）: 一旦事务完成，数据库的改变必须是持久化的。 2.14 事务管理的两种方式 2.15 声明式事务管理声明式事务管理有两种常用的方式: 一种是基于tx和aop命名空间的xml配置文件， 一种是基于@Transactional注解， 随着Spring和Java的版本越来越高，大家越趋向于使用注解的方式，下面我们两个都说。 ①: 基于tx和aop命名空间的xml配置文件 配置文件 123456789&lt;tx:advice id="advice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="insert" propagation="REQUIRED" read-only="false" rollback-for="Exception"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id="pointCut" expression="execution (* com.gray.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="advice" pointcut-ref="pointCut"/&gt;&lt;/aop:config&gt; 12345678910111213141516//测试代码@Testpublic void transTest() &#123; System.out.println("before transaction"); Integer sum1 = baseSevice.sum(); System.out.println("before transaction sum: "+sum1); System.out.println("transaction...."); try&#123; baseSevice.insert("INSERT INTO tbl_account VALUES (100);",true); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println("after transaction"); Integer sum2 = baseSevice.sum(); System.out.println("after transaction sum: "+sum2);&#125; ②: 基于@Transactional注解 这种方式最简单，也是最为常用的，只需要在配置文件中开启对注解事务管理的支持。 12&lt;!-- 声明式事务管理 配置事物的注解方式注入--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 123456789//然后在需要事务管理的地方加上@Transactional注解，如：@Transactional(rollbackFor=Exception.class)public void insert(String sql, boolean flag) throws Exception &#123; dao.insertSql(sql); // 如果flag 为 true ，抛出异常 if (flag)&#123; throw new Exception("has exception!!!"); &#125;&#125; rollbackFor属性指定出现Exception异常的时候回滚，遇到检查性的异常需要回滚，默认情况下非检查性异常，包括error也会自动回滚。 测试代码和上面那个一样 2.16 IOC 和 DI 的理解2.16.1 IoC是什么Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”. ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象,也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了. 2.16.2 IoC(控制反转)首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 2.16.3 DI(依赖注入)IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 2.16.4 我对IoC(控制反转)和DI(依赖注入)的理解在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。 所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。 这是我对Spring的IoC(控制反转)的理解。DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了 2.17 什么是 Spring inner beans？在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。内部 bean 可以用 setter 注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例，然后在 Customer 内部使用。 12345678910public class Customer&#123; private Person person; //Setters and Getters&#125;public class Person&#123; private String name; private String address; private int age; //Setters and Getters&#125; 内部 bean 的声明方式如下： 12345678910&lt;bean id="CustomerBean" class="com.howtodoinjava.common.Customer"&gt; &lt;property name="person"&gt; &lt;!-- This is inner bean --&gt; &lt;bean class="com.howtodoinjava.common.Person"&gt; &lt;property name="name" value="lokesh" /&gt; &lt;property name="address" value="India" /&gt; &lt;property name="age" value="34" /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 2.18 请举例说明如何在 Spring 中注入一个 Java 集合？Spring 提供了以下四种集合类的配置元素：1、 : 该标签用来装配可重复的 list 值。2、 : 该标签用来装配没有重复的 set 值。3、: 该标签可用来注入键和值可以为任何类型的键值对。4、 : 该标签支持注入键和值都是字符串类型的键值对。下面看一下具体的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans&gt; &lt;!-- Definition for javaCollection --&gt; &lt;bean id="javaCollection" class="com.gupaoedu.JavaCollection"&gt; &lt;!-- java.util.List --&gt; &lt;property name="customList"&gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- java.util.Set --&gt; &lt;property name="customSet"&gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- java.util.Map --&gt; &lt;property name="customMap"&gt; &lt;map&gt; &lt;entry key="1" value="INDIA"/&gt; &lt;entry key="2" value="Pakistan"/&gt; &lt;entry key="3" value="USA"/&gt; &lt;entry key="4" value="UK"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- java.util.Properties --&gt; &lt;property name="customProperies"&gt; &lt;props&gt; &lt;prop key="admin"&gt;admin@gupaoedu.com&lt;/prop&gt; &lt;prop key="support"&gt;support@gupaoedu.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.19 请解释 Spring Bean 的自动装配？在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。 XML 方式: 下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配：&lt;bean id=&quot;employeeDAO&quot; class=&quot;com.gupaoedu.EmployeeDAOImpl&quot; autowire=&quot;byName&quot; /&gt; 注解方式: 除了 bean 配置文件中提供的自动装配模式，还可以使用@Autowired 注解来自动装配指定的bean。 在使用@Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。&lt;context:annotation-config /&gt;也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 1&lt;bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/&gt; 配置好以后就可以使用@Autowired 来标注了。注意要想@Autowired生效 还要 在 xml中像上述方式一样注册被注解的类即EmployeeDAOImpl 1234@Autowiredpublic EmployeeDAOImpl ( EmployeeManager manager ) &#123; this.manager = manager;&#125; 建议用&lt;context:component-scan&gt; 而不用 &lt;context:annotation-config/&gt; 原因:&lt;context:component-scan&gt;首先有和&lt;context:annotation-config/&gt;一样的作用，此外，它还可以扫描指定包下的类，将拥有(@Component,@Controller,@Service,@Repository)注解的它们注册到Spring容器中,而不用我们手动在xml文件中去注册bean。 2.20 请解释各种自动装配模式的区别？在 Spring 框架中共有 5 种自动装配，让我们逐一分析。1.no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean定义中用标签明确的设置依赖关系。2.byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。3.byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。4.constructor：构造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。5.autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byTpe 的自动装配方式。 2.21 如何开启基于注解的自动装配？要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：1、引入配置文件中的下引入 123&lt;beans&gt; &lt;context:annotation-config /&gt;&lt;/beans&gt; 2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor 12345&lt;beans&gt; &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProc essor&quot;/&gt;&lt;/beans&gt; 2.22 、 自动装配有哪些局限性？自动装配有如下局限性：重写：你仍然需要使用 和&lt; property&gt;设置指明依赖，这意味着总要重写自动装配。原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 2.23 Spring Bean 作用域之间的区别？Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：①: singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。②: prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。③: request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。④: Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。⑤: global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。 2.24 Spring 框架中的单例 Beans 是线程安全的么？Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。 最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。 2.25 请解释 Spring Bean 的生命周期？Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean容器中移除。Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。 Bean 的生命周期由两组回调（call back）方法组成: 初始化之后调用的回调方法。 销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： nitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init()方法和 destroy()方法 @PostConstruct 和@PreDestroy 注解方式 使用 customInit()和 customDestroy()方法管理 bean 生命周期的代码样例如下： 12345&lt;beans&gt; &lt;bean id="demoBean" class="com.gupaoedu.task.DemoBean" init-method="customInit" destroy-method="customDestroy"&gt; &lt;/bean&gt;&lt;/beans&gt; 2.26 请举例解释@Required在产品级别的应用中，IOC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置“dependency-check”来解决这个问题。在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正 确 配 置 。 或 者 你 宁 可 验 证 某 个 bean 的 特 定 属 性 是 否 被 正 确 的 设 置 。 即 使 是 用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。需要用如下的方式使用来标明 bean 的设值方法。 12345678910public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;&#123; private String designation; public String getDesignation() &#123; return designation; &#125; @Required public void setDesignation(String designation) &#123; this.designation = designation; &#125;&#125; RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被@Required 注解的 bean 属性是否被正确的设置了。在使用 RequiredAnnotationBeanPostProcesso 来验证bean 属性之前，首先要在 IOC 容器中对其进行注册： 1&lt;bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /&gt; 但 是 如 果 没 有 属 性 被 用 @Required 注 解 过 的 话 ， 后 置 处 理 器 会 抛 出 一 个BeanInitializationException 异常。 2.27 请举例解释@Autowired 注解?@Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像@Required 注解、构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。比如，可以在设值方法上使用@Autowired 注解来替代配置文件中的 元素。当 Spring 容器在setter 方法上找到@Autowired 注解时，会尝试用 byType 自动装配。当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 1234567891011public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker)&#123; System.out.println("Inside TextEditor constructor." ); this.spellChecker = spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 12345678910//下面是没有构造参数的配置方式：&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- Definition for textEditor bean without constructor-arg --&gt; &lt;bean id="textEditor" class="com.gupaoedu.TextEditor"&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id="spellChecker" class="com.gupaoedu.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; 2.28 请举例说明@Qualifier 注解？@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 1234public class Customer&#123; @Autowired private Person person;&#125; 下面我们要在配置文件中来配置 Person 类 1234567&lt;bean id="customer" class="com.gupaoedu.common.Customer" /&gt;&lt;bean id="personA" class="com.gupaoedu.common.Person" &gt; &lt;property name="name" value="lokesh" /&gt;&lt;/bean&gt;&lt;bean id="personB" class="com.gupaoedu.common.Person" &gt; &lt;property name="name" value="alex" /&gt;&lt;/bean&gt; Spring 会知道要自动装配哪个 person bean 么？不会的，但是运行上面的示例时，会抛出下面的异常： 123Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.gupaoedu.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： 12345public class Customer&#123; @Autowired @Qualifier("personA") private Person person;&#125; 2.29 构造方法注入和设值注入有什么区别？请注意以下明显的区别：1.在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。2.设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法仅在对象被创建时调用。 3.在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 4.在 设 值 注 入 时 如 果 对 象 A 和 对 象 B 互 相 依 赖 ， 在 创 建 对 象 A 时 Spring 会 抛 出sObjectCurrentlyInCreationException 异常，因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。 2.30 Spring 框架中有哪些不同类型的事件？Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件，如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 123456789public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt; &#123; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //process event &#125;&#125; Spring 提供了以下 5 中标准的事件：1.上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。2.上下文开始事件（ContextStartedEvent）：当容器调用 ConfigurableApplicationContext的 Start()方法开始/重新开始容器时触发该事件。3.上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext的 Stop()方法停止容器时触发该事件。4.上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。5.请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 123456public class CustomApplicationEvent extends ApplicationEvent&#123; public CustomApplicationEvent ( Object source, final String msg )&#123; super(source); System.out.println("Created a Custom event"); &#125;&#125; 为了监听这个事件，还需要创建一个监听器： 123456public class CustomEventListener implements ApplicationListener &lt;CustomApplicationEvent &gt; &#123; @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123; //handle event &#125;&#125; 之后通过 applicationContext 接口的 publishEvent()方法来发布自定义事件。 12CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext,“Test message”);applicationContext.publishEvent(customEvent); 2.31 Spring 框架中都用到了哪些设计模式？Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：1、代理模式—在 AOP 和 remoting 中被用的比较多。2、单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。3、模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。4、委派模式：Spring 提供了 DispatcherServlet 来对请求进行分发。5、工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext接口的核心理念。6、代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 三、SpringMVC3.1 MVC 开发模式的流程 3.2 springMVC 的概念以及原理前端控制器DispatcherServlet 处理器映射器HandlerMapping 处理器适配器HandlerAdapter 处理器Handler 视图解析器viewResolver 页面文件view 来看一下springMVC的流程图: 结合这个流程图,咱们来简单的描述一下这个过程: ①: 首先用户发起 request 请求,请求 DispatcherServlet 前端控制器. ②: 然后DispatcherServlet 前端控制器请求 HandlerMapping 处理器映射器查找 Handler(就是Controller)得到处理器执行链(即HandlerExecutionChain), ③: 并将处理器执行链返回给 DisptcherServlet. ④: DisptcherServlet 找到 Handler 之后要挑选合适的适配器 HanlderAdapter ⑤: 来执行 Handler(就是Controller). ⑥: 执行完 Handler 之后.返回 ModelAndView 对象给HanlderAdapter . ⑦: HanlderAdapter 将 ModelAndView 返回给 DisptcherServlet ⑧: DisptcherServlet 将 ModelAndView 交给 viewResolver ⑨: viewResolver 视图解析器来解析ModelAndView 返回 view 对象交给 DisptcherServlet ⑩: DisptcherServlet 将 modle 渲染到 view.然后响应用户 这个流程图很重要,理解了这个流程之后,对于之后的理解,springMVC有很大的帮助哦! 四、Mybatis4.1 什么是MyBatis？答：MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。 4.2 Mybatis是如何进行分页的？分页插件的原理是什么？1）Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。 2）分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。 举例：select from student，拦截sql后重写为：select t. from （select * from student）t limit 0，10 4.3 MyBatis与Hibernate有哪些不同？1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 2）Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 4.4 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt; parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt; resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt; select&gt;、&lt; insert&gt;、&lt; update&gt;、&lt; delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。 4.5 什么是MyBatis的接口绑定,有什么好处？答：接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置. 4.6 Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。 关联对象查询，有两种实现方式: 一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。 4.7 MyBatis里面的动态Sql是怎么设定的?用什么语法?答：MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。 4.8 使用MyBatis的mapper接口调用时有哪些要求？1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同 2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 4）Mapper.xml文件中的namespace即是mapper接口的类路径。 4.9 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？答：第一种是使用&lt; resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。 第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。 有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 4.10 MyBatis接口绑定有几种实现方式,分别是怎么实现的?答：接口绑定有两种实现方式: 一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定, 另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名. 4.11 .MyBatis实现一对一有几种方式?具体怎么操作的？答：有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。 4.12 什么情况下用注解绑定,什么情况下用xml绑定？答：当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多 4.13 MyBatis的好处是什么？答：1） MyBatis把sql语句从Java源程序中独立出来， 放在单独的XML文件中编写，给程序的维护带来了很大便利。 2） MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。 3） 因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句， 因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。 五、Maven5.1 什么是Maven？Maven使用项目对象模型(POM)的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 Maven的出现，解决了开发过程中的jar包升级及依赖的难题。它可以对项目依赖的jar包进行管理，可以让你的项目保持基本的依赖，排除冗余jar包，并且可以让你非常轻松的对依赖的jar包进行版本升级。而这些仅仅是Maven最基本的功能，它可以在这基础上对项目进行清理、编译、测试、打包、发布等等构建项目的工作。 5.2 Maven和ANT的区①: maven&amp;ant同属apach是流行的构建工具。 ②: maven的中央仓库和pom.xml文件。中央仓库统一存放了开发用到的各种jar包，要用时只需要添加依赖到pom文件中，maven就会自动下载，当然为了方便一般会在本地建一个仓库，减少下载时间。pom文件是maven的配置文件，maven就是通过管理pom文件和一些核心插件来管理项目。 ③: ant的build.xml文件。build文件是ant的配置文件，ant依靠它来执行操作，与maven不同的是ant没有固定一条程序链。你想要执行什么操作以及操作之间的顺序和依赖关系，都需要手动添加到build文件中，一点一滴都要写清楚，否则ant就不会执行。 ④: maven和ant区别 Maven 拥有约定，只要遵守约定，它就知道你的源代码在哪里。Maven 是声明式的。你需要做的只是创建一个 pom.xml 文件然后将源代码放到默认的目录。Maven 会帮你处理其它的事情。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉 Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。缺点是运行许多默认目标。 而ant没有约定，项目生命周期，它是命令式的。所有操作都要手动去创建、布置。甚至连build.xml文件都需要手动创建。 5.3 Maven仓库是什么Maven仓库是基于简单文件系统存储的，集中化管理Java API资源（构件）的一个服务。仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径。得益于 Maven 的坐标机制，任何 Maven项目使用任何一个构件的方式都是完全相同的，Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其它项目使用。 对于Maven来说，仓库分为两类：本地仓库和远程仓库 5.4 Maven的工程类型有哪些？POM工程 POM工程是逻辑工程。用在父级工程或聚合工程中。用来做jar包的版本控制。 JAR工程 将会打包成jar用作jar包使用。即常见的本地工程 - Java Project。 WAR工程 将会打包成war，发布在服务器上的工程。如网站或服务。即常见的网络工程 - Dynamic Web Project。war工程默认没有WEB-INF目录及web.xml配置文件，IDE通常会显示工程错误，提供完整工程结构可以解决。 5.5 Maven常用命令有哪些？install 本地安装， 包含编译，打包，安装到本地仓库 编译 - javac 打包 - jar， 将java代码打包为jar文件 安装到本地仓库 - 将打包的jar文件，保存到本地仓库目录中。 clean 清除已编译信息。 删除工程中的target目录。 compile 只编译。 javac命令 deploy 部署。 常见于结合私服使用的命令。 相当于是install+上传jar到私服。 包含编译，打包，安装到本地仓库，上传到私服仓库。 package 打包。 包含编译，打包两个功能。 六、Nginx6.1 什么是Nginx？Nginx (engine x) 是一个高性能的HTTP和反向代理服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 Nginx 是一个很强大的高性能Web和反向代理服务，它具有很多非常优越的特性：在连接高并发的情况下，Nginx是Apache服务不错的替代品：Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一。 6.2 Nginx有哪些作用？http协议代理 搭建虚拟主机 服务的反向代理 在反向代理中配置集群的负载均衡 6.3 什么是正向代理？正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。 6.4 什么是反向代理？反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 七、Redis7.1 什么是Redis？答：Remote Dictionary Server(Redis)是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 7.2 Redis的特点什么是？\1. 支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash表)、set(集合)、zset(排序set)、hyperloglog(基数估算) \2. 支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。 \3. 支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。 单进程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。 7.3 Redis数据类型有哪些?①: String(字符串) ②: Hash(hash表) ③: List(链表) ④: Set(集合) ⑤: SortedSet(有序集合zset) 7.4 Redis中的常用命令哪些？incr 让当前键值以1的数量递增，并返回递增后的值 incrby 可以指定参数一次增加的数值，并返回递增后的值 decrby 可以指定参数一次递减的数值，并返回递减后的值 incrbyfloat 可以递增一个双精度浮点数 append 作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value。返回值是追加后字符串的总长度。 mget/mset 作用与get/set相似，不过mget/mset可以同时获得/设置多个键的键值 del 根据key来删除value flushdb 清除当前库的所有数据 hset 存储一个哈希键值对的集合 hget获取一个哈希键的值 hmset 存储一个或多个哈希是键值对的集合 hmget 获取多个指定的键的值 hexists 判断哈希表中的字段名是否存在 如果存在返回1 否则返回0 hdel 删除一个或多个字段 hgetall 获取一个哈希是键值对的集合 hvals 只返回字段值 hkeys 只返回字段名 hlen 返回key的hash的元素个数 lpush key value向链表左侧添加 rpush key value向链表右侧添加 lpop key 从左边移出一个元素 rpop key 从右边移出一个元素 llen key 返回链表中元素的个数 相当于关系型数据库中 select count(*) lrange key start end lrange命令将返回索引从start到stop之间的所有元素。Redis的列表起始索引为0。 lrange也支持负索引 lrange nn -2 -1 如 -1表示最右边第一个元素 -2表示最右边第二个元素，依次类推。 lindex key indexnumber 如果要将列表类型当做数组来用，lindex命令是必不可少的。lindex命令用来返回指定索引的元素，索引从0开始 如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。 Lset key indexnumber value 是另一个通过索引操作列表的命令，它会将索引为index的元素赋值为value。 sadd key value 添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0 scard key 返回set的元素个数，如果set是空或者key不存在返回0 smembers key 返回key对应set的所有元素，结果是无序的 sismember key value 判断value 是否在set中，存在返回1，0表示不存在或者key不存在 srem key value 从key对应set中移除给定元素，成功返回1，如果value 在集合中不存在或者key不存在返回0 zadd key score value 将一个或多个value及其socre加入到set中 zrange key start end 0和-1表示从索引为0的元素到最后一个元素（同LRANGE命令相似） zrange key 0 -1 withscores 也可以连同score一块输出，使用WITHSCORES参数 zremrangebyscore key start end 可用于范围删除操作 ping 测试redis是否链接 如果已链接返回 PONG echo value测试redis是否链接 如果已链接返回 echo命令后给定的值 keys 返回所有的key 可以加通配 exists key判断string类型一个key是否存在 如果存在返回1 否则返回0 expire key time(s) 设置一个key的过期时间 单位秒。时间到达后会删除key及value ttl key 查询已设置过期时间的key的剩余时间 如果返回-2表示该键值对已经被删除 persist 移除给定key的过期时间 select dbindex 选择数据库(0-15) move key dbIndex 将当前数据库中的key转移到其他数据库中 dbsize 返回当前数据库中的key的数目 info 获取服务器的信息和统计 flushdb 删除当前选择的数据库中的key flushall 删除所有数据库中的所有key quit 退出连接 7.5 Redis的配置以及持久化方案有几种答：以下两种 RDB方式 AOF方式 7.6 什么是RDB方式？答：是RDB是对内存中数据库状态进行快照 RDB方式：将Redis在内存中的数据库状态保存到磁盘里面，RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态（默认下，持久化到dump.rdb文件，并且在redis重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB的快照文件，同步到内存中的 时间是20-30秒） RDB的生成方式： 1、执行命令手动生成 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间.服务器不能处理任何命令请求， BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求，创建RDB文件结束之前，客户端发送的BGSAVE和SAVE命令会被服务器拒绝 2、通过配置自动生成 可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令 例如： save 900 1 save 300 10 save 60 10000 那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行 服务器在900秒之内，对数据库进行了至少1次修改 服务器在300秒之内，对数据库进行了至少10次修改 服务器在60秒之内，对数据库进行了至少10000次修改 7.7 什么是AOF方式？AOF持久化方式在redis中默认是关闭的，需要修改配置文件开启该方式。 AOF：把每条命令都写入文件，类似mysql的binlog日志 AOF方式：是通过保存Redis服务器所执行的写命令来记录数据库状态的文件。 AOF文件刷新的方式，有三种： appendfsync always - 每提交一个修改命令都调用fsync刷新到AOF文件，非常非常慢，但也非常安全 appendfsync everysec - 每秒钟都调用fsync刷新到AOF文件，很快，但可能会丢失一秒以内的数据 appendfsync no - 依靠OS进行刷新，redis不主动刷新AOF，这样最快，但安全性就差 默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾 AOF数据恢复方式 服务器在启动时，通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态，具体过程： 载入AOF文件 创建模拟客户端 从AOF文件中读取一条命令 使用模拟客户端执行命令 循环读取并执行命令，直到全部完成 如果同时启用了RDB和AOF方式，AOF优先，启动时只加载AOF文件恢复数据 八、Dubbo九、其他9.1 什么是Solr？答：Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。 Solr是一个高性能，采用Java开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文检索引擎。 文档通过Http利用XML 加到一个搜索集合中。查询该集合也是通过http收到一个XML/JSON响应来实现。 它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大Data Schema来定义字段，类型和设置文本分析，提供基于Web的管理界面等。 9.2 Solr是由哪两个部分构成？答：如下两个部分 Solr的web服务 Solr的索引库 9.3 什么是正排索引？正排索引是以文档的ID为关键字，索引文档中每个字的位置信息，查找时扫描索引中每个文档中字的信息直到找出所有包含查询关键字的文档。 但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。 尽管正排索引的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。 9.4 什么是倒排索引？对数据进行分析，抽取出数据中的词条，以词条作为key，对应数据的存储位置作为value，实现索引的存储。这种索引称为倒排索引。 当solr存储文档时，solr会首先对文档数据进行分词，创建索引库和文档数据库。所谓的分词是指：将一段字符文本按照一定的规则分成若干个单词. 9.5 什么是ActiveMQ？ActiveMQ是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。ActiveMQ使用Apache提供的授权，任何人都可以对其实现代码进行修改。 ActiveMQ的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成消息通信中间件 ActiveMQ实现了JMS标准并提供了很多附加的特性。 这些附加的特性包括，JMX管理（java Management Extensions，即java管理扩展），主从管理（master/salve，这是集群模式的一种，主要体现在可靠性方面，当主中介（代理）出现故障，那么从代理会替代主代理的位置，不至于使消息系统瘫痪）、消息组通信（同一组的消息，仅会提交给一个客户进行处理）、有序消息管理（确保消息能够按照发送的次序被接受者接收）。消息优先级（优先级高的消息先被投递和处理）、订阅消息的延迟接收（订阅消息在发布时，如果订阅者没有开启连接，那么当订阅者开启连接时，消息中介将会向其提交之前的，其未处理的消息）、接收者处理过慢（可以使用动态负载平衡，将多数消息提交到处理快的接收者，这主要是对PTP消息所说）、虚拟接收者（降低与中介的连接数目）、成熟的消息持久化技术（部分消息需要持久化到数据库或文件系统中，当中介崩溃时，信息不会丢失）、支持游标操作（可以处理大消息）、支持消息的转换、通过使用Apache的Camel可以支持EIP、使用镜像队列的形式轻松的对消息队列进行监控等。 9.5 消息服务的应用场景有哪些？答：如下3个场景都可以使用消息服务 1、异步处理 2、应用的解耦 3、流量的削峰 9.6 什么是JMS？JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。 9.7 B/S和C/S的含义及其区别C/S结构，即Client/Server(客户机/服务器)结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可充分利用两端硬件环境优势。早期软件系统多以此作为首选设计标准。 B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，节约了开发成本，便于软件维护。 区别 1、C/S是建立在局域网的基础上的。B/S是建立在广域网的基础上的，但并不是说B/S结构不能在局域网上使用。 2、B/S业务扩展简单方便，通过增加页面即可增加服务器功能。C/S的客户端还需要安装专用的客户端软件，不利于扩展。 3、B/S维护简单方便。开发、维护等几乎所有工作也都集中在服务器端，当企业对网络应用进行升级时，只需更新服务器端的软件就可以，这减轻了异地用户系统维护与升级的成本 4、B/S响应速度不及C/S； 5、B/S用户体验效果不是很理想 9.8 说说你对容器的理解容器也是 java 程序，它的主要作用是为应用程序提供运行环境。 容器用来接管安全性、并发性、事务处理、交换到辅助存储器和其它服务的责任. 以tomcat为例： Tomcat是一个后台服务进程，其它的servlet（相当于DLL）是在Tomcat容器内运行,Broswer只与Tomcat通迅; Tomcat接受browser的请求，经过一系列动作（如果是静态网页，那么装载，按http协议形成响应流;如果是动态的如JSP，那就要调用JDK 中的servlet.jsp接口，解释形成静态网页，按http协议生成响应流发送回browser）后，形成静态网页，返回响应。 9.9 为什么要使用连接池？传统的数据库连接方式 一个连接对象对应一个物理连接 每次操作都打开一个物理连接， 使用完都关闭连接，造成系统性能低下。 连接池技术 客户程序得到的连接对象是连接池中物理连接的一个句柄，调用连接对象的close()方法,物理连接并没有关闭,数据源的实现只是删除了客户程序中的连接对象和池中的连接对象之间的联系. 数据库连接的建立及关闭是耗费系统资源的操作，在大型应用中对系统的性能影响尤为明显。为了能重复利用数据库连接对象,缩短请求的响应时间和提高服务器的性能,支持更多的客户，应采用连接池技术 9.10 数据库连接池的原理 数据库连接池的原理: 传统连接方式: 首先调用Class.forName()方法加载数据库驱动， 然后调用DriverManager.getConnection()方法建立连接. 连接池技术: 连接池解决方案是在应用程序启动时就预先建立多个数据库连接对象,然后将连接对象保存到连接池中。 当客户请求到来时,从池中取出一个连接对象为客户服务。 当请求完成时,客户程序调用close()方法,将连接对象放回池中. 对于多于连接池中连接数的请求，排队等待。 应用程序还可根据连接池中连接的使用率，动态增加或减少池中的连接数 9.11 MVC模式及其优缺点 9.11.1 MVC原理MVC是一种程序开发设计模式,它实现了显示模块与功能模块的分离。提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。 1、模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性 2、视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成 3、控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用 9.11.2 MVC的优点1、降低代码耦合性。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。 2、有利于分工合作。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。 3、有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。 9.11.3 MVC的不足之处1、增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 2、视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。 3、视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 4、目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。 9.11.4 MVC模式完成分页功能的基本思路是什么？1）页面提交页码(第几页)到Servlet中 2）Servlet接收到页码后，将页码传递给分页工具类(PageBean) 3）Servlet中调用Service层传入PageBean对象 4）Service层调用DAO层传入PageBean对象 5）Servlet中得到查询出来的数据，并setAttrivute保存 6）在页面中得到(getAttribute)数据，遍历输出 9.11.5 常用的Web容器答： Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常用服务器的简介： IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。 WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。 WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。 Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。 Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。 Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>框架相关面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、正则表达式简介:1.1 概念正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 1.2 发展历史正则表达式的”祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。 1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为”神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为”正则集的代数”的表达式，因此采用”正则表达式”这个术语。 随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。 如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。 1.3 应用领域①: C# 正则表达式 ②: Java 正则表达式 ③: JavaScript 正则表达式 ④: Python 正则表达式 ⑤: Ruby 正则表达式 1.4 为什么使用正则表达式？典型的就是搜索和替换操作 通过使用正则表达式，可以： 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。 例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。 1.5 举例例1: 我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用以下正则表达式来设定。 例2: ^ 为匹配输入字符串的开始位置。 [0-9]+匹配多个数字，[0-9] 匹配单个数字，+匹配一个或者多个。 abc$匹配字母abc并以abc结尾，$ `为匹配输入字符串的结束位置。 二、正则表达式语法:2.1 速查表 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.\ \n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(\ )”来组合一个模式的各个部分是很有用。例如“industr(?:y\ ies)”就是一个比“industry\ industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95\ 98\ NT\ 2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95\ 98\ NT\ 2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95\ 98\ NT\ 2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95\ 98\ NT\ 2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x\ y 匹配x或y。例如，“z\ food”能匹配“z”或“food”。“(z\ f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 字母少的时候直接列举,字母多的时候中间用-; 如[相xyz],和[a-z] [^xyz] 负值字符集合。匹配未包含的任意字符。例如，[^abc]可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，[^a-z]可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于[^A-Za-z0-9_]。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 2.3 分类: 非打印字符(不能看到) 打印字符也可以是正则表达式的组成部分。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoob 中的 ，简单的说就是表示任何字符串的意思。如果要查找字符串中的 符号，则需要对 进行转义，即在其前加一个 \: runo*ob 匹配 runo*ob。许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 `\`。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 { 标记限定符表达式的开始。要匹配 {，请使用 \{。 \ 指明两项之间的一个选择。要匹配 \ ，请使用 `\ `。 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。——零多星 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。——一多加 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。——-零一问 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 \b 匹配一个单词边界，即字与空格间的位置。 \B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符优先级 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \任何元字符、任何字符 定位点和序列（即：位置和顺序） \ 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m\ food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m\ f)ood”。 2.4 ^和$2.4.1 关于 ^ 的理解1^once 这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。 例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配,因为它的开头是There不是once。 2.4.2 关于 $ 的理解正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。 1bucket$ 这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。 2.4.3 字符 ^ 和 $ 同时使用表示精确匹配（字符串与模式一样） 2.4.4 如果一个模式不包括^和$那么它与任何包含该模式的字符串匹配。 例如：模式 1once 与下列字符串是匹配的。 12There once was a man from NewYorkWho kept all of his cash in a bucket. 2.4.5 对于一些特殊字符如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是 \t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式： 1^\t 类似的，用\n表示”新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。 2.5 字符簇把所有的可能字符放在一个中括号里：这种方式只能表示一个字符 12//例如: 下面模式与任何元音字符匹配，但只能表示一个字符。[AaEeIiOoUu] 用连字号可以表示一个字符的范围,如： 12345678//下面这些同上也是只能表示一个字符[a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9\.\-] //匹配所有的数字，句号和减号 [ \f\r\t\n] //匹配所有的白字符 2.6 剔除某个字符^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 ^ 时，它表示”非“或”排除“的意思，常常用来剔除某个字符。 例如: 我们要求第一个字符不能是数字： 12//这个模式与"&amp;5"、"g7"及"-2"是匹配的，但与"12"、"66"是不匹配的。^[^0-9][0-9]$ 12345//下面是几个排除特定字符的例子：[^a-z] //除了小写字母以外的所有字符 [^\\\/\^] //除了(\)(/)(^)之外的所有字符 [^\"\'] //除了双引号(")和单引号(')之外的所有字符 特殊字符 .(点，句号)在正则表达式中用来表示除了”新行”之外的所有字符。所以模式 ^.5$ 与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式 . 可以匹配任何字符串，除了空串和只包括一个“新行”的字符串。 2.7 确定重复出现你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。 跟在字符或字符簇后面的花括号{ }用来确定前面的内容的重复出现的次数。 字符簇 描述 ^[a-zA-Z_]$ 所有的字母和下划线 ^[[:alpha:]]{3}$ 所有的3个字母的单词 ^a$ 字母a ^a{4}$ aaaa ^a{2,4}$ a的个数在2至4之间; aa,aaa或aaaa ^a{1,3}$ a的个数在1至3之间; a,aa或aaa ^a{2,}$ 包含至少两个a的字符串 如aaXXXX,aaaXXXX,aaaaXXXX,XXXXaa,aXaXXXaX等等 ^a{2,} 如：aardvark和aaab，但apple不行 a{2,} 如：baad和aaa，但Nantucket不行 \t{2} 两个制表符 .{2} 两个除换行符 \n 之外的任何字符 这些例子描述了花括号的三种不同的用法。 一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ； 一个数字加逗号 {x,}的意思是前面的内容出现x或更多的次数 ； 两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。 我们可以把模式扩展到更多的单词或数字： 1234^[a-zA-Z0-9_]&#123;1,&#125;$ // 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]&#123;0,&#125;$ // 所有的正整数 ^\-&#123;0,1&#125;[0-9]&#123;1,&#125;$ // 所有的整数 ^[-]?[0-9]+\.?[0-9]+$ // 所有的浮点数 最后一个例子不太好理解: 这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。 特殊字符 ? 与 {0,1} 是相等的，它们都代表着： 0个或1个前面的内容 或 前面的内容是可选的 。 12//^[-]?[0-9]+\.?[0-9]+$可以简化为：^\-?[0-9]&#123;1,&#125;\.?[0-9]&#123;1,&#125;$ 特殊字符 * 与 {0,} 是相等的，它们都代表着 0 个或多个前面的内容 。最后，字符 + 与 {1,} 是相等的，表示 1 个或多个前面的内容 ， 12345678910^[a-zA-Z0-9_]&#123;1,&#125;$ // 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]&#123;0,&#125;$ // 所有的正整数 ^\-&#123;0,1&#125;[0-9]&#123;1,&#125;$ // 所有的整数 ^[-]?[0-9]+\.?[0-9]+$ // 所有的浮点数//上面的简化为: ^[a-zA-Z0-9_]+$ // 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]*$ // 所有的正整数 ^\-?[0-9]+$ // 所有的整数 ^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery必知必会]]></title>
    <url>%2FjQuery%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html</url>
    <content type="text"><![CDATA[一、jQuery简介:1.1 介绍:jQuery 是一个 JavaScript 框架。 jQuery 极大地简化了 JavaScript 编程。 特点: jQuery是一个轻量级的”写的少，做的多”的JavaScript库。 1.2 功能jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 提示： 除此之外，Jquery还提供了大量的插件。 1.3 如何用–&gt;第一步?要想在jsp中使用jQuery首先需要在JSP页面中引入jQuery文件 1234567891011//方式一: 下载jQuery文件到本地,然后存到项目目录下 [下载路径:](http://jquery.com/download/)&lt;head&gt; &lt;script src="/本地目录/jquery-1.10.2.min.js"&gt;&lt;/script&gt;&lt;/head&gt;//方式二: 直接引用网络路径(例如:引用百度的cdn)&lt;head&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;//注: 没有在 &lt;script&gt; 标签中使用 type="text/javascript" 的原因是: 在 HTML5 中，不必那样做了。//JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！ 1.4 jQuery 语法通过 jQuery，您可以选取（查询，query） HTML 元素，并对它们执行”操作”（actions）。 基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 \ 元素 $(“p.test”).hide() - 隐藏所有 class=”test” 的 \ 元素 $(“#test”).hide() - 隐藏所有 id=”test” 的元素 1.5 事件之文档加载完毕如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作,可以这样: 两种方法: 1234567891011121314151617//jQuery 入口函数://方法一: $(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;);//方法二: 较简洁---&gt;推荐使用$(function()&#123; // 开始写 jQuery 代码... &#125;); 补充: JavaScript 入口函数: 123window.onload = function () &#123; // 执行代码&#125; jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 1.6 jQuery 选择器jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。 jQuery 中所有选择器都以美元符号开头：$( ) 1.6.1 选择器分类:①: 基本选择器: ID选择器( #id选择器 )—&gt;语法: 举例 $(“#test”) 类选择器(.class 选择器)—&gt;语法: 举例 $(“.test”) 元素选择器—-&gt;语法: 举例 $(“div”) 通配选择器—&gt;语法: 举例 $(“*“) 选择器分组 交集选择器—-&gt; HTML中的语法：选择器1.选择器2.选择器N{}——HTML例子：p.hello{}是元素选择器和类选择器构成———(交点) 并集选择器—-&gt;HTML中的语法：选择器1,选择器2,选择器N{}—–HTML例子：div,p,#box,.hello{}是元素,id和类选择器构成——-(逗比) 1234$("*") //选取所有元素$(this) //选取当前 HTML 元素$("p.intro") //选取 class 为 intro 的&lt;p&gt;元素$("#test") //选取id为test的元素 ②: 层级选择器: 后代元素选择器: 语法：祖先元素 后代元素{ } ———————————————– (后空翻） 兄弟元素选择器 选取后一个兄弟元素 语法: 前一个 + 后一个————————————————(嘉玲兄) 选取后边所有的兄弟元素 语法: 前一个 ~ 后一个————————————————-(浪全兄) 子元素元素选择器: 语法：父元素 &gt; 子元素 { }———————————————– （父大于子） 1234$('div &gt; p') //选择所有div元素里面的直接子元素P$('div p') //选择div元素里面所有的p元素$('.prev + div').css("border", "3px groove red");//选取prev后面的第一个的div兄弟节点$(".prev ~ div").css("border", "3px groove blue");//选取class属性的值为prev的元素后面的所有的div兄弟节点 ③: 属性选择器 1234var $icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的对象// 例如: name="icon-1", name="icon-2"var $names = $('[name$=with]'); // 找出所有name属性值以with结尾的对象// 例如: name="startswith", name="endswith" ④: 表单选择器 :——-&gt; 语法: $(:名称)——-&gt;名称可以是input元素的type属性的值 注: 与过滤选择器区别是: ==:前面没有内容== 123$("#frmTest :password").addClass("bg_red");$(":hidden");//选择所有隐藏域 (&lt;input type="hidden"/&gt;) 及 所有不可见元素（CSS display 属性值为 none）$(":button");//选择所有按钮 (&lt;input type="button"/&gt;) 和 &lt;button&gt;...&lt;/button&gt; ⑤: 过滤选择器 ——–&gt; 一般语法: $(选择器 :过滤器) 原理: 先根据选择器得到符合条件的元素或元素集合, 然后再根据过滤规则,从该元素或元素集合中筛选符合条件的元素或元素集合. 基本过滤选择器 写法 描述 $(‘p:first’) 选取页面元素内的第一个p元素 $(‘p:last’) 选取页面元素内的最后一个p元素 $(‘li:not(.red)’) 选取 class属性的值 不是 red 的 li 元素 集合元素 $(‘p:even’) 选取索引是偶数的P元素(索引从0开始) $(‘p:odd’) 选取索引是奇数的p元素(索引从0开始) $(‘p:eq(index)’) 选取索引等于index的p元素(索引从0开始,索引支持负数) $(‘p:gt(index)’) 选取索引&gt;index的p元素(索引从0开始) $(‘p:lt(index)’) 选取索引&lt;index的p元素(索引从0开始) $(‘:header’) 选取标题元素h1~h6 $(‘:animated’) 选取正在执行动画的元素 $(‘input:focus’) 选取当前被焦点的元素 jQuery为常用的过滤器提供了丰富的方法 eq(index) 获取是index索引值的元素(索引从0开始,负值从后开始) first() 选取第一个元素 last() 选取最后一个元素 not(selector) 选取不是该选择器的元素———&gt;其中selector代表选择器 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;p&gt;第一个P&lt;/p&gt;&lt;p id="select"&gt;第二个P&lt;/p&gt;&lt;p&gt;第三个P&lt;/p&gt;&lt;h3&gt;我是h3&lt;/h3&gt;&lt;h4&gt;我是h4&lt;/h4&gt;&lt;input type="text" value="123"&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $('p:first').css('color','pink'); // $('p').first().css('color','pink'); $('p:last').css('color','orange'); // $('p').last().css('color','orange'); $('p:not(#select)').css('background','green'); // $('p').not('#select').css('background','green'); $('p:eq(1)').css('color','red'); // $('p').eq(1).css('color','red'); $('p:gt(1)').css('width','80px'); $('p:lt(1)').css('width','120px'); $('p:even').css('font-family','华文行楷'); $('p:odd').css('font-family','隶书'); $(':header').css('color','blue');//全局查找 $('h4:header').css('color','peru');//限定了是h4 $('input').focus();//设置页面刷新就激活焦点 $('input:focus').css('color','deeppink') // :focus过滤器必须是网页初始状态就已经被激活的焦点元素,不能是通过鼠标点击或Tab键激活 &#125;);&lt;/script&gt;&lt;/body&gt; 内容过滤选择器 写法 描述 $(‘:contains(“百度”)’) 选取含有”百度”文本的元素集合 $(‘a:contains(“百度”)’).css(‘border’,’double’); 选取文本为”百度”的超链接的集合 $(‘:empty’) 选取不包含子元素或空文本的元素集合 $(‘:has(selector)’) 选取含有该selector选择器的元素(必须是父元素上调用,返回的是父元素)集合 $(‘:parent’) 选取含有子元素或文本的元素集合 has() jQuery提供了一个has()方法作用等同has过滤器 jQuery提供了parent相关方法,但与过滤器含义不等同 parent() 选择当前元素的父元素 parents() 选择当前元素的祖先元素(包括父元素) parentsUntil() 选择当前元素的祖先元素,遇到指定元素则停止 123456789101112131415161718192021222324252627282930313233&lt;body&gt;&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt; &lt;span&gt;我是第一个span&lt;/span&gt; &lt;span id="show"&gt;我是第二个span&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;nav style="width:100px;height:100px;background:deeppink"&gt; &lt;p style="width:80px;height:50px;background:orangered"&gt; &lt;span&gt;测试parents&lt;/span&gt; &lt;/p&gt;&lt;/nav&gt;&lt;script type="text/javascript"&gt; $(function ()&#123; $('a:contains("百度")').css('border','double'); $('p:empty').css('background','orange').css('height','50px').css('width','50px');/*必须是块 级元素,width和height才有效*/ $('div:has(#show)').css('color','peru');//has过滤器 $('div').has('#show').css('width','120px');//has方法 $('div:parent').css('color','red').css('border','dashed');//查找所有作为父亲的div(含子元素的 div) $('#show').parent().css('background','green');//查找某元素的父亲 //这两者是有区别的,且color会影响borderColor的颜色 //$('p&gt;span').parents().css('border','groove'); alert($('p&gt;span').parents().length); //结果为4个----&gt;即p,nav,body,html这四个祖先元素 alert($('p&gt;span').parents()[3].nodeName); //结果为html---&gt;下标从零开始 $('p&gt;span').parentsUntil('body').css('border','groove'); &#125;);&lt;/script&gt;&lt;/body&gt; 属性过滤选择器 12345678910111213141516171819202122&lt;div id="d1" style="display: none"&gt;hello&lt;/div&gt;&lt;div id="d2" &gt;world&lt;/div&gt;&lt;div id="d3" style="visibility: hidden"&gt;!&lt;/div&gt;&lt;div id="d 4" myid&gt;&lt;/div&gt;&lt;input type="text" &gt; &lt;script src="http://apps.bdimg.com/libs/jquery/1.6.4/jquery.js"&gt;&lt;/script&gt;&lt;script&gt; var v1=$("[style]") var v2=$("[dispaly]") var v3=$("[myid]") var v4=$("[id='d2']") var v5=$("[id!='d2']") var v6=$("[id^='d']") var v7=$("[id$='3']") var v8=$("[id~='d']") var v9=$("[id*='d']") //组合属性选择器([attribute1][attribute2]…[attributeN]) var v10=$("body div[id][style]")&lt;/script&gt; 子元素过滤选择器 （注意:子元素过滤器查找的该元素是作为第几个孩子元素,返回是该元素也就是孩子） | 写法 | 描述 || ——————————— | ——————————————- || $(‘li:first-child’) | 查找li作为第一个孩子的元素 || $(‘li:last-child’) | 获取li的父元素的最后一个子元素 || $(‘li:only-child’) | 获取只有一个子元素的元素 || $(‘li:nth-child(even/odd/index)’) | 获取li是偶数/奇数/索引的子元素(索引从1开始) | 1234567891011121314151617181920212223242526&lt;body&gt;&lt;ul&gt; &lt;li&gt;1aaa&lt;/li&gt; &lt;li&gt;2bbb&lt;/li&gt; &lt;li&gt;3ccc&lt;/li&gt; &lt;li&gt;4ddd&lt;/li&gt; &lt;li&gt;5eee&lt;/li&gt;&lt;/ul&gt;&lt;div style="height:50px;background:#ccc;"&gt; &lt;span&gt;我是唯一的孩子&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function ()&#123; $('li:first-child').css('color','red'); $('li:last-child').css('color','deeppink'); //$('li:only-child').css('background','green'); $('span:only-child').css('background','green');//使div背景为绿色 $('li:nth-child(2)').css('color','peru'); $('li:nth-child(2n)').css('font-size','25px'); $('li:nth-child(3n+1)').css('font-family','华文行楷'); $('li:nth-child(odd)').css('background','wheat'); $('li:nth-child(even)').css('background','#ccc'); &#125;);&lt;/script&gt;&lt;/body&gt; 可见性过滤选择器 表单对象属性过滤选择器 1234567891011121314151617181920此选择器主要对所选择的表单元素进行过滤 1、:enabled //可用用法: $(”input:enabled”) 返回值 :集合元素 说明: 匹配所有可用元素.意思是查找所有input中不带有disabled=”disabled”的input.不为disabled,当然就为enabled啦. 2、:disabled //禁用用法: $(”input:disabled”) 返回值 :集合元素 说明: 匹配所有不可用元素.与上面的那个是相对应的. 3、:checked //被选中状态用法: $(”input:checked”) 返回值 :集合元素 说明: 匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option).这话说起来有些绕口. 4、:selected //被选中状态用法: $(”select option:selected”) 返回值 :集合元素 说明: 匹配所有选中的option元素. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;2-11&lt;/title&gt;&lt;script src="jquery-1.7.2.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;//&lt;![CDATA[$(document).ready(function()&#123; //重置表单元素 $(":reset").click(function()&#123; setTimeout(function() &#123; countChecked(); $("select").change(); &#125;,0); &#125;); //对表单内 可用input 赋值操作. $('#btn1').click(function()&#123; $("#form1 input:enabled").val("这里变化了！"); return false; &#125;) //对表单内 不可用input 赋值操作. $('#btn2').click(function()&#123; $("#form1 input:disabled").val("这里变化了！"); return false; &#125;) //使用:checked选择器，来操作多选框. $(":checkbox").click(countChecked); function countChecked() &#123; var n = $("input:checked").length; $("div").eq(0).html("&lt;strong&gt;有"+n+" 个被选中!&lt;/strong&gt;"); &#125; countChecked();//进入页面就调用. //使用:selected选择器，来操作下拉列表. $("select").change(function () &#123; var str = ""; $("select :selected").each(function () &#123; str += $(this).text() + ","; &#125;); $("div").eq(1).html("&lt;strong&gt;你选中的是："+str+"&lt;/strong&gt;"); &#125;).trigger('change'); // trigger('change') 在这里的意思是： // select加载后，马上执行onchange. // 也可以用.change()代替.&#125;);//]]&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; 表单对象属性过滤选择器.&lt;/h3&gt;&lt;form id="form1" action="#"&gt; &lt;button type="reset"&gt;重置所有表单元素&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;button id="btn1"&gt;对表单内 可用input 赋值操作.&lt;/button&gt; &lt;button id="btn2"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; 可用元素： &lt;input name="add" value="可用文本框"/&gt; &lt;br/&gt; 不可用元素： &lt;input name="email" disabled="disabled" value="不可用文本框"/&gt; &lt;br/&gt; 可用元素： &lt;input name="che" value="可用文本框" /&gt; &lt;br/&gt; 不可用元素： &lt;input name="name" disabled="disabled" value="不可用文本框"/&gt; &lt;br/&gt; &lt;br/&gt; 多选框：&lt;br/&gt; &lt;input type="checkbox" name="newsletter" checked="checked" value="test1" /&gt; test1 &lt;input type="checkbox" name="newsletter" value="test2" /&gt; test2 &lt;input type="checkbox" name="newsletter" value="test3" /&gt; test3 &lt;input type="checkbox" name="newsletter" checked="checked" value="test4" /&gt; test4 &lt;input type="checkbox" name="newsletter" value="test5" /&gt; test5 &lt;div&gt;&lt;/div&gt; &lt;br/&gt; &lt;br/&gt; 下拉列表1：&lt;br/&gt; &lt;select name="test" multiple="multiple" style="height:100px"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected="selected"&gt;湖南&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected="selected"&gt;天津&lt;/option&gt; &lt;option&gt;广东&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;br/&gt; 下拉列表2：&lt;br/&gt; &lt;select name="test2" &gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;湖南&lt;/option&gt; &lt;option selected="selected"&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;br/&gt; &lt;div&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其他方法 方法 写法 描述 is(s/o/e/f) $(‘span’).is(‘.red’) 判断span标签的class名是否是red hasClass(class) $(‘span’).eq(2).hasClass(‘.red’) 判断页面中的第二个span是否拥有class名为red slice(start,end) $(‘span’).slice(0,2) 选定span的索引是0和1的 end() $(‘span’).find(‘p’).end() 返回当前元素的上一个状态(这里的上一个状态可以是当前元素的父元素,也可以是当前元素的同级元素) contents() $(‘span’).contents() 获取span元素下的所有节点(元素节点、文本节点、属性节点) filter(s/o/e/f) $(‘span’).filter(‘.red,:first-child’) 过滤器:多种选择器的组合 注: s（是选择器）、o（是对象）、e（是索引）、f（是函数） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt;&lt;ul id="test"&gt; &lt;li&gt;0-1&lt;/li&gt; &lt;li id="red"&gt;1-2&lt;/li&gt; &lt;li&gt;2-3&lt;/li&gt; &lt;li title="blue" aaa="bbb"&gt;3-4&lt;/li&gt; &lt;li&gt;4-5&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;0-1&lt;/li&gt; &lt;li&gt;1-2&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; $(function () &#123;//***************is方法 alert($('li:nth-child(2)').is('#red'));//true alert($('#red').is($('li')));//true alert($('#red').is($('li').get(1)));//true alert($('li'));//jQuery对象 alert($('li').get(1));//DOM对象 alert($('li').is($('li').eq(1)));//true alert($('#red').is(function () &#123; return $(this).attr('id')==='red'; &#125;));//ture //***************hasClass方法// alert($('li').eq(1).hasClass('.red'));//false //***************slice方法 $('li').slice(1).css('background','peru');//从索引为1开始到最后都选定 $('li').slice(0,2).css('color','deeppink');//选定索引0和1 $('li').slice(0,-2).css('font-weight','bold');//从倒数第三个位置向前选定所有 $('li').slice(2,-2).css('font-size','20px');//前两个和后两个都不选定 //***************end方法 alert($('#test').find('li').get(0));//[object HTMLLIElement] alert($('#test').find('li').end().get(0));//[object HTMLUListElement] alert($('#test').find('li').parent().get(0));//等价上列 $('#test').next('ul').css('color','deeppink');//返回当前元素的同级元素ul //***************content方法 alert($('ul:nth-child(2)').contents().size());//5 alert($('ul:nth-child(2)').children().size());//3 var count=$('ul:nth-child(2)').contents(); for(var i=0;i&lt;count.length;i++)&#123; alert(i+':'+count[i].nodeName); //0:#text 1:LI 2:#text 3:LI 4:#text &#125; //***************filter方法 $('ul').filter('#test,:last').css('background','green'); //寻找满足id为test的ul,以及最后一个ul,并给予背景为绿色的样式 $('li').filter($('#test&gt;li:nth-child(2)')).css('color','deeppink'); $('li').filter($('li:nth-child(3)')).css('color','green'); $('li').filter(function () &#123; return $(this).attr('title')=='blue'&amp;&amp;$(this).attr('aaa')=='bbb'; &#125;).css('color','purple'); &#125;);&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205//选择器使用实例: $("#id", ".class") 复合选择器 //-------------&gt;记忆方法: 豆腐$(div p span) 层级选择器 //div下的p元素中的span元素------&gt;记忆方法: 后空翻$(div&gt;p) 父子选择器 //div下的所有p元素----&gt; 记忆方法: 父大于子$(div+p) 相邻元素选择器 //div后面的p元素(仅一个p)-----&gt;记忆方法: 嘉玲兄$(div~p) 兄弟选择器 //div后面的所有p元素(同级别)-----&gt;记忆方法:浪全兄$(.p:last) //类选择器 加 过滤选择器 第一个和最后一个（first 或者 last）$("#mytable td :odd") //层级选择 加 过滤选择器 奇偶（odd 或者 even）$("div p :eq(2)") //索引选择器 div下的第三个p元素（索引是从0开始）$("a[href='www.baidu.com']") //元素选择器 加 属性选择器$("p:contains(test)") // 内容过滤选择器，包含text内容的p元素$(":emtyp") //内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent 相反$(":hidden") //所有隐藏元素 visible $("input:enabled") //选取所有启用的表单元素$(":disabled") //所有不可用的元素$("input:checked") //获取所有选中的表单元素$("select option :selected") //获取选中的元素基本过滤选择器选取第一个元素(:first) //选择第一个div元素. $('#btn1').click(function()&#123; $('div:first').css("background","#bfa"); &#125;)选取最后一个元素(:last) //选择最后一个div元素. $('#btn2').click(function()&#123; $('div:last').css("background","#bfa"); &#125;)去除所有的与给定选择器匹配的元素(:not(selector)) //选择class不为one的 所有div元素. $('#btn3').click(function()&#123; $('div:not(.one)').css("background","#bfa"); &#125;)选取索引是偶数的所有元素，索引从0开始(:even) //选择 索引值为偶数 的div元素。 $('#btn4').click(function()&#123; $('div:even').css("background","#bfa"); &#125;)选取索引是奇数的所有元素，索引从0开始(:odd) //选择 索引值为奇数 的div元素。 $('#btn5').click(function()&#123; $('div:odd').css("background","#bfa"); &#125;)选取索引等于指定index的元素，索引从0开始(:eq(index)) //选择 索引等于 3 的元素 $('#btn6').click(function()&#123; $('div:eq(3)').css("background","#bfa"); &#125;)选取索引大于指定index的元素，索引从0开始(:gt(index)) //选择 索引大于 3 的元素 $('#btn7').click(function()&#123; $('div:gt(3)').css("background","#bfa"); &#125;)选取索引小于指定index的元素，索引从0开始(:lt(index)) //选择 索引小于 3 的元素 $('#btn8').click(function()&#123; $('div:lt(3)').css("background","#bfa"); &#125;)选取标题元素(:header) //选择 所有的标题元素.比如h1, h2, h3等等... $('#btn9').click(function()&#123; $(':header').css("background","#bfa"); &#125;)选取当前正在执行的动画的所有元素(:animated) //选择 当前正在执行动画的所有元素. $('#btn10').click(function()&#123; $(':animated').css("background","#bfa"); &#125;);选取当前获取焦点的所有元素(:focus) //选择 当前获取焦点的所有元素. $('#btn11').click(function()&#123; $(':focus').css("background","#bfa"); &#125;);内容过滤选择器选取包含指定文本的元素(:contains(text)) //选取含有文本"di"的div元素. $('#btn1').click(function()&#123; $('div:contains(di)').css("background","#bbffaa"); &#125;)选取不包含子元素或文本的空元素(:empty) //选取不包含子元素(或者文本元素)的div空元素. $('#btn2').click(function()&#123; $('div:empty').css("background","#bbffaa"); &#125;)选取含有选择器匹配元素的元素(:has(selector)) //选取含有class为mini元素 的div元素. $('#btn3').click(function()&#123; $("div:has('.mini')").css("background","#bbffaa"); &#125;)选取包含子元素或文本的空元素(:parent) //选取含有子元素(或者文本元素)的div元素. $('#btn4').click(function()&#123; $('div:parent').css("background","#bbffaa"); &#125;)可见性过滤器选取不可见的元素(:hidden) //选取所有不可见的元素.包括&lt;input type="hidden"/&gt;. $('#btn_hidden').click(function()&#123; $('div:hidden').show(3000).css("background","#bbffaa"); &#125;)选取可见的元素(:visible) //选取所有可见的元素. $('#btn_visible').click(function()&#123; $('div:visible').css("background","#FF6500"); &#125;)属性过滤器选取拥有此属性的元素([attribute]) //选取含有 属性title 的div元素. $('#btn1').click(function()&#123; $('div[title]').css("background","#bbffaa"); &#125;)选取属性值为value的元素([attribute=value]) //选取 属性title值等于 test 的div元素. $('#btn2').click(function()&#123; $('div[title=test]').css("background","#bbffaa"); &#125;)选取属性值不等于value的元素([attribute!=value]) //选取 属性title值不等于 test 的div元素. $('#btn3').click(function()&#123; $('div[title!=test]').css("background","#bbffaa"); &#125;)选取属性值以value开始的元素([attribute^=value]) //选取 属性title值 以 te 开始 的div元素. $('#btn4').click(function()&#123; $('div[title^=te]').css("background","#bbffaa"); &#125;)选取属性值以value结束的元素([attribute$=value]) //选取 属性title值 以 est 结束 的div元素. $('#btn5').click(function()&#123; $("div[title$=est]").css("background","#bbffaa"); &#125;)选取属性值含有value的元素([attribute*=value]) //选取 属性title值 含有 es 的div元素. $('#btn6').click(function()&#123; $("div[title*=es]").css("background","#bbffaa"); &#125;)选取属性值等于value或前缀为value(即”value-xxx”)的元素([attribute|=value]) //选取 属性title等于en或以en为前缀（该字符串后跟一个连字符'-'）的元素 $('#btn3').click(function()&#123; $('div[title|="en"]').css("background","#bbffaa"); &#125;)选取属性值用空格分隔的值中包含给定值的元素([attribute~=value]) //选取 属性title用空格分隔的值中包含字符uk的元素. $('#btn4').click(function()&#123; $('div[title~="uk"]').css("background","#bbffaa"); &#125;)组合属性选择器([attribute1][attribute2]…[attributeN]) //组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有 es 的元素. $('#btn7').click(function()&#123; $("div[id][title*=es]").css("background","#bbffaa"); &#125;)子元素过滤选择器选取每个父元素下的第一个子元素，返回集合元素 //选取每个父元素下的第一个子元素 $('#btn2').click(function()&#123; $('div.one :first-child').css("background","#bbffaa"); &#125;)选取每个父元素下的最后一个子元素，返回集合元素 //选取每个父元素下的最后一个子元素 $('#btn3').click(function()&#123; $('div.one :last-child').css("background","#bbffaa"); &#125;)选取每个父元素下的唯一子元素，返回集合元素 //如果父元素下的仅仅只有一个子元素，那么选中这个子元素 $('#btn4').click(function()&#123; $('div.one :only-child').css("background","#bbffaa"); &#125;)选取每个父元素下的第index个子元素或者奇偶元素，index从1算起 //选取每个父元素下的第2个子元素 $('#btn1').click(function()&#123; $('div.one :nth-child(2)').css("background","#bbffaa"); &#125;) 1.6.2 关于 : 和 [ ] 这两个符号的理解： 即为 jQuery 的过滤选择器，语法类似于 css 中的伪类选择器；可以理解为种类的意思，如：p:first，p 的种类为第一个。 [ ] 很自然的可以理解为属性的意思，如：[href] 选取带有 href 属性的元素。 1.6.3 \$(“button”) 与 $(“:button”)区别:前者为基本选择器中的元素选择器, 只能获取 \ 元素。 后者为表单选择器: 可以选取所有button包括作为属性值的button和button标签 例如: type=”button” 的 \ 元素 和\ 元素 1.7 jQuery事件### 1.7.1 常用的 jQuery 事件方法①: $(document).ready() ②: click() 和 dblclick()——当双击元素时，会发生 dblclick 事件 123$("p").dblclick(function()&#123; $(this).hide();&#125;); ③: mouseenter() 和 mouseleave() 及 mousedown() mouseup()—–当在元素上松开鼠标按钮时，会发生 mouseup 事件。 ④: hover() ⑤: focus() 和 blur()—-当元素失去焦点时，发生 blur 事件。 123$("input").blur(function()&#123; $(this).css("background-color","#ffffff");&#125;); ⑥: bind(),unbind() ⑦: submit() 1.8 获取内容和属性jQuery 中非常重要的部分，就是操作 DOM 的能力。 DOM = Document Object Model（文档对象模型）,DOM 定义访问 HTML 和 XML 文档的标准 1.8.1 获得内容 - text()、html() 以及 val()三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 123$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;); 1.8.2 获取属性 - attr()123456789101112131415161718192021//下面的例子演示如何获得链接中 href 属性的值：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; //获得链接中 href 属性的值： alert($("#baidu").attr("href")); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;a href="//www.baidu.com" id="baidu"&gt;百度&lt;/a&gt;&lt;/p&gt; &lt;button&gt;显示 href 属性的值&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 1.9 attr 和 prop 的区别介绍：对于 HTML 元素本身就带有的固有属性，在处理时，使用 prop 方法。 对于 HTML 元素我们自己自定义的 DOM 属性，在处理时，使用 attr 方法。 prop()函数的结果: ​ 1.如果有相应的属性，返回指定属性值。 ​ 2.如果没有相应的属性，返回值是空字符串。 attr()函数的结果: ​ 1.如果有相应的属性，返回指定属性值。 ​ 2.如果没有相应的属性，返回值是 undefined。 具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop() 实例 ： 123456789101112&lt;a href="https://www.baidu.com" target="_self" class="btn"&gt;百度&lt;/a&gt;/*这个例子里 &lt;a&gt; 元素的 DOM 属性有: href、target 和 class，这些属性就是 &lt;a&gt; 元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在 IDE 里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用 prop 方法。*/&lt;a href="#" id="link1" action="delete" rel="nofollow"&gt;删除&lt;/a&gt;/*这个例子里 &lt;a&gt; 元素的 DOM 属性有: href、id 和 action，很明显，前两个是固有属性，而后面一个 action 属性是我们自己自定义上去的，&lt;a&gt; 元素本身是没有这个属性的。这种就是自定义的 DOM 属性。处理这些属性时,建议使用attr方法。*/ 1.10 设置内容和属性1.10.1设置内容 - text()、html() 以及 val()——-&gt;本身没有内容123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("RUNOOB");&#125;); 1.10.2 text()、html() 以及 val() 的回调函数1234567891011121314/*回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。*/$("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;);&#125;);$("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;);&#125;); 1.10.3 设置属性 - attr()1234567891011121314//改变（设置）链接中 href 属性的值：$("button").click(function()&#123; $("#baidu").attr("href","http://www.baidu.com/jquery");&#125;);//也允许您同时设置多个属性。$("button").click(function()&#123; $("#baidu").attr(&#123; "href" : "http://www.baidu.com/jquery", "title" : "jQuery 教程" &#125;);&#125;); 1.10.4 attr() 的回调函数1234567//回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。$("button").click(function()&#123; $("#baidu").attr("href", function(i,origValue)&#123; return origValue + "/jquery"; &#125;);&#125;); 1.11 获取和修改对比: 1.12 添加元素1.12.1 添加新内容的 jQuery 方法如下： 1.12.2 append/prepend和after/before区别举例:append: 12345678910111213&lt;p&gt; &lt;span class="s1"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;script&gt; $("p").append('&lt;span class="s2"&gt;s2&lt;/span&gt;');&lt;/script&gt; //运行结果:&lt;p&gt; &lt;span class="s1"&gt;s1&lt;/span&gt; &lt;span class="s2"&gt;s2&lt;/span&gt;&lt;/p&gt; prepend 12345678910111213&lt;p&gt; &lt;span class="s1"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;script&gt; $("p").prepend('&lt;span class="s2"&gt;s2&lt;/span&gt;');&lt;/script&gt; //运行结果:&lt;p&gt; &lt;span class="s2"&gt;s2&lt;/span&gt; &lt;span class="s1"&gt;s1&lt;/span&gt;&lt;/p&gt; after 12345678910111213&lt;p&gt; &lt;span class="s1"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;script&gt; $("p").after('&lt;span class="s2"&gt;s2&lt;/span&gt;');&lt;/script&gt;//结果是这样的:&lt;p&gt; &lt;span class="s1"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;span class="s2"&gt;s2&lt;/span&gt; 1.12.3 总结：append/prepend 是在选择元素内部嵌入。prepend 是在内部且已有内容的最前面添加,append是在内部且已有内容的后面添加 after/before 是在元素外面追加。 1.13 删除元素1.13.1 一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 在使用 remove() 的过滤器删除时，不能删除带有过滤器的子元素。就是说如果子元素符合过滤器中条件而父元素不符合的话，是不会删除符合条件的子元素，即过滤器中条件只能作用于同级，不能作用于子元素。 $(selector) 语法的返回结果是一个元素的列表，即：将 $(“#div1”) 看作一个列表，remove() 中的筛选条件实际上是对这个列表中的元素进行筛选删除，而不会去删除这个列表中不存在的元素（子元素不在这个列表中）。 1.13.2 remove和empty的区别:empty() 12345678910111213141516171819202122&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").empty(); &#125;);&#125;);&lt;/script&gt;&lt;body&gt; &lt;div id="div1" style="height:100px;width:300px;border:1px solid black;background-color:yellow;"&gt; 这是 div 中的一些文本。 &lt;p&gt;这是在 div 中的一个段落。&lt;/p&gt; &lt;p&gt;这是在 div 中的另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;br&gt; &lt;button&gt;清空div元素&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 点击前 点击后 remove() 12345678910111213141516171819&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").remove(); &#125;);&#125;);&lt;/script&gt;&lt;body&gt; &lt;div id="div1" style="height:100px;width:300px;border:1px solid black;background-color:yellow;"&gt; 这是 div 中的一些文本。 &lt;p&gt;这是在 div 中的一个段落。&lt;/p&gt; &lt;p&gt;这是在 div 中的另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;br&gt; &lt;button&gt;移除div元素&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 点击前 点击后 1.14 常用选择器实例: 语法: 选择器类型: 描述: $(“*”) 通配符选择器 选取所有元素 $(this) 元素选择器 选取当前 HTML 元素 $(“p.intro”)==也可以为(“p[class = intro]”)== 交集选择器 元素选择器与类选择器组成的交集选择器==也可以为 元素选择器与属性选择器== 选取 class值 为 intro 的 \ 元素 $(“p:first”) 基本的过滤器 选取第一个 \ 元素 $(“ul li:first”) 后代选择器和 过滤器 选取第一个 \ 元素的第一个 \ 元素 $(“ul li:first-child”) 后代选择器和 过滤器 选取每个 \ 元素的第一个 \ 元素 $(“[href]”) 属性选择器 选取带有 href 属性的元素 $(“a[target=’_blank’]”) 元素选择器和属性选择器 选取所有 target 属性值等于 “_blank” 的 \ 元素 $(“a[target!=’_blank’]”) 元素选择器和属性选择器 选取所有 target 属性值不等于 “_blank” 的 \ 元素 $(“:button”) 表单选择器 ==选取所有 type=”button” 的 \ 元素 和 \ 元素== $(“button”) 元素选择器 ==只能选取\ 元素== $(“tr:even”) 基本的过滤器 选取偶数位置的 \ 元素 $(“tr:odd”) 基本的过滤器 选取奇数位置的 \ 元素 二、jQuery与DOM2.1 jQuery 和 DOM对象互转jQuery对象: var $ x; DOM对象: var x; jQuery对象转DOM对象: —–&gt; \$x[y] 或 $x.get(y) DOM对象转jQuery对象: —-&gt;$(DOM对象) 三、jQuery与Ajax3.1 什么是 AJAX？AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript And XML）。 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。 3.2 jQuery与Ajax联系jQuery 提供多个与 AJAX 有关的方法。通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。 3.3 ajax() 方法ajax() 方法用于执行 AJAX（异步 HTTP）请求。 所有的 jQuery AJAX 方法都使用 ajax() 方法。该方法通常用于其他方法不能完成的请求 3.3.1 语法$.ajax({name:value, name:value, ... }) 该参数规定 AJAX 请求的一个或多个名称/值对。 下面的表格中列出了可能的名称/值： 名称 值/描述 async 布尔值，表示请求是否异步处理。默认是 true。 beforeSend(xhr) 发送请求前运行的函数。 cache 布尔值，表示浏览器是否缓存被请求页面。默认是 true。 complete(xhr,status) 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。 contentType 发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。 context 为所有 AJAX 相关的回调函数规定 “this” 值。 data 规定要发送到服务器的数据。 dataFilter(data,type) 用于处理 XMLHttpRequest 原始响应数据的函数。 dataType 预期的服务器响应的数据类型。 error(xhr,status,error) 如果请求失败要运行的函数。 global 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。 ifModified 布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。 jsonp 在一个 jsonp 中重写回调函数的字符串。 jsonpCallback 在一个 jsonp 中规定回调函数的名称。 password 规定在 HTTP 访问认证请求中使用的密码。 processData 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。 scriptCharset 规定请求的字符集。 success(result,status,xhr) 当请求成功时运行的函数。 timeout 设置本地的请求超时时间（以毫秒计）。 traditional 布尔值，规定是否使用参数序列化的传统样式。 type 规定请求的类型（GET 或 POST）。 url 规定发送请求的 URL。默认是当前页面。 username 规定在 HTTP 访问认证请求中使用的用户名。 xhr 用于创建 XMLHttpRequest 对象的函数。 3.3.2 实例:123456//使用 AJAX 请求改变 &lt;div&gt; 元素的文本：$("button").click(function()&#123; $.ajax(&#123;url:"demo_test.txt",success:function(result)&#123; $("#div1").html(result); &#125;&#125;);&#125;); 3.4 load() 方法jQuery load() 方法是简单但强大的 AJAX 方法。 load() 方法从服务器加载数据，并把返回的数据放入被选元素中。 3.4.1 语法: $(selector).load(URL,data,callback); 必需的 URL 参数规定您希望加载的 URL。 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback 参数是load() 方法完成后所执行的函数名称。 3.4.2 使用举例:把文件 “demo_test.txt” 的内容加载到指定的 元素中： 1$("#div1").load("demo_test.txt"); 也可以把 jQuery 选择器添加到 URL 参数。下面的例子把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的 元素中： 1$("#div1").load("demo_test.txt #p1"); 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示”外部内容加载成功！”，而如果失败，则显示错误消息： 12345678$("button").click(function()&#123; $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt=="success") alert("外部内容加载成功!"); if(statusTxt=="error") alert("Error: "+xhr.status+": "+xhr.statusText); &#125;);&#125;); 3.4.3 load方法的应用为了避免多页面情形下的代码重复，可以利用 load() 方法，将重复的部分（例如导航栏）放入单独的文件，使用下列方法进行导入： 123456789101112131415//1.当前文件中要插入的地方使用此结构：&lt;div class="include" file="***.html"&gt;&lt;/div&gt;//2.***.html中放入内容，用html格式仅仅因为会有编辑器的书写辅助。。//3.代码：$(".include").each(function() &#123; if (!!$(this).attr("file")) &#123; var $includeObj = $(this); $(this).load($(this).attr("file"), function(html) &#123; $includeObj.after(html).remove(); //加载的文件内容写入到当前标签后面并移除当前标签 &#125;) &#125;&#125;);或者在index文件里只写重复部分，剩下的一股脑放各自单独文件 load() 进来~ 3.5 get() 和 post() 方法jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。 3.5.1 HTTP 请求：GET vs. POSTGET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。 3.5.2 $.get() 方法$.get() 方法通过 HTTP GET 请求从服务器上请求数据。 3.5.2.1 语法:$.get(URL,callback); ①: 必需的 URL 参数规定您希望请求的 URL。 ②: 可选的 callback 参数是请求成功后所执行的函数名。 3.5.2.2 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：12345$("button").click(function()&#123; $.get("demo_test.php",function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;);&#125;); $.get() 的第一个参数是我们希望请求的 URL（”demo_test.php”）。第二个参数是回调函数。第一个回调参数data存放服务器返回的数据，第二个回调参数status存放请求的处理状态。 3.5.3 $.post() 方法$.post() 方法通过 HTTP POST 请求向服务器提交数据。 3.5.3.1 语法$.post(URL,data,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 data 参数规定连同请求发送的数据。 可选的 callback 参数是请求成功后所执行的函数名。 3.5.3.2 下面的例子使用 $.post() 连同请求一起发送数据：12345678910$("button").click(function()&#123; $.post("/try/ajax/demo_test_post.php", &#123; name:"百度", url:"http://www.baidu.com" &#125;, function(data,status)&#123; alert("数据: \n" + data + "\n状态: " + status); &#125;);&#125;); $.post() 的第一个参数是我们希望请求的 URL (“demo_test_post.php”)。 第二个参数{name:”百度”,url:”http://www.baidu.com&quot;},是准备发送给服务器的数据 “demo_test_post.php” 中的 PHP 脚本读取这些参数，对它们进行处理，然后返回结果。 第三个参数是回调函数function。第一个回调参数data存放服务器返回的数据，而第二个参数status存放请求的处理状态。 四、jQuery与CSS/HTML4.1 获取并设置 CSS 类jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些： addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 4.1.1 addClass() 方法4.1.1.1 向不同的元素添加 class 属性。当然，在添加类时，您也可以选取多个元素如p,h1,h2：12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important"); &#125;); &#125;); &lt;/script&gt; &lt;style type="text/css"&gt; .important &#123; font-weight:bold; font-size:xx-large; &#125; .blue &#123; color:blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题 1&lt;/h1&gt; &lt;h2&gt;标题 2&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;div&gt;这是一些重要的文本!&lt;/div&gt; &lt;br&gt; &lt;button&gt;为元素添加 class&lt;/button&gt;&lt;/body&gt; 当执行上述代码,然后点击button按钮前后,代码应该变化如下: 123456789101112131415161718192021//点击前:&lt;body&gt; &lt;h1&gt;标题 1&lt;/h1&gt; &lt;h2&gt;标题 2&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; &lt;div&gt;这是一些重要的文本!&lt;/div&gt; &lt;br&gt; &lt;button&gt;为元素添加 class&lt;/button&gt;&lt;/body&gt;//点击后:&lt;body&gt; &lt;h1 class="blue"&gt;标题 1&lt;/h1&gt; &lt;h2 class="blue"&gt;标题 2&lt;/h2&gt; &lt;p class="blue"&gt;这是一个段落。&lt;/p&gt; &lt;p class="blue"&gt;这是另外一个段落。&lt;/p&gt; &lt;div class="important"&gt;这是一些重要的文本!&lt;/div&gt; &lt;br&gt; &lt;button&gt;为元素添加 class&lt;/button&gt;&lt;/body&gt; 4.1.1.2 也可以在 addClass() 方法中规定多个类123$("button").click(function()&#123; $("body div:first").addClass("important blue");&#125;); 4.1.2 CSS() 方法css() 方法设置或返回被选元素的一个或多个样式属性。 4.1.2.1 返回 CSS 属性4.1.2.1.1 语法:css(“propertyname“); 4.1.2.1.2 下面的例子将返回首个匹配元素的 background-color 值：1$("p").css("background-color"); 4.1.2.2 设置 CSS 属性4.1.2.2.1 语法:css(“propertyname“,”value“); 4.1.2.2.2 下面的例子将为所有匹配元素设置 background-color 值：1$("p").css("background-color","yellow"); 4.1.2.3 设置多个 CSS 属性4.1.2.3.1 语法:css({“propertyname“:”value“,”propertyname“:”value“,…}); 4.1.2.2.2 下面的例子将为所有匹配元素设置 background-color 和 font-size：1$("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种排序算法]]></title>
    <url>%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、常见排序算法 二、记忆口诀(对应上面框出部分) 三、快速排序 它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。 该方法的基本思想是： 1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数。 虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法： 先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。 以一个数组作为示例，取区间第一个数为基准数。—-&gt;X 存放基准数 初始时，i = 0; j = 9; X = a[i] = 72 由于已经将 a[0] 中的数保存到 X 中，可以理解成在数组 a[0] 上挖了个坑，可以将其它数据填充到这来。 从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–; 数组变为： i = 3; j = 7; X=72 再重复上面的步骤，先从后向前找，再从前向后找。 从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++; 从i开始向后找，当i=5时，由于i==j退出。 此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。 数组变为： 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。 对挖坑填数进行总结: 1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。 2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 照着这个总结很容易实现挖坑填数的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class QuickSort &#123; static int AdjustArray(int s[], int l, int r) //返回调整后基准数的位置 &#123; int i = l, j = r; int x = s[l]; //s[l]即s[i]就是第一个坑 while (i &lt; j) &#123; // 从右向左找小于x的数来填s[i] while(i &lt; j &amp;&amp; s[j] &gt;= x) &#123; j--; &#125; if(i &lt; j) //说明是由于s[j] &lt; x 导致循环退出的,即找到了小于基准数x的数 &#123; s[i] = s[j]; //将s[j]填到s[i]中，s[j]就形成了一个新的坑 i++; &#125; // 从左向右找大于或等于x的数来填s[j] while(i &lt; j &amp;&amp; s[i] &lt; x) &#123; i++; &#125; if(i &lt; j)//说明是由于s[i] &gt;= x 导致的循环退出,即找到了大于或等于基准数x的数 &#123; s[j] = s[i]; //将s[i]填到s[j]中，s[i]就形成了一个新的坑 j--; &#125; &#125; //退出时，i等于j。将x填到这个坑中。 s[i] = x; return i;//此时的基准数存放在数组的第i个位置 &#125; static void quick_sort1(int s[], int l, int r) &#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r); // 先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 //对基准数左边的部分进行排序 quick_sort1(s, i + 1, r); // 递归调用 //对基准数右边的部分进行排序 &#125; &#125; public static void main(String[] args) &#123; int s[] = &#123;72,6,57,88,60,42,83,73,48,85&#125;; quick_sort1(s,0,9); for (int i = 0;i&lt;s.length;i++) &#123; System.out.print(s[i]+","); &#125; &#125;&#125; 四、冒泡排序这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。 冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 4.1 什么时候最快当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用） 4.2 什么时候最慢当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗） 4.3 分析找规律2个数 共比较1趟: 第1 趟比较1次 3个数共比较2趟: 第1趟比较2次 第2趟比较1次 4个数共比较3趟 第1趟比较3次 第2趟比较2次 第3趟比较1次 ………….依次类推; 规律: n个数共比较n-1趟: 第 i 趟 和 第 i 趟的比较次数之和为 需排序的数字总数; 也就是: 每一趟中比较次数: 第 i 趟 比较 n - i 次; 4.4 代码12345678910111213141516171819202122232425262728293031public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); //arr.length 个数 ,共比较 arr.length -1 趟 for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; // 第 i 趟 ,共比较 arr.length - i 次 for (int j = 0; j &lt; arr.length - i; j++) &#123;//数组下标从零开始 if (arr[j] &gt; arr[j + 1]) &#123; //左边大于右边就交换 int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false;//标记,这一趟中交换过 &#125; &#125; if (flag) &#123; // 如果flag为true,说明在某一趟中 没有交换数据,也就说明所有元素有序了,不必进行后 //面的比较 break; &#125; &#125; return arr; &#125;&#125; 五、选择排序无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 5.1 算法步骤①: 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。②: 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。③: 重复第二步，直到所有元素均排序完毕。 5.2 分析找规律2个数 共比较1趟 第1 趟比较1次 3个数共比较 2 趟 第 1 趟比较 2 次 第 2 趟比较 1 次 4个数共比较3趟 第1趟比较3次 第2趟比较2次 第3趟比较1次 ………….依次类推; 规律: n个数共比较n-1趟: 第 i 趟 和 第 i 趟的比较次数之和为 需排序的数字总数; 也就是: 每一趟中比较次数: 第 i 趟 比较 n - i 次; 发现和冒泡法规律一样; 但是代码中会有些不同. 体现在代码中时不同点表现在循环条件这里: 冒泡法中 每一趟 都是从第0号元素开始与后面元素比较, 选择法中 第 i 趟时 是让第 i 号元素与其后面所有元素比较. 5.3 代码1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // N 个数 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //数组下标从零开始 int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 六、插入排序6.1 工作原理:它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 6.2 算法步骤将整个待排序的数组元素看成两个部分: 有序序列 和 未排序序列 刚开始时数组第一个元素(下标为零) 作为 有序序列, 数组的第2个元素( 下标为1 )至最后一个元素作为 未排序序列. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素依次从有序序列的最右边开始往有序序列的左边比较直到符合条件时插入。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 6.3 代码1234567891011121314151617181920212223242526272829public class InsertSort &#123; public static void main(String[] args) &#123; int s[] = &#123;9,3,1,4,6,8,7,5,2&#125;; insertionSort(s); print(s); &#125; static void insertionSort(int []a) &#123; //下标从零开始,第一张牌作为有序序列,从第二张牌到最后一张牌中选择一张扑克牌 for (int i = 1; i &lt; a.length; i++) &#123; for (int j = i; j&gt; 0; j--)&#123;//插入有序序列 if (a[j] &lt; a[j-1]) &#123; swap(a,j,j-1); &#125; &#125; &#125; &#125; static void swap(int []s,int i,int j) &#123; int temp = s[i]; s[i] = s[j]; s[j] = temp; &#125; static void print(int[]arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+" "); &#125; &#125;&#125; 优化: 七、希尔排序希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 7.1 代码间隔为4]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web相关的面试题及答案]]></title>
    <url>%2FWeb%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[[TOC] 1. WEB应用中如果有.class和.jar类型的文件一般分别应该放在什么位置？答:.class文件放在WEB-INF/classes文件下，.jar文件放在WEB-INF/lib文件夹下 2. 元素中有一个输入框（&lt; input type=’text’ name=”username”id=”username”value=””/&gt;,请用JavaScript语言写一行代码，取得这个输入框中的值答:document.getElementById(“username”).value; 3. 简单描述一下Servlet与JSP的的相同点和区别点。区别： JSP是在HTML代码里写JAVA代码,框架是HTML; 而Servlet是在JAVA代码中写HTML代码，本身是个JAVA类。 JSP使人们把显示和逻辑分隔成为可能，这意味着两者的开发可并行进行；而Servlet并没有把两者分开。 Servlet独立地处理静态表示逻辑与动态业务逻辑.这样,任何文件的变动都需要对此服务程序重新编译;JSP允许用特殊标签直接嵌入到HTML页面, HTML内容与JAVA内容也可放在单独文件中,HTML内容的任何变动会自动编译装入到服务程序. Servlet需要在web.xml中配置，而JSP无需配置 目前JSP主要用在视图层，负责显示，而Servlet主要用在控制层，负责调度 联系： 都是Sun公司推出的动态网页技术。 先有Servlet，针对Servlet缺点推出JSP。JSP是Servlet的一种特殊形式，每个JSP页面就是一个Servlet实例——JSP页面由系统翻译成Servlet，Servlet再负责响应用户请求。 4. 请简单描述下几个您熟悉JavaScript库，它们有哪些作用和特点？JavaScript 高级程序设计（特别是对浏览器差异的复杂处理），通常很困难也很耗时。为了应对这些调整，许多的 JavaScript库应运而生。这些 JavaScript 库常被称为 JavaScript 框架。 jQuery: Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet applications）。 Prototype MooTools。 YUI - Yahoo! User Interface Framework，涵盖大量函数的大型库，从简单的 JavaScript 功能到完整的 internet widget。 5. 简单描述HTML，CSS，Javascript在Web开发中分别起什么作用？1、什么是HTML（超文本标记语言 Hyper Text Markup Language），HTML 是用来描述网页的一种语言。 2、CSS(层叠样式表 Cascading Style Sheets),样式定义如何显示 HTML 元素， 语法为：selector {property：value} 即(选择符 {属性：值}) 3、JavaScript是一种脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行 对于一个网页，HTML定义网页的结构，CSS描述网页的样子，JavaScript动作 设置一个很经典的例子是说HTML就像 一个人的骨骼、器官，而CSS就是人的皮肤，有了这两样也就构成了一个植物人了，加上javascript这个植物人就可以对外界刺激做出反应，可以思 考、运动、可以给自己整容化妆（改变CSS）等等，成为一个活生生的人。 如果说HTML是肉身、CSS就是皮相、Javascript就是灵魂。没有Javascript,HTML+CSS是植物人，没有Javascript、CSS是个毁容的植物人。 如果说HTML是建筑师，CSS就是干装修的，Javascript是魔术师。 6. 举例说明JAVA中如何解析xml，不同方式有和优缺点？答： 6.1 DOM（Document Object Model)DOM是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的。 【优点】 ①允许应用程序对数据和结构做出更改。 ②访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据。 【缺点】 ①通常需要加载整个XML文档来构造层次结构，消耗资源大。 6.2 SAX（Simple API for XML)SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点。事实上，应用程序甚至不必解析整个文档；它可以在某个条件得到满足时停止解析。一般来说，SAX还比它的替代者DOM快许多。 选择DOM还是选择SAX？ 对于需要自己编写代码来处理XML文档的开发人员来说， 选择DOM还是SAX解析模型是一个非常重要的设计决策。DOM采用建立树形结构的方式访问XML文档，而SAX采用的是事件模型。 DOM解析器把XML文档转化为一个包含其内容的树，并可以对树进行遍历。用DOM解析模型的优点是编程容易，开发人员只需要调用建树的指令，然后利用navigation APIs访问所需的树节点来完成任务。可以很容易的添加和修改树中的元素。然而由于使用DOM解析器的时候需要处理整个XML文档，所以对性能和内存的要求比较高，尤其是遇到很大的XML文件的时候。由于它的遍历能力，DOM解析器常用于XML文档需要频繁的改变的服务中。 SAX解析器采用了基于事件的模型，它在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法指定的标签已经找到。SAX对内存的要求通常会比较低，因为它让开发人员自己来决定所要处理的tag.特别是当开发人员只需要处理文档中所包含的部分数据时，SAX这种扩展能力得到了更好的体现。但用SAX解析器的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数据。 【优势】 ①不需要等待所有数据都被处理，分析就能立即开始。 ②只在读取数据时检查数据，不需要保存在内存中。 ③可以在某个条件得到满足时停止解·析，不必解析整个文档。 ④效率和性能较高，能解析大于系统内存的文档。 【缺点】 ①需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），文档越复杂程序就越复杂。 ②单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。 6.3 JDOM(Java-based Document Object Model)JDOM的目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一个Java特定模型，JDOM一直得到大力推广和促进。正在考虑通过“Java规范请求JSR-102”将它最终用作“Java标准扩展”。从2000年初就已经开始了JDOM开发。 JDOM与DOM主要有两方面不同。首先，JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。 JDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题”（根据学习曲线假定为20%）。JDOM对于大多数Java/XML应用程序来说当然是有用的，并且大多数开发者发现API比DOM容易理解得多。JDOM还包括对程序行为的相当广泛检查以防止用户做任何在XML中无意义的事。然而，它仍需要您充分理解XML以便做一些超出基本的工作（或者甚至理解某些情况下的错误）。这也许是比学习DOM或JDOM接口都更有意义的工作。 JDOM自身不包含解析器。它通常使用SAX2解析器来解析和验证输入XML文档（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。 【优点】 ①使用具体类而不是接口，简化了DOM的API。 ②大量使用了Java集合类，方便了Java开发人员。 【缺点】 ①没有较好的灵活性。 ②性能较差。 6.4 DOM4J(Document Object Model for Java)虽然DOM4J代表了完全独立的开发结果，但最初，它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过DOM4J API和标准DOM接口具有并行访问功能。从2000下半年开始，它就一直处于开发之中。 为支持所有这些功能，DOM4J使用接口和抽象基本类方法。DOM4J大量使用了API中的Collections类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然DOM4J付出了更复杂的API的代价，但是它提供了比JDOM大得多的灵活性。 在添加灵活性、XPath集成和对大文档处理的目标时，DOM4J的目标与JDOM是一样的：针对Java开发者的易用性和直观操作。它还致力于成为比JDOM更完整的解决方案，实现在本质上处理所有Java/XML问题的目标。在完成该目标时，它比JDOM更少强调防止不正确的应用程序行为。 DOM4J是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML，特别值得一提的是连Sun的JAXM也在用DOM4J. 【优点】 ①大量使用了Java集合类，方便Java开发人员，同时提供一些提高性能的替代方法。 ②支持XPath。 ③有很好的性能。 【缺点】 ①大量使用了接口，API较为复杂。 6.5 比较\1. DOM4J性能最好，连Sun的JAXM也在用DOM4J。目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的Hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J. \2. JDOM和DOM在性能测试时表现不佳，在测试10M文档时内存溢出，但可移植。在小文档情况下还值得考虑使用DOM和JDOM.虽然JDOM的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM仍是一个非常好的选择。DOM实现广泛应用于多种编程语言。它还是许多其它与XML相关的标准的基础，因为它正式获得W3C推荐（与基于非标准的Java模型相对），所以在某些类型的项目中可能也需要它（如在JavaScript中使用DOM）。 \3. SAX表现较好，这要依赖于它特定的解析方式－事件驱动。一个SAX检测即将到来的XML流，但并没有载入到内存（当然当XML流被读入时，会有部分文档暂时隐藏在内存中）。 6.6 我的看法：如果XML文档较大且不考虑移植性问题建议采用DOM4J；如果XML文档较小则建议采用JDOM；如果需要及时处理而不需要保存数据则考虑SAX。但无论如何，还是那句话：适合自己的才是最好的，如果时间允许，建议大家讲这四种方法都尝试一遍然后选择一种适合自己的即可。 7. char型变量中能不能存储一个中文汉字？答：1.java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。 2.char 在java中是2个字节，所以可以存储中文 8. 接口与抽象类一个类可以实现多个接口，但只能继承一个抽象类。 下面接着再说说两者在应用上的区别： 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下： 12345678910111213141516171819202122232425public abstract classBaseServlet extends HttpServlet&#123; public final void service(HttpServletRequest request,HttpServletResponse response) throws IOExcetion,ServletException &#123; 记录访问日志 进行权限判断 if(具有权限)&#123; try&#123; doService(request,response); &#125; catch(Excetpion e) &#123; 记录异常信息 &#125; &#125; &#125; protected abstract void doService(HttpServletRequest request,HttpServletResponse response) throws IOExcetion,ServletException; //注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的&#125;public class MyServlet1 extendsBaseServlet&#123; protected voiddoService(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException &#123; 本Servlet只处理的具体业务逻辑代码 &#125;&#125; 父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。 9. 比较一下Java 和JavaSciprt答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。 下面对两种语言间的异同作如下比较： 1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用； 2）解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行； 3）强类型变量和弱类型变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型； 4）代码格式不一样。 补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。 10. UML是什么？UML中有哪些图？答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。 在这些图形化符号中，有三种图最为重要:分别是： ①: 用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系） ②: 类图（描述类以及类与类之间的关系，通过该图可以快速了解系统） ③: 时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 11. XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？答： XML文档定义分为DTD和Schema两种形式； 其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析。 对XML的解析主要有DOM（文档对象模型）、SAX、StAX（JDK 1.6中引入的新的解析XML的方式，Streaming API for XML） 等，其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM 的树结构所造成的，这种结构占用的内存较多，而且DOM 必须在解析文件之前把整个文档装入内存,适合对XML 的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML 的顺序访问；如其名称所暗示的那样，StAX把重点放在流上。实际上，StAX与其他方法的区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（事实上 SAX 已经提出来了），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 12. 你在项目中哪些地方用到了XML？答： XML的主要作用有两个方面：数据交换（曾经被称为业界数据交换的事实标准，现在此项功能在很多时候都被JSON取代）和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理。目前很多软件都使用XML来存储配置信息，很多项目中我们通常也会将作为配置的硬代码（hard code）写在XML文件中，Java的很多框架也是这么做的。 13. 用JavaScript实现用正则表达式验证，某个字符串是合法的6位数字的邮编的函数12345678910Function testE(ss)&#123; //在正则表达式中，/顺斜杠是表示表达式的开始和结束的“定界符”。\反斜杠是表示转义字符。 //其中^匹配输入字符串的开始位置,$匹配输入字符串的结束位置 var reg = /^[1-9][0-9]&#123;5&#125;$/; if(req.test(ss))&#123; //这里调用JavaScript已有的test函数 alert(“邮编OK”) &#125; else &#123; alert(“邮编格式不正确”)； &#125;&#125; 14. 请使用JQuery将页面上的所有元素边框设置为2pix宽的虚线？123//获取指定名称的样式使用带一个参数css方法,如果要修改指定名称的样式,则使用带两个参数的css方法//*是通配符$("*").css("border","2px dashed"); 15. 如何设定JQuery异步调用还是同步调用？答案：调用jQuery中的ajax函数，设置其async属性来表明是异步还是同步，如下： 123$.ajax(&#123; async:true//表示异步，false表示同步&#125;) 16. 说出3条以上firefox和IE的浏览器兼容问题？答案： IE下,可以使用()或[]获取集合类对象; Firefox下,只能使用[]获取集合类对象. ——&gt;解决方法:统一使用[ ]获取集合类对象. IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性.——–&gt;解决方法:统一通过getAttribute()获取自定义属性 17. 请用Jquery语言写出ajax请求或者post请求代码123$.post(&#123; &#125;) 18. .jQuery中有哪几种类型的选择器？答案： 基本选择器 层次选择器 基本过滤选择器 内容过滤选择器 可见性过滤选择器 属性过滤选择器 子元素过滤选择器 表单选择器 表单过滤选择器 19. body中的onload （）函数和jQuery中document.ready()有什么区别？答案：ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件） onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。 20. 请用Jquery语言写出ajax请求或者post请求代码123$.post(“show”,&#123;uname=”张三”，pwd=”123”&#125;,function(data)&#123; alert(data)&#125;) 21. 分别写出一个div居中和其中的内容居中的css属性设置1234div &#123; margin: auto,0px; //Div居中： text-align: center;//内容居中:&#125; 22. 概述一下session与cookie的区别答案： ①: 存储角度： Session是服务器端的数据存储技术，cookie是客户端的数据存储技术 ②: 解决问题角度： Session解决的是一个用户不同请求的数据共享问题，cookie解决的是不同请求的请求数据的共享问题 ③: 生命周期角度： Session的id是依赖于cookie来进行存储的，浏览器关闭id就会失效 Cookie可以单独的设置其在浏览器的存储时间。 23. JavaScript 中 null和 undefined 是否有区别？有哪些区别？答案： ①: 赋值角度说明： null 表示此处没有值，undefined表示此处定义了但是没有赋值 ②: 从数据转换角度： Null在做数值转换时会被转换为0，undefined会被转换为NaN 23. Servlet中的doPost和doGet方法有什么区别?它们在传递和获取参数上有什么区别？答案： 区别：doPost用来处理post请求，doGet用来处理get请求，获取参数：获取的参数是相同的都是HttpServletRequest \HttpServletResponse 24. 请写出一段jQuery代码，实现把当前页面中所有的a元索中class 属性为“view-link”的链接都改为在新窗口中打开123$("a[class = view-link]").prop("target","_blank")或者: $("a[class = view-link]").attr("target","_blank")或者: $("a.view-link]").attr("target","_blank") 25. Jquery中’.get()’与’.eq()’的区别答: eq返回的是一个jquery对象 get返回的是一个html对象 26. TCP为何采用三次握手来建立连接，若釆用二次握手可以吗，请说明理由？答: 三次握手是为了防止已失效的连接请求再次传送到服务器端,让服务器错误打开连接。 二次握手不可行，因为：如果由于网络不稳定，虽然客户端以前发送的连接请求已到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到重传的请求连接后(每收到一个请求就打开一个连接)，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费 27. 以下HTTP相应状态码的含义描述正确的是（） A. 200ok表示请求成功 B. 400不良请求表示服务器未发现与请求URL匹配内容 C. 404未发现表示由于语法错误而导致服务器无法理解请求信息 D. 500内部服务器错误，无法处理请求 答案：D分析：A 200ok 表示的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。B 400 表示指出客户端请求中的语法错误C 404 客户端所给的地址无法找到任何资源 28 JSP的三大指令①: page指令实例：&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”UTF-8”%&gt; 参数import：等同与import语句&lt;%@ page import=”java.util.*” %&gt;&lt;%@ page import=”java.util., java.net.” %&gt;在一个JSP页面中可以给出多个page指令，而且import是可以重复出现的&lt;%@ page import=”java.util.*” %&gt;&lt;%@ page import=”java.next.*” %&gt; 参数pageEncoding：指定当前页面的编码如果pageEncoding没有指定，那么默认为contentType的值； 如果pageEncoding和contentType都没有指定，那么默认值为iso-8859-1 参数contentType：等同与调用response.setContentType(“text/html;charset=xxx”); 如果没有指定contentType属性，那么默认为pageEncoding的值；如果contentType和pageEncoding都没有指定，那么默认值为iso-8859-1 参数errorPage：如果当前页面出现异常，那么跳转到errorPage指定的jsp页面。例如：&lt;%@ page errorPage=”b.jsp” %&gt; 参数isErrorPage：上面示例中指定b.jsp为错误页面，但在b.jsp中不能直接使用内置对象exception，只有b.jsp中使用&lt;%@page isErrorPage=”true”%&gt;时，才能在b.jsp中使用错误页面。 autoFlush：当autoFlush为true时，表示out流缓冲区满时会自动刷新。默认为true buffer：指定out流的缓冲区大小，默认为8KB isELIgnored：当前JSP页面是否忽略EL表达式，默认为false，表示不忽略，即支持EL表达式 page指令不常用的属性： language：当前JSP编译后的语言！默认为java，当前也只能选择javainfo：当前JSP的说明信息isThreadSafe：当前JSP是否执行只能单线程访问，默认为true，模式表示它以多线程方式运行,该模式的信息同步，需访问同步方法(用synchronized标记的)来实现。session：当前页面是否可以使用session，默认为false，表示支持session的使用。extends：指定JSP编译的servlet的父类！ ②: include指令 JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。Include指令的语法格式如下：&lt;%@ include file=”文件相对 url 地址” %&gt; ③: taglib指令 taglib指令是用来在当前jsp页面中导入第三方的标签库&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core” % prefix=”c” &gt;prefix：指定标签前缀，这个东西可以随意起名uri：指定第三方标签库的uri（唯一标识） 当然，需要先把第三方标签库所需jar包放到类路径中。 29. JSP的 7种页面元素 口诀: 禁止不要动,猪叫声. 静态内容—-&gt;禁指令—-&gt;止表达式—&gt;不要动作—-&gt;动注释—–&gt;猪脚本—–&gt;叫声明——&gt;声 29.1 JSP指令：①: page指令：通常位于Jsp页面的顶端，同一个页面可以有多个page指令。 例如: &lt;%@page language=”java” important=”java.util.*” contentType=”text/html;charset=utf-8”%&gt; ②: include指令：将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。 语法：&lt;%@include file=”URL”&gt; ③: taglib指令：使用标签库定义新的自定义标签，在JSP页面中启用定制行为。 29.2注释①: HTML的注释： //客户端可见【查看网页源代码的时候可见】 ②: JSP的注释：&lt;%–JSP注释–%&gt; //客户端不可见 ③: JSP脚本【注意：&lt;% JSP脚本%&gt;】注释： 【客户端不可见】 // 单行注释 / / 多行注释 29.3 JSP脚本：在JSP页面中执行的java代码 语法：&lt;% java代码 %&gt; 29.4 JSP表达式：在JSP页面中执行的表达式 语法：&lt;%= 表达式 %&gt; 注意：表达式不以分号结束 29.5 JSP声明：在JSP页面中定义变量或者方法 语法：&lt;%! java代码 %&gt; 29.6 动作例如: &lt;jsp:include page=”Filename” &gt; 在jsp页面中包含另一个页面。 29.7 静态内容就是html,css,javascript等内容 注: &lt;%=%&gt; 不需要分号结尾，&lt;%%&gt; 需要以分号结尾，和java代码一样 30. JSP的九大内置对象答案： ①: request对象 request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。 request对象的作用域为一次请求。 request对象的常用方法如下：1 object getAttribute(String name) 返回指定属性的属性值2 Enumeration getAttributeNames() 返回所有可用属性名的枚举3 String getCharacterEncoding() 返回字符编码方式4 int getContentLength() 返回请求体的长度(以字节数)5 String getContentType() 得到请求体的MIME类型6 ServletInputStream getInputStream() 得到请求体中一行的二进制流7 String getParameter(String name) 返回name指定参数的参数值8 Enumeration getParameterNames() 返回可用参数名的枚举9 String[] getparameterValues(String name) 返回包含参数name的所有值的数组10 String getProtocol() 返回请求用的协议类型及版本号11 String getScheme() 返回请求用的计划名,如:http https及ftp等12 int getServerPort() 返回服务器接受此请求所用的端口号13 String getServerName() 返回接受请求的服务器主机名14 BufferedReader getReader() 返回解码过了的请求体15 String getRemoteAddr() 返回发送此请求的客户端IP地址16 String getRemoteHost() 返回发送此请求的客户端主机名17 void setAttribute(String key Object obj) 设置属性的属性值18 String getRealPath(String path) 返回一虚拟路径的真实路径19 void setCharacterEncoding(“gb2312”) 设置接受参数的字符集 ②: response对象 隐藏对象response是javax.servlet.ServletResponse类的实例，response 代表的是对客户端的响应，服务器端的任何输出都通过response对象发送到客户端浏览器。主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。 每次服务器端都会响应一个response实例。 response对象的常用方法如下：1 String getCharacterEncoding() 返回响应用的是何种字符编码2 ServletOutputStream getOutputStream() 返回响应的一个二进制输出流3 PrintWriter getWriter() 返回可以向客户端输出字符的一个对象4 void setContentLength(int len) 设置响应头长度5 void setContentType(String type) 设置响应的MIME类型6 sendRedirect(java.lang.String location) 重新定向客户端的请求7 void setCharacterEncoding(“gb2312”) 设置响应头的字符集 ③: session对象 隐藏对象session是javax.servlet.http.HttpSession类的实例。session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 session与cookie是记录客户访问信息的两种机制，session是用于服务器端保存用户信息，cookie用于在客户端保存用户信息。Servlet中通过request.getSession()来获取session对象，而JSP中可以直接使用。 如果JSP中配置了&lt;%@page session=”false”%&gt;,则隐藏对象session不可用。每个用户对应一个session对象。 session对象的常用方法如下: 1 long getCreationTime() 返回Session创建时间2 public String getId() 返回Session创建时JSP引擎为它设的唯一ID号3 long getLastAccessedTime() 返回此Session里客户端最近一次请求时间4 int getMaxInactiveInterval() 返回两次请求间隔多长时间此Session被取消(ms)5 String[] getValueNames() 返回一个包含此Session中所有可用属性的数组6 void invalidate() 取消Session,使Session不可用7 boolean isNew() 返回服务器创建的一个Session,客户端是否已经加入8 void removeValue(String name) 删除Session中指定的属性9 void setAttribute(String key,Object obj) 设置Session的属性10 Object getAttribute(String name) 返回session中属性名为name的对象 ④: application对象 隐藏对象application是javax.servlet.ServletContext类的对象。 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 application封装JSP所在Web应用程序的信息，例如web.xml中国配置的全局的初始化信息。Servlet中application对象需要通过ServletConfig.getServletContext()来获取。整个Web应用程序对应一个application对象。 application对象常用的方法如下：1, Object getAttribute(String name) 返回application中属性为name的对象2， Enumeration getAttributeNames() 返回application中的所有属性名3， void setAttribute(String name,Object value) 设置application属性4， void removeAttribute(String name) 移除application属性5， String getInitParameter(String name) 返回全局初始话函数6， Enumeration getInitParameterNames(） 返回所有的全局初始话参数7， String getMimeType(String filename) 返回文件的文档类型，例如getMimeType(“abc.html”)将返回“text.html”8， String getRealPath(String relativePath） 返回Web应用程序内相对网址对应的绝对路径 ⑤: out 对象 隐藏对象out是javax.servlet.jsp.JspWriter类的实例. Servlet 和JSP中输出数据都需要使用out对象。Servlet 中的out对象是通过getWriter()方法获取的。而JSP中没有定义out对象却可以直接使用。这是因为out是JSP的内置隐藏对象。 out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。服务器向客户输出的字符内容可以通过out对象输出。获取方法： PrintWriter out = response.getWriter(); out对象常用的方法如下： ①: void clear() 清除缓冲区的内容②: void clearBuffer() 清除缓冲区的当前内容③: void flush() 将缓冲内容flush到客户端浏览器④: int getBufferSize() 返回缓冲大小，单位KB⑤: int getRemaining() 返回缓冲剩余大小，单位KB⑥: isAutoFlush() 返回缓冲区满时,是自动清空还是抛出异常⑦: void close() 关闭输出流 ⑥: pageContext 对象 隐藏对象pageContext为javax.servlet.jsp.PageContext类的实例。pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。 pageContext对象代表当前JSP页面编译后的内容。通过pageContext能够获取到JSP中的资源。 pageContext常用方法如下： 1 JspWriter getOut() 返回out对象2 HttpSession getSession() 返回Session对象(session)3 Object getPage() 返回page对象4 ServletRequest getRequest() 返回request对象5 ServletResponse getResponse() 返回response对象6 void setAttribute(String name,Object attribute) 设置属性及属性值 ，在page范围内有效7 void setAttribute(String name,Object obj,int scope) 在指定范围内设置属性及属性值 ，int1=page,2=request,3=session,4=application8 public Object getAttribute(String name) 取属性的值9 Object getAttribute(String name,int scope) 在指定范围内取属性的值10 public Object findAttribute(String name) 寻找一属性,返回起属性值或NULL11 void removeAttribute(String name) 删除某属性12 void removeAttribute(String name,int scope) 在指定范围删除某属性13 int getAttributeScope(String name) 返回某属性的作用范围14 Enumeration getAttributeNamesInScope(int scope) 返回指定范围内可用的属性名枚举15 void release() 释放pageContext所占用的资源16 void forward(String relativeUrlPath) 使当前页面重导到另一页面17 void include(String relativeUrlPath) 在当前位置包含另一文件 ⑦: config 对象 隐藏对象config是javax.servlet.ServletConfig类的实例. config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 ServletConfig封装了配置在web.xml中初始化JSP的参数。JSP中通过config获取这些参数。每个JSP文件中共有一个config对象。 config对象的常用方法如表：1 String getInitParameter(String name) 返回配置在web.xml中初始化参数2 Enumeration getInitParameterNames() 返回所有的初始化参数名称3 ServletContext getServletContext() 返回ServletContext对象4 String getServletName 返回Servlet对象 ⑧: page 对象 page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 ⑨: exception 对象 隐藏对象exception为java.lang.Exception类的对象。exception封装了JSP中抛出的异常信息。要使用exception隐藏对象，需要设置&lt;%@page isErrorPage”true”%&gt;。隐藏对象exception通常被用来处理错误页面， exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。 31. JSP的十大动作 语法 描述 jsp:include 在页面被请求的时候引入一个文件。 jsp:useBean 寻找或者实例化一个JavaBean。 jsp:setProperty 设置JavaBean的属性。 jsp:getProperty 输出某个JavaBean的属性。 jsp:forward 把请求转到一个新的页面。 jsp:plugin 根据浏览器类型为Java插件生成OBJECT或EMBED标记。 jsp:element 定义动态XML元素 jsp:attribute 设置动态定义的XML元素属性。 jsp:body 设置动态定义的XML元素内容。 jsp:text 在JSP页面和文档中使用写入文本的模板 32. Ajax有四种技术组成：DOM,CSS,JavaScript，XmlHttpRequest，其中控制文档结构的是（） A. DOM B. CSS C. JavaScript D. XmlHttpRequest 答案：A 33. 如何配置一个servlet?在web.xml中使用如下标签: 12345678910111213//方法一: XML方式&lt;servlet&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;//方法二: 注解方式: 类上面加下面这句@WebServlet(name="servlet", urlPatterns=&#123;"/*"&#125;)或者@WebServlet("/请求路径") 34. JavaScript，如何定义含有数值1至8的数组？1var arr=[1,2,3,4,5,6,7,8] 35. 以下JavaScipt语句会产生运行错误的是_（） A. var obj=( ); B. var obj=[ ]; C. var obj=//; D. var obj=1; 答案：AC 36. HTML字符实体的作用及其常用字符实体36.1 字符实体拥有三个部分:①: 一个and符号（&amp;） ②: 一个实体名或者一个实体号 ③: 最后是一个分号（;） 36.2 常见字符实体 36.3 注意:①: 在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities） ②: 虽然 html 不区分大小写，但实体字符对大小写敏感。 ③: 浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用&amp;nbsp;字符实体。 ④: 一些在键盘上找不到的字符也可以使用字符实体来替换。 37. HTML表单的作用和常用11个表单项类型表单的作用： 利用表单可以收集客户端提交的有关信息。 常用表单项类型： input标签 的type属性值 功能 input标签 type属性 功能 text 单行本框 reset 重置按钮 password 密码框 submit 提交按钮 radio 单选按钮 textarea 文本域 checkbox 复选框 select 下拉框 button 普通按钮 hidden 隐藏域 38. form中input设置为readonly和disabled的区别 readonly disabled 有效对象 只针对type为text/password有效 对所有表单元素有效 表单提交 当表单元素设置readonly后，表单提交能将该表单元素的值传递出去。 当表单元素设置disabled后，表单提交不能将该表单元素的值传递出去。 39. 引入样式的三种方式及其优先级别①: 外部样式表（存放.css文件中） 不需要style标签; 1&lt;link rel=”stylesheet” href=”引用文件地址” /&gt; ②: 嵌入式样式表 123&lt; style type=“text/css”&gt; p&#123;color:red;&#125;&lt;/style&gt; ③: 内联样式 标签属性名为style 1&lt;p style=“color:red;”&gt;&lt;/p&gt; 优先级级别：内联定义 &gt; 嵌入式样式表 &gt; 外部CSS 40. 盒子模型盒子模型类似于生活中的盒子，具有4个属性，外边距，内边距，边框，内容。 外边距：margin，用于设置元素和其他元素之间的距离。 内边距：padding,用于设置元素内容和边框之间的距离。 边框：border,用于设置元素边框粗细，颜色，线型。 内容：width,height,用于设置元素内容显示的大小。 41. JavaScript语言及其特点Javascript一种基于对象(object-based)和事件驱动(Event Driven)的简单的并具有安全性能的脚本语言。特点： ①: 解释性： JavaScript不同于一些编译性的程序语言，例如C、C++等，它是一种解释性的程序语言，它的源代码不需要经过编译，而直接在浏览器中运行时被解释。 ②: 基于对象： JavaScript是一种基于对象的语言。这意味着它能运用自己已经创建的对象。因此，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。 ③: 事件驱动： JavaScript可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的响应，是以事件驱动的方式进行的。所谓事件驱动，就是指在主页中执行了某种操作所产生的动作，此动作称为“事件”。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。 ④: 跨平台:JavaScript依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可正确执行。 42. JavaScript常用数据类型有哪些①: 数值型(Number)：整数和浮点数统称为数值。例如85或3.1415926等。 ②: 字符串型(String)：由0个,1个或多个字符组成的序列。在JavaScript中，用双引号或单引号括起来表示，如“您好”、‘学习JavaScript’等。 不区分单引号、双引号。 ③: 逻辑（布尔）型(Boolean)：用true或false来表示。 ④: 空（null）值(Null)：表示没有值，用于定义空的或不存在的引用。 要注意，空值不等同于空字符串””或0。 ⑤: 未定义（Undefined）值：它也是一个保留字。表示变量虽然已经声明，但却没有赋值。 ⑥: 除了以上五种基本的数据类型之外，JavaScript还支持复合数据类型，包括对象和数组两种。 43. Ajax的优点和缺点优点：减轻服务器的负担,按需取数据,最大程度的减少冗余请求，局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验，基于xml标准化,并被广泛支持,不需安装插件等，进一步促进页面和数据的分离 缺点：AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性. 44. 怎样防止表单刷新重复提交问题？（说出思路即可）JS脚本方式: 第一种：定义全局变量，在form提交前判断是否已有提交过 123456789101112&lt;script&gt; var checkSubmitFlg = false; //初始为false,表示没有提交过 function checkSubmit()&#123; if(checkSubmitFlg == true)&#123; //如果为true,说明checkSubmitFlg的值被修改了,也就是之前提交过; return false;//返回false,阻止提交事件 &#125; checkSubmitFlg = true; //如果能执行这一句,说明checkSubmitFlg==false,说明表单没有被提交过,此时可以提交,于是将checkSubmitFlg的值改为true; return true;//返回true,表示运行提交 &#125;&lt;/script&gt;&lt;form action="" onsubmit="return checkSubmit();"&gt;&lt;/form&gt; 第二种：单击提交按钮后，立刻禁用改按钮 第三种：单击提交按钮后，弹出屏蔽层，防止用户第二次点击 45. JQuery.get()和JQuery.ajax()方法之间的区别是什么？JQuery.ajax()是对原生的javaScript的ajax的封装，简化了ajax的步骤，用户可用JQuery.ajax()发送get或者post方式请求, Jquery.get()是对ajax的get方式的封装，只能发送get方式的请求。 46. Jquery里的缓存问题如何解决？例如（$.ajax()以及$.get()）方法一: $.ajax()请求时候加上cache:false的参数，如： 12345678$.ajax(&#123; type : "get", url : "XX", dataType : "json", cache:false, success : function(json) &#123; &#125;&#125;); 或者: 方法二: $.get()请求时候加上时间，如: 1$.get("url","data"+new Date(),function(data)&#123;&#125;); 47. Javascript是面向对象的，怎么体现Javascript的继承关系？Javascript里面没有像java那样的继承，javascript中的继承机制仅仅是靠模拟的，可以使用prototype原型来实现 48. Javascript的有几种变量。变量范围有什么不同？可以分为三种 ①: 原生类型（string,number,boolean） ②: 对象（Date,Array） ③: 特殊类型（var vara;(只什么没有定义),var varb = null;(定义一个变量并赋值为null)） 49. Js如何获取页面的dom对象1、直接获取 //1.1 – id方式获取 var varid = document.getElementById(&quot;unameid&quot;); //1.2 – name获取(获取的是数组对象) var varname = document.getElementsByName(&quot;sex&quot;); //1.3 – 元素获取(获取的是数组对象) var varinput = document.getElementsByTagName(&quot;input&quot;); 2、间接方式获取 //2.1 父子关系 –childNodes var varchilds = document.getElementById(&quot;div01&quot;).childNodes; //2.2 子父关系–parentNode var varfather2 = document.getElementById(&quot;unameid&quot;).parentNode; //2.3 兄弟之间相互获取 nextSibling：下一个节点 previousSibling：上一个节点 50. Servlet API中forward() 与redirect()的区别？答：为实现程序的模块化，就需要保证在不同的Servlet之间可以相互跳转，而Servlet中主要有两种实现跳转的方式：FORWARD方式与redirect方式。 Forward() : 是服务器内部的重定向，服务器直接访问目标地址的URL，把那个URL的响应内容读取出来，而客户端并不知道，因此在客户端浏览器的地址栏里不会显示跳转后的地址，还是原来的地址。由于在整个定向的过程中用的是同一个Request，因此FORWARD会将Request的信息带到被定向的ＪＳＰ或Servlet中使用。 Redirect():则是客户端的重定向，是完全的跳转，即客户端浏览器会获取跳转后的地址，然后重新发送请求，因此浏览器中会显示跳转后的地址。同时，由于这种方式比FORWARD方式多了一次网络请求，因此其效率低于FORWARD方式，需要注意到的是，客户端的重定向可以通过设置特定的HTTP 头或写JavaScript脚本来实现。 鉴于以上的区别，一般当FORWARD方式可以满足需求时，尽可能的使用FORWARD方式。但在有些情况下，例如，需要跳转到一个其他服务器上的资源时，则必须使用redirect 方式。 51. Session域和request域什么区别？作用域：存放数据，获取数据（传递数据） 有效的作用域：生命周期，作用范围 51.1 httpServeltRequest:生命周期：一次请求之间 作用范围：所有被请求转发过的servlet都能获取到 51.2 httpSession:生命周期：一次会话 作用范围：所有的servlet都可以获取到 51.3 servletContex:生命周期：从项目开始运行到服务器关闭 作用范围：所有的servlet都可以获取到 51.4 作用域如何选用？httpServeltRequest：和当前请求有关的信息 httpSession：和当前用户有关的信息 servletContex：访问量比较大，不易更改 52. 页面中有一个命名为bankNo的下拉列表，写js脚本获取当前选项的索引值，如果用jquery如何获取12345//js方式:var a = document.getElementsByName("bankNo")[0].value;//jQuery方式:var b = $("select[name=bankNo]").val(); 53. 写出要求11位数字的正则表达式1234//^开始, $结束 \d 匹配一个数字字符。等价于[0-9]。^[1-9]\d&#123;10&#125;$或者:^[1-9][0-9]&#123;10&#125;$ 54. 分别获取指定name、Id的javascript对象，如果用jquey如何获取1234567js: document.getElementById("id"); document.getElementsByName("name");jquery: $("#id"); $("元素名称[name="name值"]"）; 55. 如何设置一个层的可见/隐藏12可见 : document.getElementById("divid").style.display = "block";隐藏 : document.getElementById("divid").style.display = "none"; 56. 描述JSP中动态INCLUDE与静态INCLUDE的区别？动态导入 ①: 会将多个jsp页面分别再编写成java文件，编译成class文件 ②: jsp文件中允许有相同的变量名，每个页面互不影响 ③: 当java代码比较多优先选用动态导入 ④: 效率相对较低，耦合性低 静态导入 ①: 会将多个jsp页面合成一个jsp页面，再编写成java文件，编译成class文件 ②: jsp文件中不允许有相同的变量名 ③: 当java代码比较少或者没有java代码是优先选用静态导入 ④: 效率相对较高，耦合性高 57. html和xhtml的区别是什么？HTML与XHTML之间的差别，粗略可以分为两大类比较：一个是功能上的差别，另外是书写习惯的差别。关于功能上的差别，主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页。 因为XHTML的语法较为严谨， 所以如果你是习惯松散结构的HTML编写者，那需要特别注意XHTML的规则。但也不必太过担心，因为XHTML的规则并不太难。下面列出了几条容易犯的错误，供大家引用。 ①: 所有标签都必须小写 在XHTML中，所有的标签都必须小写，不能大小写穿插其中，也不能全部都是大写。看一个例子。 错误：&lt; Head&gt;&lt; /Head&gt;&lt; Body&gt;&lt; /Body&gt; 正确：&lt; head&gt;&lt; /head&gt;&lt; body&gt;&lt; /body&gt; ②: 标签必须成双成对 像是&lt; p&gt;…&lt; /p&gt;、&lt; a&gt;…&lt; /a&gt;、&lt; div&gt;…&lt; /div&gt;标签等，当出现一个标签时，必须要有对应的结束标签，缺一不可，就像在任何程序语言中的括号一样。 错误：大家好&lt; p&gt;我是muki 正确：&lt; p&gt;大家好&lt; /p&gt;&lt; p&gt;我是muki&lt; /p&gt; ③: 标签顺序必须正确 标签由外到内，一层层包覆着，所以假设你先写div后写h1，结尾就要先写h1后写div。只要记住一个原则“先进后出”，先弹出的标签要后结尾。 错误：&lt; div&gt;&lt; h1&gt;大家好&lt; /div&gt;&lt; /h1&gt; 正确：&lt; div&gt;&lt; h1&gt;大家好&lt; /h1&gt;&lt; /div&gt; ④: 所有属性都必须使用双引号 在XHTML 1.0中规定连单引号也不能使用，所以全程都得用双引号。 错误：&lt; div style=font-size:11px&gt;hello&lt; /div&gt; 正确：&lt; div style=”font-size:11px”&gt;hello&lt; /div` ⑤: 不允许使用target=”_blank” 从XHTML 1.1开始全面禁止target属性，如果想要有开新窗口的功能，就必须改写为rel=”external”，并搭配JavaScript实现此效果。 错误：&lt; a href=&quot;http://blog.mukispace.com&quot; target=&quot;_blank&quot;&gt;MUKI space&lt; /a&gt; 正确：&lt; a href=&quot;http://blog.mukispace.com&quot; rel=&quot;external&quot;&gt;MUKI space&lt; /a&gt; 58. 你遇到了哪些浏览器的兼容性问题？怎么解决的？答：因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况；这是我们常见的兼容性问题。 解决方法： 1、针对不同的浏览器写不同的代码 2、使用jquery屏蔽浏览器差异 遇到不同的兼容问题，需要针对前端进行兼容适配； 59. 你知道的常用的js库有哪些？①: moment.js 举个例子： 用js转换时间戳为日期 12345678910let date = new Date(1437925575663); let year = date.getFullYear() + '-'; let month = ( date.getMonth() + 1 &lt; 10 ? '0' + (date.getMonth() + 1) :date.getMonth() + 1 ) + '-'; let day = date.getDate();... return year + month + day;//用moment.jsreturn moment(1437925575663).format('YYYY-MM-DD HH:mm:ss') ②: chart.js 绘制简单的柱状图，曲线图，蛛网图，环形图，饼图等完全够用，用法比较简单。 ③: D3.js 功能太强大了，看首页就知道了，感觉没有什么图d3绘不出来的。 ④: Rx.js 很好的解决了异步和事件组合的问题。 ⑤: lodash.js 60. Js中的三种弹出式消息提醒（警告窗口、确认窗口、信息输入窗口）的命令是什么？alter(),confirm(),prompt() 61. 谈谈js的闭包答：闭包无处不在，比如：jQuery、zepto的核心代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭包的画面： 12345678function A()&#123; function B()&#123; console.log("Hello Closure!"); &#125; return B;&#125;var C = A();C();//Hello Closure! 这是最简单的闭包。 有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻译成自然语言如下： （1）定义普通函数 A （2）在 A 中定义普通函数 B （3）在 A 中返回 B （4）执行 A, 并把 A 的返回结果赋值给变量 C （5）执行 C 把这5步操作总结成一句话就是： 函数A的内部函数B被函数A外的一个变量 c 引用。 把这句话再加工一下就变成了闭包的定义： 当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 因此，当你执行上述5步操作时，就已经定义了一个闭包！ 这就是闭包。 62. 写一段js，遍历所有的li，将每个li的内容逐个alert出来12345678&lt;body&gt; &lt;ul&gt; &lt;li&gt;张三：123&lt;/li&gt; &lt;li&gt;李四：456&lt;/li&gt; &lt;li&gt;王五：789&lt;/li&gt; &lt;li&gt;赵六：147&lt;/li&gt; &lt;ul&gt;&lt;body&gt; 123456function test()&#123; var varli = document.getElementsByTagName("li");//通过标签名获取元素 for (var i=0;i&lt;varli.length;i++) &#123; alert(varli[i].innerText); &#125;&#125; 63. 页面上如何用JavaScript对一个checkbox的所有选择项全选1234567function checkall() &#123; var varcheck = document.getEllementsByName("checkbox标签的name属性的值");//获取DOM对象 //alert(varcheck.length); for(i = 0;i &lt; varcheck.length; i++) &#123; varcheck[i].checked = true; &#125;&#125; 64. 写一个简单的JQuery的ajax12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script src = "js/jquery-1.9.1.js" type = "text/javascript"&gt;&lt;/script&gt;&lt;script&gt; function testJqAjax()&#123; //url :请求地址 //type :请求的方式 get/post //data :请求的参数(json/String) //cache :true(走缓存) false(不走缓存) //result :当ajax发送成功后会调用success后面的函数，result：相当于形参，存放了返回的数据 //async :是否为异步请求 默认true异步 , false同步 //语法: $.ajax(&#123;name:value, name:value, ... &#125;) $.ajax(&#123; url:"TestJqAjax", type:"get", /* data:"uname=zhangsan&amp;realname=张三丰", */ data:&#123;uname:"zhangsan",realname:"张三丰"&#125;, cache:false, async:false, success:function(result)&#123; alert(result); &#125; &#125;);&#125;//ajax的get方式的请求//语法: $.get(URL,callback);function jqAjaxGet()&#123; //url,[data],[callback](当ajax发送成功后调用的函数) $.get("TestJqAjax",&#123;uname:"zhangsan",realname:"张三丰"&#125;,function(result)&#123; alert(result); &#125;);&#125;//ajax的post方式的请求//语法: $.post(URL,data,callback);function jqAjaxPost() &#123; //url,[data],[callback](当ajax发送成功后调用的函数) $.post("TestJqAjax",&#123;uname:"zhangsan",realname:"张三丰"&#125;,function(result)&#123; alert(result); &#125;);&#125;&lt;/script&gt; 65. Js截取字符串abcdefg的efg12345function test2()&#123; var str = "abcdefg"; var substr = str.substring(4); alert(substr);&#125; 66. http的请求头信息包含了什么?请求行（请求方式，资源路径，协议和协议版本号） 若干请求头 请求实体内容 67. http的响应码200，404，302，500表示的含义分别是？200 - 确定。客户端请求已成功 302 - 临时移动转移，请求的内容已临时移动新的位置 404 - 未找到文件或目录 500 - 服务器内部错误 68. Servlet中request对象的方法有？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获取网络信息private void getNet(HttpServletRequest req, HttpServletResponse resp) &#123; System.out.println("TestHttpRequest.getNet(获取客户端的ip):"+req.getRemoteAddr()); System.out.println("TestHttpRequest.getNet(获取客户端的端口):"+req.getRemotePort()); System.out.println("TestHttpRequest.getNet(获取服务器的ip):"+req.getLocalAddr()); System.out.println("TestHttpRequest.getNet(获取服务器的端口):"+req.getLocalPort());&#125;//获取实体内容private void getContent(HttpServletRequest req, HttpServletResponse resp) &#123; //获取单条信息 String uname = req.getParameter("uname"); //获取多条信息，数组格式 String[] favs = req.getParameterValues("fav"); //遍历数组 //判断 if(favs!=null&amp;&amp;favs.length&gt;0)&#123; for (int i = 0; i &lt; favs.length; i++) &#123; System.out.println("TestHttpRequest.getContent(fav):"+favs[i]); &#125; &#125; String un = req.getParameter("un"); System.out.println("TestHttpRequest.getContent():"+uname+"--"+favs+"--"+un);&#125;//获取请求头信息private void getHeads(HttpServletRequest req, HttpServletResponse resp) &#123; //获取单条头信息 //System.out.println("TestHttpRequest.getHeads(获取请求头信息-浏览器头信息)："+req.getHeader("User-Agent")); //获取所有头信息--返回枚举类型 Enumeration strHeads = req.getHeaderNames(); //遍历枚举类型 while (strHeads.hasMoreElements()) &#123; String strhead = (String) strHeads.nextElement(); System.out.println("TestHttpRequest.getHeads(获取头信息):"+req.getHeader(strhead)); &#125;&#125;//获取请求行的信息private void getLines(HttpServletRequest req, HttpServletResponse resp) &#123; System.out.println("TestHttpRequest.getLines(请求方式***):"+req.getMethod()); System.out.println("TestHttpRequest.getLines(资源路径):"+req.getRequestURI()); System.out.println("TestHttpRequest.getLines(地址):"+req.getRequestURL()); System.out.println("TestHttpRequest.getLines(协议):"+req.getScheme()); System.out.println("TestHttpRequest.getLines(协议的版本号):"+req.getProtocol()); System.out.println("TestHttpRequest.getLines(获取参数信息):"+req.getQueryString()); System.out.println("TestHttpRequest.getLines(项目名称***):"+req.getContextPath());&#125; 69. Javascript的常用对象有哪些常用对象包括日期对象Date，字符串对象String，数组对象Array //获取并显示系统当前时间 1234567function testDate()&#123; var date = new Date(); var fmtDate = date.getFullYear()+"-"+(date.getMonth()+1)+ "-"+date.getDate()+"-"+date.getHours() +":"+date.getMinutes()+":"+date.getSeconds(); alert(fmtDate);&#125; //获取出’sxt’的下标位置 1234function testString()&#123; var str = 'welcome to beijingsxt'; alert(str.indexOf('sxt'));&#125; //遍历数组信息 123456function testArray()&#123; var arr = new Array('a',123,'c',true,'e'); for(var item in arr)&#123; document.write(arr[item]+" "); &#125;&#125; 70. DOM和BOM及其关系BOM浏览器对象模型，由一系列对象组成，是访问、控制、修改浏览器的属性的方法。—B即Browns就是浏览器的意思 DOM文档对象模型，由一系列对象组成，是访问、检索、修改XHTML文档内容与结构的标准方法。—D即document 关系： –BOM描述了与浏览器进行交互的方法和接口 –DOM描述了处理网页内容的方法和接口 –DOM属于BOM的一个属性 71. JavaScript中获取某个元素的三种方式JavaScript中的三种弹出式消息提醒命令是什么?window.alert() 显示一个提示信息 window.confirm() 显示一个带有提示信息、确定和取消按钮的对话框 window.prompt() 显示可提示用户输入的对话框 71.1 setTimeout与setInterval 的区别setTimeout和setInterval的语法相同。它们都有两个参数，一个是将要执行的代码字符串，还有一个是以毫秒为单位的时间间隔，当过了那个时间段之后就将执行那段代码。 不过这两个函数还是有区别的，setInterval在执行完一次代码之后，经过了那个固定的时间间隔，它还会自动重复执行代码，而setTimeout只执行一次那段代码。 window.setTimeout(“function”,time)；//设置一个超时对象，只执行一次,无周期 window.setInterval(“function”,time)；//设置一个超时对象，重复执行，周期＝’交互时间’ 72. JavaScript操作CSS的两种方式①： 第一种方式：操作元素的属性（对象.style.样式名=样式值;） 1234var child2 = document.createElement("div");//创建一个div元素child2.innerHTML = "child2";//给div元素设置内容child2.style.fontWeight = "bold";//改变样式parent.appendChild(child2); ②： 第二种方式：操作元素的类（对象.className=类;） 123456var parent = document.getElementById("parent");//改变classNamevar child0 = document.createElement("div");child0.innerHTML = "child0";child0.className = "newDiv";parent.appendChild(child0); 73. 静态网页和动态网页的联系和区别联系： 1）静态网页是网站建设的基础，静态网页和动态网页都要使用到HTMl语言。 2）静态网页是相对于动态网页而言，指没有后台数据库、不含程序和不可交互的网页、是标准的HTML文件，它的文件扩展名是.htm或.html。你编的是什么它显示的就是什么、不会有任何改变。 3）静态网页和动态网页之间并不矛盾，为了网站适应搜索引擎检索的需要，动态网站可以采用静动结合的原则，适合采用动态网页的地方用动态网页，如果必要使用静态网页，则可以考虑用静态网页的方法来实现，在同一个网站上，动态网页内容和静态网页内容同时存在也是很常见的事情。 区别： 1）程序是否在服务器端运行，是重要标志。 在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如ASP、PHP、JSP、ASP.net、CGI等。运行于客户端的程序、网页、插件、组件，属于静态网页，例如html页、Flash、javascript、VBscript等等，它们是永远不变的。 2）编程技术不同。静态网页和动态网页主要根据网页制作的语言来区分。 静态网页使用语言：HTML。 动态网页使用语言：HTML＋ASP 或 HTML＋PHP 或 HTML＋JSP 等其它网站动态语言。 3）被搜索引擎收录情况不同。 由于编程技术不容，静态网页是纯粹HTML格式的网页，页面内容稳定，不论是网页是否被访问，页面都被保存在网站服务器上，很容易被搜索引擎收录。 而动态网页的内容是当用户点击请求时才从数据库中调出返回给用户一个网页的内容，并不是存放在服务器上的独立文件，相比较于静态网页而言，动态网页很难被搜索引擎收录。 4）用户访问速度不同。 用户访问动态网页时，网页在获得搜索指令后经过数据库的调查匹配，再将与指令相符的内容传递给服务器，通过服务器的编译将网页编译成标准的HTML代码，从而传递给用户浏览器，多个读取过程大大降低了用户的访问速度。 而静态网页不同，由于网页内容直接存取在服务器上，省去了服务器的编译过程，用户访问网页速度很快。 5）制作和后期维护工作量不同。 动态网页的设计以数据库技术为基础，可以实现多种功能，降低了网站维护的工作量。 而静态网页由于没有数据库的支持，网页内容更改时需要直接修改代码，在网站内容制作和维护中，所需的工作量更大。动态网页与静态网页各有特点，网站设计师在网页设计时，主要根据网站的功能需求和网站内容多少选择不同网页。如，网站包含信息量太大时，就需要选择动态网页，反之，则选择静态网页。 74. JSP/ASP/PHP的比较ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)是目前主流的三种动态网页语言。 ASP是微软（Microsoft）所开发的一种后台脚本语言，它的语法和Visual BASIC类似，可以像SSI（Server Side Include）那样把后台脚本代码内嵌到HTML页面中。虽然ASP简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。 PHP是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用C,Java和Perl语言的语法, 并耦合PHP自己的特性,使WEB开发者能够快速地写出动态产生页面。它支持目前绝大多数数据库。 JSP是一个简化的Servlet，它是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML中插入Java程序段和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 ASP优点: 无需编译、易于生成、独立于浏览器、面向对象、与任何ActiveX scripting 语言兼容、源程序码不会外漏。 缺点: 1）Windows本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定性、跨平台性都会因为与NT的捆绑而显现出来。 2）ASP由于使用了COM组件所以它会变的十分强大，但是这样的强大由于Windows NT系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。 3）还无法完全实现一些企业级的功能：完全的集群、负载均横。 PHP优点： 1）一种能快速学习、跨平台、有良好数据库交互能力的开发语言。 2）简单轻便，易学易用。 3 ) 与Apache及其它扩展库结合紧密。 缺点： 1 ) 数据库支持的极大变化。 2 ) 不适合应用于大型电子商务站点。 JSP优点： 1 ) 一处编写随处运行。 2 ) 系统的多台平支持。 3 ) 强大的的可伸缩性。 4 ) 多样化和功能强大的开发工具支持。 缺点： 1） 与ASP一样，Java的一些优势正是它致命的问题所在。 2 ) 开发速度慢 75. CGI/Servlet/JSP的比较CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回应内容的技术。 通过CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。 Servlet 是在服务器上运行的小程序。在实际运行的时候Java Servlet与Web服务器会融为一体。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。 比较： 1） JSP从本质上说就是Servlet。JSP技术产生于Servlet之后，两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。 2 ) 与CGI相比，Servlet效率更高。Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 3）与CGI相比，Servlet更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet有可能彻底取代CGI。 76. HTTP协议工作原理及其特点 超文本传输协议（HTTP：Hypertext Transport Protocol）是万维网应用层的协议，它通过两个程序实现：一个是客户端程序（各种浏览器），另一个是服务器 （常称Web服务器） 。这两个通常运行在不同的主机上，通过交换报文来完成网页请求和响应，报文可简单分为请求报文和响应报文。 工作原理（流程）： 客户机与服务器建立连接后，浏览器可以向web服务器发送请求并显示收到的网页，当用户在浏览器地址栏中输入一个URL或点击一个超连接时，浏览器就向服务器发出了HTTP请求，请求方式的格式为：统一资源标识符、协议版本号，后边是MIME（Multipurpose Internet Mail Extensions）信息包括请求修饰符、客户机信息和可能的内容。该请求被送往由URL指定的WEB服务器，WEB服务器接收到请求后，进行相应反映，其格式为：一个状态行包括信息的协议版本号、一个成功或错误的代码，后边服务器信息、实体信息和可能的内容。即以HTTP规定的格式送回所要求的文件或其他相关信息，再由用户计算机上的浏览器负责解释和显示。 特点： 1）支持客户/服务器模式。 2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3）灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4）无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5）无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 77. get和post的区别①： 安全性： Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 ②： 传输数据限制量： Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 ③： 字符集限制： Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 ④： 效率： Get执行效率却比Post方法好。Get是form提交的默认方法。 78. 如何解决表单提交的中文乱码问题1）设置页面编码，若是jsp页面，需编写代码 &lt;%@page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; %&gt; 若是html页面，在网页头部（&lt; head&gt;&lt; /head&gt;）中添加下面这段代码 &lt; meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; 2）将form表单提交方式变为post方式，即添加method=”post”；）在Servlet类中编写代码request.setCharacterEncoding(&quot;UTF-8&quot;)，而且必须写在第一行。 3）如果是get请求，在Servlet类中编写代码 byte [] bytes = str.getBytes(&quot;iso-8859-1&quot;); String cstr = new String(bytes,&quot;utf-8&quot;); 或者直接修改Tomcat服务器配置文件server.xml增加内容： URIEncoding=&quot;utf-8&quot; 79. 如实现servlet的单线程实现servlet的单线程的jsp命令是： &lt;%@ page isThreadSafe=”false”%&gt;。默认isThreadSafe值为true。 属性isThreadSafe=false模式表示它是以Singleton模式运行，该模式implements了接口SingleThreadMode, 该模式同一时刻只有一个实例，不会出现信息同步与否的概念。若多个用户同时访问一个这种模式的页面，那么先访问者完全执行完该页面后，后访问者才开始执行。 属性isThreadSafe=true模式表示它以多线程方式运行。该模式的信息同步，需访问同步方法(用synchronized标记的)来实现。 一般格式如下： 123456public synchronized void syncmethod(...)&#123; while(...) &#123; this.wait(); &#125; this.notifyAll();&#125; 80. Servlet的生命周期①： 加载：在下列时刻加载 Servlet：（1）如果已配置自动加载选项，则在启动服务器时自动 加载 (web.xml中设置&lt; load-on-start&gt;)；（2）在服务器启动后，客户机首次向 Servlet 发出请求时;（3）重新加载 Servlet 时（只执行一次） ②： 实例化：加载 Servlet 后，服务器创建一个 Servlet 实例。（只执行一次） ③：初始化：调用 Servlet 的 init() 方法。在初始化阶段，Servlet 初始化参数被传递给 Servlet 配置对象ServletConfig。 （只执行一次） ④： 请求处理：对于到达服务器的客户机请求，服务器创建针对此次请求的一个“请求”对象和一个“响应”对象。服务器调用 Servlet 的service() 方法，该方法用于传递“请求”和“响应”对象。service() 方法从“请求”对象获得请求信息、处理该请求并用“响应”对象的方法以将响应传回客户机。service() 方法可以调用其它方法来处理请求，例如 doGet()、doPost() 或其它的方法。（每次请求都执行该步骤） ⑤： 销毁：当服务器不再需要 Servlet, 或重新装入 Servlet 的新实例时，服务器会调用 Servlet 的 destroy() 方法。（只执行一次） 81. 绝对路径、根路径、相对路径的含义及其区别绝对路径指对站点的根目录而言某文件的位置， 相对路径指以当前文件所处目录而言某文件的位置,相对路径-以引用文件之网页所在位置为参考基础，而建立出的目录路径。绝对路径-以Web站点根目录为参考基础的目录路径。 先给出一个网站结构图做实例加深理解，A网站（域名为http://www.a.com）：/include/a-test.html，/img/a-next.jpg；B网站（域名为http://www.b.com）：/include/b-test.html，/img/b-next.jpg。 相对路径是从引用的网页文件本身开始构建的，如果在A网站中的a-test.html中要插入图片a-next.jpg，可以这样做:&lt; img src=&quot;../img/a-next.jpg&quot; /&gt;，重点是img前面的../，表示从html处于的include开始起步，输入一个../表示回到上面一级父文件夹下，然后再接着img/表示又从父级文件夹下的img文件开始了，最后定位img下面的next.jpg。 根路径是从网站的最底层开始起，一般的网站的根目录就是域名下对应的文件夹，就如D盘是一个网站，双击D盘进入到D盘看到的就是网站的根目录，这种路径的链接样式是这样的：如果在A网站中的a-test.html中要插入图片a-next.jpg，可以这样做:&lt; img src=&quot;/img/a-next.jpg&quot; &gt;，以/开头表示从网站根目录算起，找到根目录下面的img文件夹下的next.jpg。 绝对路径就很好理解了，这种路径一般带有网站的域名，如果在A网站中的a-test.html中要插入图片a-next.jpg，需要这样这样写:&lt; img src=&quot;http://www.a.com/img/a-next.jpg&quot; &gt;，将图片路径上带有了域名信息，再打个比方：如果在A网站中的a-test.html中要插入B网站的图片b-next.jpg，就需要这样写：&lt; img src=&quot;http://www.b.com/img/b-next.jpg&quot; &gt;，这种方法适用与在不同网站之间插入外部网站的图片。 82. 转发和重定向的原理和区别82.1 原理： 转发是在服务端直接做的事情，是对客户端的同一个request进行传递，浏览器并不知道。 重定向是由浏览器来做的事情。重定向时，服务端返回一个response，里面包含了跳转的地址，由浏览器获得后，自动发送一个新request。转发像呼叫转移或者110报警中心，重定向似114查号台。 82.2八大区别：a) 区别1:跳转效率的不同 转发效率相对高；重定向效率相对低 b) 区别2:实现语句不同 转发 request.getRequestDispatcher(&quot;xxxx&quot;).forward(request,response) ; 重定向 response.sendRedirect(&quot;xxxx&quot;) c) 区别3:是否共有同一个request的数据 转发源组件与目标组件共有同一个request数据 重定向源组件与目标组件不共有同一个request数据（可使用session共有数据） d) 区别4:浏览器URL地址的不同 转发后浏览器URL地址保持不变（源组件地址） 重定向后浏览器URL地址改变为重定向后的地址（目标组件地址） e) 区别5:“/“路径的含义不同———————》非常重要 转发时”/“代表当前项目的根路径 ；重定向时”/“代表当前服务器的根路径 f) 区别6:跳转范围的不同 只能转发到同一应用中的URL（默认） ；可以重定向任何服务器、任何应用的URL g) 区别7:刷新是否导致重复提交 转发会导致重复提交(可以通过同步令牌解决)；重定向不会导致重复提交 h) 区别8:是否经过过滤器 转发不经过过滤器（默认情况）；重定向经过过滤器 83. JSP的执行过程在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求后，如果是第一次访问某个jsp页面，Web服务器对它进行以下3个操作。 1)翻译：由.jsp变为.java,由JSP引擎实现。 2)编译：由.java变为.class,由Java编译器实现。 3)执行：由.class变为.html,用Java虚拟机执行编译文件,然后将执行结果返回给Web服务器，并最终返回给客户端 如果不是第一次访问某个JSP页面，则只执行第三步。所以第一次访问JSP较慢。 84.JSP动作有哪些,简述作用?jsp:include：在页面被请求的时候引入一个文件。 jsp:useBean：寻找或者实例化一个JavaBean。 jsp:setProperty：设置JavaBean的属性。 jsp:getProperty：输出某个JavaBean的属性。 jsp:forward：把请求转到一个新的页面。 jsp:plugin：根据浏览器类型为Java插件生成object或embed标记。 85. page/request/session/application作用域区别page：当前页面范围 request：当前页面范围+转发页面（forward）+包含页面（include） session：当前会话： 85.1. session在以下几种情况下失效1)销毁session：Session.invalidate(); 2)超过最大非活动间隔时间 3)手动关闭浏览器（session并没有立刻失效，因为服务器端session仍旧存在，超过最大非活动间隔时间后真正失效） application：当前应用；服务器重新启动前一直有效 86. JSP和Servlet的区别和联系86.1 区别：1)JSP是在HTML代码里写JAVA代码,框架是HTML;而Servlet是在JAVA代码中写HTML代码，本身是个JAVA类。 2)JSP使人们把显示和逻辑分隔成为可能，这意味着两者的开发可并行进行；而Servlet并没有把两者分开。 3)Servlet独立地处理静态表示逻辑与动态业务逻辑.这样,任何文件的变动都需要对此服务程序重新编译;JSP允许用特殊标签直接嵌入到HTML页面, HTML内容与JAVA内容也可放在单独文件中,HTML内容的任何变动会自动编译装入到服务程序. 4)Servlet需要在web.xml中配置，而JSP无需配置。 5)目前JSP主要用在视图层，负责显示，而Servlet主要用在控制层，负责调度 86.2 联系：1)都是Sun公司推出的动态网页技术。 2)先有Servlet，针对Servlet缺点推出JSP。JSP是Servlet的一种特殊形式，每个JSP页面就是一个Servlet实例——JSP页面由系统翻译成Servlet，Servlet再负责响应用户请求。 87. 谈谈过滤器原理及其作用?87.1. 原理:过滤器是运行在服务器端的一个拦截作用的web组件，一个请求来到时，web容器会判断是否有过滤器与该信息资源相关联，如果有则交给过滤器处理，然后再交给目标资源，响应的时候则以相反的顺序交给过滤器处理，最后再返回给用户浏览器 87.2 使用场景：一般用于日志记录、性能、安全、权限管理等公共模块。 87.3 过滤器开发:过滤器是一个实现了javax.servlet.Filter接口的java类 主要业务代码放在doFilter方法中 业务代码完成后要将请求向后传递，即调用FilterChain对象的doFilter方法 87.4 配置:123456789在web.xml中增加如下代码&lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;Filter完整类名&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*(要过滤的url，此处*表示过滤所有的url)&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 88. 谈谈监听器作用及其分类?监听器也叫Listener，是一个实现特定接口的java类，使用时需要在web.xml中配置，它是web服务器端的一个组件，它们用于监听的事件源分别为SerlvetConext,HttpSession和ServletRequest这三个域对象 主要有以下三种操作: –监听三个域对象创建和销毁的事件监听器 –监听域对象中属性的增加和删除的事件监听器 –监听绑定到HttpSession域中的某个对象的状态的时间监听器 接口分类: –ServletContextListener HttpSessionListener –ServletRequestListener –ServletContextAttributeListener –HttpSessionAttributeListener ServletRequestAttributeListener –HttpSessionBindingListener(不需要配置) –HttpSessionActivationListener(不需要配置) 配置： 123&lt; listener&gt; &lt; listener-class&gt;实现以上任意接口的java类全名&lt; /listener-class&gt;&lt; /listener&gt; 89. jQuery的优势在哪里jQuery的语法更加简单。 jQuery消除了JavaScript跨平台兼容问题。 相比其他JavaScript和JavaScript库，jQuery更容易使用。 jQuery有一个庞大的库/函数。 jQuery有良好的文档和帮助手册。 jQuery支持AJAX 90. DOM对象和jQuery对象的区别及其转换90.1 DOM对象和jQuery对象的区别DOM对象，是我们用传统的方法(javascript)获得的对象， jQuery对象即是用jQuery类库的选择器获得的对象，它是对DOM对象的一种封装，jQuery对象不能使用DOM对象的方法，只能使用jQuery对象自己的方法。 90.2 DOM对象和jQuery对象的转换普通的dom对象一般可以通过$()转换成jquery对象----------&gt;即$(dom对象)` 如：var cr=document.getElementById(&quot;cr&quot;);//dom对象 var $cr = $(cr);//转换成jquery对象 由于jquery对象本身是一个集合。所以如果jquery对象要转换为dom对象则必须取出其中的某一项，一般可通过索引取出 如：$(&quot;#msg&quot;)[0]，$(&quot;div&quot;).eq(1)[0]，$(&quot;div&quot;).get()[1]，$(&quot;td&quot;)[5]这几种语法在jQuery中都是合法的 91. jQuery中$的作用主要有哪些1)$`用作选择器 例如:根据id获得页面元素$(&quot;#元素ID&quot;) 2)$相当于window.onload和$(document).ready(...) 例如:$(function(){...}); function(){...}会在DOM树加载完毕之后执行。 3)$用作JQuery的工具函数的前缀 例如： var str = &#39; Welcome to shanghai.com &#39;; str = $.trim(str);去掉空格 4)$(element)：把DOM节点转化成jQuery节点 例如：var cr=document.getElementById(&quot;cr&quot;);//dom对象 var $cr = $(cr);//转换成jquery对象 5）$(html)：使用HTML字符串创建jQuery节点 例如：var obj = $(&quot;&lt; div&gt;尚学堂，实战化教学第一品牌&lt; /div&gt;&quot;) 92. Ajax含义及其主要技术Ajax (Asynchronous JavaScript and XML 阿贾克斯)不是一个新的技术，事实上，它是一些旧有的成熟的技术以一种全新的更加强大的方式整合在一起。 Ajax的关键技术： 1)使用CSS构建用户界面样式，负责页面排版和美工 2)使用DOM进行动态显示和交互，对页面进行局部修改 3)使用XML HttpRequest异步获取数据 4)使用JavaScript将所有元素绑定在一起 93. Ajax的工作原理Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 94. JSON结构及其作用​ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。 94.1 在JSON中，有两种结构：对象和数组。{ } 对象 [ ] 数组 , 分隔属性 : 左边为属性名，右边为属性值 属性名可用可不用引号括起，属性值为字符串一定要用引号括起 举例： 1234567891011121314151617181920212223//对象varo=&#123; "xlid": "cxh", "xldigitid": 123456, "topscore": 2000, "topplaytime": "2009-08-20"&#125;； //数组jsonranklist=[ &#123; "xlid": "cxh", "xldigitid": 123456, "topscore": 2000, "topplaytime": "2009-08-20" &#125;, &#123; "xlid": "zd", "xldigitid": 123456, "topscore": 1500, "topplaytime": "2009-11-20" &#125;]; 95. 文件上传组件Common-fileUpload的常用类及其作用？DiskFileItemFactory：磁盘文件工厂类，设置上传文件保存的磁盘目录，缓冲区大小。 ServletFileUpload：上传处理类，此类真正读取客户上传的文件，同时可以设置最大接收大小。 FileItem：上传的文件对象，可以是多个文件，每个上传的文件都是一个单独的FileItem对象。 96. 说出Servlet的生命周期，并说出Servlet和CGI的区别?96.1 Servlet的生命周期Web容器先加载Servlet然后将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service方法，service方法会调用与请求对应的doGet或doPost等方法；当服务器关闭会项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy方法。 96.2Servlet和CGI的区别Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。 【补充1】SUN公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。 Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，此外将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必诟病CGI，腾讯的网站就使用了CGI技术，相信你也没感觉它哪里不好。 【补充2】Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destory() java.lang.String getServletInfo() ServletConfig getServletConfig() 97. JSP 和Servlet 有什么关系？Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。 JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于： Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来。 而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）。 JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 98. JSP中的四种作用域？答：page、request、session和application，具体如下： ①page 代表与一个页面相关的对象和属性。 ②request 代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web 组件；需要在页面显示的临时数据可以置于此作用域 ③session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中 ④application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 99. 如何实现JSP或Servlet的单线程模式？&lt;%@page isThreadSafe=”false”%&gt; 【补充】Servlet默认的工作模式是单实例多线程，如果Servlet实现了标识接口SingleThreadModel又或是JSP页面通过page指令设置isThreadSafe属性为false，那么它们生成的Java代码会以单线程多实例方式工作。显然，这样做会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题。 100. 实现会话跟踪的技术有哪些？答：由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。 ①URL 重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 ②设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。 这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。 ③cookie： cookie有两种： 一种是基于窗口的，浏览器窗口关闭后，cookie就没有了； 另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。 如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中；再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。 ④HttpSession：在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。 101. 过滤器有哪些作用和用法？答： Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。 常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。 和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain 102. 监听器有哪些作用和用法？答：Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示： ①ServletContextListener：对Servlet上下文的创建和销毁进行监听。 ②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。 ③HttpSessionListener：对Session的创建和销毁进行监听。 补充：session的销毁有两种情况： 1session超时（可以在web.xml中通过&lt; session-config&gt;/&lt; session-timeout&gt;标签配置超时时间）； 2通过调用session对象的invalidate()方法使session失效。 ④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。 ⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。 ⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。 103. 你的项目中使用过哪些JSTL标签？答：项目中主要使用了JSTL的核心标签库，包括&lt; c:if&gt;、&lt; c:choose&gt;、&lt; c: when&gt;、&lt; c: otherwise&gt;、&lt; c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。 【说明】虽然JSTL标签库提供了core、sql、fmt、xml等标签库，但是实际开发中建议只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。 104. 使用标签库有什么好处？如何自定义JSP标签？104.1使用标签库的好处包括以下几个方面：分离JSP页面的内容和逻辑，简化了Web开发； 开发者可以创建自定义标签来封装业务逻辑和显示逻辑； 标签具有很好的可移植性、可维护性和可重用性； 避免了对Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在JSP中书写小脚本） 104.2 自定义JSP标签包括以下几个步骤：①： 编写一个Java类实现实现Tag/BodyTag/IterationTag接口(通常不直接实现这些接口而是继承TagSupport/BodyTagSupport/SimpleTagSupport类，这是对适配器模式中缺省适配模式的应用)重写doStartTag()、doEndTag()等方法，定义标签要完成的功能 ②： 编写扩展名为tld的标签描述文件对自定义标签进行部署，tld文件通常放在WEB-INF文件夹或其子目录 ③： 在JSP页面中使用taglib指令引用该标签库 下面是一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.bjsxt;package com.lovo.tags;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.TagSupport;public class TimeTag extends TagSupport &#123; private static final long serialVersionUID = 1L; private String format = "yyyy-MM-dd hh:mm:ss"; private String foreColor = "black"; private String backColor = "white"; public int doStartTag() throws JspException &#123; SimpleDateFormat sdf = new SimpleDateFormat(format); JspWriter writer = pageContext.getOut(); StringBuilder sb = new StringBuilder(); sb.append(String.format("&lt;span style='color:%s;background-color:%s'&gt;%s&lt;/span&gt;", foreColor, backColor, sdf.format(new Date()))); try &#123; writer.print(sb.toString()); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; return SKIP_BODY; &#125; public void setFormat(String format) &#123; this.format = format; &#125; public void setForeColor(String foreColor) &#123; this.foreColor = foreColor; &#125; public void setBackColor(String backColor) &#123; this.backColor = backColor; &#125;&#125; 标签库描述文件（该文件通常放在WEB-INF目录或其子目录下） 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd" version="2.0"&gt; &lt;description&gt;定义标签库&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;MyTag&lt;/short-name&gt; &lt;tag&gt; //标签名 &lt;name&gt;time&lt;/name&gt; //标签对应的类 &lt;tag-class&gt;com.lovo.tags.TimeTag&lt;/tag-class&gt; //内容为空 &lt;body-content&gt;empty&lt;/body-content&gt; //标签所含属性 &lt;attribute&gt; &lt;name&gt;format&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;/attribute&gt; //标签所含属性 &lt;attribute&gt; &lt;name&gt;foreColor&lt;/name&gt; &lt;/attribute&gt; //标签所含属性 &lt;attribute&gt; &lt;name&gt;backColor&lt;/name&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; JSP页面 123456789101112131415161718192021&lt;%@ page pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="my" uri="/WEB-INF/tld/my.tld" %&gt;&lt;%String path = request.getContextPath();//获取项目名String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; font-family: "Arial"; font-size:72px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;my:time format="yyyy-MM-dd" backColor="blue" foreColor="yellow"/&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 【注意】如果要将自定义的标签库发布成JAR文件，需要将标签库描述文件（tld文件）放在JAR文件的META-INF目录下，可以JDK自带的jar工具完成JAR文件的生成。 105. 表达式语言（EL）的隐式对象及其作用？—-&gt;EL表达式105.1 表达式语言（EL）的11大隐式对象：①： pageContext ②： param（访问请求参数） ③： initParam（访问上下文参数） ④： paramValues ⑤： header（访问请求头） ⑥： headerValues ⑦： cookie（访问cookie） ⑧： applicationScope（访问application作用域） ⑨： sessionScope（访问session作用域） ⑩： requestScope（访问request作用域） ⑩： pageScope（访问page作用域） 105.2 用法如下所示：①： ${pageContext.request.method} ②： ${pageContext[“request”][“method”]} ③： ${pageContext.request[“method”]} ④： ${pageContext[“request”].method} ⑤： ${initParam.defaultEncoding} ⑥： ${header[“accept-language”]} ⑦： ${headerValues[“accept-language”][0]} ⑧： ${cookie.jsessionid.value} ⑨： ${sessionScope.loginUser.username} 【补充】表达式语言的.和[ ]运算作用是一致的，唯一的差别在于如果访问的属性名不符合Java标识符命名规则，例如上面的accept-language就不是一个有效的Java标识符，那么这时候就只能用[ ]运算符而不能使用.获取它的值 106. 表达式语言（EL）支持哪些运算符？答：除了.和[ ]运算符，EL还提供了： 算术运算符：+、-、*、/或div、%或mod 关系运算符：==或eq、!=或ne、&gt;或gt、&gt;= 或ge、&lt;或lt、&lt; =或le 逻辑运算符：&amp;&amp;或and、||或or、!或not 条件运算符：${statement? A : B}（跟Java的条件运算符类似） empty运算符：检查一个值是否为null或者空（数组长度为0或集合中没有元素也返回true） 107. Servlet 3中的异步处理指的是什么？答：在Servlet 3中引入了一项新的技术可以让Servlet异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么Servlet或Filter会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个Runnable对象交给Executor（如果不清楚请查看前文关于多线程和线程池的部分）并立即返回即可。 【补充】多线程在Java诞生初期无疑是一个亮点，而Servlet单实例多线程的工作方式也曾为其赢得美名，然而技术的发展往往会颠覆我们很多的认知，就如同当年爱因斯坦的相对论颠覆了牛顿的经典力学一般。事实上,异步处理绝不是Serlvet 3首创，如果你了解Node.js的话，对Servlet 3的这个重要改进就不以为奇了。 108. 如何在基于Java的Web项目中实现文件上传和下载？109. 简述值栈(Value-Stack)的原理和生命周期答： Value-Stack贯穿整个 Action 的生命周期，保存在request作用域中，所以它和request的生命周期一样。当Struts 2接受一个请求时，会创建ActionContext、Value-Stack和Action对象，然后把Action存放进Value-Stack，所以Action的实例变量可以通过OGNL访问。由于Action是多实例的，和使用单例的Servlet不同， 每个Action都有一个对应的Value-Stack，Value-Stack存放的数据类型是该Action的实例，以及该Action中的实例变量，Action对象默认保存在栈顶。 110. 阐述Session加载实体对象的过程。答：Session加载实体对象的步骤是： ① Session在调用数据库查询功能之前, 首先会在缓存中进行查询, 在一级缓存中, 通过实体类型和主键进行查找, 如果一级缓存查找命中且数据状态合法, 则直接返回 ② 如果一级缓存没有命中, 接下来Session会在当前NonExists记录(相当于一个查询黑名单, 如果出现重复的无效查询可以迅速判断, 从而提升性能)中进行查找, 如果NonExists中存在同样的查询条件,则返回null ③ 对于load方法, 如果一级缓存查询失败则查询二级缓存, 如果二级缓存命中则直接返回 ④ 如果之前的查询都未命中, 则发出SQL语句, 如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录, 并返回null ⑤ 根据映射配置和SQL语句得到ResultSet,并创建对应的实体对象 ⑥ 将对象纳入Session(一级缓存)管理 ⑦ 执行拦截器的onLoad方法(如果有对应的拦截器) ⑧ 将数据对象纳入二级缓存 ⑨ 返回数据对象 111. 怎么防止重复提交①：禁掉提交按钮。表单提交后使用Javascript使提交按钮disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把Javascript给禁止掉，这种方法就无效了。 ②： Post/Redirect/Get模式。在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。 这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。 ③： 在session中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在session中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从session中删除它，然后正常处理数据。 如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。 ④：在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。 112. $(document).ready(function(){ }) 和 jQuery(document).ready(function(){ }); 有什么区别？window.jQuery = window.$ = jQuery; 这两者可以互换使用。一般建议优先使用$ 113. 写出输出结果12345678910&lt;script&gt; function Foo() &#123; getName = function ()&#123;alert(1);&#125;; return this;&#125; Foo.getName = function() &#123;alert (2);&#125;; Foo.prototype.getName = function ()&#123; alert (3);&#125;; var getName = function ()&#123;alert (4);&#125;; function getName()&#123;alert (5);&#125;&lt;/script&gt; 请写出以下输出结果： Foo.getName(); // 2 getName(); // 4 Foo().getName(); // 1 getName(); // 1 new Foo.getName(); // 2 new Foo().getName(); // 3 new new Foo().getName(); // 3 114. web项目从浏览器发起交易响应缓慢，请简述从哪些方面如数分析从前端后端分别去考虑： 后台是不是数据库死锁等。 前台看看是不是js 错误，或者图片过大，dom 渲染dom树，画面优化。cmd amd 规范等]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Web相关面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础面试题及答案]]></title>
    <url>%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[目录结构: [TOC] 一、Java基础、语法1 面向对象的特征有哪些方面?答：面向对象的特征主要有以下几个方面：1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。 3)封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 4)多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 多态性的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。 举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。 同一个事件发生在不同的对象上会产生不同的结果。 作用：消除类型之间的耦合关系 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 重载和重写都是多态的体现. 2 访问修饰符public,private,protected,以及不写（默认）时的区别？答：区别如下： 作用域 当前类 同包 子类 其他 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × ×类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。 ####2.1 类的访问权限只有两种 public公共的 可被同一项目中所有的类访问。 (必须与文件名同名) default默认的 可被同一个包中的类访问。 2.2 成员（成员变量或成员方法）访问权限共有四种：public 公共的 可以被项目中所有的类访问。(项目可见性) protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性） default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性） private 私有的 只能被这个类本身访问。（类可见性） 3 String 是最基本的数据类型吗?答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 4 float f=3.4;是否正确? 答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型,因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 6 Java 有没有goto? 答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 7 int 和Integer 有什么区别? 答： int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 12345678public class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125; 补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示： 123456789&gt; public class Test03 &#123;&gt; &gt; public static void main(String[] args) &#123;&gt; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;&gt; System.out.println(f1 == f2);&gt; System.out.println(f3 == f4);&gt; &#125;&gt; &#125;&gt; 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。 装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache是Integer的内部类，其代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1f2的结果是true，而f3f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 8 &amp;和&amp;&amp;的区别和联系，|和||的区别和联系8.1&amp;和&amp;&amp;的联系(共同点)：&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。 操作数1&amp;操作数2，操作数1&amp;&amp;操作数2， 表达式1&amp;表达式2，表达式1&amp;&amp;表达式2， 情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。 情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。 表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。 8.2 &amp;和&amp;&amp;的区别(不同点)：(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。 对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。 对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。 综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。 、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。 |和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似 注: 很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。 9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。 答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。 String str = new String(“hello”); 上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。 补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。 10 Math.round（-11.2）的运行结果是答案: -11 分析： 小数点后第一位=5 正数：Math.round(11.5)=12 负数：Math.round(-11.5)=-11 小数点后第一位&lt;5 正数：Math.round(11.46)=11 负数：Math.round(-11.46)=-11 小数点后第一位&gt;5 正数：Math.round(11.68)=12 负数：Math.round(-11.68)=-12 根据上面例子的运行结果，我们还可以按照如下方式总结，或许更加容易记忆： 参数的小数点后第一位&lt;5，运算结果为参数整数部分。 参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。 参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分。 Java 中的 Math. round(-1. 5) 等于多少?等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。 终结：大于五全部加，等于五正数加，小于五全不加。 11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上? 答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。 12 用最有效率的方法计算2乘以8? 答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。 使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数。对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3 补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num &lt;==&gt; (num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。 13 数组有没有length()方法?String 有没有length()方法？ 答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。 14 在Java 中，如何跳出当前的多重嵌套循环？ 答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; ok: for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;10;j++) &#123; System.out.println("i=" + i + ",j=" + j); if(j == 5) &#123; break ok; &#125; &#125; &#125; &#125;&#125;//运行结果如下: i=0,j=0i=0,j=1i=0,j=2i=0,j=3i=0,j=4i=0,j=5 /*通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。 */int arr[][] = &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;boolean found = false;for(int i=0;i&lt;arr.length &amp;&amp; !found;i++) &#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] == 5) &#123; found = true; break; &#125; &#125; &#125; //运行结果如下: i=0,j=0i=0,j=1i=0,j=2i=1,j=0i=1,j=1 15 构造器（constructor）是否可被重写（override）? 答：构造器不能被继承，因此不能被重写，但可以被重载。 16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？ 答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括： 使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 17 是否可以继承String 类? 答：String 类是final类，不可以被继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。 18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。 补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。 19 String 和StringBuilder、StringBuffer 的区别? 答：Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。 补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。 补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。 20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分? 答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！ 21 描述一下JVM 加载class文件的原理机制? 答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 补充： 1.由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。 2.类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： a)Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； b)Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； c)System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 22 char 型变量中能不能存贮一个中文汉字?为什么? 答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。 补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。 23 抽象类（abstract class）和接口（interface）有什么异同? 答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 在接口中定义成员变量在声明的时候是必须要初始化的，并且都是 public static final 的。比如你在接口中定义一个变量 i，可以这么写： 12345public interface IDemo&#123; // 必须初始化 int i = 10;&#125; 它的真正代码是这样的： 1234public interface IDemo&#123; public static final int i = 10;&#125; 那么这是为什么呢？ 因为在 Java 中，接口是高层次的抽象，体现的是 OCP（对修改关闭，对扩展开放）的设计原则，这也是我们设计中一直追求的。 首先要弄清接口的含义。接口就是提供一种统一的“协议”，而接口中的属性也属于“协议”中的成员。它们是公共的，静态的,不可变的常量，相当于全局常量。 抽象类是“不完全”的类，相当于是接口和具体类的一个中间层，即满足接口的抽象，也满足具体的实现。 如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。 也许你会想，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况：如果接口 A 中有一个 public 访问权限的静态变量 a。按照 java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。 通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。 接口中的方法前面的public abstract ,属性前面的public static final都可以省略的。 总之: ①: 接口中没有变量,只有常量,且默认修饰符public static final; 另外接口中方法的默认修饰符: public abstract ②: 抽象类可以没有抽象方法,但如果一个类中有抽象方法,那么这个类必须声明为抽象方法. 24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？ 答：内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示： 123456789101112131415161718192021public class Outer&#123; int out_x = 0; public void method() &#123; Inner1 inner1 = new Inner1(); public class Inner2 //在方法体内部定义的内部类 &#123; public method() &#123; out_x = 3; &#125; &#125; Inner2 inner2 = new Inner2(); &#125; public class Inner1 //在方法体外面定义的内部类 &#123; &#125;&#125; 在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下： Outer outer = new Outer(); Outer.Inner1 inner1 = outer.new Innner1(); 在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。 对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。 在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称： 1234567891011public class Outer&#123; public void start() &#123; new Thread( new Runable()&#123; public void run()&#123;&#125;; &#125; ).start(); &#125;&#125; 最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类： Outer.Inner inner = newOuter.Inner(); 由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。 在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。 备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。 Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*** 扑克类（一副扑克） * @author sxt * */public class Poker &#123; private static String[] suites = &#123;"黑桃", "红桃", "草花", "方块"&#125;; private static int[] faces = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;; private Card[] cards; /** * 构造器 */ public Poker() &#123; cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) &#123; for(int j = 0; j &lt; faces.length; j++) &#123; cards[i * 13 + j] = new Card(suites[i], faces[j]); &#125; &#125; &#125; /** * 洗牌 （随机乱序） */ public void shuffle() &#123; for(int i = 0, len = cards.length; i &lt; len; i++) &#123; int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; &#125; &#125; /** * 发牌 * @param index 发牌的位置 */ public Card deal(int index) &#123; return cards[index]; &#125; /** * 卡片类（一张扑克） * [内部类] * @author sxt */ public class Card &#123; private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) &#123; this.suite = suite; this.face = face; &#125; @Override public String toString() &#123; String faceStr = ""; switch(face) &#123; case 1: faceStr = "A"; break; case 11: faceStr = "J"; break; case 12: faceStr = "Q"; break; case 13: faceStr = "K"; break; default: faceStr = String.valueOf(face); &#125; return suite + faceStr; &#125; &#125;&#125; 12345678910111213//测试类class PokerTest &#123; public static void main(String[] args) &#123; Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card("红心", 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A &#125;&#125; 25 Java 中会存在内存泄漏吗，请简单描述。 答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况： 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰? 答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 27 静态变量和实例变量的区别？ 答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。 28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？ 答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。 29 如何实现对象克隆？123456789101112131415public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static &lt;T&gt; T clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源 &#125;&#125; 答：有两种方式： 1.实现Cloneable接口并重写Object类中的clone()方法； 2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。 下面是测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 人类 * @author sxt*/class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125;&#125;/** * 小汽车类 * @author sxt*/class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]"; &#125;&#125;class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person("Hao LUO", 33, new Car("Benz", 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand("BYD"); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。 30 GC 是什么？为什么要有GC？ 答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： • 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 • 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 • 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的JVM参数： • -Xms / -Xmx — 堆的初始大小 / 堆的最大大小 • -Xmn — 堆中年轻代的大小 • -XX:-DisableExplicitGC — 让System.gc()不产生任何作用 • -XX:+PrintGCDetail — 打印GC的细节 • -XX:+PrintGCDateStamps — 打印GC操作的时间戳 31 String s=new String(“xyz”);创建了几个字符串对象？ 答：两个对象，一个是静态存储区的”xyz”,一个是用new创建在堆上的对象。 32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）? 答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。 33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？ 答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？ 答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 36 Java 中的final关键字有哪些用法？答: (1) 修饰类：表示该类不能被继承； (2) 修饰方法：表示方法不能被重写但是允许重载； (3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）； (4) 修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。 37 指出下面程序的运行结果:1234567891011121314151617181920212223class A&#123; static&#123; System.out.print("1"); &#125; public A()&#123; System.out.print("2"); &#125;&#125;class B extends A&#123; static&#123; System.out.print("a"); &#125; public B()&#123; System.out.print("b"); &#125;&#125;public class Hello&#123; public static void main(String[] args)&#123; A ab = new B(); ab = new B(); &#125;&#125; 答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。 考点：静态代码块优先级 &gt; 构造方法的优先级如果再加一个普通代码块，优先顺序如下：静态代码块&gt;普通代码块&gt;构造方法 38 说说数据类型之间的转换: 1)如何将字符串转换为基本数据类型？ 2)如何将基本数据类型转换为字符串？ 答： 1)调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 2)一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串 39 如何实现字符串的反转及替换？ 答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示： 1234567public class A&#123; public static String reverse(String originStr) &#123; if(originStr == null || originStr.length() &lt;= 1) return originStr; return reverse(originStr.substring(1)) + originStr.charAt(0); &#125;&#125; 40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？ 答：代码如下所示: String s1 = “你好”; String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”); 41 日期和时间： 1)如何取得年,月,日、小时,分钟,秒？ —-&gt;抽象类Calendar的方法 2)如何取得从1970年1月1日0时0分0秒到现在的毫秒数？ —-&gt;两种常用方法 3)如何取得某月的最后一天，第一天？ —–&gt;也就是获取过去或未来的日期,使用add方法 4)如何格式化日期？ —–&gt;SimpleDateFormat类的format方法 5)如何获取形如Sat Jun 01 10:29:07 CST 2019类型日期? ——-&gt;Calendar调用getInstance后调用getTime方法, 或者调用Date类的无参构造器 6) add()和roll()的区别 ——-&gt; roll方法是在本月内循环. 答：操作方法如下所示： 1)创建java.util.Calendar 实例，调用getInstance()方法后调用其get()方法传入不同的参数即可获得参数所对应的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &#123; public static void main(String[] args) &#123; // 获取当前年份、月份、日期 Calendar cale = Calendar.getInstance(); ////创建实例 默认是当前时刻 /* Calendar类源码: public final static int YEAR = 1; 所以1则代表的是对年份操作，同理2是对月份 操作，3是对星期操作，5是对日期操作，11是对小时操作，12是对分钟操作，13是对秒操作，14是对毫秒操作。 */ //其中Calendar.YEAR的值为1,这里也可以换为 int year = cale.get(1); int year = cale.get(Calendar.YEAR); /*注: 加1是因为MONTH是从零计数,即0--&gt;11对应1月---&gt;12月; 例如:如果当前是2019年6月,则 cale.get(Calendar.MONTH)的值就是5,要想与月份一致,则加1即可. */ int month = cale.get(Calendar.MONTH) + 1; // DATE是DAY_OF_MONTH的同义词,本月的第一天值为1。 int day = cale.get(Calendar.DATE); int hour = cale.get(Calendar.HOUR_OF_DAY); int minute = cale.get(Calendar.MINUTE); int second = cale.get(Calendar.SECOND); /*注: DAY_OF_WEEK:一个星期中的第几天,从1-7对应 星期日-星期六; 如果想让星期一作为一个星期的第一 天,则减一即可.例如今天星期一,cale.get(Calendar.DAY_OF_WEEK)得到的值则为2,要想与星期相一致, 则减1即可. */ int dow = cale.get(Calendar.DAY_OF_WEEK)-1; int dom = cale.get(Calendar.DAY_OF_MONTH); int doy = cale.get(Calendar.DAY_OF_YEAR); System.out.println("Current Date: " + cale.getTime()); System.out.println("Year: " + year); System.out.println("Month: " + month); System.out.println("Day: " + day); System.out.println("Hour: " + hour); System.out.println("Minute: " + minute); System.out.println("Second: " + second); System.out.println("Day of Week: " + dow); System.out.println("Day of Month: " + dom); System.out.println("Day of Year: " + doy); &#125;&#125;/*运行结果Current Date: Fri May 31 21:51:04 CST 2019Year: 2019Month: 5Day: 31Hour: 21Minute: 51Second: 4Day of Week: 6Day of Month: 31Day of Year: 151*/ 2)以下方法均可获得该毫秒数: java.lang.System.currentTimeMillis();—–&gt;通常用来计算时间差. Calendar.getInstance().getTimeInMillis(); java.util.Date().getTime()——&gt;目前已经弃用 3)示例代码如下: 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; /*add方法: 在给定的日历字段中添加或减去指定的时间量 c.add(Calendar.DATE, X);//取指定天数的时期， 取过去天的日期用负数，取未来天数日期用正数，在"X"处 如 c.add(Calendar.DATE, -1)取当前日期前 一天的日期*/ // 获取当月第一天和最后一天 SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); String firstday, lastday; Calendar cale = Calendar.getInstance(); // 获取当前月的第一天 cale = Calendar.getInstance(); //add方法就可以解决大部分的功能。比如我们需要得到当前年，月，日，小时，分钟，秒，毫秒的前面时间或 //者后面时间 cale.add(Calendar.MONTH, 0); cale.set(Calendar.DAY_OF_MONTH, 1); firstday = format.format(cale.getTime()); // 获取当前月的最后一天 cale = Calendar.getInstance(); cale.add(Calendar.MONTH, 1); cale.set(Calendar.DAY_OF_MONTH, 0); lastday = format.format(cale.getTime()); System.out.println("本月第一天和最后一天分别是 ： " + firstday + " and " + lastday); &#125;&#125;//运行结果: //本月第一天和最后一天分别是 ： 2019-05-01 and 2019-05-31//或者使用: time.getActualMaximum(Calendar.DAY_OF_MONTH); 4)利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; Date ss = new Date(); System.out.println("一般日期输出：" + ss); System.out.println("时间戳：" + ss.getTime()); //Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样 SimpleDateFormat format0 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String time = format0.format(ss.getTime());//这个就是把时间戳经过处理得到期望格式的时间 System.out.println("格式化结果0：" + time); SimpleDateFormat format1 = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒"); time = format1.format(ss.getTime()); System.out.println("格式化结果1：" + time); &#125;&#125;/*运行结果: 一般日期输出：Fri May 31 22:18:07 CST 2019时间戳：1559312287526格式化结果0：2019-05-31 22:18:07格式化结果1：2019年05月31日 22时18分07秒*/ 5) 获取形如Sat Jun 01 10:29:07 CST 2019类型日期 123System.out.println(Calendar.getInstance().getTime());或者System.out.println(new Date()); 6) add与roll 1234567891011121314151617181920212223242526272829//add()方法 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); Calendar cal=Calendar.getInstance(); cal.set(Calendar.YEAR, 2019); //Calendar.YEAR设值为2019cal.set(Calendar.MONTH,8);// Calendar.MONTH设值为8,对应的月份为8+1=9月cal.set(Calendar.DAY_OF_MONTH, 3); //Calendar.DAY_OF_MONTH设为3,即9月的第3天,也就是2019年9月3日cal.add(Calendar.DATE, -4); // Calendar.DATE 减 4, 即2019年9月3日向后退4天,就是2019年8月30 Date date=cal.getTime(); System.out.println(df.format(date)); //输出为:2019-08-30 cal.add(Calendar.DATE, 4); //上面的结果上Calendar.DATE 加 4, 即2006年8月30日向前4天,就是2006年9月3date=cal.getTime(); System.out.println(df.format(date)); //输出为:2019-09-03输出： 2019-08-30 2019-09-03 //roll方法 cal.set(Calendar.YEAR, 2019); cal.set(Calendar.MONTH,8); // Calendar.MONTH设值为8,对应的月份为8+1=9月 cal.set(Calendar.DAY_OF_MONTH, 3);//Calendar.DAY_OF_MONTH设为3,即9月的第3天,也就是2019年9月3日cal.roll(Calendar.DATE, -4);// Calendar.DATE 减 4, 即2019年9月3日向后退4天(在9月循环),就是2019年9月29 date=cal.getTime(); System.out.println(df.format(date)); cal.roll(Calendar.DATE, 4); //上面的结果上Calendar.DATE 加 4, 即2019年9月29日向前4天,就是2019年9月3date=cal.getTime(); System.out.println(df.format(date)); //输出为: 2019-09-03 输出： 2019-09-29 2019-09-03 可见，roll()方法在本月内循环，一般使用add()方法； 补充: \1. java中主要使用:三个类来处理日期和时间 a. java.util.Date(日期) , ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的毫秒数,主要用于创建日期对象并获取日期 b. java.util.Calendar（日历） , ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分 c. java.text.DateFormat（日期格式化） ————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat \2. 月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写，有要求 \3. 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 1506582000000 1System.out.println(new Date().getTime());//1559301422873 抽象类Calendar的对象调用getInstance方法后,调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017 12345678System.out.println(Calendar.getInstance().getTime());//Fri May 31 19:27:52 CST 2019System.out.println(Calendar.getInstance());/*java.util.GregorianCalendar[time=1559302072601,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=falsee,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2019,MONTH=4,WEEK_OF_YEAR=22,WEEK_OF_MONTH=5,DAY_OF_MONTH=31,DAY_OF_YEAR=151,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=5,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,MINUTE=27,SECOND=52,MILLISECOND=601,ZONE_OFFSET=28800000,DST_OFFSET=0]*/ 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52 42 打印昨天的当前时刻。123456789public class Test &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE, -1); System.out.println(cal.getTime()); &#125;&#125;//运行结果: Fri May 31 15:19:44 CST 2019 43 比较一下Java 和JavaSciprt。 答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。 下面对两种语言间的异同作如下比较： 1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用； 2）解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行； 3）强类型变量和弱类型变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型； 4）代码格式不一样。 补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。 44 什么时候用assert？ 答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。 断言用于调试目的： assert(a &gt; 0); // throws an AssertionError if a &lt;= 0 断言可以有两种形式： assert Expression1; assert Expression1 : Expression2 ; Expression1 应该总是产生一个布尔值。 Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。 断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记： javac -source 1.4 Test.java 要在运行时启用断言，可使用-enableassertions 或者-ea 标记。 要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。 要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。 45 Error 和Exception 有什么区别? 答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示： 因此，用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再递归而是回溯了）。 46 try{}里 有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后? 答：会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; int d = temp5(1); System.out.println("c = "+d); &#125; public static int temp5(int c) &#123; try &#123; return c; &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125; finally &#123; c = c + 1; System.out.println("执行finally,修改c的值..." +"修改后C为: "+ c); &#125; return c; &#125;&#125;//运行结果: /*执行finally,修改c的值...修改后C为: 2c = 1*/ 在异常处理时提供 finally 块来执行任何清除操作。 如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。 finally中语句不执行的唯一情况中执行了System.exit(0)语句。 47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？ 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。 48 运行时异常与受检异常有何异同？答: 异常表示程序运行过程中可能出现的非正常状态: 运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。 受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。 Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则： • 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） • 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 • 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） • 优先使用标准的异常 • 每个方法抛出的异常都要有文档 • 保持异常的原子性 • 不要在catch中忽略掉捕获到的异常 异常的分类: 编译异常、运行异常、检查性异常、逻辑异常. 编译异常: 由于程序语法不合规范，编译不通过 非运行时异常: 又称检查性异常也称受检异常，此类异常必须被捕获处理—&gt;如IO操作错误,类没找到等 记忆方法: 检查性异常为”IO操作错误”,”类没找到”等,其他基本上是运行时异常. 49 列出一些你常见的运行时异常？ 答： ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下表越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 50 final, finally, finalize 的区别?final修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承例如：String类、Math类等。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写，但是能够重载。 使用final修饰的对象，对象的引用地址不能变，但是对象的值可以变！ finally在异常处理时提供 finally 块来执行任何清除操作。如果有finally的话，则不管是否发生异常，finally语句都会被执行。一般情况下，都把关闭物理连接(IO流、数据库连接、Socket连接)等相关操作，放入到此代码块中。 finalize方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作。finalize() 方法是在垃圾收集器删除对象之前被调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。 一般情况下，此方法由JVM调用，程序员不要去调用！ 51 Java跨平台原理（字节码文件、虚拟机） C/C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。 Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。 字节码文件不面向任何具体平台，只面向虚拟机。 Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。 Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。 Java的跨平台原理决定了其性能没有C/C++高 52 Java三大版本Java2平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本： Standard Edition(标准版) J2SE 包含那些构成Java语言核心的类。 比如：数据库连接、接口定义、输入/输出、网络编程 Enterprise Edition(企业版) J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。 比如servlet、JSP、XML、事务控制 Micro Edition(微缩版) J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。 比如：呼机、智能卡、手机、PDA、机顶盒 他们的范围是：J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类 应用场合，API的覆盖范围各不相同 53. Java的安全性53.1 语言层次的安全性主要体现在：Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。 垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。 异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。 强制类型转换：只有在满足强制转换规则的情况下才能强转成功。 53.2 底层的安全性可以从以下方面来说明Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。 在运行环境提供了四级安全性保障机制： 字节码校验器 -类装载器 -运行时内存布局 -文件访问限制 54. 什么是JVM？什么是JDK？ 什么是JRE？54.1 JVM :JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。 54.2 JRE：JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 54.3 JDK：JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。 bin:最主要的是编译器(javac.exe) include:java和JVM交互用的头文件 lib：类库 jre:java运行环境 （注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而 jre则是只能运行class而没有编译的功能。 eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。 54.4 JDK,JRE,JVM三者关系概括如下：jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDK、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。 55 Java三种注释类型共有单行注释、多行注释、文档注释3种注释类型。使用如下： ①: 单行注释，采用“//”方式.只能注释一行代码。如：//类成员变量 ②: 多行注释，采用“/…/”方式，可注释多行代码，其中不允许出现嵌套。如： /*System.out.println(“a”); System.out.println(“b”); System.out.println(“c”);*/ ③: 文档注释，采用“/*…/”方式。如： /*子类 Dog*@author Administrator\/public class Dog extends Animal{} 56. i++和++i的异同之处####56.1 共同点： 1、i++和++i都是变量自增1，都等价于i=i+1 2、如果i++,++i是一条单独的语句，两者没有任何区别 3、i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。 56.2 不同点：如果i++,++i不是一条单独的语句，他们就有区别i++ ：先运算后增1。如： 1234int x=5;int y=x++;System.out.println("x="+x+", y="+y);//以上代码运行后输出结果为：x=6, y=5 ++i ： 先增1后运算。如： 1234int x=5;int y=++x;System.out.println("x="+x+", y="+y);//以上代码运行后输出结果为：x=6, y=6 57 基本数据类型的类型转换规则基本类型转换分为自动转换和强制转换。 自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可 以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。 强制转换规则：高级变为低级需要强制转换。 如何转换： （1）赋值运算符“=”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。 （2）赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。 (3)可以将整型常量直接赋值给byte, short, char等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。 58 if多分支语句和switch多分支语句的异同之处相同之处：都是分支语句，多超过一种的情况进行判断处理。 不同之处： switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有break跳出），不加判断地执行下去; 而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。 switch为等值判断（不允许比如&gt;= &lt;=），而if为等值和区间都可以，if的使用范围大。 59. while和do-while循环的区别while先判断后执行，第一次判断为false,循环体一次都不执行 do while先执行 后判断，最少执行1次。 如果while循环第一次判断为true, 则两种循环没有区别。 60. break和continue的作用break: 结束当前循环并退出当前循环体。 break还可以退出switch语句 continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。 61. 递归的定义和优缺点递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。 递归算法解决问题的特点： (1) 递归就是在过程或函数里调用自身。 (2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。 (3) 递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。 (4) 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。 62. .数组的特征数组是（相同类型数据）的（有序）（集合） 数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素element 元素的表示 数组名[下标或者索引] scores[7] scores[0] scores[9] 索引从0开始 每个数组元素有默认值 double 0.0 boolean false int 0 注: 数组元素有序的，不是大小顺序，是索引 的顺序 数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，数组的类型是固定的，只能是一个 没有length方法,但是有length属性,length是数组长度. 数组的长度是固定的，一经定义，不能再发生变化（数组的扩容） 63. 请写出冒泡排序代码1234567891011121314151617181920212223242526272829303132public static void sort(int[] a) &#123; int temp = 0; // 外层循环，它决定一共走几趟 for (int i = 0; i &lt;a.length-1; ++i) &#123; //内层循环，它决定每趟走一次 for (int j = 0; j &lt;a.length-i-1 ; ++j) &#123; //如果后一个大于前一个 if (a[j + 1] &lt; a[j]) &#123; //换位 temp = a[j];a[j] = a[j + 1];a[j + 1] = temp; &#125; &#125; &#125; public static void sort2(int[] a) &#123; int temp = 0; for (int i = 0; i &lt;a.length-1; ++i) &#123; //通过符号位可以减少无谓的比较，如果已经有序了，就退出循环 int flag = 0; for (int j = 0; j &lt;a.length-1-i ; ++j) &#123; if (a[j + 1] &lt; a[j]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; flag = 1; &#125; &#125; if(flag == 0)&#123; break; &#125; &#125; &#125; 64. 请写出选择排序的代码12345678910111213141516171819public static void sort(int arr[]) &#123; int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 认为目前的数就是最小的, 记录最小数的下标 int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[minIndex] &gt; arr[j]) &#123; // 修改最小值的下标 minIndex = j; &#125; &#125; // 当退出for就找到这次的最小值 if (i != minIndex) &#123; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125;&#125; 65. 请写出插入排序的代码12345678910public static void sort(int arr[]) &#123; int i, j; for (i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; for (j = i; j &gt; 0 &amp;&amp; temp &lt; arr[j - 1]; j--) &#123; arr[j] = arr[j - 1]; &#125; arr[j] = temp; &#125;&#125; 66. 类和对象的关系类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。 类和对象好比图纸和实物的关系，模具和铸件的关系。 比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。 小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。 67. 面向过程和面向对象的区别两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。 比喻 蒋介石和毛泽东分别是面向过程和面向对象的杰出代表，这样充分说明，在解决复制问题时，面向对象有更大的优越性。 面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。 区别 编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。 封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。 面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。 68. 方法重载和方法重写（覆盖）的区别 英文 位置不同 作用不同 重载 overload 同一个类中 在一个类里面为一种行为提供多种实现方式并提高可读性 重写 override 子类和父类间 父类方法无法满足子类的要求，子类通过方法重写满足要求 修饰符 返回值 方法名 参数 抛出异常 重载 无关 无关 相同 不同 无关 重写 大于等于 小于等于 相同 相同 小于等于 重载只关注方法名和参数即可,其他都无关 重写方法名和参数必须相同,其他三个也有要求 69. this和super关键字的作用this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量；this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句。，而且在静态方法当中不允许出现this关键字。 super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员） super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。 70. static关键字 static可以修饰变量、方法、代码块和内部类 static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。 static变量和非static变量的区别(都是成员变量，不是局部变量) 1.在内存中份数不同 不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份 static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量 2.在内存中存放的位置不同 3.访问的方式不同 实例变量： 对象名.变量名 stu1.name=”小明明”; 静态变量：对象名.变量名 stu1.schoolName=”西二旗小学”; 不推荐如此使用 类名.变量名 Student.schoolName=”东三旗小学”; 推荐使用 4.在内存中分配空间的时间不同 static方法也可以通过对象名.方法名和类名.方法名两种方式来访问 static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。 static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员 71.final和abstract关键字 abstract只能修饰方法和类，不能修饰字段； final和abstract是功能相反的两个关键字，可以对比记忆 abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。 final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。 特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如 1`package` `com.bjsxt;` `class` `Test &#123;`` ``public` `static` `void` `main(String[] args) &#123;`` ``final` `Dog dog = ``new` `Dog(``"欧欧"``);`` ``dog.name = ``"美美"``;``//正确`` ``dog = ``new` `Dog(``"亚亚"``);``//错误`` ``&#125;``&#125;` 72. 写出java.lang.Object类的六个常用方法(1)public boolean equals(java.lang.Object)//比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等； (2)public native int hashCode() 获取哈希码 (3)public java.lang.String toString() 把数据转变成字符串 (4)public final native java.lang.Class getClass() 获取类结构信息 (5)protected void finalize() throws java.lang.Throwable //垃圾回收前执行的方法 (6)protected native Object clone() throws java.lang.CloneNotSupportedException 克隆 (7)public final void wait() throws java.lang.InterruptedException //多线程中等待功能 (8)public final native void notify() 多线程中唤醒功能 (9)public final native void notifyAll() 多线程中唤醒所有等待线程的功能 73. 继承条件下构造方法的执行过程继承条件下构造方法的调用规则如下： 情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。 情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。 情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。 特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。 74.==和equals的区别和联系“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值； “==”使用情况如下： a) 基本类型，比较的是值 b) 引用类型，比较的是地址 c) 不能比较没有父子关系的两个对象 equals()方法使用如下： a) 系统类一般已经覆盖了equals()，比较的是内容。 b) 用户自定义类如果没有覆盖equals()，将调用父类的equals （比如是Object），而Object的equals的比较是地址（return (this == obj);） c) 用户自定义类需要覆盖父类的equals() 注意：Object的==和equals比较的都是地址，作用相同 75. 谈谈Java的多态实现多态的三个条件（前提条件，向上转型、向下转型） 1、继承的存在；（继承是多态的基础，没有继承就没有多态） 2、子类重写父类的方法。（多态下会调用子类重写后的方法） 3、父类引用变量指向子类对象。（涉及子类到父类的类型转换） 向上转型 Student person = new Student() 将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。 向下转型 Student stu = (Student)person; 将一个指向子类对象的父类引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，，否则将出现ClassCastException，不是任意的强制转换 向下转型时可以结合使用instanceof运算符进行强制类型转换，比如出现转换异常—ClassCastException 76. 简述Java的垃圾回收机制传统的C/C++语言，需要程序员负责回收已经分配内存。 76.1显式回收垃圾回收的缺点：1）程序忘记及时回收，从而导致内存泄露，降低系统性能。 2）程序错误回收程序核心类库的内存，导致系统崩溃。 Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制，简称GC； 1）可以提高编程效率。 2）保护程序的完整性。 3）其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。 76.2 垃圾回收机制的 特点1）垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。 2）对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。 3）垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。 4）可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。 现在的JVM有多种垃圾回收 实现算法，表现各异。 垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。 程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。 永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。 77. 基本数据类型和包装类####77.1 八个基本数据类型的包装类 基本数据类型 包装类 byte Byte boolean Boolean short Short char Character int Integer long Long float Float double Double 77.2 为什么为基本类型引入包装类2.1基本数据类型有方便之处，简单、高效。 2.2但是Java中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是Object）。 为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。 77.3 包装类和基本数据类型之间的转换3.1包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型 3.2包装类——-new WrapperClass(primitive) 3.2包装类——-new WrapperClass(primitive) 4) 自动装箱和自动拆箱 JDK1.5提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换 5) 包装类还可以实现基本类型变量和字符串之间的转换 78. Integer与int的区别int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。 在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。 另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 79.java.sql.Date和java.util.Date的联系和区别1） java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。 2）JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用… 总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分. 80. 使用递归算法输出某个目录下所有文件和子目录列表1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; String path = "D:/301SXT"; test(path); &#125; private static void test(String path) &#123; File f = new File(path); File[] fs = f.listFiles(); if (fs == null) &#123; return; &#125; for (File file : fs) &#123; if (file.isFile()) &#123; System.out.println(file.getPath()); &#125; else &#123; test(file.getPath()); &#125; &#125; &#125;&#125; 81. Java中接口的修饰符可以为（）（选择一项） A private B. protected C. final D. abstract 答案：D分析：接口中的访问权限修饰符只可以是public或default,接口中的所有的方法必须要实现类实现，所以不能使用final,接口中所有的方法默认都是abstract的，所以接口可以使用abstract修饰，但通常abstract可以省略不写 82. 为什么接口里面的属性必须是常量即final修饰, 且静态即static修饰知识点1：一个类，首先他会在内存里面有一个类对象，然后由类对象生成类的对象 知识点2：为什么接口Interface里面的属性必须是常量呢？ 因为类可以被实例化，实例化的类的对象里面的变量就会被赋初始值。比如String 是 null int是0，double是0.0。但是接口呢？接口不能被实例化，所以接口里面如果是变量的话不会被赋初始值这样就会出问题。所以接口里面的值必须是常量final而且一定是static不管写不写都是 知识点3：那为什么它要是静态的呢？因为static是什么？是所有对象可以访问，而且可以直接通过类名访问。接口有对象么？显然没有,因为接口不能被实例化，必须通过类名来访问所以是要静态的。 补充: Java的interface中，成员变量的默认修饰符为：public static final Java的interface中，方法的默认修饰符是：public abstract 以上两种都可以，老司机一般都是第二种。既然是静态最终的变量，也就意味着在外面访问的时候不能修改这个成员变量的值。所以在接口中定义成员变量的，一般都是常量。不会修改的。如果要进行修改的话，定义在接口具体实现类中。 83. 给定以下代码，程序将输出 （）（选择一项）12345678910111213class A &#123; public A()&#123; System.out.println("A"); &#125;&#125;class B extends A&#123; public B()&#123; System.out.println("B"); &#125; public static void main(String[] args) &#123; B b=new B(); &#125;&#125; A 不能通过编译 B. 通过编译，输出AB C. 通过编译，输出B D. 通过编译，输出A 答案：B分析：在继承关系下，创建子类对象，先执行父类的构造方法，再执行子类的构造方法 84. 为什么说静态的不能访问非静态的，而非静态的能访问静态的？原因：生命周期：静态的执行早于非静态的（也就是说晚生成的能调用早生成的，而早生成的不能调用晚生成的） 85. 选出合理的标识符（）（选择两项） A _sysl_111 B. 2 mail C. $change D. class 答案：AC分析： 标识符的命令规范，可以包含字母、数字、下划线、$，不能以数字开头，不能是Java关键字 86. 面向对象的特征有哪些方面？请用生活中的例子来描述答: 面向对象的三大特征：封装、继承、多态。 举例：（比如设计一个游戏）我现在创建了一个对象，名叫战士。 战士的属性是—性别，年龄，职业，等级，战斗力，血量。 它的方法—战斗，逃跑，吃饭，睡觉，死。 后来，我又建了一个对象，叫人。 属性:性别，年龄，职业，等级，血量 方法:逃跑，吃饭，睡觉，死。 我让人，成为战士的父类，战士可以直接继承人的属性和方法。 战士修改成— 属性:战斗力。 方法:战斗。 看上去战士的资料变少了，实际上没有，我们仍然可以调用方法—战士.死。 而且我们还可以重载战士.死的方法，简称重载死法。 我还建了一个对象—法师，父类也是人。 属性:法力值 方法:施法，泡妞。 你看，用了继承，创建对象变得更方便了。 再后来，我又建立了一个对象，叫怪物。 属性:等级，战力，血量。 方法:战斗，死。 建了个对象，叫白兔怪，父类怪物，可继承怪物所有的属性和方法。 属性:毛色。 方法:卖萌，吃胡萝卜。 87. 说明内存泄漏和内存溢出的区别和联系内存泄漏: 是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错 总结: memory leak会最终会导致out of memory！ 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。 88.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？答：Java中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的状态信息 写入到一个字节流中使其可以通过socket进行传输、或者持久化到存储数据库或文件系统中；然后在需要的时候通过字节流中的信息来重构一个相同的对象。 一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接口即可。 对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上 传送对象的字节序列。 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 89. 不通过构造函数也能创建对象吗？答：Java创建对象的几种方式（重要）： 1、 用new语句创建对象，这是最常见的创建对象的方法。 2、 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。 3、 调用对象的clone()方法。 4、运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。 (1)和(2)都会明确的显式的调用构造函数 ； (3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。 90. .匿名内部类可不可以继承或实现接口。为什么？答：匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现. 1、由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。 2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。 3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。 91. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。(1) 在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt; K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt; K, V&gt;可以理解为HashMap&lt; Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。 虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型。 92. 简述Java中如何实现多态实现多态有三个前提条件： 1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。 2、子类重写父类的方法。（多态下会调用子类重写后的方法）。 3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。 最后使用父类的引用变量调用子类重写的方法即可实现多态。 93.Java 中 Math.random（）/Math.random（）值为？如果除数与被除数均为0.0的话，则运行结果为NaN（Not a Number的简写），计算错误 94. Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？不是，两者没有任何关联； Pair是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例化而已；所以，Pair&lt; Manager&gt;和Pair&lt; Employee&gt;不是子类的关系。 95. 接口和抽象类的区别抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现 两者的区别主要体现在两方面：语法方面和设计理念方面 语法方面的区别是比较低层次的，非本质的，主要表现在： 接口中只能定义全局常量(静态常量)，不能定义变量。抽象类中可以定义常量和变量。 接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。 抽象类中可以有构造方法，但不能用来实例化，而在子类实例化时执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。 一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。 一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。 抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a”的关系，即父类和子类在概念本质上应该是相同的。 接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。接口和实现之间可以认为是一种“has-a的关系” 96. 同步代码块和同步方法有什么区别相同点： 同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。 而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。 一般情况下，如果此“目标”为this，同步方法和代码块没有太大的区别。 区别： 同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。 97. 静态内部类和内部类有什么区别静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。 静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。 实例化方式不同： 1) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象 2) 非静态内部类：通过外部类的对象实例生成内部类对象 98.反射的概念与作用反射的概念： 反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。 Java反射可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射. java反射使得我们可以在程序运行时动态加载一个类，动态获取类的基本信息和定义的方法,构造函数,域等。 除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获取类实例的域值。反射使java这种静态语言有了动态的特性。 反射的作用： 通过反射可以使程序代码访问装载到JVM 中的类的内部信息 1) 获取已装载类的属性信息 2) 获取已装载类的方法 3) 获取已装载类的构造方法信息 反射的优点： 增加程序的灵活性。 如struts中。请求的派发控制。 当请求来到时。struts通过查询配置文件。找到该请求对应的action。已经方法。 然后通过反射实例化action。并调用响应method。 如果不适用反射，那么你就只能写死到代码里了。 所以说，一个灵活，一个不灵活。 很少情况下是非用反射不可的。大多数情况下反射是为了提高程序的灵活性。因此一般框架中使用较多。因为框架要适用更多的情况。对灵活性要求较高。 99.Java程序的种类有（）(多选) A 类 (Class) B. Applet C. Application D. Servlet 答案：BCD分析：是Java中的类，不是程序；内嵌于Web文件中，由浏览器来观看的Applet；可独立运行的 Application；服务器端的 Servlet。 100. 下列标识符不合法的有（）(多选) A new B. $Usdollars C. 1234 D. car.taxi 答案：ACD分析：new是Java的关键字；C. 数字不能开头；D. 不能有“.”。 101. 不能用来修饰interface的有（）(多选) A private B. public C. protected D. static 答案：ACD分析：能够修饰interface的只有public、abstract以及默认的三种修饰符。 102. 下列说法错误的有（）(多选) A 在类方法中可用this来调用本类的类办法 B. 在类方法中调用本类的类方法时可以直接调用 C. 在类方法中只能调用本类中的类方法 D. 在类方法中绝对不能调用实例方法 答案：ACD分析：类方法是在类加载时被加载到方法区存储的，此时还没有创建对象，所以不能使用this或者super关键字；C. 在类方法中还可以调用其他类的类方法；D. 在类方法可以通过创建对象来调用实例方法。 103. 下列说法错误的有（）(多选) A Java面向对象语言容许单独的过栈与函数存在 B. Java面向对象语言容许单独的方法存在 C. Java语言中的方法属于类中的成员（member） D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同 答案：ABC分析：B. Java不允许单独的方法，过程或函数存在，需要隶属于某一类中；C. 静态方法属于类的成员，非静态方法属于对象的成员。 104. 下列说法错误的有（）(多选) A 能被java.exe成功运行的java class文件必须有main()方法 B. J2SDK就是Java API C. Appletviewer.exe可利用jar选项运行.jar文件 D. 能被Appletviewer成功运行的java class文件必须有main()方法 答案：BCD分析：B. J2SDK是sun公司编程工具，API是指的应用程序编程接口；C. Appletviewer.exe就是用来解释执行java applet应用程序的，一种执行HTML文件上的Java小程序类的Java浏览器；D. 能被Appletviewer成功运行的java class文件可以没有main（）方法。 105. 不通过 构造函数 也能创建对象么（） A 是 B. 否 答案：A分析：Java创建对象的几种方式：(1) 用new语句创建对象，这是最常见的创建对象的方法。(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。(3) 调用对象的clone()方法。(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。 106. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？答: 接口可以继承接口，抽象类可以实现接口，抽象类可以继承实体类。 107.写一个Java正则，能过滤出html中的&lt; a href=”url”&gt;title&lt; /a&gt;形式中的链接地址和标题. \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如[^xyz]可以匹配“plain”中的“p”。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 108. Class类的getDeclaredFields()方法与getFields()的区别？答:getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法 getFields(): 只能获取所有public声明的方法, 包括继承的方法 109. 在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？答:不正确。 通常情况下，进行比较判断的处理，switch 和if-else可以互相转换来写；if-else作用的范围比switch-case作用范围要大，但是当switch-case和if-else都可以用的情况下，通常推荐使用switch-case。 比如： 1234567891011121314151617181920switch (ch) &#123; case 'a': System.out.println("A"); break; case 'b': System.out.println("B"); break; case 'c': System.out.println("C"); break; case 'd': System.out.println("D"); break; case 'e': System.out.println("E"); break; default: System.out.println("other"); break;&#125; 换为if-else 12345678910111213if (ch == 'a') &#123; System.out.println("A");&#125; else if (ch == 'b') &#123; System.out.println('B');&#125; else if (ch == 'c') &#123; System.out.println("C");&#125; else if (ch == 'd') &#123; System.out.println("D");&#125; else if (ch == 'e') &#123; System.out.println("E");&#125; else &#123; System.out.println("Other");&#125; 110.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？final修饰基本类型变量，其值不能改变。 但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。 例如: 1234567class Test &#123; public static void main(String[] args) &#123; final Dog dog = new Dog("欧欧"); dog.name = "美美";//正确, 因为指向的堆内存中的对象的属性值仍旧可以改变 dog = new Dog("亚亚");//错误, 因为栈内存中的引用不能改变 &#125;&#125; 111. 请解释以下常用正则含义：\d, \D, \s, ., *, ?, |, [0-9]{6}, \d+\d: 匹配一个数字字符。等价于[0-9] \D: 匹配一个非数字字符。等价于[\^0-9] \s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v] . ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 *：匹配前面的子表达式*零次或多次。要匹配 字符，请使用 \。 +：匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 ?: 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 |:将两个匹配条件进行逻辑“或”（Or）运算 [0-9]{6}:匹配连续6个0-9之间的数字 \d+：匹配至少一个0-9之间的数字 {n,m}: m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 112 下面那些声明是合法的？（） A long l = 4990 B. int i = 4L C. float f = 1.1 D. double d = 34.4 答案：AD分析：B int属于整数型应该是int=4 C应该是float f=1.1f 113. 重载和重写区别重载： 方法重载（Overload）：一个类中有多个方法，名字必须相同，参数不同（如参数个数，种类，参数顺序不同），与返回值修饰符无关； 格式特点：1.方法名必须相同。2.方法的参数表必须不同如果参数个数不同，就不管它的参数类型了！如果参数个数相同，那么参数的类型必须不同。3.方法的返回类型、修饰符可以相同，也可不同。 重写： 方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同, 返回值和权限修饰符可相同可不相同 方法重写必须满足下列条件(1) 子类的方法名、参数列表必须和覆盖的方法完全一致(2) 子类的方法返回类型[层次]必须小于等于所覆盖的方法 (java 5或者以前，必须一样，java 7 java 8可以不同，但是必须是父类返回值的派生类。)(3) 子类的方法权限修饰符必须大于等于所覆盖的方法(4) 子类抛出的异常下不能超过父类相应方法抛出的异常(子类异常不能大于父类异常) 114. 下面哪个函数是public void example(){….}的重载函数？（） A private void example（int m）{…} B. public int example（）{…} C. public void example2（）{…} D. public int example（int m.float f）{…} 答案：AD分析：BC定义的是新函数,因为B中虽然方法名与题目中方法名相同,但参数表和题目中的参数表相同,不符合重载条件 例2下面哪几个函数是public void example（）{….}的重载函数（） A public void example（int m）{…} B. public int example（int m）{…} C. public void example2（）{…} D. public int example（int m，float f）{…} 答案：ABD 115. 打印结果：1234567891011121314151617public class Test&#123; public static void main(String args[])&#123; Test t=new Test(); int b = t.get(); System.out.println(b); &#125; public int get() &#123; try &#123; return 1; &#125;finally&#123; return 2; &#125; &#125;&#125;//结果: 2 116. .指出下列程序的运行结果1234567891011121314151617181920212223242526272829303132333435363738394041//例1: int i=9;switch (i) &#123; default: System.out.println("default"); case 0: System.out.println("zero"); break; case 1: System.out.println("one"); break; case 2: System.out.println("two"); break;&#125;//打印结果：defaultzero//例2:int i=9;switch (i) &#123; case 0: System.out.println("zero"); break; case 1: System.out.println("one"); break; case 2: System.out.println("two"); break; default: System.out.println("default");&#125;//打印结果:default //注意: '在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一'个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有' 117. 什么是编译型语言，什么是解释型语言？java可以归类到那种？计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。 翻译的方式有两种，一个是编译，一个是解释。 用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。 解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。 编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。 JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。 118. 下面代码执行后的输出是什么（）12345678910outer:for (int i = 0; i &lt; 3; i++) &#123; inner: for (int j = 0; j &lt; 2; j++) &#123; if (j == 1) &#123; continue outer; &#125; System.out.println(j + " and " + i); &#125;&#125; A 0 and 00 and 10 and 2 B. 1 and 01 and 11 and 2 C. 2 and 02 and 12 and 2 答案：A 119. 请问以下代码执行会打印出什么？1234567891011121314151617181920212223//父类：class FatherClass &#123; public FatherClass() &#123; System.out.println("FatherClassCreate"); &#125;&#125;//子类class ChildClass extends FatherClass &#123; public ChildClass() &#123; System.out.println("ChildClass Create"); &#125; public static void main(String[] args) &#123; FatherClass fc = new FatherClass(); //子类构造器第一行默认会有super();所以每次调用子类构造器,都会先执行父类构造器. ChildClass cc = new ChildClass(); &#125;//运行结果: FatherClassCreateFatherClassCreateChildClass Create 120. 如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？答：因为类A、B不是接口，所以是不可以直接实现的，但可以将A、B类定义成父子类，那么C类就能实现A、B类的功能了。假如A为B的父类，B为C的父类，此时C就能使用A、B的功能。 —–java中没有多继承但是有多重继承 121. 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？答：构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法 构造方法不能被继承 和 重写. 122.如何将字符串2013-02-18 10:53:10转换为日期类型且格式化为：2013-02-18 10:53:10？1234567891011121314151617public class Test &#123; public static void main(String[] args) throws ParseException &#123; //第一步：将字符串（2013-02-18 10:53:10）转换成日期Date DateFormat sdf=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String sdate="2013-02-18 10:53:10"; Date date=sdf.parse(sdate); System.out.println(date); //第二步：将日期Date转换成字符串String DateFormat sdf2=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String sdate2=sdf2.format(date); System.out.println(sdate2); &#125;&#125;//运行结果：Mon Feb 18 10:53:10 CST 20132013-02-18 10:53:10 123. 下面哪些是对称加密算法（） A. DES B. MD5 C. DSA D. RSA 答案：A分析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES常用的非对称加密算法有：RSA、DSA、ECC使用单向散列函数的加密算法：MD5、SHA 124. 以下Java代码段会产生几个对象1234567publicvoid test()&#123; String a="a"; String b="b"; String c="c"; c=a+""+b+""+c; System.out.print(c);&#125; 答案: 一个对象，因为编译期进行了优化，3个字符串常量直接折叠为一个 125.System.out.println(‘a’+1);的结果是分析：’a’是char型，1 是int行，int与char相加，char会被强转为int型，char的ASCII码对应的值是97，所以加一起打印98 126. 成员变量用static修饰和不用static修饰有什么区别？1、两个变量的生命周期不同。 成员变量随着对象的创建而存在，随着对象的被回收而释放。 静态变量随着类的加载而存在，随着类的消失而消失。 2、调用方式不同。 成员变量只能被对象调用。 静态变量用类名调用 ：Person.country 3、别名不同。 成员变量也称为实例变量。 静态变量称为类变量。 4、数据存储位置不同。 成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据. 静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据. 127. Java中关于super关键字的作用在子类继承父类中，一般有一行super的语句，需要记住三种使用方法： 1、super.变量/对象名；使用这种方法可以直接访问父类中的变量或对象，进行修改赋值等操作 2、super.方法名()；直接访问并调用父类中的方法 3、super();调用父类的初始化方法，其实就是调用父类中的public xxx()方法，通常第三种指代的是super()的省略写法，系统会默认添加此句。 特殊情况：如果父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数，即不能使用系统默认的“super()”，而需要显性写出super(xxx) 128. 如果变量用final修饰，则怎样？如果方法final修饰，则怎样？1、用final修饰的类不能被扩展，也就是说不可能有子类； 2、用final修饰的方法不能被替换或隐藏： ​ ① 使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）； ​ ② 使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏（hidden）； 3、用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同： ​ ① 静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始 化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化表达式完成； ​ ② 实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行； ​ ③ 方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体 （body）结束，在此期间其值不能改变； ​ ④ 构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化，为对应实参值，终止于构造器体结束，在此期间其值不能改变； ​ ⑤ 异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变； ​ ⑥ 局部变量在其值被访问之前必须被明确赋值； 129. Java反射技术主要实现类有哪些，作用分别是什么？在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中 1）Class类：代表一个类 2）Field 类：代表类的成员变量(属性) 3）Method类：代表类的成员方法 4）Constructor 类：代表类的构造方法 5）Array类：提供了动态创建数组，以及访问数组的元素的静态方法 Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类 Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的 结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口 方 法 示 例 对象名 .getClass() String str=”bdqn”;Class clazz = str.getClass(); 对象名 .getSuperClass() Student stu = new Student();Class c1 = stu.getClass();Class c2 = stu.getSuperClass(); Class.forName() Class clazz = Class.forName(“java.lang.Object”);Class.forName(“oracle.jdbc.driver.OracleDriver”); 类名.class 类名.classClass c2 = Student.class;Class c2 = int.class 包装类.TYPE 包装类.TYPEClass c2 = Boolean.TYPE; 131. 反射的使用场合和作用、及其优缺点1）使用场合 在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。 2）主要作用 通过反射可以使程序代码==访问装载到JVM 中的类的内部信息==，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息 3）反射的优点 反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它==允许程序创建和控制任何类的对象==，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的 4） Java反射技术应用领域很广，如软件测试等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术 5）反射的缺点 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。 使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码==更复杂。== 132.面向对象设计原则有哪些面向对象设计原则是面向对象设计的基石，面向对象设计质量的依据和保障，设计模式是面向对象设计原则的经典应用 1）单一职责原则SRP 2）开闭原则OCP 3）里氏替代原则LSP 4）依赖注入原则DIP 5）接口分离原则ISP 6）迪米特原则LOD 7）组合/聚合复用原则CARP 8）开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他设计原则都可以看作是开闭原则的实现手段或方法 133 接口和抽象类有什么区别？ 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。 构造函数：抽象类可以有构造函数；接口不能有。 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。 134 抽象类能使用 final 修饰吗？不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息： 135 普通类和抽象类有哪些区别？ 普通类不能包含抽象方法，抽象类可以包含抽象方法,也可以没有抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 136抽象类必须要有抽象方法吗？不需要，抽象类不一定非要有抽象方法。 示例代码： 12345abstract class Cat &#123; public static void sayHi() &#123; System. out. println("hi~"); &#125;&#125; 上面代码，抽象类并没有抽象方法但完全可以正常运行。 137 final 在 Java 中有什么作用？ final 修饰的类叫最终类，该类不能被继承。 final 修饰的方法不能被重写。 final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。 138 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？不对，两个对象的 hashCode() 相同，equals() 不一定 true。 代码示例： 1234String str1 = "通话";String str2 = "重地";System. out. println(String. format("str1：%d | str2：%d", str1. hashCode(),str2. hashCode()));System. out. println(str1. equals(str2)); 执行的结果： 12str1：1179395 | str2：1179395false 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 139 == 和 equals 的区别是什么？== 解读 对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 代码示例： 1234567String x = "string";String y = "string";String z = new String("string");System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true 代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。 equals 解读 equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat &#123;public Cat(String name) &#123; this.name = name; &#125; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;Cat c1 = new Cat("王磊");Cat c2 = new Cat("王磊");System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 原来 equals 本质上就是 ==。 那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： 123String s1 = new String("老王");String s2 = new String("老王");System.out.println(s1.equals(s2)); // true 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 140 JDK 和 JRE 有什么区别？Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序 JRE： Java Runtime Environment JDK：Java Development Kit JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。 JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。 如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。 JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本再说说java的跨平台吧:java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行 最后解释下机器码和字节码的区别:一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码 意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～ 二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～ 小结: JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的==开发环境和运行环境==。 JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的==运行==提供了所需==环境==。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。 141 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。 142 是否可以在static环境中访问非static变量？static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 143 .Java支持的数据类型有哪些？什么是自动拆装箱？Java语言支持的8种基本数据类型是： byte short int long float double boolean char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱 Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程 144 Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？—-68题Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对， 方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 145 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。 146 Java支持多继承么？Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的接口和抽象类的区别是什么？作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 147 接口和抽象类的区别是什么？Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。抽象类可以在不提供接口方法实现的情况下实现接口。Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。也可以参考JDK8中抽象类和接口的区别 148 什么是值传递和引用传递？值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递 二、String1. 下面程序的运行结果是（）（选择一项）123String str1="hello";String str2=new String("hello");System.out.println(str1==str2); A. true B. false C. hello D. he 答案：B分析：str1没有使用new关键字，在堆中没有开辟空间，其值”hello”在常量池中，str2使用new关键字创建了一个对象，在堆中开辟了空间，”==”比较的是对象的引用，即内存地址，所以str1与str2两个对象的内存地址是不相同的. 2. Java语言中，String类中的indexOf( )方法返回值的类型是（） A. int16 B. int32 C. int D. long 答案：C 3. 给定以下代码，程序的运行结果是 （）（选择一项）——&gt;易错题12345678910111213141516public class Example &#123; String str=new String("good"); char [] ch=&#123;'a','b','c'&#125;; public static void main(String[] args) &#123; Example ex=new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str+"and"); System.out.print(ex.ch); &#125; public void change(String str,char ch[])&#123; str="test ok"; ch[0]='g'; &#125;&#125; A. goodandabc B. goodandgbc C. test okandabc D. test okandgbc 答案：B分析：在方法调用时，在change方法中对str的值进行修改，是将str指向了常量池中的”test ok”，而主方法中的ex.str仍然指向的是常量池中的”good”。字符型数组在方法调用时，将主方法中ex.ch的引用传递给change方法中的ch，指向是堆中的同一堆空间，所以修改ch[0]的时候,ex.ch可以看到相同的修改后的结果。 4. 执行下列代码后，哪个结论是正确的（）（选择两项）String[] s=new String[10]; A. s[10]为”” B. s[9]为null C. s[0]为未定义 D. s.length为10 答案：BD分析：引用数据类型的默认值均为nulls.length数组的长度 5. 实现String类的replaceAll方法思路说明：replaceAll方法的本质是使用正则表达式进行匹配，最终调用的其实是Matcher对象的replaceAll方法。 1234567891011121314151617181920public class TestStringReplaceAll &#123; public static void main(String[] args) &#123; String str = "a1s2d3f4h5j6k7"; // 将字符串中的数字全部替换为0 System.out.println(replaceAll(str, "\\d", "0")); &#125;/** * @param str:源字符串 * @param regex:正则表达式 * @param newStr:替换后的子字符串 * @return 返回替换成功后的字符串 */ public static String replaceAll(String str, String regex, String newStr) &#123; Pattern pattern = Pattern.compile(regex); Matcher mathcer = pattern.matcher(str); String reslut = mathcer.replaceAll(newStr); return reslut; &#125;&#125; 6. 在“=”后填写适当的内容：123456789101112String []a=new String[10];则：a[0]~a[9]=null;a.length=10;如果是int[]a=new int[10];则：a[0]~a[9]= 0a.length= 10如果为 int b;则System.out.println(b); //编译不通过,提示变量b未初始化 7. 是否可以继承String类?答:不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。 public final class String implements java.io.Serializable, Comparable&lt; String&gt;, CharSequence 8. 给定两个字符串s和t， 写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。12345678910111213141516public class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length())//长度不相等,则一定不是重组词 return false; int bit[] = new int[26]; for(int i = 0;i &lt; s.length();i++)&#123; bit[s.charAt(i) - 'a']++; &#125; for(int i = 0;i &lt; s.length();i++)&#123; if(--bit[t.charAt(i) - 'a'] &lt; 0) return false; &#125; return true; &#125;&#125; 9. String s = new String(“abc”);创建了几个String对象。答: 两个或一个， ”abc”对应一个对象，这个对象放在字符串常量缓冲区，常量”abc”不管出现多少遍，都是缓冲区中的那一个。 new String每写一遍，就创建一个新的对象，它依据那个常量”abc”对象的内容来创建出一个新String对象。如果以前就用过’abc’，这句代表就不会创建”abc”自己了，直接从缓冲区拿。 10. 输出结果？1234567String str1="hello";String str2="he"+new String("llo");System.out.println(str1==str2);System.out.println(str1.equal(str2));//运行结果:falsetrue 11. 下面哪个是正确的（） A. String temp[ ] = new String{“a”,”b”,”c”}; B. String temp[ ] = {“a”,”b”,”c”}; C. String temp= {“a”,”b”,”c”}; D. String[ ] temp = {“a”,”b”,”c”}; 答案：BDnew 对象时是圆括号()给数组赋值用花括号,给变量赋值不能用花括号 12. 已知如下代码：执行结果是什么（）12345678910111213public class Test &#123; public static void main(String[] args) &#123; String s1 = new String("Hello"); String s2 = new String("Hello"); System.out.print(s1 == s2); String s3 = "Hello"; String s4 = "Hello"; System.out.print(s3 == s4); s1 = s3; s2 = s4; System.out.print(s1 == s2); &#125;&#125; A. false true true B. true false true C. true true false D. true true false 答案：A 13. 字符串如何转换为int类型1234567891011121314public class Test &#123; public static void main(String[] args) &#123; //方式一 int num=Integer.parseInt("123"); //方式二 Integer in = new Integer("123"); int a = in.intValue(); System.out.println(a); //方式三 int num2=Integer.valueOf("123"); System.out.println(num+" "+num2); &#125;&#125; 14. 写一个方法，实现字符串的反转，如：输入abc，输出cba123456789101112131415public class Test &#123; public static void main(String[] args) &#123; String result=reverse("abc"); System.out.println(result); &#125; public static String reverse(String str)&#123; StringBuilder result = new StringBuilder(""); char[] chArra = str.toCharArray();//字符串转换为字符数组 for(int i = chArra.length-1;i &gt;= 0;i--)&#123;//从后往前取值 char ch = chArra[i]; result.append(ch);//连接取出的字符 &#125; return result.toString();//字符数组转换为字符串 &#125;&#125; 15. 编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”123456789//使用字符串的replaceAll方法public classDemo1 &#123; public static void main(String[] args) &#123; String s="I follow Bill Gate.Tom Gate.John Gate"; System.out.println(s); s=s.replaceAll("Gate","Gates"); System.out.println(s); &#125;&#125; 16. String 是最基本的数据类型吗?答： 不是 。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）—-&gt;(如类(例如String),数组,枚举,接口)。 17. String 和StringBuilder、StringBuffer 的区别?答： Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder 相同点： 它们都可以储存和操作字符串，同时三者都使用final修饰，都属于终结类不能派生子类，操作的相关方法也类似例如获取字符串长度等； 不同点： 其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的，而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改，在修改的同时地址值不会发生改变。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。 在此重点说明一下，String、StringBuffer、StringBuilder三者类型不一样，无法使用equals()方法比较其字符串内容是否一样！ 补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。 补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。 123456789101112131415161718public class smallT &#123; public static void main(String[] args) &#123; String a = "Programming"; String b = new String("Programming"); String c = "Program" + "ming"; System.out.println(a == b); System.out.println(a == c); System.out.println(a.equals(b)); System.out.println(a.equals(c)); System.out.println(a.intern() == b.intern()); &#125;&#125;//运行结果falsetruetruetruetrue 解析： String类存在intern()方法，含义如下：返回字符串对象的规范化表示形式.它遵循以下规则:对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。 字符串比较分为两种形式: 一种使用比较运算符”==”比较，他们比较的是各自的字符串在内存当中的地址值是否相同；另一种是使用equals()方法进行比较，比较的是两个字符串的内容是否相同(前提是该类重写了equals方法,否则equals方法还是比较的是地址)！ 18. String类为什么是final的答：1） 为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。 2）为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性，如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点。 19. String s=”Hello”;s=s+”world!”;执行后，是否是对前面s指向空间内容的修改？答：不是对前面s指向空间内容的直接修改。 因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。 通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。 同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。 例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做： 12345678public class Demo &#123; private String s; ... public Demo &#123; s = "Initial Value"; &#125; ...&#125; 而非 s = new String(“Initial Value”); 后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。 至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。 20. 下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;答：对于如下代码： String s1 = “a”; String s2 = s1 + “b”; String s3 = “a” + “b”; System.out.println(s2 == “ab”); System.out.println(s3 == “ab”); 第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 题目中的第一行代码被编译器在编译时优化后，相当于直接定义一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。 写如下两行代码: String s = “a” + “b” + “c” + “d”; System.out.println(s == “abcd”); 最终打印的结果应该为true。 21. String 类的常用方法都有那些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 22. 如何将字符串反转？使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 示例代码： 12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append("abcdefg");System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append("abcdefg");System. out. println(stringBuilder. reverse()); // gfedcba 23. String str=”i”与 String str=new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。 24. Java 中操作字符串都有哪些类？它们之间有什么区别？操作字符串的类有：String、StringBuffer、StringBuilder。 String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。 StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。 25. String 属于基础的数据类型吗？String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。 三、集合1. Java集合体系结构（List、Set、Collection、Map的区别和联系） 1、Collection 接口存储一组不唯一，无序的对象 2、List 接口存储一组不唯一，有序（插入顺序）的对象 3、Set 接口存储一组唯一，无序的对象 4、Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set） 2. Vector和ArrayList的区别和联系 线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。 性能：ArrayList 在性能方面要优于 Vector。 扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。 相同点： 1）实现原理相同—底层都使用数组 2）功能相同—实现增删改查等操作的方法相似 3）都是长度可变的数组结构，很多情况下可以互用 不同点： 1）Vector是早期JDK版本提供，ArrayList是新版本替代Vector的 2）Vector线程安全，ArrayList重速度轻安全，线程非安全长度需增长时，Vector默认增长一倍，ArrayList增长50% 3. ArrayList和LinkedList的区别和联系相同点： 两者都实现了List接口，都具有List中元素有序、不唯一的特点。 不同点： ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高； LinkedList采用链表存储方式。插入、删除元素时效率比较高 4. Array 和 ArrayList 有何区别？ Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。 Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。 Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。 5. HashSet的使用和原理（hashCode()和equals()）1）哈希表的查询速度特别快，时间复杂度为O（1）。 2）HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。 3）系统类已经覆盖了hashCode方法, 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。 4）向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。 5）在哈希表中判断两个元素是否重复要使用到hashCode()和equals()。hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。 6） Y=K(X) ：K是函数，X是哈希码，Y是地址 6. TreeSet的原理和使用（Comparable和comparator）1）TreeSet集合，元素不允许重复且有序(自然顺序) 2）TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。 3）可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。 4）可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。 7. 集合和数组的比较（为什么引入集合）数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合。具体如下： 1）数组的效率高于集合类. 2）数组能存放基本数据类型和对象，而集合类中只能放对象。 3）数组容量固定且无法动态改变，集合类容量动态改变。 4）数组无法判断其中实际存有多少元素，length只告诉了array的容量。 5）集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。 6）集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。 8. Collection和Collections的区别1）Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。 2）Java中还有一个Collections类，专门用来操作集合类 ，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 9. 下列说法正确的有（）（选择一项） A. LinkedList继承自List B. AbstractSet继承自Set C. HashSet继承自AbstractSet D. TreeMap继承自HashMap 答案： C分析：A：LinkedList实现List接口B：AbstractSet实现Set接口D：TreeMap继承AbstractMap 10. Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？答：HashMap与Hashtable实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用 两者的主要区别如下 1、Hashtable是早期JDK提供的接口，HashMap是新版JDK提供的接口 2、Hashtable继承Dictionary类，HashMap实现Map接口 3、Hashtable线程安全，HashMap线程非安全 4、Hashtable不允许null值，HashMap允许null值 HashSet与HashMap的区别 1、HashSet底层是采用HashMap实现的。HashSet 的实现比较简单，HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。 2、HashMap的key就是放进HashSet中对象，value是Object类型的。 3、当调用HashSet的add方法时，实际上是向HashMap中增加了一行(key-value对)，该行的key就是向HashSet增加的那个对象，该行的value就是一个Object类型的常量 11. 列出Java中的集合类层次结构？答:Java中集合主要分为两种：Collection和Map。Collection是List和Set接口的父接口；ArrayList和LinkedList是List的实现类；HashSet 和TreeSet是Set的实现类；LinkedHashSet是HashSet的子类。HashMap和TreeMap是Map的实现类；LinkedHashMap是HashMap的子类。 图中：虚线框中为接口，实线框中为类。 12. List，Set，Map各有什么特点答:List 接口存储一组可重复，有序（插入顺序）的对象。 Set 接口存储一组不可重复，无序的对象。 Map接口存储一组键值对象，提供key到value的映射。key无序，不可重复。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set） 13.合并两个有序的链表123456789101112131415161718192021222324public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null || l2 == null) &#123; return l1 != null ? l1 : l2; &#125; ListNode head = l1.val &lt; l2.val ? l1 : l2; ListNode other = l1.val &gt;= l2.val ? l1 : l2; ListNode prevHead = head; ListNode prevOther = other; while (prevHead != null) &#123; ListNode next = prevHead.next; if (next != null &amp;&amp; next.val &gt; prevOther.val) &#123; prevHead.next = prevOther; prevOther = next; &#125; if(prevHead.next==null)&#123; prevHead.next=prevOther; break; &#125; prevHead=prevHead.next; &#125; return head; &#125;&#125; 14. 用递归方式实现链表的转置。123456789101112131415161718192021222324/**Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;* &#125;*/public class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null) &#123;//递归结束条件 return head; &#125; ListNode prev = reverseList(head.next); head.next.next = head; head.next = null; return prev; &#125;&#125; 15. 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets (int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); if(nums.length == 0 || nums == null) return res; Arrays.sort(nums); //排序 dfs(nums, 0, item, res); //递归调用 res.add(new ArrayList&lt;Integer&gt;()); //最后加上一个空集 return res; &#125; public static void dfs(int[] nums, int start, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res)&#123; for(int i = start; i &lt; nums.length; i ++)&#123; item.add(nums[i]); //item是以整数为元素的动态数组，而res是以数组为元素的数组，在这一步，当item增加完元素后，item // 所有元素构成一个完整的子串，再由res纳入 res.add(new ArrayList&lt;Integer&gt;(item)); dfs(nums, i + 1, item, res); item.remove(item.size() - 1); &#125; &#125;&#125; 16. Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？答：1. Map的实现类有HashMap,LinkedHashMap,TreeMap \2. HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序(即插入有序)；TreeMap默认是自然升序(即自然有序)） \3. LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序 \4. TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性 \5. LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表 17. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？1234567891011121314151617public class Stack &#123; LinkedList list = new LinkedList(); public synchronized void push(Object x) &#123; synchronized (list) &#123; list.addLast(x); notify(); &#125; &#125; public synchronized Object pop() throws Exception&#123; synchronized(list)&#123; if(list.size()&lt;=0)&#123; wait(); &#125; return list.removeLast( ); &#125; &#125;&#125; 答：将if( list.size() &lt;= 0 )改成：while( list.size() &lt;= 0 ) 18. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？答： TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小。 TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。 Collections 工具类的sort方法有两种重载的形式: 第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较； 第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。 19. Java.util.Map的实现类有分析：Java中的java.util.Map的实现类 1、HashMap 2、Hashtable 3、LinkedHashMap 4、TreeMap 20. List里面如何剔除相同的对象？请简单用代码实现一种方法12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; li1 = new ArrayList&lt;String&gt;(); li1.add("8"); li1.add("8"); li1.add("9"); li1.add("9"); li1.add("0"); System.out.println(li1); //方法:将List中数据取出来来存到Set中 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); for(int i = 0;i &lt; li1.size();i++)&#123; set.add(li1.get(i)); &#125; System.out.println(set); &#125;&#125; 21. List、Set、Map 是否继承自Collection 接口？答：List、Set 的父接口是Collection，Map 不是其子接口，而是与Collection接口是平行关系，互不包含。 Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 22. 说出ArrayList、Vector、LinkedList 的存储性能和特性？答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢， Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差， 而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快,查询较慢。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖） 。同理，Stack类继承Vector也是不正确的。 23. List、Map、Set 三个接口，存取元素时，各有什么特点？答：List以特定索引来存取元素，可有重复元素。 Set不能存放重复元素（用对象的equals()方法来区分元素是否重复） 。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 24. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。 TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。 Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型 （需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用。 例子1： Student.java 1234567891011121314151617181920212223public class Student implements Comparable&lt;Student&gt; &#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125; //@Override //public int compareTo(Student o) &#123; // return this.age - o.age; // 比较年龄(年龄的升序) //&#125; @Override public int compareTo(Student o) &#123; return -(this.age - o.age); // 比较年龄(年龄的降序) &#125; &#125; Test01.java 1234567891011121314151617class Test01 &#123; public static void main(String[] args) &#123; Set&lt;Student&gt; set = new TreeSet&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) set.add(new Student("Hao LUO", 33)); set.add(new Student("XJ WANG", 32)); set.add(new Student("Bruce LEE", 60)); set.add(new Student("Bob YANG", 22)); for(Student stu : set) &#123; System.out.println(stu); &#125; // 输出结果: // Student [name=Bob YANG, age=22] // Student [name=XJ WANG, age=32] // Student [name=Hao LUO, age=33] // Student [name=Bruce LEE, age=60] &#125;&#125; 例子2： Student.java 123456789101112131415161718192021222324public class Student &#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; /** * 获取学生姓名 */ public String getName() &#123; return name; &#125; /** * 获取学生年龄 */ public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125;&#125; Test02.java 1234567891011121314151617181920212223242526272829303132333435363738class Test02 &#123; public static void main(String[] args) &#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) list.add(new Student("Hao LUO", 33)); list.add(new Student("XJ WANG", 32)); list.add(new Student("Bruce LEE", 60)); list.add(new Student("Bob YANG", 22)); // 通过sort方法的第二个参数传入一个Comparator接口对象 // 相当于是传入一个比较对象大小的算法到sort方法中 // 由于Java中没有函数指针、仿函数、委托这样的概念 // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 Collections.sort(list, new Comparator&lt;Student&gt; () &#123; @Override public int compare(Student o1, Student o2) &#123; // TODO 自动生成的方法存根 if(o1 instanceof Student &amp;&amp; o2 instanceof Student) &#123; Student c1 = (Student) o1; Student c2 = (Student) o2; // return c1.getId().compareTo(c2.getId()); int i = c1.getAge().compareTo(c2.getAge()); if (i == 0) &#123;//如果两个对象的ID相同， return c1.getName().compareTo(c2.getName());//就接着比较姓名 &#125; return i; //如果id不同 &#125; return 0; &#125; &#125;); for(Student stu : list) &#123; System.out.println(stu); &#125; &#125;&#125; 25. HashMap和Hashtable的区别和联相同点： 实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用 不同点： 1、Hashtable是早期提供的接口，HashMap是新版JDK提供的接口 2、Hashtable继承Dictionary类，HashMap实现Map接口 3、Hashtable线程安全，HashMap线程非安全 4、Hashtable不允许null值，HashMap允许null值 26. 如何实现数组和 List 之间的转换？ 数组转 List：使用 Arrays. asList(array) 进行转换。 List 转数组：使用 List 自带的 toArray() 方法。 12345678// list to arrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list. add("王磊");list. add("的博客");list. toArray();// array to listString[] array = new String[]&#123;"王磊","的博客"&#125;;Arrays. asList(array); 27. 说一下 HashSet 的实现原理？HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。 28. 说一下 HashMap 的实现原理？HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。 29如何决定使用 HashMap 还是 TreeMap？对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。 30 HashMap 和 Hashtable 有什么区别？ 存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。 线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。 推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代 31. List、Set、Map 之间的区别是什么？List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。 三者之间的区别，如下表： 32. Collection 和 Collections 有什么区别？ Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。 Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。 33. Java 容器都有哪些？Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示： Collection List ArrayList LinkedList Vector Stack Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable 34Java集合类框架的基本接口有哪些？集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。 35 为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 36 什么是迭代器(Iterator)？Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的 迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的 remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 37 Iterator和ListIterator的区别是什么？下面列出了他们的区别：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 38. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？一：快速失败（fail—fast） ​ 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。 ​ 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 ​ 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 ​ 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 ​ 二：安全失败（fail—safe） ​ 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 ​ 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 ​ 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 ​ 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 39. Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 四、多线程4.1 下面程序的运行结果（）（选择一项）123456789101112public static void main(String[] args) &#123; Thread t=new Thread()&#123; public void run()&#123; pong(); &#125; &#125;; t.run(); System.out.println("ping");&#125;static void pong()&#123; System.out.println("pong");&#125; A. pingpong B. pongping C. pingpong和pongping都有可能 D. 都不输出 答案：B 补充: 1） start方法： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 2） run（）： run()方法只是类的一个普通方法而已，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待，run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。 总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run( )方法中，start( )方法启动线程将自动调用 run( )方法，这是由jvm的内存机制规定的。并且run( )方法必须是public访问权限，返回值类型为void。 4.2 下列哪个方法可用于创建一个可运行的类（） A. public class X implements Runnable{public void run() {……}} B. public class X extends Thread{public void run() {……}} C. public class X extends Thread{public int run() {……}} D. public class X implements Runnable{protected void run() {……}} 答案：AB分析： 继承Thread和实现Runable接口 4.3 说说乐观锁与悲观锁答：悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block阻塞,直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。 4.4 在Java中怎么实现多线程?描述线程状态的变化过程。答：当多个线程访问同一个数据时，容易出现线程安全问题，需要某种方式来确保资源在某一时刻只被一个线程使用。需要让线程同步，保证数据安全线程同步的实现方案： 同步代码块和同步方法，均需要使用synchronized关键字 同步代码块：public void makeWithdrawal(int amt) { synchronized (acct) { } } 同步方法：public synchronized void makeWithdrawal(int amt) { } 线程同步的好处：解决了线程安全问题 线程同步的缺点：性能下降，可能会带来死锁 4.5 请写出多线程代码使用Thread或者Runnable，并说出两种的区别。方式1：继承Java.lang.Thread类，并覆盖run() 方法。优势：编写简单；劣势：无法继承其它父类 12345678910111213141516public class ThreadDemo1 &#123; public static void main(String args[]) &#123; MyThread1 t = new MyThread1(); t.start(); while (true) &#123; System.out.println("兔子领先了，别骄傲"); &#125; &#125;&#125;class MyThread1 extends Thread &#123; public void run() &#123; while (true) &#123; System.out.println("乌龟领先了，加油"); &#125; &#125;&#125; 方式2：实现Java.lang.Runnable接口，并实现run()方法。优势：可继承其它类，多线程可共享同一个Thread对象；劣势：编程方式稍微复杂，如需访问当前线程，需调用Thread.currentThread()方法 1234567891011121314151617public class ThreadDemo2 &#123; public static void main(String args[]) &#123; MyThread2 mt = new MyThread2(); Thread t = new Thread(mt); t.start(); while (true) &#123; System.out.println("兔子领先了，加油"); &#125; &#125;&#125;class MyThread2 implements Runnable &#123; public void run() &#123; while (true) &#123; System.out.println("乌龟超过了，再接再厉"); &#125; &#125;&#125; 4.6 在多线程编程里，wait方法的调用方式是怎样的？答:wait方法是线程通信的方法之一，必须用在 synchronized方法或者synchronized代码块中，否则会抛出异常，这就涉及到一个“锁”的概念，而wait方法必须使用上锁的对象来调用，从而持有该对象的锁进入线程等待状态，直到使用该上锁的对象调用notify或者notifyAll方法来唤醒之前进入等待的线程，以释放持有的锁。 4.7 Java线程的几种状态答:线程是一个动态执行的过程，它有一个从产生到死亡的过程，共五种状态： ①: 新建（new Thread） 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动） 例如：Thread t1=new Thread(); ②: 就绪（runnable） 线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start(); ③: 运行（running） 线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。 ④: 死亡（dead） 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 ⑤: 堵塞（blocked） 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。（调用motify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） 4.8 在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（） A. sleep() B. Suspend() C. wait() D. yield() 答案：D分析：yield会是线程进入就绪状态 4.9 volatile关键字是否能保证线程安全？答:不能。虽然volatile提供了同步的机制，但是只是一种弱的同步机制，如需要强线程安全，还需要使用synchronized。 Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 一、volatile的内存语义是： 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新到主内存中。 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量。 二、volatile底层的实现机制 如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 1 、重排序时不能把后面的指令重排序到内存屏障之前的位置 2、使得本CPU的Cache写入内存 3、写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 4.10 请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？(1) 继承Thread类 123456789public class java_thread extends Thread&#123; public static void main(String args[]) &#123; new java_thread().run(); System.out.println("main thread run "); &#125; public synchronized void run() &#123; System.out.println("sub thread run "); &#125;&#125; (2) 实现Runnable接口 123456789public class java_thread implements Runnable&#123; public static void main(String args[]) &#123; new Thread(new java_thread()).start(); System.out.println("main thread run "); &#125; public void run() &#123; System.out.println("sub thread run "); &#125;&#125; 在Executor框架下，利用Executors的静态方法可以创建三种类型的常用线程池： 1）FixedThreadPool这个线程池可以创建固定线程数的线程池。 2）SingleThreadExecutor是使用单个worker线程的Executor。 3）CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。 4.11 关于sleep()和wait()，以下描述错误的一项是（） A. sleep是线程类（Thread）的方法，wait是Object类的方法 B. Sleep不释放对象锁，wait放弃对象锁 C. Sleep暂停线程、但监控状态任然保持，结束后会自动恢复 D. Wait后进入等待锁定池，只针对此对象发出notify方法后获取对象锁进入运行状态。 答案：D分析：针对此对象的notify方法后获取对象锁并进入就绪状态，而不是运行状态。另外针对此对象的notifyAll方法后也可能获取对象锁并进入就绪状态，而不是运行状态 4.12 进程和线程的区别是什么？进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 区别 进程 线程 根本区别 系统进行资源分配的单位 是CPU调度和执行的单位 开销 每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。 线程可以看成时轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。 分配内存 系统在运行的时候会为每个进程分配不同的内存区域 除了CPU之外，不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源 包含关系 没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。 4.13 以下锁机机制中，不能保证线程安全的是（） A. Lock B. Synchronized C. Volatile 答案：C 4.14 创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。答：用一个for循环创建线程对象，同时调用wait()方法，让所有线程等待；直到最后一个线程也准备就绪后，调用notifyAll(), 同时启动所有线程。 比如：给你n个赛车，让他们都在起跑线上就绪后，同时出发，Java多线程如何写代码？ 思路是，来一辆赛车就加上一把锁，并修改对应的操作数，如果没有全部就绪就等待，并释放锁，直到最后一辆赛车到场后唤醒所有的赛车线程。代码参考如下： 123456public class CarCompetion &#123; // 参赛赛车的数量 protected final int totalCarNum = 10; // 当前在起跑线的赛车数量 protected int nowCarNum = 0;&#125; 1234567891011121314151617181920212223242526272829303132public class Car implements Runnable&#123; private int carNum; private CarCompetion competion = null; public Car(int carNum, CarCompetion competion) &#123; this.carNum = carNum; this.competion = competion; &#125; @Override public void run() &#123; synchronized (competion) &#123; competion.nowCarNum++; while (competion.nowCarNum &lt; competion.totalCarNum) &#123; try &#123; competion.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; competion.notifyAll(); &#125; startCar(); &#125; private void startCar() &#123; System.out.println("Car num " + this.carNum + " start to run."); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Car num " + this.carNum + " get to the finish line."); &#125;&#125; 12345678public static void main(String[] args) &#123; CarCompetion carCompetion = new CarCompetion(); final ExecutorService carPool = Executors.newFixedThreadPool(carCompetion.totalCarNum); for (int i = 0; i &lt; carCompetion.totalCarNum; i++) &#123; carPool.execute(new Car(i, carCompetion)); &#125; 4.15 同步和异步有何异同，在什么情况下分别使用它们？答：1.如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 2.当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 3.举个例子: 打电话是同步 发消息是异步 4.16 Java线程中，sleep()和wait()区别答：sleep是线程类(Thread)的静态方法；作用是导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复；调用sleep()不会释放对象锁。 wait是Object类的方法；对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池队列。只有针对此对象发出notify方法(或notifyAll)后本线程才进入对象锁定池，准备获得对象锁后进入就绪状态。 4.17 sleep()和yield()有什么区别?答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； ② 运行态的线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； ④ sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。 4.18 下面所述步骤中，是创建进程做必须的步骤是（） A. 由调度程序为进程分配CPU B. 建立一个进程控制块 C. 为进程分配内存 D. 为进程分配文件描述符 答案：BC 4.19 无锁化编程有哪些常见方法？（） A. 针对计数器，可以使用原子加 B. 只有一个生产者和一个消费者，那么就可以做到免锁访问环形缓冲区（Ring Buffer） C. RCU（Read-Copy-Update），新旧副本切换机制，对于旧副本可以采用延迟释放的做法 D. CAS（Compare-and-Swap），如无锁栈，无锁队列等待 答案：D分析：A 这方法虽然不太好，但是常见B ProducerConsumerQueue就是这个，到处都是C linux kernel里面大量使用D 本质上其实就是乐观锁，操作起来很困难。。单生产者多消费者或者多生产者单消费者的情况下比较常见，也不容易遇到ABA问题。 4.20 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。 只有等待当前线程执行完毕释放锁资源之后，其他线程才有可能进行执行该同步方法！ 延伸: 对象锁分为三种：共享资源、this、当前类的字节码文件对象 4.21 请说出与线程同步相关的方法。答：\1. wait():使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； \2. sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常； \3. notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，**而且与优先级无关； \4. notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争； \5. JDK 1.5通过Lock接口提供了显式(explicit)的锁机制，增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁(unlock())的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象； \6. JDK 1.5还提供了信号量(semaphore)机制，信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。 下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。 银行账户类： 1234567891011121314151617181920212223242526272829package com.bjsxt;/** * 银行账户 * @author sxt * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 存钱线程类： 1234567891011121314151617181920package com.bjsxt;/** * 存钱线程 * @author sxt李端阳 * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; account.deposit(money); &#125; &#125; 测试类： 12345678910111213141516package com.bjsxt;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test01 &#123; public static void main(String[] args) &#123; Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) &#123; service.execute(new AddMoneyThread(account, 1)); &#125; service.shutdown(); while(!service.isTerminated()) &#123;&#125; System.out.println("账户余额: " + account.getBalance()); &#125;&#125; 在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： \1. 在银行账户的存款（deposit）方法上同步（synchronized）关键字 1234567891011121314151617181920212223242526272829package com.bjsxt;/** * 银行账户 * @author SXT李端阳*/public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public synchronized void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 在线程调用存款方法时对银行账户进行同步 123456789101112131415161718192021package com.bjsxt;/** * 存钱线程 * @author SXT * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; synchronized (account) &#123; account.deposit(money); &#125; &#125;&#125; 通过JDK 1.5显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 123456789101112131415161718192021222324252627282930313233343536373839404142package com.bjsxt;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 银行账户 * * @author SXT李端阳 * */public class Account &#123; private Lock accountLock = new ReentrantLock(); private double balance; // 账户余额 /** * 存款 * * @param money * 存入金额 */ public void deposit(double money) &#123; accountLock.lock(); try &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; finally &#123; accountLock.unlock(); &#125; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。 4.22 编写多线程程序有几种实现方式？答：Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，同时也可以实现资源共享，显然使用Runnable接口更为灵活。 补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.bjsxt;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;class MyTask implements Callable&lt;Integer&gt; &#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125;&#125;public class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integer&gt; future : list) &#123; while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125;&#125; 4.23 synchronized关键字的用法？答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。 4.24 启动一个线程是用run()还是start()方法?答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 API解释如下： 4.25 什么是线程池（thread pool）？答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 有通过Executors工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。 4.26 线程的基本状态以及状态之间的关系？ 除去起始（new）状态和结束（finished）状态，线程有三种状态: 分别是：就绪（ready）、运行（running）和阻塞（blocked）。 其中就绪状态代表线程具备了运行的所有条件，只等待CPU调度（万事俱备，只欠东风）； 处于运行状态的线程可能因为CPU调度（时间片用完了）的原因回到就绪状态，也有可能因为调用了线程的yield方法回到就绪状态，此时线程不会释放它占有的资源的锁，坐等CPU以继续执行；运行状态的线程可能因为I/O中断、线程休眠、调用了对象的wait方法而进入阻塞状态（有的地方也称之为等待状态）； 而进入阻塞状态的线程会因为休眠结束、调用了对象的notify方法或notifyAll方法或其他线程执行结束而进入就绪状态。注意：调用wait方法会让线程进入等待池中等待被唤醒，notify方法或notifyAll方法会让等待锁中的线程从等待池进入等锁池，在没有得到对象的锁之前，线程仍然无法获得CPU的调度和执行。 4.27 简述synchronized 和java.util.concurrent.locks.Lock的异同？答：Lock是Java 5以后引入的新的API，和关键字synchronized相比 主要相同点： Lock 能完成synchronized所实现的所有功能； 主要不同点： Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally 块中释放（这是释放外部资源的最好的地方）。 4.28 创建线程的两种方式分别是什么,优缺点是什么？方式1：继承Java.lang.Thread类，并覆盖run() 方法。 优势：编写简单； 劣势：单继承的限制—-无法继承其它父类，同时不能实现资源共享。 123456789101112131415161718package com.bjsxt;public class ThreadDemo1 &#123; public static void main(String args[]) &#123; MyThread1 t = new MyThread1(); t.start(); while (true) &#123; System.out.println("兔子领先了，别骄傲"); &#125; &#125;&#125;class MyThread1 extends Thread &#123; public void run() &#123; while (true) &#123; System.out.println("乌龟领先了，加油"); &#125; &#125;&#125; 方式2：实现Java.lang.Runnable接口，并实现run()方法。 优势：可继承其它类，多线程可共享同一个Thread对象； 劣势：编程方式稍微复杂，如需访问当前线程，需调用Thread.currentThread()方法 12345678910111213141516171819package com.bjsxt;public class ThreadDemo2 &#123; public static void main(String args[]) &#123; MyThread2 mt = new MyThread2(); Thread t = new Thread(mt); t.start(); while (true) &#123; System.out.println("兔子领先了，加油"); &#125; &#125;&#125;class MyThread2 implements Runnable &#123; public void run() &#123; while (true) &#123; System.out.println("乌龟超过了，再接再厉"); &#125; &#125;&#125; 4.29 Java创建线程后，调用start( )方法和run( )的区别两种方法的区别 1） start方法： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 2） run（）： run()方法只是类的一个普通方法而已，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待，run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。 总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run( )方法中，start( )方法启动线程将自动调用 run( )方法，这是由jvm的内存机制规定的。并且run( )方法必须是public访问权限，返回值类型为void。 两种方式的比较 ： 实际中往往采用实现Runable接口，一方面因为java只支持单继承，继承了Thread类就无法再继续继承其它类，而且Runable接口只有一个run方法；另一方面通过结果可以看出实现Runable接口才是真正的多线程。 4.30 线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 生命周期的五种状态: 新建（new Thread） 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动） 例如：Thread t1=new Thread(); 就绪（runnable） 线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start(); 运行（running） 线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。 死亡（dead） 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 堵塞（blocked） 由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t)方法. 不释放锁 ,使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。释放锁（调用notify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） 4.31 如何实现线程同步？当多个线程访问同一个数据时，容易出现线程安全问题，需要某种方式来确保资源在某一时刻只被一个线程使用。需要让线程同步，保证数据安全 线程同步的实现方案： 1）同步代码块，使用synchronized关键字 同步代码块： 123synchronized (同步锁) &#123; 授课代码;&#125; 同步方法：synchronized关键字标记在方法的返回值之前 123public synchronized void makeWithdrawal(int amt) &#123;&#125; 线程同步的好处：解决了线程安全问题 线程同步的缺点：性能下降，可能会带来死锁 注意： 同步代码块，所使用的同步锁可以是三种， 1、this 2、 共享资源 3、 字节码文件对象 同步方法所使用的同步锁，默认的是this 4.32 说说关于同步锁的更多细节答：Java中每个对象都有一个内置锁。 同步: 一个访问完后,下一个访问, 不存在同时的并发访问.—-&gt;也就是顺序访问,串行访问 当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。 当程序运行到synchronized同步方法或代码块时该对象锁才起作用。 一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。 释放锁是指持锁线程退出了synchronized同步方法或代码块。 关于锁和同步，有以下几个要点： 1）只能同步方法或同步一部分代码即同步代码块，而不能同步变量和类； 2）每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？ 3）不必同步类中所有的方法，类可以同时拥有同步和非同步方法。 4）如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。 5）如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。 6）线程睡眠(调用sleep方法)时，它所持的任何锁都不会释放。 7）线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。 8）同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步一个方法中的一部分代码块。 9）在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。 4.33 Java中实现线程通信的三个方法的作用是什么？Java提供了3个方法(wait,notify,notifyall)解决线程之间的通信问题，均是java.lang.Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常。 方法名 作 用 final void wait() 表示线程一直等待，直到其它线程通知唤醒它 void wait(long timeout) 线程等待指定毫秒参数的时间 final void wait(long timeout,int nanos) 线程等待指定毫秒、微妙的时间 final void notify() 唤醒一个处于等待状态的线程。注意的是: 在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 final void notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，注意: 并不是给所有唤醒线程一个对象的锁，而是让它们竞争. 4.44 进程和线程的区别是什么？进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。 线程与进程的区别归纳： a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 c.调度和切换：线程上下文切换比进程上下文切换要快得多。 d.在多线程OS中，进程不是一个可执行的实体。 4.45 创建线程有几种不同的方式？你喜欢哪一种？为什么？有4种方式可以用来创建线程： 继承Thread类 实现Runnable接口 应用程序可以使用Executor框架来创建线程池 实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 还有一种方式是实现Callable接口 4.46 同步方法和同步代码块的区别是什么？区别： 同步方法默认用this或者当前类class对象作为锁； 同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法； 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰； 4.47 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 4.48什么是死锁(deadlock)？所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件： 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。 4.49 如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 五、IO流5.1 说说BIO、NIO和AIO的区别Java AIO： 异步 非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。——————-&gt;爱亦菲 Java BIO： 同步 并 阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。————–&gt;不同祖 Java NIO： 同步 非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。—————&gt; 辣痛扉 NIO比BIO的改善之处是把一些无效的连接挡在了启动线程之前，减少了这部分资源的浪费（因为我们都知道每创建一个线程，就要为这个线程分配一定的内存空间） AIO比NIO的进一步改善之处是将一些暂时可能无效的请求挡在了启动线程之前，比如在NIO的处理方式中，当一个请求来的话，开启线程进行处理，但这个请求所需要的资源还没有就绪，此时必须等待后端的应用资源，这时线程就被阻塞了。 适用场景分析： AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持，在成长中，Netty曾经使用过，后来放弃。 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解，如之前在Apache中使用。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持，如在 Nginx，Netty中使用。 简言之: 阻塞: 什么事都不干,干等着 ​ 同步: 主动观察 异步: 等别人通知 注: 这里的同步 和 线程中的同步是不一样的. AIO——–&gt;爱亦菲 BIO——–&gt;不同祖 NIO——–&gt;辣痛扉 5.2 Files的常用方法都有哪些？ Files. exists()：检测文件路径是否存在。 Files. createFile()：创建文件。 Files. createDirectory()：创建文件夹。 Files. delete()：删除一个文件或目录。 Files. copy()：复制文件。 Files. move()：移动文件。 Files. size()：查看文件个数。 Files. read()：读取文件。 Files. write()：写入文件。 5.3 BIO、NIO、AIO 有什么区别？ BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 5.4 Java 中 IO 流分为几种？按功能来分：输入流（input）、输出流（output）。 按类型来分：字节流和字符流。 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。 六、堆和栈6.1 简述堆和栈的区别在说堆和栈之前，我们先说一下JVM（虚拟机）内存的划分： Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。 JVM内存的划分有五片： 寄存器； 本地方法区； 方法区； 栈内存； 堆内存。 我们重点来说一下堆和栈： 栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。 堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。 下面我们通过一个图例详细讲一下堆和栈： 比如主函数里的语句 int [] arr=new int [3];在内存中是怎么被定义的： 主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体： 那么堆和栈是怎么联系起来的呢? 我们刚刚说过给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。（可以理解为c或c++的指针，Java成长自c++和c++很像，优化了c++） 如果当int [] arr=null; arr不做任何指向，null的作用就是取消引用数据类型的指向。 当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。 堆(Heap) Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建； Java虚拟机规范描述:所有的对象实例及数组都要在堆上分配； Java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可; (线程共享)堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问; (异常提示)如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.==OutOfMemoryError==； (内存分配)动态分配内存 栈(Stack) 存放基本类型的数据和对象的引用，即存放变量; 如果存放的是基本类型数据（非静态变量），则直接将变量名和值存入stack中的内存中 如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）; (线程私有)栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存; (内存分配)栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题 (异常提示)如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.==StackOverFlowError==； (内存分配)内存分配固定； 存取速度比堆要快，仅次于寄存器，栈数据可以共享； 6.2 小结： 堆和栈的区别可以用如下的比喻来看出： 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就 走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小. 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 (经典！) 所以堆与栈的区别很明显： 1.(存储内容)栈内存存储的是局部变量而堆内存存储的是实体； 2.(更新速度)栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 3.(回收机制)栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收 4.(线程共享)堆内存中的对象对所有线程可见。(线程私有)栈内存归属于单个线程，每个线程都会有一个栈内存 5.(内存分配)堆内存:动态分配内存;栈内存分配固定； 6.(异常提示)如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.==OutOfMemoryError==；(异常提示)如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.==StackOverFlowError==；]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息系统项目管理师案例分析知识点]]></title>
    <url>%2F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[1、项目建议书的内容（4个） 2、项目章程、项目管理计划的内容 3、项目范围说明书的内容、范围基准、WBS分解3个方法8个原则 4、缩短活动工期的五种方法 5、成本控制的内容 6、成本估算、预算的三个步骤/工具和技术 7、质量控制的七种工具（老七、新七）、质量审计的目标、QA的职责 8、团队建设的五个阶段 9、管理项目团队的工具和技术、冲突的特点/解决的方法 10、风险的应对措施（积极/消极，会举例子） 11、配置管理的六个活动/基线和非基线配置项/配置库3个 12、变更的八个工作程序、项目总结的意义、信息系统后评价的内容]]></content>
      <categories>
        <category>考证</category>
      </categories>
      <tags>
        <tag>信息系统项目管理师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息系统项目管理师之论文部分]]></title>
    <url>%2F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E4%B9%8B%E8%AE%BA%E6%96%87%E9%83%A8%E5%88%86.html</url>
    <content type="text"><![CDATA[十大知识领域、五大项目管理过程组、47个过程启动过程组 2个规划过程组 24个执行过程组 8个监控过程组 11个收尾过程组 2个 一、整体管理1.1 可以从以下方面去写:①: 6个过程 (命题概率较大) ②: PDCA (命题概率较大) ③: 5大过程组 注: PDCA是质量管理和项目管理的基本模型。PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Action(行动)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。 1.2 写作思路: 过程 通俗解释 写作要点(举例: 根据子题目写) 1 制定项目章程 正式批准项目的启动,为项目经理授权 不用写太多,一句话带过,如项目发起人发布了这个文件,项目启动了,我被授权了. 2 制定项目管理计划 和大家一起编制项目管理计划,为项目的执行奠定基础 可写计划编写的原则,工具,步骤等内容,列举项目管理计划包含了什么内容 3 指导和管理项目执行 按照项目管理计划来指定项目的执行 如何按照计划来指导和管理项目, 如: 根据计划做了什么安排,怎么安排等 4 监督和控制项目工作 做好项目的纠偏控制 如何设置监控点,如何进行监控和捕获项目信息,什么时候发现项目状态有问题,分析什么原因造成的,如何解决的. 5 整体变更管理 变更不可避免,当发生变更时严格按照变更流程进行项目变更管理工程. 具体举例,如何进行变更控制(6个流程) 6 项目收尾 项目通过验收,交付了产品,还要召开项目总结会议,进行项目总结和评估审计等工作. 写验收情况,项目总结会议的作用,内容,最后更新组织过程资产等 1.3 过程,输入,输出,工具和技术 过程+输入 工具/技术 输出 1.3.1 制定项目章程 (启动过程组) ①: 项目工作说明书 专家判断 项目章程 ②: 商业论证 引导技术 ③: 协议 ④: 事业环境因素 ⑤: 组织过程资产 口诀: 工商议事有组织,专家引导出章程(工:工作说明书,商: 商业论证,议: 协议,事: 事业环境因素,) 1.3.2 制定项目管理计划 (规划过程组) ①: 项目章程 专家判断 项目管理计划 ②: 其他过程的输出 引导技术 ③: 事业环境因素 ④: 组织过程资产 ⑤: 初步项目范围说明书 口诀: 章程输出靠业组,专家引导出计划 1.3.3 指导与管理项目执行 (执行过程组) ①: 项目管理计划 专家判断 可交付性成果 ②: 批准的变更请求 项目管理信息系统 工作绩效数据 ③: 事业环境因素 会议 变更请求 ④: 组织过程资产 项目管理计划更新 口诀: 计变业组会专项, 效果变更新文划( 计: 项目管理计划, 业: 事业环境因素,专: 专家, 项: 项目管理信息系统,效:绩效,果:可交付性成果,变:变更请求,新:更新,文: 文件,划:计划) 项目文件更新 1.3.4 监控项目工作 (监控过程组) ①: 项目管理计划 专家判断 变更请求 ②: 进度预测 项目管理信息系统 工作绩效报告 ③: 成本预测 会议 项目管理计划更新 ④: 确认的变更 项目文件更新 ⑤: 工作绩效信息 ⑥: 事业环境因素 ⑦: 组织过程资产 口诀: 计划进成预测后,业组确认变更信(输入而言) 1.3.5 实施整体变更控制 (监控过程组) ①: 项目管理计划 专家判断 批准的变更请求 ②: 工作绩效报告 会议 变更日志 ③: 变更请求 变更控制工具 项目管理计划更新 ④: 事业环境因素 项目文件更新 ⑤: 组织过程资产 口诀: 计划变更效业组,批准日志新文划 1.3.6 结束项目或阶段 (收尾过程组) ①: 项目管理计划 专家判断 最终产品,服务或成果移交 ②: 验收的可交付成果 分析技术 组织过程资产更新 ③: 组织过程资产 会议 管理收尾规程 口诀: 计划验收无事业,会议分析有专家 合同收尾规程 1.4 论文格式:第一部分: 摘要部分: 300字左右 第二部分: 正文部分: 2700字左右 总共3000字左右. 1.5 范文: 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 论信息系统工程项目的整体管理摘要: 2005 年 3 月我作为项目经理参与了某市的公安部人口管理信息系统，该项目是为了实现该市平安城市的 5 年规划。它投资 800 万元。工期为 1 年。目标是采用统一的技术路线和架构体系构建开放的、集成的、一体化的信息化的应用环境.该项目主要实现了常住人口户籍办公管理、二代身份证管理、暂住人口户籍管理、租赁房屋管理等。2006 年 3 月通过了甲方的验收，获得了甲方的一致好评。本文以我的实际经验讨论了有关大型整体管理的体会，主要从制定项目章程、制定项目范围说明书(初步)、制定项目管理计划、指导和管理 项目执行、监督和控制项目工作、整体变更控制、项目收尾方面做了论述。正文: 为了实现某市平安城市的 5 年规划，某市决定开发一个公安系统的人口管理信息系统。工期为 1 年，投资 800 万元。我公司在 2005 年 2 月中标了该市的公安部人口管理信息系统项目，签署了建设合同。2006 年 3 月通过了甲方的验收。项目分为平台开发和项目部署 2 个阶段。软件方面考虑到各区县地理位置分布的不集中，计算机硬件和软件存在较大的差异等问题，我们决定采用 J2EE 框架的 3 层 BS 模式，解决了各种应用系统中应用的不兼容问题， 提高了该系统的易用性。数据库采用了 Oracle 9g 来管理各项数据。服务器操作软件采用比较通用的 Windows Server 2003。硬件方面采用 IBM System X 系列的服务器提高了系统的稳定性和高性能。在应用层面上我们实现了常住人口户籍办公管理、二代身份证管理、暂住人口户籍管理、租赁房屋管理等功能。由千该项目工期紧，工作量大，在制定项目章程的时候 决定了多个分项的项目经理和总经理。我作为项目总经理参与了该项目的管理。接下来我将结合实际工作从制定项目章程，制定项目范围说明书(初步)，制定项目管理计划，指导和管理项目执行，监督和控制项目工作，整体变更控制及项目收尾来讨论大型项目的整体管理。一、制定项目章程 项目章程是实施项目开发的前提和确定项目开发什么产品的依据。经过公司领导的授权 我被任命为该项目的总经理。由千项目的规模比较大、工期较紧，我们根据合同、项目工作 说明书等过程资产确认了另外 3 名项目经理。我作为总经理统一协调。二、制定项目管理计划 俗话说得好，“磨刀不误砍柴工”，在实施项目开发之前，做好应有的准备工作是很有必要的。完备的计划是项目实施的根本前提。为此我组织召开了“项目工作计划的会议”，会议邀请了各团队的项目经理、业务专家和技术专家。 在制定范围控制管理计划进行 WBS 分解的时候，我发现由千涉及的人员较多，个人的知识水平也参差不齐，信息尚不够明确。因此我们决定采用滚动波式计划。对于即将开展的活动进行详细的分析和计划，对于后期的活动尽量粗略地估计，避免出现大范围的变更。 在制定进度控制计划的历时估算时因为我有过许多类似项目管理的经验。因此大部分的活动我采用了类比估算法，从而节约了时间。此外我们还考虑了活动存在的风险情况。在与负责二代身份证管理的经理讨论的过程中，我们发现身份证采集的设备驱动程序来自第三方，驱动的连接是否正常直接影响到了信息采集活动的开展。因此相关的业务、技术专家和团队成员调整了估算方法，采用了三点估算法。该方法主要有 3 个数据，分别是最乐观历时估算 a、最悲观历时估算 c、最有可能历时估算 b，而后利用 T=(a+4b+c)取其平均值。经过个专家和开发团队成员的讨论，认为最乐观的时间为 2 个工作日、最悲观的时间为 6 个工作日、最有可能的时间为 4 个工作日。最后该活动的历时为 4 个工作日。为项目的按时完工打下了基础。 在制定质量控制管理计划的时候我们发现客户的有些要求与相关的法律法规相冲突。为此我及时通知了客户，与客户进行了沟通，最后我们修改了相关质量标准，使项目的质量得到了保证。 在制定人力资源计划的时候为了保证有充足的资源去完成项目。团队的所有项目经理、 相关业务专家和技术专家经过讨论决定采用自下而上的方式进行估算，对每一层下面工作所需的资源进行估算，最后将所有的资源进行汇总。比如二代身 份证信息管理可以分解为身份证信息的采集、信息的存储、信息的修改、信息的存储。信息采集工作需要忱卡器一台、能够在 Java 中成功调用 DLL 动态库一个以及 Java 程序开发人员 2 名；信息存储工作需要通用数据库存储过程一个、Java 程序开发人员 2 名。暂住人口户籍管理、租赁房屋管理的分项经理这时提出也需要Java 的开发人员各 2 名。我们检查公司的人力资源表后发现缺少 2 名Java 程序员，我及时向公司领导汇报了情况，经领导同意我们又招聘了 2 名程序员，完成了资源的合理分配。通过讨论我还制作了活动资源日历，保证每个活动都有后备的资源考虑。 我们还制定了项目成本控制管理计划、沟通管理计划、采购管理计划、风险管理计划等。三、指导和管理项目执行“懂业务的不懂技术，懂技术的不懂业务”，在这种情况下项目的风险很大，一旦开发人 员没有理解业务去开发，将导致严重的返工，最终影响项目进度。因此在开发的时候我要求 每个开发的具体功能必须要求项目经理组织相关干系人对开发人员进行交底，避免返工的发 生。开发这一阶段在每完成一个里程碑式的可交付物时，我都会邀请客户来进行确认签字，保证了我们开发产品的有效性，减少了无谓的变更。四、监督和控制项目工作 在项目执行的过程中总会遇到各种各样的问题。那么怎样才能预防和控制各种问题的发生呢？每周我会根据绩效信息与计划进度表进行比较，进行偏差分析，利用挣值技术计算进度偏差情况，及时采取纠正和预防措施。比如负责二代身份证信息管理项目的丁工还负责其他项目的系统需求分析和设计，因其他项目上的事情比较多，二代身份证管理的需求分析 和详细设计迟迟不能开始，已落后千计划，SV=-3。如果再不提交将会影响到编码阶段。届时，我与丁工进行了沟通，与他协商决定，我负责帮他完成一部分其他项目的工作，他加班负责把马上要进行编码阶段的二代身份证信息管理的需求分析和设计提交出来，最终二代身份证信息管理的编码工作按计划开展。五、整体变更控制 项目开发的过程中客户的需求经常会有变更。为了防止频繁的变更对项目进度等带来的 不利影响。项目的初期我们成立了由客户方、开发方和监理方组成项目控制委员会 CCB。客户或者开发方每个需要的变更都要经 CCB 的批准才能实行。六、项目收尾 经过项目全体人员的共同努力，2006 年 2 月终千完成了压力测试，2006 年 3 月项目一次性通过了甲方的验收。回顾项目的进度管理工作的过程中，项目能成功通过验收得益千在 事前进行了充分的计划和准备工作。我觉得项目管理的能力和项目开发的能力是有很大的区 别的。一个成功而高效的项目开发必须要有一个能统筹管理和善千沟通的项目经理。特别是 作为大型项目经理，我们的主要工作就是平衡各种资源的利用，使其达到最佳的效率。怎样才能达到这个最佳。这个是我在今后的工作中需要长期实践和摸索的内容。虽然项目成功通过了验收没有大的事故发生，但仍然存在许多问题，主要有以下几点：(1) 在需要客户确认时，与客户的沟通方式比较单一，只是一味等待，导致某些工作落后 千计划进度，影响了整体计划。(2) 需求分析还不够全面，某些功能没有能够很完善地实现。(3) 软件测试不系统，用例准备仍不够充分，忽视了压力测试。系统实际运行后随着参保 职工和定点结算的增加，运行速度下降很快，达不到设计要求。虽然通过升级硬件缓解了这个问题，但造成资金的额外投入。 1.6 模板:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 项目整体管理是项目管理的必要条件，是项目管理的有效基础，是项目管理的重要内容。为了保障项目的持续进展，确保项目的有序进行，保证项目能够顺利的上线，我从制定项目章程、制定初步范围说明书、制定项目管理计划、管理和指导项目执行、监控项目工作、整体变更控制和合同收尾等六个方面加强项目的整体管理。第一，制定项目章程。 制定项目章程是项目整体管理的第一步。通过制定项目章程明确项目的整体目标，通过收益法判断整体的项目收益。整个项目采用项目型管理方式。正式任命我作为项目经理。假定某某省某某市的计划生育政策具有延续性，不会有大的变更，这样保障需求不会发生实质的变更。假定项目开发人员中的主力开发人员不会在项目开发过程离职。系统的人口信息表的存放数据量为600万条，系统的响应时间不超过6秒，系统的从需求分析到系统试运行时间为1年，系统的并发用户为50个。系统的项目干系人分为四类：甲方的领导层，关心整体项目进度情况；甲方的业务人员，关心项目的具体业务的实现；乙方的领导层，关心项目的成本、质量及合同的收款情况；乙方的项目团队曾元，关心项目的需求、设计、编码、测试、实施上线。第二，制定初步范围说明书。 项目初步范围说明书是项目整体管理的第二步。项目初步范围说明书是项目各个阶段提交的交付物和为提交交付物所做的工作。我初步制定了项目初步范围说明书包括需求分析报告、系统概要设计、系统详细设计、模块开发卷宗、测试规范、系统集成规范、系统验收规范、系统产品说明书、系统代码。制定了初步工作分解结构。第三、制定项目管理计划。 制定项目管理计划是项目整体管理的第三步。项目管理计划包括成本管理计划、质量管理计划、时间管理计划、风险识别册、人力资源沟通计划等。通过制定项目管理计划，整个项目按照制定的计划预期稳步向前推进。第四，管理和指导项目执行。 采用工具sourceSafe建立配置管理系统，对所有的文档及变更记录进行管理。采用OA系统作为所有项目干系人的沟通工具，所有的变更文档记录及相关的项目文档资料通过OA的流程管理进行处理。比如，有的程序员对J2EE比较熟悉，这次开发采用.NET路线，因此请对.NET精通的专家对不熟悉J2EE的程序员进行培训。要求质量管理人员按照编码规范对代码进行走查，不符合要求责令修改。第五，监控项目工作。 监控项目工作是项目整体管理的第五个步骤。对整个项目在成本、风险、质量、进度等方面进行监控。在每个里程碑的节点上开面对面沟通会议，对前一阶段的工作进行审核把关，同时对出现的问题进行记录，寻找解决办法；通过每周的项目例会，对这一周的工作进行总结，出现的问题进行记录，及时把问题解决。通过每天的项目组成员的工作日志，记录成员每天的工作情况，以便于及时的把问题查找出来。通过每天的工作日志、每周的项目例会及里程碑节点的会议及时的与项目计划进行比对，找出偏差，及时处理。第六、整体变更控制。 成立变更控制管理委员会，对整个项目的需求变更进行管理控制。变更管理委员会对申请的变更要审核、评估。批准后的变更要按计划执行，同时对执行后的项目进行追踪。第七，项目收尾。 项目收尾包括管理收尾和合同收尾。通过项目范围说明书、合同等文档的要求，对提交给用户的可交付物进行比对。对已完成的可交付请求客户确认签字，对用户确定需要进一步完善的可交付物要及时的按照文档资料要求处理。最后整体验收。例如，按照合同要求，我们用惠普的loadrunner对系统进行了50并发用户的压力测试，同时在开发的过程也组织了人力对人口的基础数据进行了录入，响应时间小于6秒。同时提交的文档资料整体提交完毕，人员培训已经完成，系统试运行三个月情况良好，满足用户需求。 二、范围管理2.1 可以从以下方面去写:①: 6个过程 (命题概率较大) ②: PDCA (命题概率较大) ③: 范围结合需求 ④: 问题解决的角度 注: 其中 1 命题概率大，建议 6 个过程的角度必须准备 2.2 写作思路: 过程 通俗解释 写作要点 1 范围规划 编写项目范围管理计划 写我组织相关人员进行了项目范围管理计划的编制,在编制之前做了什么准备,通过什么方法进行编制,编制后的计划包含什么内容. 2 收集需求 记录并管理干系人的需要和需求过程 哪些类型的需求, 输入,输出,工具技术,该过程的重要性,遇到什么问题,如何解决,需求文件,建立需求跟踪矩阵等. 3 范围定义 对项目和产品详细描述,并写到详细的范围说明书中,形成详细的范围说明书. 举例描述,本项目的某个功能原来是怎么定义,现在是如何详细的表示,最终说明书包含什么 4 创建工作分解结构WBS 项目的可交付物和项目管理的工作进行分解,分解为更小更易于管理的单元. 为什么要分解,是采用树形还是列表型,以什么作为第一层,分解的五个步骤是什么,遵循什么原则 5 范围确认 阶段性的接受项目的可交付物,对不可接受的说明理由,重新整改. 具体通过什么方式进行范围确认,哪些进行了确认,哪些没有,是什么原因,怎样整改. 6 范围控制 管理好变更,避免出现范围蔓延 写范围管理的重要性,如何进行范围控制的,如何防止范围蔓延 2.3 过程,输入,输出,工具和技术 过程+输入 工具/技术 输出 2.3.1 范围规划 (规划过程组) ①: 项目管理计划 专家判断 范围管理计划 ②: 项目章程 会议 需求管理计划 ③: 事业环境因素 模板,表格,标准 ④: 组织过程资产 ⑤: 初步项目范围说明书 口诀: 章程计划找业组, 专家会议两计划 2.3.2 收集需求 (规划过程组) ①: 范围管理计划 访谈 需求文件 ②: 需求管理计划 问卷 需求跟踪矩阵 ③: 干系人管理计划 观察 ④: 项目章程 标杆 ⑤: 干系人登记册 原型 口诀: 范需人划章程册, 需求文件矩阵出(划: 管理计划), 文件分析 系统交互图 焦点小组 引导式研讨会 群体创新技术 群体决策技术 2.3.3 范围定义 (规划过程组) ①: 范围管理和计划 专家判断 项目范围说明书(详细) ②: 项目章程 产品分析 项目管理计划更新 ③: 需求文件 可选方案识别 ④: 组织过程资产 引导式研讨会 口诀: 范划章程需文组, 文件更新出范书 2.3.4 创建工作分解结构WBS (规划过程组) ①: 范围管理计划 分解技术 范围基准 ②: 详细项目范围说明书 专家判断 项目管理计划更新 ③: 需求文件 WBS分解结构模板 WBS和WBS字典 ④: 事业环境因素 ⑤: 组织过程资产 口诀: 范划范书需业组,文件更新出基准 2.3.5 范围确认 (监控过程组) ①: 项目管理计划 检查 验收的可交付性成果 ②: 需求文件 群体决策 变更请求 ③: 需求跟踪矩阵 工作绩效信息 ④: 核实的可交付性成果 项目文件更新 ⑤: 工作绩效数据 口诀: 计划需文效成果,文件变更绩效出 2.3.6 范围控制 ①: 项目管理计划 偏差分析 工作绩效信息 ②: 需求文件 变更控制系统 变更请求 ③: 需求跟踪矩阵 配置管理系统 项目管理计划更新 ④: 工作绩效数据 重新规划 项目文件更新 ⑤: 组织过程资产 组织过程资产更新 口诀: 计划需文效矩组,计组文件齐更新 2.4 范文:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 论信息系统工程项目的范围管理摘要: 2009 年 5 月，我作为项目经理，参与了××物流公司条形码项目。该项目是为了提升××物流公司日常业务运作中货物流转交换的准确性和及时性，解决该公司现有业务运作中的货物差错率高、装卸效率低、记录颗粒度粗等问题，进而提升整体运营服务质量，实现×× 物流公司由低端运输向高端公路快运转型的战略目标。 作为该公司的重点战略项目，项目总投资 2000 万元，项目工期为 2 年，系统主要实现了以下功能：CD对货物流转交换过程中的每一个环节的扫描，实现货物运输全过程跟踪处理功能；＠基千计划与实际扫描结果的比对，实现装卸差错及时发现、及时解决；＠货物异常处理；＠提送货任务的指派与管理。 2011 年 6 月，该项目通过了客户的验收，顾得了甲方的好评，成为公路运输行业实施条码技术的成功案例；得到业内的一致认可。本文结合作者的实际经验讨论了项目的范围管理，主要从制定范围计划、定义范围、创建 WBS，以及核实范围、控制范围这几个方面进行论述。正文: 2009 年 5 月，我参与了××物流公司条形码项目建设，该项目应××物流公司由低端运输向高端公路快运转型的战略而立项，是 2009 年该公司的重点项目。项目建设周期为 2年，由 2009 年 5 月开始，到 2011 年 6 月验收结束，项目总投资为人民币 2000 万元。其目标是建立一套高效实用的条码系统，全面提高流转交换的准确性和及时性，降低差错，提升运营服务质量，实现由低端运输向高端公路快运转型的战略目标。 系统采用 C/S 架构，服务端应用采用 J2EE+Oracle 的模式开发，服务器使用 HP 的 580G7， 操作系统为Redhat 企业版 Linux 5.4，数据库使用 Oracle 11g R2 并做 RAC，中间件采用 IBM 的 WebSphere 并做集群，终端应用基千 Microsoft 的Windows CE 平台，采用 C#语言开发， 运行千 PDA 上。项目采用矩阵型组织结构，从各职能部门抽调主干成员，组成专门的项目团队。我被任命为该项目的项目经理，负责项目的管理工作，直接向项目总监汇报。下面我将结合本项目从制定范围管理计划、定义范围、创建工作分解结构、核实范围、控制范围这几个方面对项目的范围管理进行介绍。一、制定范围计划 作为一名合格的项目管理者，做任何事之前都应该先做好计划。好的计划，是成功实施项目的基础。有些人为做项目范围计划花费了太多时间，不如把它们用千执行工作，项目将会更快更好地完成，我认为这是一个错误的想法，通过省略范围计划制定，虽然能短暂时间内节省一定的时间，但在长期来看，常常会因缺乏管理计划指导而使得范围定义不清、范围蔓延，以致无法完成项目。因此，在该项目中，我非常重视范围计划的制定，在正式做计划之前，我先查找了公司组织过程资产，找出制定范围管理计划的模板，再结合以往项目的经验，制定出一份初步的计划，然后召集项目团队成员讨论，对计划进行修改和完善，在全体参与下，最终完成一份详细的、科学的范围管理计划，用千指导项目如何定义、分解以及核实和控制范围。二、定义范围 一个成功的项目，应该做且只做成功完成项目所需的全部工作。为了保证这一点，就需要在项目前期定义一个明确的项目范围。在项目的早期阶段，我带领团队，到了客户现场收集需求，我组织了客户的运营部门、服务质量部门、IT 部门以及我的需求团队，召开需求讨论会，共同商讨项目范围。在收集需求的时候，客户有时候需求描述得不是很清楚，造成了双方对需求理解有歧义，甚至有时候客户对千其需求自己都不清楚，只有一个模糊的概念； 针对这种情况，我采用原型法将收集到的需求，做成模型供客户参考确认，以此消除彼此的歧义，充分挖掘用户的需求，并基千团队自身的经验以及专业水平，对客户的需求进行引导、细化，将其模糊的概念形象化，粗糙的需求具体化。 基于需求文件，我召集项目的主要干系人进行开会讨论，同时邀请了系统的最终用户代表（包括甲方的业务员，装卸工、调度等）对系统功能做评价，通过用户的角度，去发现和改进系统的功能，以此最终形成了完整的项目范围说明书，主要包含：CD条码项目的产品范围描述（包括取派件管理、装卸管理、异常管理等）；＠项目的主要可交付成果（用户文档、应用系统、源代码等）；＠产品验收标准（系统运行稳定、功能满足业务需求、相关文档齐全等）；＠项目的除外责任（该项目涉及的仓库环境改造，强电、弱电改造不包含在该项目范围中）；＠项目制约因素（之前的预算和系统设计仅针对定日达产品进行，如果扩展到零担，必须追加投入、延长项目时间）；＠项目假设条件（假设项目涉及的场站改造、人员素质提高可以配合条码项目进行持续改进，假设甲方的业务系统满足条码项目上线后给其增加的负载）；＠项目的目标、总预算、资源，以及主要里程碑等。三、创建 WBS 基于项目范围说明书，我和我的团队开始对项目范围进行分解，以形成该项目的 WBS。在分解过程中，我按照以下原则进行分解。在各层次上保持项目的完整性，我将该项目涉及的需求调研、系统设计、开发、测试等完整的模块都一一列出，避免遗漏必要的组成部分。一个工作单元只从属千某个上层单元。对千该项目中的数据库设计，我就只将其归入系统设计单元中，在其他单元不再重复出现，避免了交叉从属。相同层次的工作单元应有相同性质。对千系统设计单元下的数据库设计、接口设计、系统设计等设计内工作，它们从属性上来讲， 都属千设计，因此我将其一并归入系统设计单元下。工作单元应能分开不同的责任者和不同的工作内容。对千该项目中每个工作包，我都指定唯一的负责人和其负责的工作内容，便千项目管理进行计划和控制的管理。对千该项目的每个工作包，我都对其进行编号，并与组织结构图和成本控制点深度融合，便千项目的日后管理。应包括项目管理工作，包括分包出去的工作。对千该项目，我将项目管理和外包的 AP 部署也一并纳入 WBS 中，并逐层分解。WBS 的最低层次的工作单元是工作包；对千该项目中工作单元，我参照 8/80 小时原则细化成具体的工作包，并指定具体的负责人。同时制作 WBS 词典，对工作包做具体描述。四、核实范围 范围确认并不是件容易的事情，在与客户的沟通上，我们希望客户尽快确认以便尽快开展后续的开发阶段工作，而客户则可能认为自己什么也没看到，怎么确认呢？针对这种情况， 我在提交文档给客户的相关干系人后，重点对客户的 IT 人员进行沟通培训，详细介绍系统的设计，然后用他们的声音去向客户的业务部门做出介绍，这样既有益千专业人员之间的技术沟通，也有益千客户业务部门对系统范围的认可与信任。同时，在与客户的业务部门沟通时，我重点强调，虽然范围确认是正式的，但这并不意味着项目的范围就是铁板一块，不能再修改了，只要走标准的变更流程，且审批通过的，都是可以进行变更的。这样就消除了客户的顾虑，便千快速、高效地完成范围确认。五、控制范围控制范围就是监督项目的范围状态，管理范围基础变更的过程。因此在项目中，我定期组织召开项目状态审查会，审查项目的范围，通过对照范围基础，找出范围偏差，并做分析，严格杜绝一切的范围蔓延以及锁金。 例如，在一次状态审查会上，我发现项目的功能模块中，系统管理以及库存管理模块多了登录日志以及盘库两块功能，我查了一下系统变更日志，未找到有类似的变更记录，千是我参照责任分配矩阵，分别找到这两个模块开发的负责人询问原因，A 成员告诉我，他增加登录日志这个功能，是因为客户在一次电话中，向他提过希望在系统管理模块中加一个登录日志的功能，B 成员则是因为在开发库存管理模块时，发现整个库存管理没有库存盘点的功能，他认为做库存管理，肯定需要用到盘点功能，而且这是个亮点，所以他私自增加了这一功能。针对这两种情况，我首先向这两名成员强调了范围基准以及变更流程的重要性；其次， 针对这两项多出来的功能，我要求相关人员提交正式的变更申请，走正常的变更控制流程。从事项目管理工作的我深知，项目范围不是一经定义，就一成不变的，项目干系人出千项目利益以及各种情况考虑，总会有一些需求变更，管理这些变更，需要在项目规划时，就制定好变更控制流程以及成立一个专门的需求变更控制委员会（CCB）。 因此，我和我的团队在项目早期就制定了一套标准的变更流程：CD提交变更申请；＠评估变更；＠报 CCB 审批；＠实施变更并调整基准；＠将变更信息通知相关干系人；＠对变更的结果进行追踪与审核。有了这些流程以及 CCB 的控制，项目的需求变更得以良性发展，变更带来更多的是项目利益以及效率的提升。 经过我和我的团队不懈努力，该项目最终千 2011 年 5 月试运行成功，并在同年 6 月通过了客户验收小组的验收，得到了甲方的好评，使得××物流公司运营的货物差错率降低了50%，客户投诉率降低了 20%，理赔损失降低了 20%，提升了该公司的整体运营服务水平、客户满意度及公司形象，为××物流公司由低端运输向高端公路快运转型提供强有力的保障。项目最终能成功完成，得益千我在项目中有效的范围管理，采用科学的范围管理方法、工具和技术，为项目的范围管理带来了事半功倍的效果。同时，在该项目的实施过程中，也出现了一些问题，本人觉得处理得不是很好，主要在千项目中的冲突管理以及项目风险识别方面还存在不足，后续我将加强这两个方面的学历与知识积累，不断提升自身项目管理水平，为中国物流行业的信息化发展添砖加瓦 2.5 模板1234567891011121314151617181920212223242526项目范围管理是项目管理的核心部分，是项目管理的必要条件，是项目管理持续发展的基础，是项目管理有效进行的前提。我从范围规划、范围定义、工作分解结构、范围确认、范围控制等五个方面开展了项目范围管理的工作。第一，范围规划。范围规划是项目范围管理的第一个环节。范围规划确保范围定义、工作分解结构、范围确认和范围控制如何开展。第二，范围定义。范围定义是制定项目范围说明书的过程，项目范围说明书是确定整个项目工作中的可交付物及提交可交付物所做的工作。本项目采用快速原型结合面向对象开发的方法。先根据甲方沟通，确定甲方的重要项目干系人分类。一类是甲方的领导层确定系统要达到的整体目标，另一类是甲方的业务人员，他们的要求是系统的具体功能。我方人员通过与各类项目干系人进行沟通，通过制作界面原型与甲方不断确认，把需求确定下来，把范围确定下来。第三，创建工作分解结构。创建工作分解结构项目范围管理的重要环节。通过工作分解结构把项目的整体工作分解成工作包。通过滚动式规划，把近期的工作分解较为详细，远期的工作分解较为初略。根据工作分解结构，初步整个项目分解成业务需求、用户需求、功能需求、概要设计、详细设计、系统编码、单元测试、整体测试、集成测试、安全测试、压力测试、系统培训、系统试运行。第四，范围确认。范围确认是我方与甲方对项目说明书确认的一个过程，对于系统开发过程中所提交的文档、资料、软件等可交付物及为这些交付物所做的工作的确认。整个范围确认是贯穿整个过程的始终。我方和用户方商定，所有的提交的可交付物，用户必须制定项目联系人签字盖章，如果拒绝提交，也要提出书面说明。第五，范围控制。范围控制是保证整个项目有效实施的重要内容。我方与用户方成立变更控制委员会。对用户方提出的范围变更请求必须提交书面申请，由变更控制委员会进行审核，审核通过后执行，并对执行的结果进行跟踪。建立sourcesafe软件配置管理系统。把所有的文档用配置管理系统管理起来，对整个项目的管理及范围变更有非常清晰的认识。 三、进度管理3.1 可以从以下方面去写:①: 7个过程 (命题概率较大) ②: PDCA (命题概率较大) 3.2 写作思路: 过程 通俗解释 写作要点(举例: 根据子题目写) 1 制定进度管理计划 写一个叫做进度管理计划的文档 我组织相关人员进行了进度管理计划的编制工作，在进行编制前做了什么准备,通过什么方法进行了编制，编制后的计划包含什么内容等，计划的重要性等等 2 定义活动 看项目里面到底有多少活动需要完成，识别出来并记录下来 活动定义和 WBS 的关系，举例写下结合本项目有哪些活动？ 3 排列活动顺序 明确各活动之间的顺序等相互的依赖关系，并记录下来 举例描述下活动的逻辑关系 4 估算活动资源 估算下每个活动到底需要多少材料、人员、设备等等资源 某某活动需要什么资源，需要多少资源，什么时候需要等等。是通过什么方式进行估算的等内容 5 估算活动持续时间 估算下完成某活动所需要的持续时间 什么方法对本项目中的一些活动进行了历时估算，是多少时间等。 6 制定进度计划 分析这些活动的顺序、历时、资源需求和相关的一些进度约束等内容来编制项目的进度计划 通过什么方法进行进度计划的制定的 7 进度控制 监控项目的具体状态， 如果发现有偏差，我们需要进行纠偏 进度控制的重要性、工作内容，举例挣值分析，发现项目进度怎么样了，分析为什么，进行纠偏 3.3 过程,输入,输出,工具和技术 过程+输入 工具/技术 输出 3.3.1 规划进度管理 ①: 项目管理计划 专家判断 进度管理计划 ②: 项目章程 分析技术 ③: 事业环境因素 会议 ④: 组织过程资产 口诀: 章程计划找业组,分家会上进管子 3.3.2 定义活动 ①: 进度管理计划 分解 活动清单 ②: 范围基准 滚动式规则 活动属性 ③: 事业环境因素 专家判断 里程碑清单 ④: 组织过程资产 口诀: 业组进管炒基范,分家滚出清属里 3.3.3 排列活动顺序 ①: 进度管理计划 紧前关系绘图法PDM 项目进度网络图 ②: 活动清单 确定依赖关系 项目文件更新 ③: 活动属性 提前与滞后 ④: 里程碑清单 ⑤: 项目范围管理书 ⑥: 事业环境因素 ⑦: 组织过程资产 口诀: 范进业组清属里, 前后紧赖网新文 3.3.4 估算活动资源 ①: 进度管理计划 自下而上估算 资源分解结构 ②: 活动清单 备选方案分析 活动资源需求 ③: 活动属性 项目管理软件 项目文件更新 ④: 资源日历 发布的估算数据 ⑤: 风险登记册 专家判断 ⑥: 活动成本估算 ⑦: 事业环境因素 ⑧: 组织过程资产 口诀: 业组进管估成本,清属资历有风险 自选软件算专家 分解需求新文件 3.3.5 估算活动持续时间 ①: 进度管理计划 专家判断 活动持续时间估算 ②: 活动清单 类比估算 项目文件更新 ③: 活动属性 参数估算 ④: 活动资源需求 三点估算 ⑤: 资源日历 群体决策技术 ⑥: 项目范围说明书 储备分析 ⑦: 风险登记册 ⑧: 资源分解结构 ⑨: 事业环境因素 ⑩: 组织过程资产 口诀: 业组资需分日进,清属范书有风险 3.3.6 制定进度计划 ①: 进度管理计划 进度网络分析 进度基准 ②: 活动清单 关键路径法 项目进度计划 ③: 活动属性 关键链法 进度数据 ④: 项目进度网络图 资源优化技术 项目日历 ⑤: 活动资源需求 建模压缩技术 项目管理计划更新 ⑥: 资源日历 提前与滞后 项目文件更新 ⑦: 活动持续时间估算 进度压缩 ⑧: 项目范围说明书 进度计划编制 ⑨: 风险登记册 ⑩: 项目人员分配 ⑩: 资源分解结构 ⑩: 事业环境因素 ⑩: 组织过程资产 口诀: 业组资需分日进,清属范书有风险,人员进 3.3.7 控制进度计划 ①: 项目管理计划 绩效审查 工作绩效信息 ②: 进度管理计划 项目管理软件 进度预测 ③: 工作绩效数据 资源优化技术 变更请求 ④: 项目日历 建模技术 项目管理计划更新 ⑤: 进度数据 提前与滞后 项目文件更新 ⑥: 组织过程资产 进度压缩 组织过程资产更新 进度计划编制工具 口诀: 两数两划组日历 3.4 范文: 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 论项目进度管理【摘要】2008 年 10 月，XX 发展股份有限公司作为系统集成项目的总包商承接了 XX 市人力资源和社会保障局所委托的XX市基本臣疗保险门诊实时结算信息系统建设项目，我作为项目经理负责全程管理该项目，该项目的主要业务目标是建设覆盖全市 1800 家臣保定点臣疗机构的门诊实时结算系统;在实施该项目过程中，项目在时间管理方面具有以下特点:项目业务功能复杂，涉及到 XX 市 1800 家臣保定点臣疗机构和 1300 万臣保参保人，同时该项目工期较长历时一年多，涉及的项目干系人众多，并目_项目属千 2009 年 XX 市政府折子土程，要求必须在 2009 年底完成。因而该项目的时间管理是项目成功的关键。在充分分析了该项目特点的基础上，在时间管理方面我对项目的所有活动通过活动分解进行了定义，使用前导图的方法对项目活动进行了排序，经过对项目活动的资源估算、项目活动历时估算并制订了项目进度计划，形成了项目进度甘特图，在项目执行过程中依据项目甘特图，进行项目绩效测量，根据绩效测量的结果以及通过项目进度变更控制系统对项目进度进行了很好的控制。在项目的各个里程碑阶段都很好地在确保项目质量和成本的基础上， 按照项目时间进度计划完成了项目。最终，在 2009 年底由 XX 市政府正式宣布系统一次性上线成功。该项目在时间管理过程中还存在一些不足，例如在活动历时估算时我们还应该更多的安排预留时间，为项目风险做好时间方面的准备;在制订顷目进度计划时，我们还应该更多考虑资源平衡方面的问题，使项目资源得到更充分的利用;在进度控制阶段，我们在各个里程碑评审过程中还应该增加用户参与，与用户更好地进行项目进度沟通。争取在今后的项目管理过程中百尺竿头、更进一步。【正文】2008 年 10 月，XX 发展股份有限公司作为系统集成总承包商承接了 XX 市人力资源和社会保障局所委托的 XX 市基本臣疗保险门诊实时结算项目，我作为项目经理负责全程项日管理，并参与了业务需求讨论和系统分析等工作。该项目覆盖了全市 18 个区县、1800 家臣保定点臣疗机构和 1300 万参保人。在参保人门诊就臣费用结算时，使用社保片实时计算臣保基金和个人支付金额，参保个人只需负担个人支付金额即可完成结算过程，将门诊费用报销支付时间由几个月缩短为儿秒钟，极大地方便了参保人。该项目从 2008 年 10 月开工，到2009 年 12 月验收结束，历时一年多，项目涉及 XX 市和 18 区县人社局、1800 家定点臣疗机构，项目干系人众多，项目业务需求内容繁多。由千项目属千 XX 市政府折子工程，项目时间进度要求必须在 2009 年底完成，项目管理过程中的时间管理尤为重要，是项目是否成功的重要评价标准。在具体管理过程中，我根据项目实际情况，遵循时间管理的主要方法， 对项目活动进行了定义、排序，资源估算、历时估算并制订了项目进度计划，在项目执行过程中，通过项目进度变更控制系统对项目进度进行很好的控制，最终在既定的时间完成了所有项目工作，取得了良好的效果。2009 年底由 XX 市政府正式宣布一次性上线成功，目前运行情况良好。一、活动定义首先，我们根据项目范围说明书以及项目的 WBS 对项目的所有活动进行了定义。我们将项目先进行了阶段定义，包括项目的需求获取、需求分析、系统设计、系统开发、系统测试、用户测试、系统试点、系统正式上线阶段，然后，我根据项目进展的不同阶段，采用滚动规划方法，将项目涉及到的所有活动逐步进行了定义。对千近期需要完成的工作在工作分解结构最下层详细规划，远期需要完成的工作则表现在工作分解结构相对高的层次上。通过滚动规划方式随着项目工作的开展，项目活动也逐层逐步清晰。二、活动排序根据活动定义，我将所有活动进行了排序，通过前导图的方法，将所有活动之间的依赖关系整理形成项目网络图。在此阶段中最重要的就是明确各个活动之间的依赖关系，例如在系统测试试阶段，我们通过与用户沟通，最终明确先进行我们公司内部的自测工作，然后由用户代表在公司的实验室环境下进行用户测试，最后再选择两家试点臣院在臣院实地环境下进行现场测试;而对千公司内部测试阶段，我们将臣院端系统与区县经办机构端的系统进行同步闭环测试。三、活动的资源估算为了做好所有项目活动在所需资源上面的准备工作，我们还对项目活动的资源进行了估算，通过自下而上的估算方法我们整理了整个项目所需要的相关资源。例如在测试阶段，我们针对所需要测试的系统数量、每个系统的测试人员数量，以及试点测试臣院的数量，我们估算了所需要测试用忱卡机具以及测试卡的数量，在系统测试之前要求机具和卡片提供商必须按时提供测试用的设各以保证测试工作的顺利进行。四、活动的历时估算对千活动历时估算我们使用了活动历时二点估算法，由千在系统开发过程中业务算法相对比较复杂，具体开发过程中可能会遇到很多不确定因素，为此，我要求项目人员估算了最乐观、最悲观以及最可能的时间的开发时间，使用三点估算法计算公式计算出项目活动的历时估算。例如对千系统测试工作，无法很准确地估算测试 bug 的修改时间，为此我要求测试人员进行了三点估算，最乐观的时间为 3 周，最悲观的时间为 8 周，最可能的时间为 G 周，通过三点估算公式计算出估算时间为 5.9 周。通过使用三点估算法设置统计权重，运用统计规律降低了项目历时的不确定性。五、制订进度计划在前期时间管理工作的基础上，我制订了项目进度计划，通过项目甘特图全面反映了项目进度状况。在制订进度计划过程中，使用了关键路径法，根据各项目活动之间的依赖关系以及项目活动所使用的资源情况，我们分析并寻找了项目的关键活动，并形成了项目的关键路径。通过平衡与协调项目资源使用情况，最终制订了项目计划甘特图。为了使项目干系人都了解和掌握项目进度计划，我们还将项目计划甘特图印刷成册，形成了项目手册，下发给项目参与各方，得到了用户方以及项目监理方的好评。六、进度控制在项目执行过程中，每周各子项目组根据项目进展报告进行挣值分析，并形成项目跟踪甘特图，并与项目计划甘特图进行比对，如果发现有滞后现象则安排项目组进行赶工。每两周项目整体进行绩效测量通过挣值分析以及项目跟踪甘特图进行绩效评估。如果出现进度变更，则通过项目组以及公司两级进度变更控制系统进行变更评审。对千项目工作重大的变更则由项目监理公司主持召开项目监理会，与用户方和监理方共同沟通项目进度变更情况，对千批准的变更申请，在监理会后形成项目进度变更报告，发送项目相关各方。【结束语】在门诊实时结算项目管理过程中，我全面应用了项目时间管理的方法，使得该项目在时间管理方面较好地达到了预期目的，确保了 2009 年底系统上线。鉴千我们在项目初期通过项目工作分解进行了活动定义，使用了前导图法对项目活动进行了排序，并使用了自下而上的估算方法对项目活动进行了资源估算，使用了项目历时三点估算法降低了历时估算的不确定性，最终形成项目进度计划，并在项目执行过程中很好地运用了绩效测量以及项目组与公司两级进度控制系统，对项目进度进行了控制，并且在项目监理方的组织下与用户进行了有效的沟通，最终确保了在 2009 年底完成了项目所有工作，并由 XX 市政府正式宣布一次性上线成功。通过总结，对千项目在时一间管理方面我认为还存在一些不足:第一，在项目活动历时一估算时还应该更多的安排预留时间，为项目风险做好时间方面的准备。第二，在制订进度计划方面还应该更多考虑资源平衡方面的问题，使项目在确保时间进度不变的情况下更好地减少成本。第三，在项目执行过程中，各个里程碑评审过程还应该加强用户参与，在项目进度方面增加与用户的沟通。如果对千以上方面能够进行更好的总结与提高，在今后的项目管理过程中时间管理的水平将得到不断提高，真正达到“百尺竿头、更进一步”的目标。 3.5 模板12345678910111213141516171819202122232425262728293031323334353637项目时间管理是项目管理的一个非常重要的环节，是项目管理的必要条件之一，是保障项目的有序的进行的基础，确保项目的持续发展的前提。因此，我从活动定义、活动排序、活动资源评估、活动历时评估、制定进度表和进度控制等六个方面对项目时间管理进行了把握。第一，活动定义。根据项目范围说明书、项目管理计划、组织过程资产等资料，我对整个项目进行活动定义。通过四个步骤控制账户、规划定义、工作包、活动对整个项目进行分解。通过滚动式规划对近期发生的工作进行详细分解，把分解活动放在工作分解结构的最下层。把远期发生的工作暂时放在工作分解结构的上层。根据整个项目情况，工作包分解成需求分析、概要设计、详细设计、系统编码、系统测试、系统培训、系统试运行、系统上线。然后在把每个工作包在进行详细分解成活动。例如系统测试分解成单元测试、整体测试、集成测试、安全测试、压力测试。定义好后列出活动清单及活动属性。第二，活动排序。活动排序是时间管理的第二个步骤。根据活动清单用前导图的方法对活动进行排序。例如系统编码工作中，某程序员负责基础信息采集的子系统的编码，他所进行的工作分解后，按照活动顺序依次为行政区采集的编码，户人口信息的采集编码、户成员基础信息采集编码、已婚育龄妇女基础信息的采集编码、已婚育龄妇女指纹接口对接的编码、手术人员基础信息的采集编码、新生儿基础信息的采集编码。第三，活动资源估算。活动资源估算是每个活动占用的资源进行估算。根据活动的资源估算汇总成工作包所占的资源估算。例如，编码的活动定义和排序完成以后，根据活动的数量及难易程度，判断开发这些活动所需的高级程序员以及普通程序员的人数，某某省某某市人口计划和生育系统需要4个高级程序员和2个普通程序员。第四，活动历时估算。活动历时估算是估算每个活动所占用的时间。根据活动开发的工作量的大小判断活动的时间。根据过去开发项目的经验，我对这次项目开发进行了估算。例如权限管理和用户管理功能因过去有开发项目的源代码，因此编码及单元测试的时间估算为2天。第五，制定进度表。制定进度表是项目时间管理中关键的一环，因此根据前导图，通过关键路径法制定出真个个开发过程的时间。需求分析1个月、系统设计1个月、系统编码6个月、系统测试1个月、系统培训1个月、系统试运行3个月。因此从系统需求分析到系统正式上线的周期大概为1年零1个月。第六，进度控制。进度控制对于项目时间管理来说是非常重要的环节。根据项目实际开发的时间与进度表的时间的偏差进行计算，判断项目时间进展情况。在开发的过程中，由于统计报表管理中人口计划生育国统七张表的统计口径根据政策发生了变更，然后活动重新进行了定义排序估算，根据新的时间，开发周期将会超期。为此，我们利用赶工的方法，加班加点把统计报表子系统在预计的周期内完成。 四、成本管理五、质量管理六、人力资源管理七、沟通管理八、风险管理九、采购管理十、干系人管理]]></content>
      <categories>
        <category>考证</category>
      </categories>
      <tags>
        <tag>信息系统项目管理师</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息系统项目管理师常考知识点]]></title>
    <url>%2F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[十大知识领域、五大项目管理过程组、47个过程启动过程组 2个 规划过程组 24个执行过程组 8个监控过程组 11个收尾过程组 2个 项目管理过程组 与 知识领域： 序号 十大知识领域 启动过程组 规划过程组 执行过程组 监控过程组 收尾过程组 1 项目整合管理 1. 制定项目章程 2. 制定项目管理计划 3. 指导与管理项目工作 4. 监控项目工作5. 管理控制变更 6. 结束项目或阶段 2 项目范围管理 7. 规划范围管理8. 收集需求9. 定义范围10. 创建WBS 11. 确认范围12. 控制范围 3 项目时间管理 13. 规划进度管理14. 定义活动15. 排列活动顺序16. 估算活动资源17. 估算活动持续时间18. 制定进度计划 19. 控制进度 4 项目成本管理 20. 规划成本管理21. 估算成本22. 制定预算 23. 控制成本 5 项目质量管理 24. 规划质量管理 25. 实施质量保证 26. 控制质量 6 项目人力资源管理 27. 规划人力资源管理 28. 组件项目团队29. 建设项目团队30. 管理项目团队 7 项目沟通管理 31. 规划沟通管理 32. 管理沟通 33. 控制沟通 8 项目风险管理 34. 规划风险管理35. 识别风险36. 实施定性风险分析37. 实施定量风险分析38. 规划风险应对 39. 控制风险 9 项目采购管理 40. 规划采购管理 41. 实施采购 42. 控制采购 43. 结束采购 10 项目干系人管理 44. 识别干系人 45. 规划干系人管理 46. 管理干系人参与 47. 控制干系人参与 记忆技巧: ①: 只有两个启动过程组,两个收尾过程组————-&gt;启动过程组只位于 整体管理 和 项目干系人管理; 收尾过程组只位于 整体管理 和 采购管理 ②: 范围,时间,成本,风险 没有 执行过程组(口诀: 范进成风无执行) ③: 人力资源管理 没有 监控过程组(口诀: 人力资源无监控) 范围管理——范 6时间管理(又称进度管理)——进 7整体管理——整 6沟通管理——狗 3质量管理——子 3成本管理——成 4人力资源管理 , 项目干系人管理——人 4,4风险管理——风 6采购管理——采 4 口诀: 范进整狗子,成人风采. 对应的过程数: 676 3344 464 口诀: 两启两收先来记 口诀: 范进成风无执行 口诀: 人力资源无监控 范围管理口诀: 范围需要先收集，裁剪补充再定义； 拆分工作创WBS，审批输出一基准 控制范围先确认. 进度管理口诀: 进度先要定活动，然后才能排顺序； 资源 时间要估算，这样才能制计划。 风险管理口诀: 风险识别要靠前，定性定量分析全； 已知未知要了解，这样才能来应对。 PMBOK五大过程组是什么？PMBOK五大过程组是：启动过程、规划过程、执行过程、监控过程、收尾过程。各用一句话概括项目管理知识体系五大过程组：1、启动过程组：作用是设定项目目标，让项目团队有事可做；2、规划过程组：作用是制定工作路线，让项目团队“有法可依”；3、执行过程组：作用是“按图索骥”，让项目团队“有法必依”；4、监控过程组：作用是测量项目绩效，让项目团队“违法必究”，并且尽量做到“防患于未然”；5、收尾过程组：作用是了结项目（阶段）“恩怨”，让一切圆满。 PMBOK十大知识领域是什么？PMBOK十大知识领域是：整合管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理、干系人管理。各用一句话概括项目管理知识体系十大知识领域：1、整合管理：其作用犹如项链中的那根线；2、范围管理：做且只做该做的事；3、时间管理：让一切按既定的进度进行；4、成本管理：算准钱和花好钱；5、质量管理：目的是满足需求；6、人力资源管理：让团队成员高效率地和你一起干；7、沟通管理：在合适的时间让合适的人通过合适的方式把合适的信息传达给合适的人；8、风险管理：“无事找事”，从而让项目“无险事”；9、采购管理：当好甲方；10、干系人管理：和项目干系人搞好关系并令其满意。 一、UML相关知识:UML: 统一的建模语言(Unified Modeling Language),独立于软件开发过程,它不是可视化的程序设计语言而是一种可视化建模语言 1.1 五种结构视图:①: 用例视图(用例图) ②: 逻辑视图 (类图 / 对象图): 又称设计视图描述系统的功能需求,表示了设计模型中在架构方面具有重要意义的部分,即类,子系统,包和用例实现的自己. ③: 进程视图(协作图,状态图,序列图,活动图): 并发问题, 关注进程,线程,对象等运行时概念,及并发,同步,通信 ④: 实现视图(构件图): 描述软件结构 构件图: 描述各种软件构件之间的依赖关系,是一种说明了系统静态实现视图 ⑤: 部署视图(部署图): 分布问题 部署图: 显示系统软硬件之间的物理架构, 是一种说明了系统体系结构的静态实施视图 口诀: 用逻辑进程实现部署, 静态实现构件图 1.2 UML2.0 中的14种图静态视图: ①: 部署图—&gt;部②: 对象图—–&gt;队③: 用例图——&gt;用④: 包图——-&gt;包⑤: 复合图(组合结构图)—-&gt;袱⑥: 制品图: 描述系统的物理结构,制品包括文件,数据库等—-&gt;制品⑦: 构件图—–&gt;够⑧: 类图—–&gt;累 口诀: 部队用包袱制品够累 动态视图: ①: 活动图—–&gt;东 ②: 顺序图—-&gt;西也称顺序图,按照时间顺序描述对象间的交互,强调对象间消息发送的顺序,显示对象间动态的合作关系. ②: 状态图—–&gt;装 ④: 通信图(UML1.0中 称 协作图)—-&gt;信描述对象间的交互和链接,显示对象间如何发送消息,其中顺序号指明消息的嵌套关系,和发生顺序. ⑤: 定时图: 是一种交互图,强调消息跨越不同对象或参与者的实际时间,而不仅仅只是关心消息的相对顺序.—–&gt;是⑥: 交互概览图(活动图和顺序图的混合物)—-&gt;交互 口诀: 东西装信是交互 1.3 类之间的关系四种:①: 关联(组合,聚合)②: 泛化③: 依赖④: 实现 【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门,鸟和翅膀的关系 口诀: 鸟翅组合强关联,相依为命同根生 【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 1.4 用例图:从用户的角度描述系统功能,描述的是系统用户与系统,系统与外部系统的交互,是开发者与用户交流的工具. 用例是系统的一个功能单元 1.4.1 用例图中用例之间的关系:①: 关联(association)②: 泛化(generialize)关系.③: 包含include(或使用User)④: 扩展(extends) 口诀: 类与用例两不同,包含扩展类中无 二、计算机组成原理相关2.1 关于总线:总线: 计算机中各个部件相连的通信线, 2.1.1 总线分以下4类:①: 中央处理器内部总线 寄存器与寄存器, 寄存器与运算器 ②: 部件内总线 一块插卡的内部总线(片级总线), 如显卡,多功能卡等插卡都使用了~实现本卡上各芯片互联 ③: 系统总线 各个功能部件(中央处理器,存储器,外设)之间互连的总线. 分为: 数据总线 ,地址总线 , 控制总线 ④: 外部总线 计算机系统之间,或者是计算机和其他设备 2.2 Cache:高速缓冲存储器,介于中央处理器和主存之间. 如果不命中则从主存中取出需要的块,同时送往CPU 和 Cache 写回法: 先写cache,并用标志位加以说明,直至经过重写的字块被从cache中替换出来时再写入主存 三、信息系统:一般指采集,处理,分析,存储,传输,检索信息的具有完整功能的集合体. 3.1 信息库存储大量数据,文档的资料库 包含内容:①: 网络目录(存放了电子表格软件,项目信件和数据等)②: 打印的文档③: 一个或多个Case工具目录②: 到上述组织的内联网网站接口 3.2 ERPERP: 是一个软件ERP项目: 管理变革项目,不像传统财务核算软件,只是替代用户的手工业务 ERP强调 事前计划,事中控制,事后分析的管理理念和及时调整的管理策略—–前计中控后分析 财务软件 强调 事后核算. 3.3 建立企业信息系统原则:自上而下的规划, 自下而上的分布实现 3.4 计算机的数据环境类型:按照管理层次从低到高排列: 数据文件—&gt;应用数据库—&gt;主题数据库—-&gt;信息检索数据库 3.5 总监理工程师代表 不能拥有的职权:①: 不能主持编写项目监理规划②: 不能签发工程开工报审表,工程竣工监理报告, 工程款支付证书③: 不能调解合同争议,处理索赔,审批工程延期④: 不能调换人员总结: 不能拥有与规划,开工,支付,索赔,人员,相关的职权 3.6 WebService协议和技术:WebService体系结构是一种面向服务的体系结构(SOA),这种体系结构设置了3个角色和3种操作. 简单说就是 一种跨编程语言和操作系统平台的远程调用技术. XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术. 3个角色: 服务提供者、服务请求者、服务注册中心(服务提供者在这里发布他们的服务描述)3种操作: 发布服务描述、查询或查找服务描述、根据服务描述绑定或调用服务. ①: XML : 是WebService平台中表示数据的基本格式. ②: SOAP: Simple Object Access Protocol 简单对象访问协议, 实现系统间能用“软件-软件对话的方式相互调用”,打破了软件应用,网站,和各种设备之间格格不入的状态,实现基于Web无缝集成的目标 ③: UDDI: 是一种规范,提供基于Web服务的注册和发现机制,目的是为电子商务建立标准. UDDI它为Web服务提供3个重要的技术支持: ①: 标准,透明,专门描述Web服务的机制 ②: 调用Web服务 ③: 访问Web服务注册中心 3.7 网络接入技术广义上说跟网络接入相关的都可以算是网络接入技术,如: LAN方式,拨号接入方式,DSL方式,光纤接入,Cabel Modem线缆调制解调器接入,IEEE802.11 无线局域网接入,GPRS和3G,HFC,XDSL,DDN,PSTN,ISDN ①: HFC: Hybrid Fiber Coaxial 混合光纤同轴电缆网,经济实用的综合数字服务宽带网接入技术,光纤干线,同轴电缆,用户配线网络三部分组成,有线电视台出来的节目信号,先变成光信号在干线上传输,到用户区后把光信号转为电信号,经过分配器分配后通过同轴电缆送到用户. ②: XDSL :数字用户线路 (Digital Subscribe Line)是各种DSL的总称,如ADSL,VDSL,SDSL等 ADSL: Asymmetric Digital Subscribe Line 非对称数字用户环路.所谓非对称指的是上行和下行带宽不对称. VDSL: Very Speed Digital Subscriber Line 超高速数字用户线路 CDMA: Code Division Multiple Access 码分多址 ③: DDN: (Digital Data NetWork)专线上网方式,传输速率高,质量好,延时小等特点,将数万或数十万条光缆为主体的数字电路,通过数字电路管理设备构成的数据传输基础网络. 注: NetBEUI: 不属于网络接入技术,它用于本地局域网,不能与其他网络的计算机进行沟通 3.8 数据仓库数据仓库的用户为管理层,它的数据随业务持续增长. 面向主题的,集成的,相对稳定的反映历史变化的数据集合,用于支持管理决策 是对多个异构数据源(包括历史数据)的有效集成,集成后按照主题重组,其中的数据一般不再修改,且数据随业务持续增长. 3.9 SAN(存储区域网络)包括FCSAN 和 IPSAN FCSAN 使用数据传输协议中的 FiberChannel(FC: 一种高速网络技术标准,千兆位数据传输的技术标准) 3.10 ISCSIInternet Small Computer System Interface, 它基于TCP/IP协议 3.11 信息化项目监理分三种: ①: 咨询式监理 ②: 里程碑式监理 ③: 全程式监理 3.12 软件构件(软件中间件)的标准:①: OMG组织(对象管理组织)提出的CORBA 为解决分布式处理环境中软硬件的互连而提出. ②: 微软提出的COM 组件架构** ③: SUN提出的EJB: 用于封装业务, 中间层业务功能由EJB构件实现,JSP用于实现业务逻辑处理结果的动态发布,构成动态的HTML页面,中间层也可用servlet实现更为灵活的动态页面. 3.13 信息系统工程监理活动主要内容::四控,三管,一协调. 四控: 信息系统工程的质量控制进度控制投资控制变更控制 三管: 信息系统工程的合同管理信息管理安全管理 一协调: 协调有关单位间的工作关系. 3.14 监理文件3.14.1 监理规划在监理委托合同签订后,由总监理工程师主持编写,监理单位技术负责人书面批准的指导监理开展工作的纲领性文件 作用: ①: 监理项目部职能的具体体现②: 指导监理项目部开展工作③: 信息系统工程监理管理部门进行监督 监理单位的主要内容和依据④: 建设单位 检查 监理单位是否能认真,全面履行信息系统工程监理委托合同的重要依据 3.14.2 监理实施细则在监理规划指导下,由专业监理工程师针对项目具体情况制定的更具有可实施,可操作的业务性文件,指导具体监理业务的开展. 3.14.3 监理大纲 :是社会监理单位为了获得监理任务,在投标前由监理单位编制的项目监理方案性文件,是投标书的重要组成部分, 3.16 进度控制技术手段:①: 甘特图②: 网络图单代号网络图: 箭头是关系, 结点是活动双代号网络图: 箭头是活动, 结点是事件.③: 香蕉 曲线图法两条S型曲线组合而成的闭合曲线:ES曲线是: 计划以各项工作的最早开始时间安排进度而绘制LS曲线是: 计划以各项工作的最迟开始时间安排进度而绘制ES各点均在LS各点的左边,ES和LS起点和终点相同,所以ES与LS围成的图形像香蕉. 注: ABC分析法:帕累托分析法,把分析的对象分成A,B,C三类,从而有区别地确定管理方式 3.17 旁站监理:是监理单位控制工程质量的重要手段,主要在关键部位或关键工序施工过程中,由监理人员在现场进行的监督活动.网络综合布线,设备开箱检验,机房建设等活动涉及隐蔽工程,需要进行旁站监理,确保这些活动的过程质量. 3.18 信息系统常用开发方法:①: 结构化方法 三部分组成: 结构化方法.结构化设计,结构化程序设计. 基本思想: 用户至上(开发人员始终与用户保持联系),自顶向下设计,自底向上逐步实现,模块化设计 按照信息系统生命周期,应用结构化系统开发方法,将整个系统开发过程分为若干阶段,然后一步一步依次进行,前一阶段是后一阶段的依据. 包括数据流的分析方法: 数据流图,数据字典 缺点: 开发周期长, 难以适应需求变化,不适合开发大规模的复杂的系统 ②: 原型方法 需求不清, 快速开发一个原型系统, 通过反复修改来实现最终系统需求 ③: 面向对象方法OO 面向对象法分三个阶段: 分析: 分析模型由 用例模型,类-对象模型,对象-关系模型,对象-行为模型组成. 设计 概要设计(软件基础架构),详细设计(完整的类架构) 主要是类设计,用例设计,子系统设计 实现 ④: 面向服务的方法SO 跨构件的功能调用,进一步将接口定义和实现解耦,使信息系统快速响应需求与环境变化 3.19 信息系统的生命周期:3.19.1 项目的生命周期分四个阶段:①: 启动②: 计划③: 执行④: 收尾 3.19.2 信息系统的生命周期分四个阶段:①: 立项②: 开发③: 运维④: 消亡 开发阶段细分为5个阶段 划——总体规划阶段分——系统分析阶段即——系统设计阶段实——系统实施阶段验——系统验收阶段 口诀: 划分即实验 ①: 系统规划阶段 (初步调查,可行性分析和项目开发计划)———-&gt;划 做系统调查和可行性分析 对现行系统的状况进行初步调查,研究建设新系统的必要性和可能性,拟定系统的备选方案,对这些方案进行可行性研究,写出可行性研究报告,可行性研究报告审议通过后,将新系统建设方案及实施计划编写成系统设计任务书 可行性研究: 操作可行性,技术可行性,经济可行性. 经济可行性分析: 包括 支出分析, 收益分析, 收益投资比, 投资回收期,敏感性分析. 该阶段最终形成可行性研究报告 系统设计任务书 可行性研究方法: 经济评价法,市场预测法,投资估算法,增量净收益法等. ②: 系统分析阶段(需求分析) 又称逻辑设计阶段——–做什么———&gt;分 根据系统设计任务书所确定的范围,对现行系统进行详细调查,描述缺陷和不足,然后确定新系统的目标和逻辑功能. 为设计阶段提供新系统的逻辑模型,内容包括组织结构及功能分析,业务流程分析,数据和数据流程分析数据流图DFD 系统说明书: 既是给用户看的,也是下一阶段的工作依据,也是将来验收系统的依据,用户通过它了解未来系统的功能,判断是否为要求的系统 该阶段最终形成系统说明书 ③: 系统设计阶段(概要设计,详细设计)————-怎么做——–&gt;即 根据系统说明书中规定的功能要求,考虑实际条件,具体设计实现逻辑模型的技术方案. 系统架构设计,数据库设计,功能模块设计,安全控制方案设计等 E-R图描述现实世界概念模型,用于数据库设计 ④: 系统实施阶段(编码,测试)——-&gt;实 将设计的系统付诸实施,这一阶段包括 计算机等设备的购置,安装和调试,程序的编写和调试,人员培训,系统调试等系统实施按实施计划分阶段完成,每阶段写出实施进展报告,系统测试后写出系统测试分析报告. 该阶段最终形成实施进展报告,系统测试分析报告 ⑤: 系统维护阶段(或验收运行维护)———&gt;验 口诀: 划分即实验 易错点: ①: 规划阶段产生 系统设计任务书 而不是设计阶段产生 ②: 分析阶段 产生 逻辑模型,设计阶段来实现, 而不是实施阶段来实现. 3.20 企业中信息系统的分类:3.20.1 根据服务对象而言分为:①: 面向作业处理: OA办公自动化系统,DAMS数据采集与监测*系统 ②: 面向管理控制 KM知识管理系统,CIMS计算机集成制造系统 ③: 面向决策计划 MES管理专家系统,DSS决策支持系统,SIS战略信息系统 3.21: 网络存储3.21.1 现有存储的三大模式:①: 直接附加存储DAS,不带任何存储操作系统 ②: 网络附加存储NAS(NetWork Attached Storage: ) 是将存储设备通过标准的网络拓扑结构(如以太网)连接到一系列计算机上. 它是一种专用的数据存储服务器,它以数据为中心,将存储设备和服务器彻底分开,NAS在网络中独立的设备,分配IP地址,通过网络来访问和存取. 支持多种TCP/IP协议,支持即插即用,类似于文件服务器 ③: 存储区域网络 SAN :易扩展的存储技术 注: 哈希散列表存储: 不是网络存储结构, 它是根据关键码值而直接进行访问的数据结构(也就是把关键码值映射到表中一个位置来访问记录,以加快查找速度) 3.22 .NET一般的高级程序语言(C#,VB)会直接将代码编译为机器语言,而编译.NET是不同的,多了一个环节,就是先将高级语言编译成为中间语言(IL),中间语言最终编译为机器代码.这些中间语言是.NET框架中所有语言编译后的结果,比如C#,VB语言编写的两个类,编译后中间语言看起来一样,这就显示了.NET跨平台的事实. 3.23 常见产品与语言:.NET Framework —&gt;可用于C#,C++,VBWASP是web应用框架—–&gt;使用PHP5开发DelPhi是集成开发环境IDE—-&gt;使用PascalGLUE是一种java扩展包 3.24 CRM是集成化的信息管理系统, 存储了企业现有和潜在客户的信息,并且对这些信息进行自动的处理从而产生更人性化的市场管理策略. 它是以客户为中心的商业策略,而不是传统的以产品或市场为中心将业务中心转移到客户,根据不同的客户有重点的采取不同的策略 3.25 工作流工作流技术不是开发过程管理的技术,所以它不能提升开发过程的灵活性 主要提供业务流程建模,管理,控制功能. 3.26 2G/3G/4G标准GSM 是2G标准 GPRS是2G移动数据业务 四种国际3G标准: WCDMA,CDMA2000,WinMAX,TD-SCDMA(时同步码分多址,由中国自主研发) LTE是4G标准 3.27 电子商务:原始电子商务: 使用电子信息技术工具进行商务活动凡使用诸如电报,电话,广播,点水,传真以及计算机,计算机网络等手段,工具进行商务活动,都可称之为电子商务. 3.27.1 第四方物流为第一,二,三方提供物流规划,咨询,物流信息系统,供应链管理等活动.它是一个供应链的集成商,是供需双方及第三方物流的领导力量. 3.27.2 第三方物流:生产经营企业为集中搞好业主,把原来属于自己处理的物流活动,以合同方式委托给专业物流服务企业,同时提供信息系统与物流企业保持密切联系,以达到对物流全程管理控制的一种物流运作和管理方式. 3.28 经济计量分析:工作程序顺序:设定模型—&gt;估计参数—&gt;检验模型—&gt;应用模型 3.29 关于GCCGNU Compiler Collection , 即GNU编译器套件 , 它是以GPL许可证所发行的自由软件,也是GNU计划的关键部分. 3.30 文件审批流程承建方提交的&lt;&lt;项目质量管理计划&gt;&gt;先由建设方技术总监对内容,范围审核后,再送交监理方批准 3.31 关于监理①: 当专业监理工程师需要调整时,总监理工程师应该 书面通知 建设单位和承包单位. ②: 当总监理工程师需要调整时,监理单位应该征得建设单位同意并书面通知建设单位 监理单位应该于委托监理合同签订后10个工作日内将监理项目部的组织形式,人员构成及对总监理工程师的任命书书面形式通知建设单位. 建设单位应该将委托的监理单位,监理内容,书面通知承建单位. 3.32 企业信息化结构分类: ①: 产品层②: 作业层③: 管理层④: 决策层 3.33 云计算是一种服务关键技术:虚拟化 : 是一种资源管理技术, 包括服务器虚拟化 和 应用虚拟化分布式系统: 分布式存储 和 分布式计算 3.34 操作系统安全①: 切断: 可用性的威胁: 如非法用户破坏硬盘,破坏系统资源等 ②: 截取 机密性的威胁:非法窃取和拷贝文件等 ③: 篡改 完整性的威胁,非法用户修改网络中正在传送的消息等 ④: 伪造 合法性的威胁,如非法用户把伪造的消息插入系统中等 口诀: 切可用,截机密,篡完整,伪合法 3.35 信息安全:①: 设备安全: 是信息系统安全的首要问题,稳定,可靠,可用性 ②: 数据安全: 秘密,完整,可用性 ③: 内容安全: 政治,法律,道德层次 ④: 行为安全 ⑤: 物理安全: 机房出入口应该安排专人值守,控制,鉴别和记录进入的人员. 注: 不包括人员安全 3.36 物联网两项关键技术: ①: 传感器技术: 感受被测量的信息,将模拟信号转换为 ②: 嵌入式技术 3.37 智能 特点①: 感知能力 ②: 记忆,思维能力: 能存储感知到的外部信息,及由思维产生的知识,同时能利用已有的知识对信息进行分析、计算、比较、判断、联想、决策. ③: 学习,自适应能力: 通过与环境的相互作用,不断学习积累知识,使自己能适应环境. ④: 行为决策能力 注: 思维能力 和 学习能力自适应能力概念容易混淆, 所以 只要记住 出现 学习和自适应就是学习自适应能力 3.38 区块链:3.38.1 定义:是分布式数据存储 、点对点传输、共识机制、机密算法等计算机技术的新型应用机制. 3.38.2 区块链2.0 技术架构自下而上分为数据层: 网络层: 包括 P2P组网机制, 数据传播机制,数据验证机制 共识层: 激励层: 智能合约层: 3.39 IaaS 、PaaS 、SaaS云服务只是一个统称，可以分成三大类: IaaS: Infrastructure-as-a-service 基础设施即服务——-&gt;向用户提供计算机能力、存储空间,等基础设施方面的服务 PaaS: Platform-as-a-service 平台即服务——–&gt;向用户提供虚拟的操作系统、数据库管理系统、Web应用等平台化的服务. SaaS: Software-as-a-service 软件即服务—–&gt;向用户提供应用软件如CRM、办公软件等, 简言之: IAAS就是服务器，也就是硬件PAAS就是开发工具SAAS就是码农做出来的网站 三者的区别详解: 请设想你是一个餐饮业者，打算做披萨生意。 （1）方案一：IaaS 他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。 （2）方案二：PaaS 除了基础设施，他人还提供披萨饼皮。 你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。 （3）方案三：SaaS 他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。 SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。 IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。 3.40 EAI 企业应用集成作用: 消除消息孤岛,将多个信息系统连接起来,实现无缝集成. ①: 控制集成: 在业务逻辑层上 ②: 业务流程集成: 或称 过程集成, 超越了数据 和 系统, 由一系列的标准的统一的数据格式的工作流组成. ③: 数据集成是白盒集成 ④: 表示集成: 也称 界面集成 属于黑盒集成. 注: 控制集成 与 业务流程集成 概念上易混淆, 所以只记住 控制集成: 在业务逻辑层上就Ok. 3.41 设备安全①: 稳定性: 一定时间内不出故障的概率 ②: 可靠性: 一定时间内能正常执行任务的概率 ③: 可用性: 随时可以正常使用的概率 3.42 网络安全①: 防火墙: 将内部网和公众访问网分开.阻挡对网络的非法访问和不安全数据的传递,使得本地系统和网络免于受许多网络安全威胁 ②: 入侵检测系统: 注重的是网络安全状况的监管,通过监视网络或系统资源,寻找 违反安全策略的行为或攻击迹象,并发出报警, 核心是 数据分析 ③: 入侵防护系统: 倾向于提供主动防护,注重对入侵行为的控制,设计宗旨: 预先对入侵活动和攻击性网络流量进行拦截 ④: 蜜罐技术: 通过模拟一个或多个易受攻击的主机和服务,给攻击者提供一个容易攻击的目标. 做个比喻: 防火墙相当于小区保安,在门口拦截一切可疑人等,而入侵检测系统相当于小区里的监控,监控小区里面发生的异常. ⑤: 访问控制: 分为自主访问控制和强制访问控制两大类 自主访问控制: 用户有权对自己创建的对象进行访问,并可以将这些对象的访问权限授权于其他用户,或收回权限 强制访问控制: 由系统(通过专门设置的系统安全员)对用户所创建的对象进行统一的强制性控制,按照规定的规则决定哪些用户可以对哪些对象进行什么样的操作,即使是创建者用户,在创建一个对象后,也可能无权访问该对象. 3.43 信息系统规划工具P / O矩阵: 过程/组织矩阵(Progress/organization) C/U矩阵: 创建/用户矩阵(Create/User): 数据类型 和 企业过程 R/D矩阵: 资源/数据矩阵(Resource/Data): 3.44 CCB 变更控制委员会CCB(Change Control Board) 在CMMI(Capability Maturity Model Integration)中，是“变更控制委员会”的含义，同时具有配置控制委员会（Configuration Control Board）的含义。 CCB可以由一个小组担任，也可以由多个不同的组担任，负责做出决定究竟将哪些已建议需求变更或新产品特性付诸应用。典型的变更控制委员会会同样决定在哪一些版本中纠正哪些错误。 CCB的成员应当能代表变更涉及的团体。其可能包括如下方面的代表： 1.产品或计划管理部门 2.项目管理部门 3.开发部门 4.测试或质量保证部门 5.市场部或客户代表 6.制作用户文档的部门 7.技术支持部门 3.44.1 CCB负责组织 对 变更申请进行评估 并确定以下内容:①: 变更对项目的影响 ②: 变更的内容是否必要 ③: 变更的范围是否考虑周全 ④: 变更的实施方案是否可行 ⑤: 变更工作量估计是否合理 CCB决定是否接受变更,并将决定通知相关人员 变更由变更控制委员会CCB审批 3.45 变更请求:由项目经理审查,评价, 由CCB来批准或否决. CCB决定是否变更项目基准. 项目经理负责项目的监控. 注: 项目集指导委员会 是项目的决策机构,负责为项目集的管理方式提供支持. 3.45.1 配置项的三种状态:①: 草稿: 配置项刚建立时 如 V 0.X ②: 正式发布: 配置项通过评审后,其状态变为”正式发布” 如V 1.X; V2.X; V3.X等 ③: 正在修改: 正式发布后,如果修改必须依照”变更控制规程”执行,其状态变为”正在修改”.当配置项修改完毕并通过评审时,其状态又变为”正式发布”,如此循环. 如V 1.XY V2.XY 小升级是升级小数点后面的数字, 第一次小升级为V1.1 ,第二次为V1.2 , 所以二次小的升级后版本号是V1.2 注: X.YZ 是表示正在修改的版本 3.46 两化融合①: 工业化 和 信息化 发展攻略的融合 主攻方向: 智能制造 3.47 大数据 3.48 信息系统安全等级第一级: 用户自主保护——&gt;普通内联网用户—-&gt;普用 第二级: 系统审计保护——&gt;通过内联网进行商业活动,需要保密的非重要单位.—商用 第三级: 安全标记保护——-&gt;地方各级国家机关,该级别受到破坏后会对社会秩序,和公共利益造成严重损害,或对国家安全造成损害.—-地国 第四级: 结构化保护——–&gt;中央级国家机关,国家重点科研单位机构—–中央国 第五级: 访问验证保护级——-&gt;国防关键部门——最高级别 口诀: 一主二审三标四化五验证 口诀: 验国防,化中央,标地方 3.49 互联网+ 3.50 项目建议书的内容①: 项目的必要性 ②: 项目的市场预测 ③: 项目建设必须的条件 ④: 产品或服务的市场预测 不包含风险因素和对策 3.51 开发总成本①: 研发成本 ②: 行政管理 ③: 销售与分销 ④: 财务费用和折旧 注: 前三个成本的总和为经营成本 3.52 变更性质①: 重大变更 ②: 重要变更 ③: 一般变更 3.53 组织级项目管理①: 项目组合管理: 通过选择正确的项目集和项目、设定工作的优先级并提供必要的资源的方式来促成组织的战略实现. ②: 项目集管理: 对其所包含的项目子集和项目的依赖关系进行有效的管理,从而实现项目集的特定利益 ③: 项目管理: 通过制定和实施集合来完成特定的工作范围,支持项目集和项目组合目标的实现.最终确保组织战略得以实现. 要求三者战略方向一致 3.54 评审和审计①: 管理评审: 监控进展决定计划和进度的状态,或评价用于达到目标所用管理方法的有效性. ②: 技术评审: 评价软件产品,已确定其对使用意图的适合性. 口诀: 管监控,技意图 评审者按照规范的步骤对软件需求、设计、代码或技术文档进行仔细地检查,以找出和消除其中的缺陷.目的主要在于发现问题和验证符合性. 注: 评价所用管理方法的有效性属于过程管理或过程审计的内容,不属于技术评审. ③: 走查 ④: 审计: 是正式组织的活动,识别违例情况,并要生成审计报告,采取根正性行动. 审计的目的: 提供软件产品对于可应用规则标准指南计划和流程的遵从性的独立评价. 3.55 权力/利益分析法: 属于第二区域的项目干系人: 项目的客户, 项目经理的主管领导—————-权力大,利益高应该重点管理 3.55.1 成员:项目团队成员属于: 供应商属于: 项目经理属于: 3.55.2 管理策略原则:权力高,利益高 的干系人的管理策略是: 重点管理,即使报告 权力高,利益低 的干系人 的管理策略是: 令其满意 权力低,利益高的干系人 的管理策略是: 随时告知 权力低,利益低的干系人 的管理策略是: 花较少的精力监督即可. 口诀: 重点管理双高, 权高利低满意即可 3.56 项目计划①: 一般的项目计划: 主要关注的是 项目活动的计划. ②: 大型及复杂的项目: 制定活动计划 之前必须考虑项目的过程计划,也就是必须考虑用什么方法和过程来完成项目. 过程计划: 制定过程, 执行过程,监督过程,但不包括 裁剪过程. ③: 大型及复杂的项目的控制过程 有3个重要因素: 项目绩效跟踪,外部变更请求,变更控制. 注: 里程碑设置 不管是 小项目还是大项目一般都需要 3.57 网络系统的设计原则①: 可靠性原则 ②: 安全性原则 ③: 高效性原则 ④: 可扩展性原则: 能在规模和性能两个方向上进行扩展 3.58 项目管理办公室①: 建立项目管理的支撑环境 ②: 提供项目管理指导咨询 ③: 多项目的管理和监控 注: 制定项目管理计划 由 各项目团队来做. 3.59 信息物理系统CPS是一个综合计算,网络和物理环境的多维复杂系统,通过3C(Computer,Communication,Control)技术的融合与深度写作实现大型工程系统的实时感知,动态控制和信息服务.CPS实现计算,通信,与物理系统的一体化,可以使物理系统更加可靠,高效,实时协同. 3.60 布线 3.61 对象模型技术OMT把需求分析收集的信息构造在三层模型中,即对象模型,动态模型,功能模型 对象模型: 对谁做 动态模型: 何时做 功能模型: 做什么 3.62 项目配置项详细设计,概要设计,源代码的成果是一定要进入基线配置项的,因为这些是软件开发的产品过程成果,必须纳入基线严格管理. 注: 进度计划一般不会纳入基线来管理 3.63 软件版本号小升级是升级小数点后面的数字, 第一次小升级为V1.1 ,第二次为V1.2 , 所以二次小的升级后版本号是V1.2 注: X.YZ 是表示正在修改的版本 3.64 未来经济发展的重要特征:数据驱动 3.65 网络安全审计从审计级别上分为: ①: 系统级审计 ②: 应用级审计 ③: 用户级审计 3.66 企业级项目管理办公室PMO分类: 日常性职能,战略性职能 战略性职能: 项目组合管理,确定资源分配优先顺序,提高企业项目管理能力 3.67 绩效评估的过程①: 制定绩效评估计划 ②: 确定评估项 ③: 组织评估团队 ④: 收集审核绩效数据资料 ⑤: 进行定量,定性分析 ⑥: 归纳分析撰写评价报告 3.68 需求阶段本阶段的工作成功,应该 编制 需求规格说明书,初步用户手册,和数据要求说明. 3.69 项目的组织结构:职能型型组织: 项目型: 1) 员工缺乏事业上连续性和保障,因为项目解散了,员工不好安排 2) 不利于沟通,技术知识共享 3) 难以监测控制 矩阵型: 缺点: 项目组成员可能接受多头领导 3.70 人员职责QA: 检查工作产品及过程与规范的符合性 项目经理: 组织对概要设计同行评审 过程改进小组: 组织对软件的过程的改进 配置管理员: 文件版本管理 3.71 开放式系统的特点:①: 可移植性/兼容性 ②: 可裁剪性 ③: 互操作性 3.72 对称加密与非对称加密与数字摘要算法:3.72.1 对称加密:加密和解密都是同一个密钥. 特点: 加密解密快, 密钥管理简单, 加密强度不高, 只适合一对一传输,不适合一对多加密传输. 举例: DES,,3DES, SDBI, RC4, AES, IDEA DES: 64比特明文+ 64比特密钥———&gt;16次加密变换====&gt;得到64比特密文 64比特密钥包含8比特奇偶校验位,所以实际密钥长度为56位. 3DES: 三重DES,密钥长度128位,实际112位,3DES相当于两倍于DES密钥长度的加密效果. IDEA: 密钥长度128位 3.72.2 非对称加密一般A向B发送内容信息: 加密用公钥,解密用私钥如果是数字签名技术: 将摘要信息用发送者私钥加密,与原文一起发送给接收者,接收者只有用 发送者公钥解密才能得到被加密的摘要信息,然后用HASH函数对收到的原文产生一个摘要信息,与解密的摘要信息对比. 注意: 综上: 非对称算法其实 并不区分加密密钥和解密密钥,每个密钥都可以用来加密 和 解密. 密钥管理复杂,需要第三方认证中心 举例: RSA,ECC 3.72.3 数字摘要举例: MD5, SHA 3.72.4 CA安全认证中心是发放,管理,废除数字证书的机构,并作为受信任的第三方,承担PKI体系中公钥合法性检验的责任. 数字签名: 非对称密钥加密技术与数字摘要技术综合应用,可以防消息抵赖 认证技术: 防信息被假冒,通常是PKI/CA证书体系 加密技术: 防信息被窃取,包括各种对称密钥,非对称密钥算法 完整性技术: 防信息被篡改,常见的数字摘要(HASH)算法有MD5,SHA 3.73 软件设计分类: 结构设计, 数据接口设计, 过程设计 结构设计: 软件系统各主要部件之间的关系. 数据设计: 接口设计: 软件内部,软件和操作系统间以及 软件和人之间如何通性. 过程设计: 3.74 配置管理3.75 大型项目统一项目过程中没有优化过程 3.76 监理审查承建单位选择的分包单位的资质是在什么阶段?建设工程实施准备阶段 3.77 建设和承建单位的区别建设单位: 执行国家建设计划,使用建设投资的单位 承建单位: 具体施工单位,没有什么权利 3.78 管理科学 3.79 J2EE核心技术 四、软件工程相关4.1 数据流图:4.1.1 四个要素:①: 数据流②: 加工③: 数据存储④: 外部实体 : 存在于软件系统之外的人员或组织 4.2 软件维护:交付前和交付后,都要进行,是为需要提供软件支持的全部活动 4.2.1 四种类型:①: 纠正性维护: 改正测试阶段未发现,投入生产运行一段时间后暴露的问题——&gt;就②: 适应性维护: 能适应变化(如迁移数据库,或操作系统),环境变化后能继续使用——-&gt;是③: 预防性维护: 更正潜在错误,为改进软件未来的可维护性,和可靠性,或者给未来的改进提供更好的基础而做出的修改–&gt;鱼④: 完善性维护: 增加功能——&gt;丸 口诀: 就是鱼丸 技巧: 题目中出现预防 / 未来 / 潜在 等字,基本可锁定预防性维护 4.3 开发方法:4.3.1 原型法:需求不清, 快速开发一个原型系统, 通过反复修改来实现最终系统需求 4.3.2瀑布模型:明确所有需求,变更少,不需要二次开发 瀑布模型将软件生命周期分为制定计划(问题定义,可行性研究),需求分析,软件设计(概要设计,详细设计),软件实现(编码),软件测试,运行维护等六个阶段. 4.3.3 喷泉模型描述面向对象的软件开发过程 4.3.4 V模型 ①: 开发和测试同等重要,左侧代表开发阶段,右侧代表测试阶段②: 针对每个开发阶段,都有一个测试级别与之对应③: 适用于需求明确和需求变更不频繁的情形 单元测试: 一般由开发人员来执行, 针对编码过程, 检查每个模块内是否正确实现了详细设计说明中的功能性能,接口等集成测试: 针对概要设计,检查模块间的接口关系,和验证已集成的软件是否符合设计要求.系统测试: 针对需求分析, 检查系统作为一个整体是否有效的得到运行,验收测试: 通常由业务专家或用户进行,确认产品功能,性能是否符合用户业务上的需要是否和用户需求一致. 4.3.5 增量迭代模型需求不确定 很多不确定因素且项目参与人员还不能完全理解项目需求,范围,计划多期开发. 4.4 CMMI 模型:Capability Maturity Model Integration 能力成熟度集成模型,整合了不同的CMM模型 两种表示方法: ①: 阶段式: 组织的成熟度等级针对整个组织进行统一评价成熟度等级 1) 初始级CMM1: 管理无章法，缺乏健全的管理制度 2) 可重复级 CMM2 : 新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件 3) 已定义级 CMM3 : 开发过程，包括技术工作和管理工作,均已实现标准化、文档化。建立了完善的培训制度和专家评审制度 4) 已管理级(定量管理级) CMM4 : 产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的 5) 优化级 CMM5 : 拥有防止出现缺陷、识别薄弱环节以及加以改进的手段 已管理级 有7个过程域: 过程和质量保证 : 使工作人员客观洞察过程和相关工作产品 ②: 连续式: 组织的过程能力等级 针对组织的某些过程度评级(相对单个过程域),即评价组织的某个PA的能力等级为2级或3级. 口诀: 阶段组成熟,连续组过能 4.5 软件质量模型:4.5.1 McCall 质量模型:三种视角来定义和识别软件质量 ①: 产品转移: 可移植,可复用性 ②: 产品修改: 可维护 ③: 产品运行: 正确,可靠,效率,完整性 4. 6 需求分析:4.6.1 作用:描述一个系统必须做什么,或者一个系统是什么(从用户那里了解需求的本质,知道软件需要做什么功能.) 4.6.2 需求分析阶段用到的图形工具:①: 层次方框图: 又称层次模块结构图, 将系统分为若干个子系统,子系统再划分为若干个模块,大模块再分为若干小模块,需求分析阶段可以用此图画出系统的功能蓝图. ②: 用例图: 从用户角度描述系统功能,是用户所能观察到的系统功能模型图,它可以用于需求分析阶段 ③: IPO图: Input Processing Output 输入加工输出, 描述功能需求的输入和输出,它可以用于需求分析阶段 注: N-S图也称盒图,不能用于需求分析阶段, 在流程图中完全去掉流程线,全部算法写在一个矩形阵内,在框内还包含其他框的流程图形式.主要用于程序设计 4.6.3 产生的文档:软件需求规格说明,数据要求说明,初步用户手册 初步用户手册通常是需求人员编写,写完需求文档,就可以写初步用户手册了(肯没有最终的功能界面,但已经可以作为联机帮助手册) 注: 数据库设计是 详细设计的产物, 软件产品规格说明(产品说明书) 是 产品做出来后写的 4.7 软件需求4.7.1 需求的层次:①: 业务需求 企业或客户对系统高层次的目标要求,业务需求通常来自 项目投资人,购买产品的客户,实际用户的管理者,市场营销部门或产品策划部门. ②: 用户需求 描述用户的目标, 用户要求系统必须能完成的任务 ③: 系统需求 包括功能需求,非功能需求非功能性需求: 系统必须具备的属性或品质,及设计约束 4.7.2 系统需求分类①: 功能需求: 开发人员必须在产品中实现的软件功能,用户利用这些功能来完成任务,满足业务需求 例如: 按照订单及原材料自动安排生产排序定期生成销售分析报表 ②: 性能需求 软件或人与软件交互的静态或者动态数值需求.如响应速度,处理速度 ③: 外部接口需求 用户接口,硬件接口,软件接口,通信接口 ④: 设计约束和质量属性 设计约束: 受硬件限制例如: 系统可实现对多字符集支持,GBK,BIG5,UTF-8等必须运行在UNIX系统下等 属性: 可用性,安全性,可维护性,可转移/转换性,效率例如: 系统同时支持1000个独立站点的并发访问.系统实行同城异地双机备份,保障数据安全 技巧: 看到”必须完成” 基本可以锁定功能需求 看到”速度”基本可以锁定性能需求 看到”安全,并发,字符集”基本可以锁定约束和质量属性 4.7.3 质量功能部署QFD对需求的分类:QFD: Quality Function Deployment : 是一种将用户要求转换为软件需求的技术. 常规需求: 用户认为系统应具备的功能 期望需求: 用户想当然认为系统应具备的功能 意外需求: 用户没有提出的,开发人员自己加的 4.7.4 需求分析的阶段①: 需求提出 ②: 需求描述 ③: 需求评审 4.8 敏捷方法敏捷软件开发宣言:①: 个体和交互胜于过程和工具: 以人为本的思想②: 可以工作的软件胜于面面俱到的文档③: 客户合作优于合同谈判④: 响应变化优于遵循计划 4.9 软件过程改进4.9.1 五条核心原则:①: 注重问题②: 强调知识创新③: 鼓励参与④: 领导层的统一⑤: 计划不断改进 4.10 软件测试4.10.1 从是否关心软件内部结构和具体实现的角度分类: 白盒测试 黑盒测试 灰盒测试: 介于白盒和黑盒之间,多用于集成测试阶段 4.10.2 边界值分析法是一种黑盒测试用例设计方法,针对每一个边界,取一个刚好超出边界的值,再取一个刚好在边界内 或等于 的值. 例如: 10&lt;=X&lt;=100,X为整数, 则测试用例为 X=9,X=10, X=100,X=101 例如10&lt;=X,X为整数,则测试用例为: X=9,X=10 4.10.2 从是否执行程序的角度分类: 静态测试 和 动态测试 4.10.2.1 静态测试: 不运行被测程序本身,仅通过分析或检查源程序的语法,结构过程,接口等来检查程序的正确性.代码的静态测试 和 文档的静态测试. 对文档的静态测试: 检查单的形式进行 对代码的静态测试: 采用桌前检查, 代码走查, 和代码审查 桌面检查: 对程序执行情况,进行人工模拟,逐步检查源代码中有无逻辑或语法错误的方法来检测故障. 代码走查: 程序员或设计者引导开发组成员通读已经书写的设计文档或编码 代码审计: 由某人、某小组或借助某种工具对代码进行独立的审查,以验证其是否 符合软件设计文件 和程序设计标准. 代码评审: 也称代码复查, 通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动. 口诀: 捉错误, 揍设编, 审标准, 评质量 4.10.2.2 动态测试: 通过运行被测程序,检查运行结果与预测结果的差异,并分析运行效率,正确性和健壮性等性能,该方法由三部分组成: 构造测试用例,执行程序,分析程序的输出结果.白盒测试属于动态测试 注: 黑盒测试 : 也称 功能测试,不关注内部结构 4.11 设计模式①: 根据 处理范围不同: 分为类模式和对象模式 类模式处理类与子类之间的关系,通过继承建立,在编译期间确定,属于静态关系 对象模式 处理对象之间的关系,在运行时刻变化,更具有动态性. ②: 根据目的与用途分为 : 创建型, 行为型,结构型 4.12 软件测试类型①: 回归测试: 修改了旧代码后,重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误. ②: 冒烟测试: 这一术语源于硬件行业 ③: Alpha测试 ④: Beta测试 ⑤: 静态测试 五、计算机网络 OSI 7层模型: 物理层————巫数据链路层——术网络层————忘传输层————传会话层————会表示层————彪应用层————鹰 口诀: 巫术忘传会彪鹰 5.0 会话层管理主机之间的会话进程,即负责建立,终止进程之间的会话,还利用在数据中插入校验点来实现数据同步. 5.1 传输层:传输层: 实现端用户之间可靠通信 SPX(序列分组交换协议) 5.2 表示层对上层数据或信息进行转换,以保证一个主机应用层信息,能被另一主机的应用程序理解. MPEG协议 数据加密,压缩,格式转换. 5.3 物理层:①: 集线器: 收集多个端口来的数据帧,并广播出去 是共享带宽式的,带宽由端口平均分配 ②: 调制解调器: 模数/数模信号转换③: 中继器: 用于完全相同的两类网络的互连,对数据信号重新发送或转发,来扩大网络传输距离. IEEE802.11: 标准定义了三种物理层通信技术:直接序列扩频跳频扩频漫反射红外线 5.4 数据链路层:以太网交换机,根据以太帧中的地址转发数据帧. IEEE802系列规范 5.5 网络层5.5.1 路由器:5.5.2 路由协议分类:内部网关协议IGP: 在一个AS(AutonomousSystem)自制系统(指有权自主决定在本系统应该采用何种路由选择协议的网络)内的路由协议 外部网关协议: AS之间的路由协议 5.6 100BaseFX:F: fiber光纤 是在光纤上实现的100Mbps标准, 运行于光缆上,适合长距离/骨干传输,802.3u标准 5.7 层次化网络设计:5.7.1 三个关键层概念:①: 核心层: Core Layer 目标: 高效速度传输,为网络提供骨干组件 ②: 汇聚层: Distribution Layer 核心层与终端用户接入层的分界面 完成网络访问的策略控制,广播域的定义,过滤寻址等数据处理业务. ③: 接入层: Access Layer 网络分段,广播/多播能力,介质访问的安全性,路由发现,MAC地址的过滤 口诀: 汇策略,核骨干 5.8 关于TCP/UDP:5.8.1 基于TCP协议 :HTTP ,FTP,Telnet, SMTP ,POP3, WWW 注: TFTP,NTP,SNMP是基于UDP 5.9 网络交换5.9.1 4 个发展阶段:①: 电路交换面向连接,在通信前,需要为通信双方分配一条具有固定带宽的通信线路,通信双方在通信过程中将一直占用所分配的资源到通信结束. ②: 报文交换 采用存储转发机制,以报文为传送单元,用于实时性要求低,报文较短的通信业务 ③: 分组交换 面向无连接,采用存储转发方式, 将数据分割为小段并添加头部,作为数据传送的基本单元即分组, 比电路交换的电路利用率高,但时延大,适用于计算机网络,数据传输可靠,线路利用率较高 ④: ATM (Asynch-ronous TransferMode) 异步传输模式,将面向连接机制和分组机制相结合,在通信开始前需要建立连接,但是该连接并不独占物理通道,而是和其他连接统计复用,同时所有的媒体信息,被分割并封装为固定长度的分组在网络中传送和交换. 适合传送高速数据业务,ATM技术复杂性,导致ATM交换机造价及其昂贵 5.10 双绞线屏蔽双绞线(Shielded Twisted Pair): 增加了全屏蔽层,减少了衰减和噪音, 价格贵重量重,不易安装,一般用于涉密信息等要求高的情况下 非屏蔽双绞线(UnShielded Twisted Pair) 5.11 APAP接入点(Access Point) 是用于无线网络的无线HUB,是无线网络的核心. 它是移动计算机用户进入有线以太网骨干的接入点,AP可简单安装在天花板或墙壁,他在开放空间最大覆盖范围300米,无线传输速率11Mbps,理论上可同时接入1024 个移动设备. 5.12 可用于查询IP地址的常见命令:①: nslookup②: tracert③: ping 用法: 命令+ 域名 ,如 nslookup www.baidu.com 注: ipconfig 用于查询本地电脑IP,网关等信息的,命令后面不带网址. 5.13 网络分类5.13.1 按照作用范围分:广域网WAN: (Wide Area Network) 如北京到上海之间的网络按照作用范围分,它属于广域网 城域网MAN 局域网LAN 5.14 IEEE802IEEE802.1: 定义局域网体系结构,寻址,网络互联和网络. IEEE802.3 : 是以太网标准(局域网标准) IEEE802.6: 城域网协议 IEEE802.11 : 是无线局域网WIFI的技术标准 5.15 WLAN无线网络常用的认证与加密方式:5.15.1 WEPWired Equivalent Privacy ,有线等效保密,是对在两台设备间无线传输的数据进行加密的方式,用于防窃听 5.15.2 WPAWPA目前有四种认证方式: WPA: 替代WEP, 加强了生成加密密钥的算法,增加了防数据中途被篡改的功能和认证功能 WPA2: 与WPA相比,增加了AES的加密方式 WPA-PSK WPA2-PSK 5.14 网络设备 5.15 以太网①: 使用CSMA/CD(即载波监听多路访问及冲突检测技术) ②: 支持半双工和全双工 ③: 以太网帧长度不固定,如Ethernet II类型以太网帧最小长度为64字节(6+6+2+46+4),最大长度为1518字节(6+6+2+1500+4) 5.16 WLAN无线网络 5.16 OSI七层模型中各层的功能: 5.17 网关: 六、数据库6.1 六种范式:①: INF②: 2NF③: 3NF④: BCNF⑤: 4NF⑥: 5NF 范式级别越高,数据冗余程度越小,存储同样的数据就需要分解成更多张表,数据库性能(速度)将下降 七、立项管理7.1 立项管理的5个阶段①: 项目建议 ②: 项目可行性分析 ③: 项目审批 ④: 项目招标 ⑤: 项目合同谈判和签订 7.2 系统方法论的基本原则:①: 整体性原则 ②: 相关性原则 ③: 有序性原则 ④: 动态性原则 ⑤: 最优化原则 注: 不包括易用性 7.3 大项目和普通项目区别大项目注重过程, 先指定过程计划,再制定活动计划 即先确定用什么方法和过程,再平衡成本和收益 八、项目整体管理:项目整合管理包括为识别、定义、组合、统一和协调各项目管理过程组的各种过程和活动而开展的过程与活动。在项目管理中，“整合”兼具统一、合并、沟通和集成的性质，对受控项目从执行到完成、成功管理干系人期望和满足项目要求，都至关重要。项目整合管理包括选择资源分配方案、平衡相互竞争的目标和方案，以及管理项目管理知识领域之间的依赖关系。虽然各项目管理过程通常以界限分明、相互独立的形式出现，但在实践中它们会以本指南无法全面叙述的方式相互交叠、相互作用。 4.1制定项目章程——编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件的过程。 4.2制定项目管理计划——定义、准备和协调所有子计划，并把它们整合为一份综合 项目管理计划的过程。项目管理计划包括经过整合的项目基准和子计划。 4.3指导与管理项目工作——为实现项目目标而领导和执行项目管理计划中所确定的工作，并实施已批准变更的过程。 4.4监控项目工作——跟踪、审查和报告项目进展，以实现项目管理计划中确定的绩效目标的过程。 4.5实施整体变更控制——审查所有变更请求，批准变更，管理对可交付成果、组织过程资产、项目文件和项目管理计划的变更，并对变更处理结果进行沟通的过程。 4.6结束项目或阶段——完结所有项目管理过程组的所有活动，以正式结束项目或阶段的过程。 通过考虑为完成项目而开展的其他类型的活动，可以更好地理解项目与项目管理的整合性质。以下是项目管理团队所开展的活动的例子： 确定、审查、分析并理解范围。包括项目需求、产品需求、准则、假设条件、制约因素和可能影响项目的其他因素，以及如何管理和处理这些内容。 使用结构化的方法（如PMBOK®指南中所述的方法）把收集到的项目信息转化为项目管理计划。 开展活动，以产生项目的可交付成果。 测量和监督项目进展，并采取适当措施以实现项目目标。 在项目管理过程组的各过程间，经常反复发生联系。例如，在项目早期，规划过程组为执行过程组提供书面的项目管理计划；然后，随着项目的进展，规划过程组还将根据变更情况，更新项目管理计划。 8.1 事业环境因素:①: 国家标准或行业标准②: 帮助管理项目的工具(项目管理信息系统)③: 实施单位的企业文化和组织机构④: 市场状况⑤: 行业数据库⑥: 现有设施和固定资产等⑦: 项目干系人对风险的承受力 8.2 组织过程资产①: 变更控制流程 项目团队可以 选择,增补 是 组织过程资产范畴②: 合同 也 属于 组织过程资产③: 产品组件标准 也 属于 组织过程资产④: 以往项目的经验教训 组织内部形成的 而不是全行业 的 统一标准 则不能算组织过程资产. 口诀: 合同教训 是 组织,叫鸡验指纹 8.3 五大过程组,47个子过程8.3.1 启动过程组(项目启动)定义并批准项目或项目阶段, 制定项目章程,和识别项目干系人 8.3.2 计划过程组(指定项目计划)①: 建立WBS 和 WBS字典②: 项目风险分析③: 定义和细化目标,规划最佳的行动方案. 活动排序 8.3.3 执行过程组(指导和管理项目执行)项目团队的组建项目质量保证询价卖方选择 8.3.4 监督和控制组8.3.5 项目收尾合同收尾管理收尾 : 也叫行政收尾,覆盖整个项目,阶段完成或项目完成都需要收尾(包括项目评价,总结经验教训,归档项目文件等)指导项目收尾的程序和方法, 包括收尾的所有活动 及角色 职责. 8.4 项目管理计划过程的输入①: 项目章程: 用于确定项目地位,对项目经理授权②: 事业环境因素③: 组织过程资产 8.5 项目初步范围说明书内容:①: 产品范围描述②: 项目需求和可交付成果⑤: 产品或服务的需求和特点⑥: 制约因素⑦: 假设条件⑧: 初始WBS⑨: 成本概算⑩: 验收标准⑩: 进度里程碑⑩: 项目边界⑩: 最初定义的风险 8.6 项目工作说明书SOW内容:SOW：对内部项目而言，由项目发起人提出；对外部项目而言，可以作为投标文档一部分从客户那里得到 ①: 业务需求: 一个组织的业务需求可能是培训,市场需求技术进步,法律需求或政府的标准 ②: 产品范围描述: 记录项目所要创建的产品的需求,以及产品或服务的特性. ③: 项目目标,战略计划: 所有项目都要支持组织的战略目标,执行组织要把战略计划作为项目选择的一个要素来考虑. 口诀: 爷参战。 8.7 项目收尾的输出:①: 合同收尾章程②: 管理收尾章程③: 组织过程资产更新 8.8 合同收尾 的内容项目验收 8.9 项目评估主要由第三方实施, 而不是由建设方,承建方等 主要特征:①: 整体性 : 综合集成经济,环境 ,风险,技术运行②: 目标性③: 相关性: 时间,知识,逻辑④: 动态性: 项目生命周期 依据: ①: 项目建议书 ②: 项目可行性研究报告 ③: 报送单位的申请报告及主管部门的初审意见 ④: 有关资源,配件,燃料,水,电等方面的协议文件 注: 不包括项目变更管理策略 8.10 项目管理计划的内容:①: 范围基准: 范围说明书,WBS,WBS字典 ②: 进度基准 ③: 成本基准 ④: 其他管理计划 注: 项目绩效信息 是在 项目执行中产生的,不包括在项目管理计划中 8.11 项目监控工作成果:变更请求工作绩效报告项目管理计划更新项目文件更新 注: 工作绩效报告 能提供当前项目的状态与预测项目状态的比较. 8.12 项目章程的内容: (很重要)项目章程包含来源于商业文件中的相关项目信息。既然商业文件不是项目文件，项目经理就不可以对它们进行更新或修改，只可以提出相关建议, 本过程仅开展一次或仅在项目的预定义点开展。 指定项目经理及授权级别概要的里程碑计划干系人的影响职能组织项目目的或论证结果商业需求,产品需求,项目需求,项目概述概要预算假设及约束条件项目的业务方案投资回报率 总结: 各种需求 作用: ①: 确定项目经理,规定项目经理的权利 ②: 正式确认项目的存在,给项目一个合法的地位 ③: 规定项目的总体目标,包括范围,质量,成本,时间等 ④: 通过叙述项目启动的理由,把项目与执行组织的日常经营运作及战略计划联系起来. 8.13 项目文件:①: 质量管理计划 ②: 范围管理计划 ③: 进度管理计划 ④: 成本管理计划 九、项目范围管理:项目范围管理包括确保项目做且只做所需的全部工作，以成功完成项目的各个过程。 5.1规划范围管理——创建范围管理计划，书面描述将如何定义、确认和控制项目范围的过程。 5.2收集需求——为实现项目目标而确定、记录并管理干系人的需要和需求的过程。 5.3定义范围——制定项目和产品详细描述的过程。 5.4创建 WBS——将项目可交付成果和项目工作分解为较小的、更易于管理的组件的过程。 5.5确认范围——正式验收已完成的项目可交付成果的过程。 5.6控制范围——监督项目和产品的范围状态，管理范围基准变更的过程。 在项目环境中，“范围”这一术语有两种含义： 产品范围——某项产品、服务或成果所具有的特性和功能。 项目范围——为交付具有规定特性与功能的产品、服务或成果而必须完成的工作。项目范围有时也包括产品范围。 管理项目范围所需的各个过程及支持工具与技术，会因项目而异。经过批准的项目范围说明书、工作分解结构（WBS）和相应的WBS词典构成项目范围基准。只有通过正式变更控制流程才能进行基准变更。在开展确认范围、控制范围及其他控制过程时，基准被用作比较的基础。 应该根据项目管理计划（见4.2.3.1节）来衡量项目范围的完成情况，根据产品需求（见5.2节）来衡量产品范围的完成情况。项目范围管理各过程需要与其他知识领域中的过程整合起来，以确保项目工作能实现规定的产品范围。 9.1 WBS的3种分解方法:一般是滚动式滚则,不是一开始就将所有活动直接分解到工作包. ①: 生命周期的各阶段作为分解的第二层,可交付性成果在第三层 ②: 主要可交付性成果在第二层 ③: 子项目安排在第一层,再分解子项目的WBS 9.2 WBS的分解过程注意事项:①: 必须面向交付成果 ②: 只由一个人负责,尽管可能多人参与 ③: 任务分解应该控制在4~6层 ④: 分包出去的工作,和项目管理工作也在WBS中 ⑤: 并非一成不变 ④: 工作单元从属唯一,也就是一个工作单元只能从属于某个上层单元,避免交叉从属 ⑤: 相同层次的工作单元有相同的性质 ⑥:WBS的编制需要所有(主要)项目干系人的参与 ⑦: 最底层应该具有可比性,可定量检查. ⑧: 工作单元应该能区分不同的责任者和不同的工作内容. ⑨: 树型结构不适合大型项目 ⑨: 工作包8/80是一个推荐做法 ⑨: 每个工作包不一定都要分配给一个成员,没有此规定,也就是 可以不分配 注: WBS中必须包含全部工作内容,即100%原则,未包括的则不属于项目范围,如果要增加必须遵循变更流程. 大项目的WBS分解,可按照产品结构,生命周期,3个层次制定分解,不包含风险分解结构. 9.3 WBS过程的功能:①: 责任分工明确②: 定义绩效考核和控制基线③: 提高成本、时间和资源估算的准确度④: 识别可交付成果和工作包 物料清单: 描述一个产品所需要的实际部件,组件和构件的分级表格. 9.4 项目范围基线:①: 批准的项目范围说明书②: WBS③: WBS字典: 提供WBS要素的详细信息. 9.5 工作包①: 工作包是进度安排和成本估算,资源需求及控制的依据,是底层单元 ②: 工作包必须是具体的 注: 子项目一般还是很大,不是工作包,工作包是底层单元. 9.6 需求跟踪矩阵:目的: 追溯需求实现情况,和回溯需求来源,而不是确认需求 可改善产品质量,降低维护成本,容易实现重用 回溯: 又称逆向跟踪, 检查设计文档,代码测试用例等是否能在&lt;&lt;产品需求规格说明书&gt;&gt;中找到出处 总结: 追溯: 是跟踪需求,以免需求被做漏,做偏; 回溯: 是查需求的源头,了解为什么要做这个需求 口诀: 追漏回源 9.7 项目范围说明书:包含产品范围 和 项目范围 范围说明书的输入是 : 项目章程 范围说明书的 主要内容: 可交付成果,项目目标 项目范围说明书的详细介绍 它进一步并且正式明确了项目所应该产生的成果和项目可交付的特征，并在此基础上进一步明确和规定了项目利益相关者之间希望达成共识的项目范围，为未来项目的决策提供一个管理基线。 在进行范围确定前，一定要有范围说明书，因为范围说明书详细说明了为什么要进行这个项目，明确了项目的目标和主要的可交付成果，是项目班子和任务委托者之间签订协议的基础，也是未来项目实施的基础，并且随着项目的不断实施进展，需要对范围说明进行修改和细化，以反映项目本身和外部环境的变化。在实际的项目实施中，不管是对于项目还是子项目，项目管理人员都要编写其各自的项目范围说明书。 内容详细的项目范围说明书应包含产品的范围描述、验收标准、可交付成果、项目的主要责任、制约因素、假设条件。 具体来看，项目的范围说明书主要应该包括以下三个方面的内容： 项目的合理性说明1．项目的合理性说明。即解释为什么要实施这个项目，也就是实施这个项目的目的是什么。项目的合理性说明为将来提供了评估各种利弊关系的基础。 项目目标2．项目目标。前面已经讲过，项目目标是所要达到的项目的期望产品或服务，确定了项目目标，也就确定了成功实现项目所必须满足的某些数量标准。项目目标至少应该包括费用、时间进度和技术性能或质量标准。当项目成功地完成时，必须向他人表明，项目事先设定的目标均已达到。值得注意的一点是，如果项目目标不能够被量化，则要承担很大的风险 清单3．项目可交付成果清单。如果列入项目可交付成果清单的事项一旦被完满实现，并交付给使用者——项目的中间用户或最终用户，就标志着项目阶段或项目的完成。例如，某软件开发项目的可交付成果有能运行的电脑程序、用户手册和帮助用户掌握该电脑软件的交互式教学程序。但是如何才能得到他人的承认呢？这就需要向他们表明项目事先设立的目标均已达到，至少要让他们看到原定的费用、进度和质量均已达到。 要求一般来说，项目范围说明书要由项目班子来编写，而且在编写项目范围说明书时，项目班子需要在实际工作中考虑限制或制约自己行动的各种因素。例如，准备采取的行动是否有可能违背本组织的既定方针。 在编写项目范围说明书时必须有项目的成果说明书，以作为范围规划的前提依据。所谓成果，是指任务的委托者在项目结束或者项目某个阶段结束时要求项目班子交出的成果。比如，对于某软件开发项目来说，要求设计规划部门交出全部开发的可交付成果。显然，对于这些要求交付的成果都必须有明确的要求和说明。 范围说明书因项目类型的不同而不同。规模大、内容复杂的项目，其范围说明书也可能会很长。政府项目通常会有一个被称作工作说明书（SOW）的范围说明。有的工作说明书可以长达几百页，特别是要对产品进行详细说明的时候。总之，范围说明书应根据实际情况做适当的调整以满足不同的、具体的项目的需要。 9.7.1 产品范围和 项目范围的区别:产品范围: 产品或 服务所应该包含的功能 项目范围: 为了能交付产品,项目所必须做的工作. 9.8 创建WBS的输入:①: 范围管理计划②: 项目范围说明书③: 需求文件④: 组织过程资产 9.9 范围确认的输入:①: 项目范围说明书②: WBS③: 项目范围管理计划④: 可交付物(可交付成果) 9.9 范围确认和项目收尾区别:范围确认 强调 核实与接受 可交付成果, 以及验收可交付成果 项目收尾 强调 结束项目所要做的流程性工作, 以及验收产品 9.10 WBS字典:包括账户编码,工作描述,执行组织,里程碑列表,资源需求,成本估算,活动列表等是对工作包的细节描述.不包含管理储备 9.11 控制账户:控制账户是一个管理控制点,在该控制点上,把范围预算,实际成本和进度加以整合,并与挣值比较,以测量绩效. 每个工作包分配到一个控制账户,并根据”账户编码”为工作包建立唯一的标识,是创建WBS的最后一步. 每个控制账户可能包括一个或多个工作包,但一个工作包只能属于一个控制账户. 9.12 追溯和回溯区别:追溯: 客户需求向前追溯到需求, 跟踪需求,以免被做漏做偏 回溯: 从需求回溯相应的客户需求, 查清需求源头,了解为什么要做这个需求 需求跟踪: 主要不是 确认需求,而是 追溯需求实现情况 和回溯需求来源. 9.13 需求开发五过程:顺序如下: ①: 需求获取: 提炼出符合解决问题的用户需求,——-产生&lt;&lt;用户需求说明书&gt;&gt; ②: 分析: 对需求分析并抽象描述,建立概念模型 ③: 定义: 根据分析的结果,进一步定义准确无误的产品需求,——产生&lt;&lt;需求规格说明书&gt;&gt; ④: 验证: 开发方和用户共同 对需求文档评审,双方达成共识后作出书面承诺,使需求文档具有商业合同的效果 ⑤: 确定需求基线 注: 先分析后定义 注: 需求阶段,应该编制 需求规格说明书, 初步用户手册, 数据要求说明. 需求规格说明书 需要经过阶段评审 和 技术评审后建立基线,它是阶段测试 和后续开发的重要基础.不能只通过同行评审就建立基线 9.14 范围确认和 质量控制:质量控制: 核实工作结果正确与否 范围确认: 有关工作结果是否可接受 质量保证: 建立对未来输出或正在进行的工作在完工时满足特定需求和期望的信心. 简言之: 控制正确性,确认可接受,保证信心. 口诀: 孔雀忍受暴行 例如: ①对详细的范围说明书进行评审,提交客户签字确认②:与客户开展审查,判断工作和交付成果是否符合标准. 9.15 范围控制:作用: 防止范围蔓延(范围蔓延就是范围不受控制)例: 客户提出新的需求时,说服他放弃新需求 ①: 影响导致范围变更的因素 ②: 确保所有被请求的变更按照项目整体变更控制流程处理. ③: 范围变更发生时进行管理 注: 不包括确定范围变更是否已经发生. 9.16 滚动式计划创建工作分解结构时,近期的要分解详细,以便于安排核实,远期的可以放一个规划包,滚动规划和分解. 9.17 项目范围管理的流程:顺序如下:①: 收集需求②: 定义范围③: 创建工作分解结构④: 核实范围⑤: 控制范围 9.18 范围管理和时间管理的顺序:范围规划——&gt;范围定义——-&gt;活动定义——-&gt;活动排序——–&gt;活动历时估算 注: 先规划,后定义 9.19 工具和技术①: 收集需求 的工具: 引导式研讨会,标杆对照 ②: 范围定义 的工具: 引导式研讨会,产品分析 ③: 范围控制的工具: 偏差分析 9.20 配置控制即配置项 和 基线的变更控制,包括下列任务: ①: 标识记录变更申请 ②: 分析评价变更 ③: 批准或否决申请 ④: 实现、验证和发布已经修改的配置项 注: 配置控制其实主要内容就是变更控制 项目经理职责: ①: 确定受变更影响的关联配置项和有关基线 ②: 将变更申请的决议通知受此变更影响的每个干系人 ③: 组织修改配置项,并在相应的文档或程序代码中记录变更信息 项目经理的作用: 使用赋予项目的资源来实现项目特定目标 配置管理员职责: 将变更后的配置项纳入基线,并将变更内容和结果通知相关人. 简言之:项目经理 负责记录变更,确定基线配置项,通知决议给干系人 9.21 需求的状态值①: 已建议: 该需求被有权提出需求的人建立 ②: 已批准: 该需求已经被分析,估计了对项目余下部分的影响,已用一个确定的版本号,或创建编号分配到相关基线中,软件开发团队已经同意实现该需求. ③: 已实现: 已经实现了代码的设计,编写,单元测试. ④: 已验证: 使用所选择的方法已验证了实现的需求,例如测试和检测 9.22 分解:将整个项目工作分解为工作包需要开展以下活动: ①: 识别和分析可交付成果及相关工作 ②: 确定WBS结构和编排方法 ③: 自上而下逐层细化分解 ④: 为WBS组件制定和分配标识编码 ⑤: 核实可交付成果分解的程度是否恰当. 9.23 工作说明书与项目范围说明书的区别工作说明书是建设方出具的 ,范围说明书是承建方编写 工作说明书 不在项目生命周期内 工作说明书是范围说明的依据。2.范围说明书是在工作说明书的基础制订。 工作说明书：是项目对所要提供的产品、成果或服务的描述。采购工作说明书：要详细规定采购的项目，以便替在的卖方确定他们是否有能力提供这些项目。项目范围说明书：描述了项目的可交付物和产生这些可交付物所必须进行的项目工作。 十、进度管理项目时间管理包括为管理项目按时完成所需的各个过程。 6.1规划进度管理——为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程。 6.2定义活动——识别和记录为完成项目可交付成果而需采取的具体行动的过程。 6.3排列活动顺序——识别和记录项目活动之间的关系的过程。 6.4估算活动资源——估算执行各项活动所需材料、人员、设备或用品的种类和数量的过程。 6.5估算活动持续时间——根据资源估算的结果，估算完成单项活动所需工作时段数的过程。 6.6制定进度计划——分析活动顺序、持续时间、资源需求和进度制约因素，创建项目进度模型的过程。 6.7控制进度——监督项目活动状态，更新项目进展，管理进度基准变更，以实现计划的过程。 通过把填有项目数据的进度规划工具看做进度模型，可以把项目进度的呈现形式（进度计划）与产生项目进度计划（见6.6.3.2节）的进度数据（见6.6.3.3节）和计算工具区分开来。进度模型是项目活动执行计划的一种表示形式，其中包含持续时间、依赖关系和其他规划信息，用以生成项目进度计划及其他进度资料。关于进度模型的更多信息，参阅《进度计划实践标准》 在进度管理计划中规定项目时间管理的各过程及其工具与技术。通过制定项目管理计划过程（见4.2节），把进度管理计划整合进项目管理计划，成为其中的一个子计划。进度管理计划确定进度规划的方法和工具（图6-2），并为编制和控制进度计划建立格式和准则。在所选的进度规划方法中，规定进度编制工具的框架和算法，以便创建进度模型。一些耳熟能详的进度规划方法包括关键路径法（CPM）和关键链法（CCM）。 应该依据定义活动、排列活动顺序、估算活动资源、估算活动持续时间等过程的输出，并结合用于创建进度模型的进度编制工具，来编制项目进度计划。经批准的最终进度计划将作为基准用于控制进度过程（见6.7节）。随着项目活动的开展，项目时间管理的大部分工作都将发生在控制进度过程中，以确保项目工作按时完成。 10.1 进度压缩的原则优先压缩关键路径上的活动和每压缩一天需要增加额外费用最小的活动 10.2 PERT,资源平衡,进度压缩,关键链法①: PERT（Program/Project Evaluation and Review Technique）即计划评审技术简单地说，PERT是利用网络分析制定计划以及对计划予以评价的技术。它能协调整个计划的各道工序，合理安排人力、物力、时间、资金，加速计划的完成。在现代计划的编制和分析手段上，PERT被广泛地使用，是现代项目管理的重要手段和方法。 ②: 资源平衡: 使资源利用更合理，会导致进度计划延长调整任务的时间安排以使得资源不被过分使用，这被称为资源平衡。资源平衡通常不会被用来缩短进度。 ③: 进度压缩: 包括赶干、快速跟进。 赶工：拿资源换时间赶工在项目管理中的定义：对成本和进度进行权衡，确定在尽量少增加费用的前提下最大限度地缩短项目所需要的时间。赶工进度并非总能产生可行的方案，反而常常增加成本。 赶工原则是“采用优先考虑赶工费用率最低的工作”。 快速跟进：调整逻辑关系通过对各种逻辑关系并行确定来缩短项目周期。在进行项目设计中，当风险不大时，通过精心安排而使项目的前后阶段相互搭接以加快项目进展速度的做法叫快速跟进。 ④: 关键链法: 是一个进度网络分析技术,根据有限的资源对项目进度计划进行调整。 10.3 赶工和快速跟进的区别:10.4 正态分布 ### 十一、成本管理估算————————产物—————————–&gt; 预算—————–产物———————-&gt; 成本基准 项目成本管理包含为使项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程，从而确保项目在批准的预算内完工。 7.1规划成本管理——为规划、管理、花费和控制项目成本而制定政策、程序和文档的过程。 7.2估算成本——对完成项目活动所需资金进行近似估算的过程。 7.3制定预算——汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程。 7.4控制成本——监督项目状态，以更新项目成本，管理成本基准变更的过程。 11.1 成本类型①: 可变成本: 如普通员工工资,消耗原材料 ②: 固定成本: 如管理者工资,设备折旧费 ③: 直接成本: 直接归属于项目工作的成本,如项目使用的物料及设备使用费,项目团队的工资,奖金等,由项目经理直接控制 ④: 机会成本: 被舍弃的选项中价值最高者 ⑤: 间接成本: 几个项目共同分摊的成本,如保安费,公司福利,财务部门费用等 ⑥: 沉没成本: 过去发生且无法回收 11.2 项目成本(直接成本)需求,设计,开发,实施(部署),上线验收,这些成本一般纳入项目成本. 可行性研究费用, 监理费用都是业主方负责(甲方)的费用,且一般在立项之前,所以不能纳入项目成本 注: 业主方出钱,以及立项之前的成本 都不属于 项目成本 11.3 成本估算11.3.1 成本估算的常用方法①: 专家判断 ②: 类比估算: 以过去类似项目参数值为基础,来估算当前项目同类参数或指标. ③: 参数估算(公式法): 利用历史数据之间的统计关系 注: 类比 和 参数估算易混淆, 所以 只记住 题目中出现 类似 就是类比估算 ④: 自下而上估算 :先对单个的工作包,进行细致的成本估算,然后向上汇总到更高层次. ⑤: 三点估算法: 考虑到估算的不确定性和风险最乐观成本: 最好情况的成本 最可能成本: 比较现实的估算 最悲观成本: 最差情况的成本 公式: 预期成本 = (最乐观+ 4 * 最可能+ 最悲观) / 6 注: 挣值分析 不是 成本估算的方法,而是 成本控制的工具 11.3.2 成本估算的输入①: 项目进度管理计划 ②: 项目管理计划 ③: 风险事件 注: 项目成本绩效报告不属于 成本估算的输入. 挣值分析法 是成本控制的工具和技术 成本估算建议在WBS 的最底层进行, WBS 最底层是工作包,是进度安排,成本估计和监控的基础.成本和进度的估算应该在工作包 这一层进行. 11.3.3 成本估算的内容:分析成本构成结果,找出各种可以相互替代的成本,协调各成本之间的关系. 11.3.4 成本估算的步骤:①: 识别并分析项目成本构成科目 ②: 估算每一个成本科目的成本大小 ③: 分析成本估算结果 ,找出各种可以相互替代的成本,协调各成本之间的关系. 11.3.5 成本估算的工具和技术储备分析 11.4 成本预算11.4.1 输入①: 成本管理计划 ②: 范围基准 ③: 活动成本估算 ④: 协议 ⑤: 资源 ⑥: 风险登记册 ⑦: 组织过程资产 ⑧: 项目进度计划 11.4.2 输出:①: 项目资金需求 ②: 项目文件更新 ③: 成本基准 11.4.3 成本预算的内容将项目的成本分配到项目的各项具体工作上属于成本预算 注: 范围基准 是 创建WBS的输出 项目的范围基准是 经过批准的项目范围说明书,WBS 和 WBS词典. 判断项目范围是否完成 需要 范围基准来衡量 判断产品范围是否完成 需要 根据产品是否满足了产品描述(软件需求规格说明书)来判断. 总结: XXX基准一般是对应XXX过程的输出 11.4.4 管理储备:①: 它不是成本基线的一部分,属于成本基准外,但是在项目预算内. ②: 由公司高层管理 ③: 用来处理非预期且不确定事件 ④: 不参加挣值计算 ⑤: 成本预算过程产生,风险控制过程使用 ####11.4.5 产物: 成本基准计划 11.4.6 应急储备:①: 由项目经理管理使用 ②: 成本估算过程中产生,风险控制过程使用 ③: 处理 预期 但 不确定事件 其他与上面相反 注: ①: 总预算 ≠ 完工预算BAC②: 总预算 ＝ 完工预算BAC + 管理储备 11.5 挣值管理EVM是把范围,进度,资源绩效综合起来考虑,以评估项目绩效和进展的方法. 11.5.1 关键指标 即计算公式:PV : 计划值—–&gt;计划完成工作的预算成本 PV: (到某一天时应该完成多少活动任务,这就是进度,也可以将进度与资金挂钩,即当到某一天时应该完成的工作量占总工作量的比例等价于应该花掉的前占总资金的比例)将资金平摊到每一天, 当到达某一天时, 计划应该花掉多少钱,这个值就是计划值,也就是说PV的值与时间有关,也就是与进度有关. EV: 挣值—–&gt;已完成工作的预算成本 (已完成 工作的 计划价值 之和) EV: 按已经完成的工作量,计划应该花掉多少钱 AC: 实际成本——&gt;已完成工作的实际成本 BAC: 项目的总计划值(完工预算) SV : 进度偏差 SV = EV - PV CV: 成本偏差 CV = EV - AC SV 为负数 表示 进度落后, 正数则相反CV 为负数 表示 成本超支, 正数则相反 SPI : 进度绩效指数 SPI = EV / PV CPI: 成本绩效指数 CPI = EV / AC SPI &lt; 1.0 则表示 进度落后, &gt;1.0 则相反CPI &lt; 1.0 则表示 成本超支, &gt;1.0 则相反 总结 : ①: SV,CV小于0 则 不好, SPI,CPI 小于1 则 不好 ②: SPI,SV 都是 EV 和 PV之间运算, CPI 和 AC 都是 EV 和 AC 之间运算. BAC: 完工预算VAC: 完工偏差 估算: ETC : 完工尚需估算(完成剩余部分)EAC : 完工估算(完成所有工作,所需预期总成本) : 按照目前的情况继续发展,完工尚需成本ETC = (BAC - EV) / CPI当进行纠偏之后: 则CPI = 1 , 所以ETC = BAC - EV 当预计剩余工作的CPI与当前一致时, 则 EAC = BAC / CPI 完工估算EAC = 实际花费AC + 完工尚需估算ETC = AC + (BAC - EV) / CPI 完工偏差VAC = 完工预算BAC - 完工估算EAC 注: ①: 总预算 ≠ 完工预算BAC 只有 管理储备为0时 总预算 ＝ 完工预算BAC ②: 总预算 ＝ 完工预算BAC + 管理储备③: 成本基线不包括管理储备,管理储备不参与挣值计算④: 成本基准 = 估算 + 应急储备⑤: 项目预算 = 成本基准 + 管理储备 = 估算 + 应急储备 + 管理储备 也就是项目总预算包括管理储备,BAC不包括 管理储备. 完工工期估算=预算工期 / SPI = 关键路径长度 / SPI 例题 例题: 11.6 成本预测11.7 成本控制在项目过程中,对形成成本的要素进行跟踪,分析,监督,控制和调节. 内容: 识别可能引起 项目成本 基准计划 发生变动的因素,对这些因素施加影响,以保证该变化朝着有利方向发展,以工作包为单位监督成本实施情况,查找偏差原因,作好实际成本的分析评估工作,对发生成本偏差工作包实施管理,并采取纠正措施,必要时修改项目成本基准计划,同时确保所有变更都准确记录在 成本基准计划中,将核准的成本变更后的 成本基准计划通知项目相关人员. 11.8 净现值指投资方案所产生的现金净流量以资金成本为贴现率折现之后与原始投资额现值的差额。 例题: ①: 净现值 = 未来报酬的总现值 － 初始投资 ②: 净现值 = 净现金 * 折现系数 折现系数 = 1 / [ ( 1 + 折现率) ^ N ] 公式: NPV=∑(CI-CO)/(1+i)^t NPV：净现值 CI：各年收益 CO：各年支出 CI-CO：净现金流量 t：时间， i：基准收益率（贴现率，基准折现率） 净现值指标是反映项目投资获利能力的指标。 决策标准： 净现值≥0 方案可行； 净现值&lt;0 方案不可行； 净现值均&gt;0 净现值最大的方案为最优方案。 净现值法就是按净现值大小来评价方案优劣的一种方法。净现值大于零则方案可行，且净现值越大，方案越优，投资效益越好。 示例: 设定折现率（基准收益率），即公式中的i 为8% 2009年，净现值=(0-800)/(1+0.08)= -740.74 2010年，净现值=(0-600)/(1+0.08)^2= -514.40 2011年，净现值=(2000-1500)/(1+0.08)^3 = 396.92 2012年，净现值=(1800-1200)/(1+0.08)^4= 441.02 2013年，净现值=(1900-1000)/(1+0.08)^5= 612.52 第五年结束时总净现值NPV= -740.74-514.40+396.92+441.02+612.52=195.32 例2: 第0期，净现值=(-630)/(1+10%)^0= -630 第1期，净现值=(330)/(1+10%)^1 = 300 第2期，净现值= (440)/(1+10%)^2 = 363.6 NPV= 300+363.6-630=33.6≈34 例3: 方案A: 第0年(初始投入的成本): (-30000)/(1+10%)^0=-30000 第一年: (14000)/(1+10%)^1=12727 第二年: (19000)/(1+10%)^2=15702 NPV=-30000+12727+15702=-1571 同理计算BCD方案. 11.9 静态投资回收期:不考虑时间价值,计算现金流量到什么时候为正值. 11.10 动态投资回收期计算净现值的和什么时候为正值,就截止 例2: 11.10 计算题:例1: 按照目前的情况继续发展,ETC = (BAC - EV) / CPIEV : 已完成工作的预算成本CPI = EV / AC 例2: 题目中说: PV: 计划值, 与进度有关(一般与时间或者完成工作量有关).一般指 到了某个工作日,完成当期计划进度的100%后, 此时应该使用了多少 资金.此题而言: PV = 40万 * ( 30 / 40 ) = 30 万, 也就是说,计划40天完成,且预算资金40万的情况下,那么,在第30天的时候且此时已经完成了30天所必须完成的工作量后 总共会用掉30万. AC: 实际成本,与成本有关. 例3: 例4: 例5: AC = 1000 + 2500 + 10000 + 15000 = 28500 EV = 1000*100%+3000*100%+8000*100%+13000*90%=23700 CPI=EV/AC=0.83 11.11 控制成本的输入①: 项目资金需求 11.12 控制成本的输出①: 工作绩效 ②: 成本预测 ③: 变更请求 ④: 项目文件更新 ⑤: 组织过程资产更新 ⑥: 项目管理计划更新 11.13 关键路径法:①: 找工期最长的那条路径 ②: 关键路径上的活动总浮动时间为0, 自由浮动时间为0 ③: 总浮动时间 = 晚完成-早完成 = 晚开始-早开始④: 最早开始 + 工期 = 最早完成 最迟开始 + 工期 = 最迟完成总结: 上下相减是浮动,左右相减是工期口诀: 早开始,迟完成,紧前紧后来分析, 其他皆可推. ⑤: 第一个活动最早开始 = 项目最早开始 最后一个项目最迟完成 = 项目最迟完成 ⑥: 自由浮动时间: 是本活动与紧后活动的关系, 指不延误任何紧后活动的最早开始且不违反进度制约因素的前提下,活动可以从最早开始推迟或拖延的时间量. 自由浮动时间 = 紧后活动最早开始的最小值 - 本活动最早完成 总之: 在关键路径法 的活动结点中的值 需要我们求的 就是 最早开始 和 最迟完成 其他的值可以依据公式推出. 总浮动时间: 不影响工期 自由浮动时间: 不影响紧后活动的最早开始时间 ⑦: 网络图: 单代号网络图: 箭头是关系, 结点是活动双代号网络图: 箭头是活动, 结点是事件.时标网络图 注: 双代号网络图的活动在箭线上,结点耗时为0,即结点的最早开始时间等于最早完成时间,从而合成一个最早开始时间(标注与结点上方) 11.13.1 一个非常重要的地方: 注: 其中活动A和活动B可以同时进行, 但只有活动A 和 活动B 都完成后, 活动C 才能开始. 另外: 当一个活动有多个紧前活动时,要看最后一个完成的活动的最早完成时间. 举个例子: C的紧前活动是A和B, 如果完成A活动需要9天,完成B活动需要10天,那么C活动最早开始时间是 第10天,而不是第九天. 总结: ⑧: 最早开始时间的求法: 要看紧前活动最早什么时候完成 (当一个活动有多个紧前活动时,要看最后一个活动的最早完成时的时间(也就是不延期时)) ⑨: 最迟完成时间求法: 要看紧后活动最迟什么时候开始(当一个活动有多个紧后活动时,要看最先一个开始的紧后活动的最迟开始时间————==原因: 确保所有的紧后活动不受影响.==) 画出双代号网络图, 计算节点的最早开始时间(标注于节点上方), 然后箭线上 每个的最早开始时间就是箭线起点的节点上方的值. 例题: 解答: E 由于在关键路径上所以总浮动时间和自由浮动时间都为0 G 在非关键路径上: 方法一: 公式法: G的总浮动时间=G最迟开始时间 - G最早开始时间 G最早开始是在第5天(因为只有一个紧前活动F,且F最早在第5天完成) G最迟开始时间=G最迟完成-G的工期=G最迟完成-4 G最迟完成要看G的紧后活动最迟什么时候开始,G只有一个紧后活动E且最迟开始时间为10(因为G在关键路径上,最迟开始=最早开始=10) G最迟开始时间=10-4=6 G的总浮动时间=6-5=1 方法二: 用工期21 减去G所在的最长路径20 得到的就是G 的总浮动时间为1天 G的自由浮动时间 = E的最早开始-G的最早完成 E最早第10天开始,G最早第9天完成 G的自由浮动时间=10-9=1 11.14 投资回收期以项目的净收益回收项目投资所需要的时间, 一般以建设期开始算起, 也可以从投产年开始算起,但是必须注明 投资回收期的判别基准是 基准投资回收期 而不是 基本投资回收期 评价标准: 将计算出的静态投资回收期Pt 与 所确定的基准投资回收期Pc 进行比较: 若Pt &lt;= Pc 表明项目投资能在规定时间内收回,则方案可以考虑 若Pt &gt; Pc , 则方案不可行 11.15 计算题应该注意的地方:①: 费用 : 有些时候指的是活动总费用,有时指的是一个人一天的费用——注意审题 11.16 成本估算和成本预算的区别成本估算是在有了方案和初步设计的基础上作出的；成本预算是在有了详细的施工图纸的基础上作出的。二者的依据不同，深度不同。 估算和预算都是最终成本前的计算，和最终的成本一般多少是有出入的，顾名思义，估算只是初步的估计，比较粗，精确度不高和最终的成本相别相对来说是比较大的，但是预算就比较细了，每一项都需要列出来，最终的成本也是需要根据预算来进行的！ 11.17 活动和工作包的区别:活动是由工作包分解而来，是实现工作包所需的具体工作。 工作包是WBS底层的可交付成果，是WBS的一部分，活动不是WBS的一部分。 工作包不表示时间、也不表示顺序，只表示项目范围；活动可表示时间、顺序、是资源估算、历史估算、费用估算的重要依据 十二、质量管理项目质量管理包括执行组织确定质量政策、目标与职责的各过程和活动，从而使项目满足其预定的需求。项目质量管理在项目环境内使用政策和程序，实施组织的质量管理体系； 并以执行组织的名义，适当支持持续的过程改进活动。项目质量管理确保项目需求，包括产品需求，得到满足和确认。 8.1规划质量管理——识别项目及其可交付成果的质量要求和/或标准，并书面描述项目将如何证明符合质量要求的过程。 8.2实施质量保证——审计质量要求和质量控制测量结果，确保采用合理的质量标准和操作性定义的过程。 8.3控制质量——监督并记录质量活动执行结果，以便评估绩效，并推荐必要的变更的过程。 每个项目都应该有一个质量管理计划。项目团队应该遵循质量管理计划并且应该以数据证明自己遵守了计划。 在与ISO保持兼容性的前提下，现代质量管理方法力求缩小差异，交付满足既定要求的成果。现代质量管理方法承认以下几方面的重要性： 客户满意。了解、评估、定义和管理要求，以便满足客户的期望。这就需要把“符合要求”（确保项目产出预定的成果）和“适合使用”（产品或服务必须满足实际需求） 结合起来。 预防胜于检查。质量应该被规划和设计，并且在项目的管理过程或可交付成果生产过程中被建造出来（而不是被检查出来）。预防错误的成本通常远低于在检查或使用中发现并纠正错误的成本。 持续改进。由休哈特提出并经戴明完善的计划—实施—检查—行动（PDCA）循环是质量改进的基础。另外，诸如全面质量管理（TQM）、六西格玛和精益六西格玛等质量管理举措，也可以改进项目的管理质量及项目的产品质量。常用的过程改进模型包括马尔科姆·波多里奇模型、组织级项目管理成熟度模型（OPM3®）和能力成熟度集成模型（CMMI®）。 管理层的责任。项目的成功需要项目团队全体成员的参与。然而，管理层在其质量职责内，肩负着为项目提供具有足够能力的资源的相应责任。 质量成本（COQ）。质量成本是指一致性工作和非一致性工作的总成本。一致性工作是为预防工作出错而做的附加努力，非一致性工作是为纠正已经出现的错误而做的附加努力。质量工作的成本在可交付成果的整个生命周期中都可能发生。例如，项目团队的决策会影响到已完工的可交付成果的运营成本。项目结束后，也可能因产品退货、保修索赔、产品召回而发生“后项目质量成本”。由于项目的临时性及降低后项目质量成本所带来的潜在利益，发起组织可能选择对产品质量改进进行投资。这些投资通常用在一致性工作方面，以预防缺陷或检查出不合格单元来降低缺陷成本。参见图8-2和8.1.2.2节。此外，与后项目质量成本有关的问题，也应该成为项目集管理和项目组合管理的关注点，以便项目、项目集和项目组合管理办公室专门开展审查，提供模板和分配资金。 图8-2IPECC、PDCA、质量成本模型和项目管理过程组在质量保证和质量控制方面的基本关系 12.1 质量控制的输入①: 项目管理计划 ②: 质量度量指标 ③: 工作绩效数据 ④: 已批准的变更请求 ⑤: 组织过程资产 ⑥: 产品服务和结果 ⑦: 质量检查表 12.2 质量控制的输出①: 确认的变更 ②: 核实的可交付性成果 12.3 质量管理过程①: 质量规划: 识别和项目有关的标准以及如何满足这些标准,确定需要对哪些过程和工作产品进行质量管理. ②: 质量保证: 建立对未来输出或正在进行的工作在完工时满足特定需求和期望的信心. ③: 质量控制: 采取措施,监督项目的具体实施结果是否符合相关的项目质量标准,并确定消除产品的不良结果的原因. 12.4 软件质量特性 功能性——功能 5可靠性——靠 3可用性——用 3效率———小 2可维护性—护 4可移植性—翼 4 大特性口诀: 功能靠用小护翼 功能性: 合——适合性准——准确性用——互用性一——依从性安——安全性 可靠性: 错——容错性译——易恢复性成——成熟性 易用性: 学——易学性姐——易理解性操——易操作性 效率: 石——时间特性源——资源特性 维护性: 试——可测试性改——可修改性定——稳定性分——易分析性 可移植性: 应——适应性装——易安装性一——一致性T ——可替换性 故事是这样的，某外语课，老师说了一段外语，谐音“合准用一安”（可以理解为：合准备用一安培），某同学错误翻译成“学姐操石源(日本人)”结果老师判定不及格，某同学试着修改定下的分数，别人告诉她，应该装一个套套去… 口诀：合准用一安，错译成，学姐操，石源，试改定分，应装一T（套套一般都用T代替） 12.4 质量管理常用工具：老七种工具：流程图、因果图、直方图、散点图、排列图、控制图、检查表。新七种工具：矩阵图、树状图、相互关系图、亲和图、过程决策方法图、活动网络图、优先矩阵图。 编成一句诗：流因直点列制查，矩树相亲策动优。 谐音是：刘英只点劣质茶，钜树相亲策动优。 诗文讲的故事是：有一个叫刘英的人在相亲时只敢点最便宜的劣质茶，为什么？家里穷呀。原来，她是锯了家里的树，卖了钱，来相亲的。可见这次相亲的策划活动有多优秀。 口诀: 刘英只点劣质茶，钜树相亲策动优 控制图: 用来分析过程是否稳定,是否发生异常情况. 12.5 规划质量管理的输入①: 项目管理计划 ②: 干系人登记册 ③: 风险登记册 ④: 需求文件 ⑤: 事业环境因素 ⑥: 组织过程资产 ⑦: 范围说明书 ⑧: 产品说明书 ⑨: 标准和规定 12.6 统计方法:①: 实验设计: 是一种统计方法,通过进行实验找出哪些变量对项目结果的影响最大. 用来识别哪些因素会对正在生产的产品或正在开发的流程的特定变量产生影响 ②: 标杆对照 ③: 过程分析: 主要是分析执行过程中的问题、无价值的活动等.用于识别问题、探究根本原因.并制定预防措施. ④: 质量审计: 对其他质量管理活动的结构性的审查,是决定一个项目质量活动是否符合组织政策,过程,程序的独立的评估. 12.6 规划质量管理的输出①: 质量测量指标: 描述项目或产品属性 以及 用于在质量控制过程如何对属性进行测量质量测量指标的例子: 准时性、故障率、可用性、成本控制、和测试覆盖度等. 提供了应该被测量的属性和允许的偏差. ②: 过程改进计划: 详细说明对项目管理过程和产品开发过程进行分析的各个步骤,以识别增值活动. ③: 质量管理计划: 描述如何实施组织的质量政策,以及如何达到项目的质量要求. ④: 质量核对单: 具体列出各项内容,用来核实所要求的一系列步骤,是否已经得到执行. 12.7 质量管理执行阶段的技术①: 质量审计 ②: 过程分析 ③: 七种基本质量工具(过程决策程序图PDPC)、统计抽样、检查、审查已批准的变更请求. 过程决策程序图: 用于理解一个目标与达成此目标的步骤之间的关系.有助于制定应急计划,因为它能帮助团队预测哪些可能破坏目标实现的中间环节 12.8 质量保证的输入①: 质量测量指标 ②: 质量管理计划 ③: 过程改进计划 ④: 工作绩效信息 ⑤: 变更请求 12.9 质量保证通过用规划过程预防缺陷,或者在执行阶段对正在进行的工作检查出缺陷,来保证质量的确定性, 而不是通过执行产品检查并发现缺陷来实现的. 12.9.1 质量保证的职能:主要职能是: 过程检查,过程改进 12.10 确认过程目的: 确保产品满足其特定的目标, 是否达到上一阶段确立的需求的过程 举例: 我要求张三期末语文考100分, 到期末时,张三语文考了100分, 我确认张三达到了我的要求 12.11 验证过程目的: 确保活动的输出产品满足活动的规范说明., 是否和软件需求一致. 举例: 我要求张三期末语文考100分, 到期末时,张三数学考了100分, 我验证张三和我的要求不一致 12.12 软件包质量要求:①: 产品描述要求 ②: 用户文档要求 ③: 程序和数据要求 12.13 编制质量计划的工具和技术①: 基准分析: 将实际计划中的项目做法同其他类似项目的实际做法进行比较,通过比较来改善和提高目前项目的质量管理,以达到项目预期的质量. 12.14 质量控制①: 主要是对产品或服务成果的控制和检查,不是评估项目绩效 所以 检查关键交付物的质量 就属于 质量控制的职能. 12.15 外部度量①: 易学性度量: 评估软件的帮助文档和文档的有效性. ②: 易操作性度量 ③: 易理解性度量 12.16 故障成本错误的纠正成本为非一致性成本,即故障成本 举例: 某如那件系统测试发现有错误并不能满足质量需求,为了纠正其错误投入了10人天的成本,该成本就属于 故障成本 12.17 控制质量的工具和技术①: 帕累托图: 特殊的垂直条形图,==用于识别造成大多数问题的少数重要原因==,在横轴上显示的原因类别,作为有效的概率分布,涵盖100%的可能观察结果. ②: 因果图: 又称鱼骨图, 发现问题的原因; 通常问题陈述放在鱼骨的头部作起点来追溯问题的来源 ③: 流程图 ④: 直方图: 用于描述集中趋势,分散程度,和统计分布形状, 与控制图不同它不考虑时间对分布内的变化的影响. ⑤: 散点图: 显示两个变量之间是否有关系 ⑥: 控制图: 实时展示项目进展信息的图表, 用于判断某一过程处于控制之中还是处于失控状态. ⑦: 核查表: 用于收集数据的查对清单(如收集缺陷数量和后果的数据) 技术: ⑧: 趋势分析 ⑨: 缺陷修复审查 ⑩: 检查(评审是检查) 12.18 审计 和 评审区别评审是检查,质量控制的工具. 质量审计是 审计其他质量管理活动的一个结构化审查,如果是问具体的流程,那么就不能用质量审计 12.19 工作绩效数据 工作绩效信息 工作绩效报告 区别与联系工作绩效数据: 是执行过程的输出，监控过程的输入。 在执行项目的工作过程中，从每个正在执行的活动中一边执行一边收集起来的，未经任何加工整理的原始观察结果和测量值用于真实，完整地记录工作的执行情况。它是指导与管理项目工作过程的输出。是项目监控时用来与计划要求做比较实际的实际数据。 例如：工作完成百分比，质量和技术绩效测量值，进度活动的开始和结束日期，变更请求的数量，缺陷数量，实际成本和实际持续时间等。 它强调的是原始的，基础的数据，再执行项目管理计划后，出现的能反映项目当前执行情况（主要是范围，进度，成本）的原始的，基础的数据。 工作绩效信息: 是监控过程的输出。 是对工作绩效数据进行加工整理（主要是与基准计划对比）后得到的，是各基层局部监控过程的输出。进行整合分析而得到的绩效数据。 在PMBOK指南中，总共有九个基层局部监控过程，即确认范围，控制范围，控制进度，控制沟通，控制质量，控制成本，控制干系人参与过程, 控制风险，控制采购。 例如：可交付成果物的状况，请求变更的执行状况，预测的完工估算。 它强调的是用工作绩效数据和基准计划的对比结果，也可以理解为偏差结果。 反映项目实际执行和计划要求之间的偏差,对偏差程度和原因的分析,以便决定是否需要变更 提供了沟通和支持项目决策的机制 注意：”可交付成果物的完成状况“属于 工作绩效信息。 工作绩效报告: 对绩效信息进一步加工，整理，汇编而得到的，关于项目绩效的专题和综合报告。他是监控工作过程的输出， 为指定决策，提出问题，采取行动或引起关注，而汇编工作绩效信息，所形成的实物或电子项目文件 是整个项目层次的更深入或更综合的执行与计划的比较。 例如：状况报告，备忘录，论证报告，信息札礼，电子报表，推荐意见或情况更新。 它强调的是可以正式提交给干系人，能全面反映项目情况的正式文件。 12.20 质量成本一致性成本: 预防成本 培训 流程文档化 评价成本 测试 检查 破坏性测试导致的损失 非一致性成本: 内部失败成本 返工 废品 外部失败成本 责任 报修 12.21 规划质量管理的首要工作识别相关质量标准 12.22 质量保证和质量控制的区别质量保证: 是执行阶段对正在进行的工作进行检查———-针对过程 质量控制: 是对阶段末得到的 可交付物/产品 进行检查——-针对阶段性成果 12.23 软件质量分类内部质量 外部质量 使用质量 十三、人力资源管理项目人力资源管理包括组织、管理与领导项目团队的各个过程。项目团队由为完成项目而承担不同角色与职责的人员组成。项目团队成员可能具备不同的技能，可能是全职或兼职的，可能随项目进展而增加或减少。项目团队成员也可称为项目人员。尽管项目团队成员被分派了特定的角色和职责，但让他们全员参与项目规划和决策仍是有益的。团队成员在规划阶段就参与进来，既可使他们对项目规划工作贡献专业技能，又可以增强他们对项目的责任感。 9.1规划人力资源管理——识别和记录项目角色、职责、所需技能、报告关系，并编制人员配备管理计划的过程。 9.2组建项目团队——确认人力资源的可用情况，并为开展项目活动而组建团队的过程。 9.3建设项目团队——提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效的过程。 9.4管理项目团队——跟踪团队成员工作表现，提供反馈，解决问题并管理团队变更，以优化项目绩效的过程。 13.1 组织分解结构OBS根据现有的部门,单位或团队进行分解.项目的活动和工作包列在负责的部门下面. 13.2 优秀团队的建设阶段:(塔克曼阶梯理论)团队发展阶段: ①: 形成阶段 ②: 震荡阶段: 个体之间争执,互相指责 ③: 规范阶段: 经过一段时间的磨合,相互熟悉了解,矛盾基本解决 ④: 发挥阶段(表现阶段): 成员积极工作,集体荣誉感非常强 ⑤: 解散阶段: 随着项目的结束,团队也被遣散. 注: 如果有新成员加入,团队又会回到形成阶段. 13.3 管理项目团队的工具和技术①: 观察和对话 ②: 项目绩效评估 ③: 冲突管理: ④: 问题日志: 注: 项目绩效,问题日志 属于 管理项目团队过程 而不是 建设项目团队过程 13.4 团队建设的内容①: 培训 ②: 认可和奖励 ③: 同地办公(集中) ④: 基本原则 ⑤: 团队建设活动 ⑥: 一般管理技能 ⑦: 组织娱乐活动让大家认识 注: 评价绩效 属于 管理团队的工具和技术 13.5 项目绩效评审在一个阶段末的项目绩效评审主要目标是本阶段的任务是否已经完成,决定项目是否从当前阶段进入下一阶段. 13.6 激励理论: X理论 ,Y理论,马斯洛理论,赫兹伯格理论,期望理论13.6.1 : X理论消极假设 ①: 人天性好逸恶劳,只要有可能就会逃避工作 ②: 人生来就以自我为中心,漠视组织要求 ③: 人们天生就反对改革 ④: 人缺乏进取心,逃避责任. 优点: 加强管理 缺点: 成员通常比较被动工作 13.6.2 Y理论积极假设 ①: 人天性并不是好逸恶劳,他们热爱工作,从工作中的到满足感和成就感 ②: 适当条件下人们愿意主动承担责任 ③: 大多数人具有一定的创造力和想象力 优点: 激发员工主动性 缺点: 对于员工把握工作而言可能又放任过度. 13.6.3 马斯洛需求是一个5层金字塔结构,当某一级的需求满足后,才会追求更高一级的需求,如此逐级上升,成为他工作的动机. 分五个层次 ①: 生理需求: 对衣食住行的需求等 级别最低位于金字塔最底层.人们在转向较高层次的需求时 总是尽力满足这类需求, 常见的激励措施 : 员工宿舍,奖金,补贴等 ②: 安全需求: 包括对人身安全,生活稳定,不至于失业 常见激励措施: 养老保险,长期劳动合同,意外保险等 ③: 社会交往需求: 友谊,爱情等隶属关系的需求. 常见的激励措施 : 员工活动,聚会,比赛,俱乐部 ④: 受尊重需求: 自尊心,荣誉感 常见的激励措施: 荣誉性的奖励, 形象地位的提升,颁发奖章. ⑤: 自我实现的需求 常见的激励措施: 参与决策,参与公司管理会议. 13.6.4 赫兹伯格理论双因素激励理论: ①: 保健因素: 与工作环境有关,能防止人们产生不满意感, 如工作环境,薪水,个人生活,人际关系,公司政策. ②: 激励因素: 与工作内容有关,能促使人们产生工作满意感, 如 工作成就感,认可和赞赏,成长和发展 类似于马斯洛理论中的 尊重和自我实现. 注: 注意 区别 保健因素 和 激励因素 ,前者的满足 可以 消除不满,后者的满足可以产生满意. 13.6.5 期望理论通过考察人们的努力行为与其获得的最终奖酬之间的因果关系,来说明激励过程,并以选择合适的行为达到最终的奖酬目标的理论 一个目标对人的激励程度有两个因素: ①: 目标效价: 实现目标后 能带来多少价值 ②: 期望值: 实现目标的可能性 激发力量=目标效价 * 期望值 13.7 人力资源管理计划的内容①: 角色和职责: 某人承担的职务,为完成工作成员必须履行的工作和职责. 角色和职责的定义的三种形式: 层级型: 工作分解结构WBS: 显示如何把项目可交付成果分解为工作包 组织分解结构OBS: 在每个部门下列出其所负责的项目或工作包 资源分解结构RBS按照资源类别和类型对资源的层级列表. 矩阵型: 责任分配矩阵RAM 用来显示分配给每个工作包的资源的表格, 即用来显示工作包与团队成员的关系,它能反映与每个人相关的所有活动,以及与每个活动相关的所有人员,它可确保任何一项任务都只有一个人负责.,从而避免职责不清. 文本型: 详细描述团队成员的职责.提供如职责,职权能力,资格等方面的信息. ②: 项目的组织结构图: 以图形方式展示项目团队成员及其报告关系. ③: 人员配备管理计划: 说明何时何种方式获得项目团队成员,以及他们需要在项目中工作多久. 13.8 人员配备管理计划的内容①: 人员招募 ②: 人员遣散计划 ③: 认可与奖励 ④: 资源日历 ⑤: 培训需要 ⑥: 合规性 13.9 组建项目团队的输入①: 角色和责任 ②: 项目的组织结构图 ③: 环境和组织结构图 13.10 组建项目团队的输出①: 资源日历 ②: 团队成员的通讯录 ③: 项目人员分配 13.11 资源日历 ,项目日历, 资源直方图区别①: 资源日历 资源工作时段,如团队成员工作时段,或休息 ②: 项目日历 项目的工作日历, 如 工作日,休息日,特殊项目的休整期(台风期,汛期) ③: 资源直方图 项目对资源的使用需求,如 某高级工程师在项目中的工作时长及负荷. 13.12 项目财务绩效评估:13.12.1 静态分析法不考虑资金的时间价值. 包括: 投资收益率法,投资回收期法 ,最小费用法 13.12.2 动态分析法考虑资金的时间价值,也叫贴现法. 包括: 净现值法,内部收益率法,投资回收期法等. 注意: 投资 回收期 有静态和动态的计算. 口诀: 最小投收是静态 13.13 绩效评估①: 包括定性和定量,主要是定量 ②: 评估人员 : 包括财务,管理,信息技术人员等 ③: 评估过程: 归纳,分析,撰写评估报告 13.14 对项目内部各成员制定绩效任务步骤:①: 对每个岗位工作内容进行分解 ②: 针对每个岗位的工作进度,成本,质量等设定KPI值,KPI 值需要设定 为高中低三种档次,给与不同的奖励 ③: 确定KPI评分标准(各评分标准,指标权重) ④: 确定考核频率 13.15 项目绩效审计①: 经济审计 ②: 效率审计 ③: 效果审计 注: 不包括 风险审计 13.16 项目人力资源管理的过程顺序13.16.1 规划人力资源管理识别和记录项目角色,职责,所需技能,并编制人员配备管理计划 13.16.2 组建项目团队确认人力资源可用情况,并为开展项目活动而组建团队, ①: 项目人员分配 13.16.3 建设项目团队提高工作能力,促进团队成员的互动,改善团队整体氛围,以提高项目绩效. 13.16.4 管理项目团队跟踪团队成员的工作表现,提供反馈,解决问题并管理团队变更,以优化项目绩效. 13.17 建设项目团队的工具和技术①: 培训(如 拓展、组织一些娱乐活动) ②: 集中办公 ③: 认可和奖励 ④: 团队建设活动 ⑤: 基本规则 ⑥: 通用管理技能 13.18 管理项目团队的输入①: 人力资源管理计划 ②: 项目人员分配清单 ③: 团队绩效评价 ④: 问题日志 ⑤: 工作绩效报告 ⑥: 组织过程资产 注: 变更请求是 输出. 口诀: 绩效日志组织入,变更请求是输出 13.19 冲突管理13.19.1 冲突的解决方法:①: 撤退/回避 ②: 妥协/协调: 双方都让步 ③: 缓和/包容 ④: 强迫/命令: 利用权力解决,使一方赢,一方输 ⑤: 合作/解决问题 13.20人际关系技能①: 领导力 ②: 沟通 ③: 激励 ④: 影响力 ⑤: 谈判 ⑥: 冲突管理 ⑦: 团队建设 ⑧: 管理技能 ⑨: 建立信任 13.21 项目经理权力来源①: 职位权力 ②: 奖励权力 ③: 惩罚权力 ④: 专家权力 ⑤: 参照权力 13.22 虚拟团队特点: ①: 将在家办公的员工纳入团队———空间 ②: 在组织内部地处不同地理位置的员工之间组织项目团队——-空间 ③: 将行动不便的或残疾人纳入团队——-人员 ④: 在工作班次,工作小时,或工作日不同的员工之间组件团队———时间 ⑤: 执行那些因为差旅费过高而被否决的项目——–开销 13.23 管理项目团队跟踪团队成员的工作表现,解决问题,管理团队变更,以优化项目绩效. 输入: ①: 人力资源管理计划 ②: 项目人员分派 ③: 团队绩效评价 ④: 问题日志 ⑤: 工作绩效报告 ⑥: 组织过程资产 工具技术: ①: 观察交谈 ②: 项目绩效评估 ③: 冲突管理 ④: 人机关系技能 输出: ①: 变更请求 ②:项目管理计划更新 ③: 项目文件更新 ④: 事业环境因素更新 ⑤: 组织过程资产更新 13.24 责任分配矩阵责任分配矩阵（RAM）是一种将项目组织分解结构（OBS）和工作分解结构（WBS）联系起来的结构，有助于确保项目工作范围的每个组成部分都分配给某个人或某个团队。责任分配矩阵（RAM）显示工作包或活动与项目团队成员之间的联系。责任分配矩阵可确保任何一项任务都只有一个人负责，从而避免混乱，做到“事事有人管”。同时，项目团队作为一个临时组织而不养“闲人”，通过责任分配矩阵明确项目团队成员在项目中“人人有事做”。RAM的典型应用是RACI（执行、负责、咨询和知情），以针对个人或小组，分配工作。 ==责任分配矩阵是规划人力资源管理过程的工具。==* 十四、沟通管理和关系人管理项目沟通管理包括为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程。项目经理的绝大多数时间都用于与团队成员和其他干系人的沟通，无论这些成员或干系人是来自组织内部（位于组织的各个层级上）还是组织外部。有效的沟通在项目干系人之间架起一座桥梁，把具有不同文化和组织背景、不同技能水平、不同观点和利益的各类干系人联系起来。这些干系人能影响项目的执行或结果。 10.1规划沟通管理——根据干系人的信息需要和要求及组织的可用资产情况，制定合适的项目沟通方式和计划的过程。 10.2管理沟通——根据沟通管理计划，生成、收集、分发、储存、检索及最终处置项目信息的过程。 10.3控制沟通——在整个项目生命周期中对沟通进行监督和控制的过程，以确保满足项目干系人对信息的需求。 上述过程所涉及的沟通活动，可按多种维度进行分类。需要考虑的维度包括（但不限于）： 内部（在项目内）和外部（客户、供应商、其他项目、组织、公众）； 正式（报告、会议记录、简报）和非正式（电子邮件、备忘录、即兴讨论）； 垂直（上下级之间）和水平（同级之间）； 官方（新闻通讯、年报）和非官方（私下的沟通）； 书面和口头，以及口头语言（音调变化）和非口头语言（身体语言）。 大多数沟通技能对于通用管理和项目管理都是相通的，例如： 主动倾听和有效倾听； 通过提问、探询意见和了解情况，确保更好地理解； 开展教育，增加团队知识，以便更有效地沟通； 寻求事实，以识别或确认信息； 设定和管理期望； 说服个人、团队或组织采取行动； 通过激励来鼓舞士气或重塑信心； 通过训练来改进绩效和取得期望结果； 通过协商，达成各方都能接受的协议； 解决冲突，防止破坏性影响； 概述、重述，并确定后续步骤。 项目干系人管理包括用于开展下列工作的各个过程：识别能影响项目或受项目影响的全部人员、群体或组织，分析干系人对项目的期望和影响，制定合适的管理策略来有效调动干系人参与项目决策和执行。干系人管理还关注与干系人的持续沟通，以便了解干系人的需要和期望，解决实际发生的问题，管理利益冲突，促进干系人合理参与项目决策和活动。应该把干系人满意度作为一个关键的项目目标来进行管理。 13.1识别干系人——识别能影响项目决策、活动或结果的个人、群体或组织，以及被项目决策、活动或结果所影响的个人、群体或组织，并分析和记录他们的相关信息的过程。这些信息包括他们的利益、参与度、相互依赖、影响力及对项目成功的潜在影响等。 13.2规划干系人管理——基于对干系人需要、利益及对项目成功的潜在影响的分析， 制定合适的管理策略，以有效调动干系人参与整个项目生命周期的过程。 13.3管理干系人参与——在整个项目生命周期中，与干系人进行沟通和协作，以满足其需要与期望，解决实际出现的问题，并促进干系人合理参与项目活动的过程。 13.4控制干系人参与——全面监督项目干系人之间的关系，调整策略和计划，以调动干系人参与的过程。 14.1 项目干系人管理的主要目的避免项目干系人 在 项目管理中 的严重 分歧 14.2 沟通管理的过程①: 编制沟通计划 ②: 记录工作日志 ③: 发布项目信息 14.3 沟通升级的原则与对方沟通—–&gt;与对方上级沟通——-&gt;与自己上级沟通——&gt;上级与上级沟通. 14.4 绩效报告的输出绩效报告 和 需求变更 ,因为 绩效报告 一般 是 与同领导或客户汇报,经常都带来或大或小的变更. 14.5 项目沟通计划第一个工具与技术 : 干系人分析 输入: 项目章程 14.6 语义障碍 和 认知障碍语义障碍 主要发生在沟通传送时认知障碍 通常发生在 信息的加工和理解上. 14.7 项目绩效评审 目标评审本阶段的任务是否完成,决定项目是否 从当前阶段进入下一阶段. 14.8 绩效评估实施过程①: 首要任务: 确定绩效评估项 ②: 组织评估团队 ③: 收集审核绩效数据资料 ④: 进行定量 和定性 评价,归纳,分析,撰写评价报告. 14.9 绩效报告的内容①: 项目进展和执行情况和调整情况 ②: 成本使用情况 ③: 团队成员绩效情况 ④: 项目存在的问题及解决措施 ⑤: 对项目的预测 ⑥: 变更请求 ⑦: 绩效目标及依据 注: 不包括 干系人沟通需求,干系人沟通需求是 在沟通管理计划里面 14.10 计算题 14.11 项目干系人分析 14.12 项目干系人管理输入:①: 干系人管理计划 ②: 沟通管理计划 ③: 变更日志 ④: 组织过程资产 注: 问题日志 是 管理干系人参与的 输出. 14.13 沟通方法有多种方法在干系人间共享信息 ①: 拉式沟通: 用于信息量大,受众很多的情况,要求接收者自行地访问信息内容,例如: 企业内网,电子在线课程,经验教训数据库,知识库②: 推式沟通: 把信息发送给需要接收这些信息的特定接收方,例如: 电子邮件,传真,信件等③: 交互式沟通: 在两方或多方进行多向信息交换,例如: 会议,电话,视频会议等 注: 最有效的沟通并解决干系人之间问题的方法————-面对面会议 14.14 沟通管理计划的工具和技术①: 沟通需求分析 14.15 沟通管理计划的输入①: 组织过程资产 ②: 项目章程 ③: 项目范围说明书 十五、风险管理项目风险管理包括规划风险管理、识别风险、实施风险分析、规划风险应对和控制风险等各个过程。项目风险管理的目标在于提高项目中积极事件的概率和影响，降低项目中消极事件的概率和影响。 11.1规划风险管理——定义如何实施项目风险管理活动的过程。 11.2识别风险——判断哪些风险可能影响项目并记录其特征的过程。 11.3实施定性风险分析——评估并综合分析风险的发生概率和影响，对风险进行优先排序，从而为后续分析或行动提供基础的过程。 11.4实施定量风险分析——就已识别风险对项目整体目标的影响进行定量分析的过程。 11.5规划风险应对——针对项目目标，制定提高机会、降低威胁的方案和措施的过程。 11.6控制风险——在整个项目中实施风险应对计划、跟踪已识别风险、监督残余风险、识别新风险，以及评估风险过程有效性的过程。 15.1 风险识别的输入:①: 风险管理计划 ②: 成本 ③: 进度 ④: 质量 ⑤: 人力资源 ⑥: 范围 ⑦: 活动成本估算 ⑧: 活动持续时间估算 ⑨: 干系人登记册 ⑩: 项目文件 ⑩: 采购文件 ⑩: 事业环境因素 ⑩: 组织过程资产 15.2 风险管理计划的内容:①: 风险类别 风险类别: 它提供了一种结构化方法以便使风险识别的过程系统化,全面化,这样就能在统一的框架下进行风险识别,目的是提高风险识别的工作质量和有效性 ②: 风险概率和影响力的定义 ③: 概率及影响矩阵 ④: 预算 ⑤: 方法论 ⑥: 角色与职责 ⑦: 已修订的项目干系人对风险的忍受度 ⑧: 报告的格式 ⑨: 制定的时间表 ⑩: 跟踪 15.3 定性风险分析对风险概率或影响进行评估和汇总,进而对风险进行排序,确定项目整体风险的等级,以便随后进一步分析或行动. 15.4 风险识别的工具①: 德尔菲技术 通过多轮征询获得专家对项目的一致见解, 项目风险专家以匿名方式参与活动,防止个人对结果产生过大影响, 当专家不在现场时,适合此方法 所以只看最后一个回合的值 ②: 头脑风暴 目的是取得一份综合的风险清单,与会人员就项目风险 集思广益 ③: 访谈 ④: 根本原因识别 ⑤: SWOT: 从项目的每个优势,劣势,机会,威胁出发,对项目进行考察,从而更全方面的考虑风险. 15.5 风险分类①: 从性质分: 静态风险: 自然力的不规则作用,人们的错误判断,和错误行为导致的风险. 动态风险: 由于人们欲望的变化,生产方式和生产技术的变化以及企业组织的变化导致的风险. ②: 从结果分: 纯粹风险: 仅仅造成损害 投机风险: 可能产生利润,可能造成损失 ③: 从风险源分: 自然事件 人为事件 软件风险 软件过程风险 项目管理风险 应用风险 用户使用风险 商业风险: 开发的产品不符合市场需求 15.6 项目风险识别的图解技术:①: 因果分析图: 又称 鱼骨图: 用于确定风险的起因 ②: 系统或过程的流程图: 反映某一系统内部各要素之间是如何相互联系的,并反映发生因果关系的机制. ③:影响图: 是一种图解表示问题的方法,反映了变量和结果之间的因果关系的相互作用,事件的时间顺序及其他关系. 15.7 风险应对策略:①: 消极风险应对策略: 改变计划,以排除风险,或保护项目目标不受影响,或对受威胁的一些项目目标放松要求. 15.8 风险识别①: 参与者: 尽可能多,尽可能广泛的人员参与,主要是 项目团队、客户、项目干系人等 ②: 风险识别是一个不断重复的系统活动,而不是一次性的 ③: 识别内部和外部风险 15.9 风险监控的输出①: 建议的纠正措施 ②: 新发现的风险 ③: 新的风险管理知识 ④: 变更申请 但不是批准的变更申请 15.10 风险三要素①: 风险事件 ②: 风险概率 ③: 风险结果 15.11 权变措施是风险监控过程中,对未识别的风险进行临时权变处理. 风险监控过程 输出 中的”建议的纠正措施”里的临时措施,即为 权变措施. ①: 对不利风险事件的未经计划的应对 15.12 定量风险分析的技术:期望货币值技术 15.13 预期收益计算 注意: EMV的计算,不是 75%* 300+60*25%+(-100) 也不是 75% *150 +25%*70+(-40) 十六、采购管理项目采购管理包括从项目团队外部采购或获得所需产品、服务或成果的各个过程。项目组织既可以是项目产品、服务或成果的买方，也可以是卖方。 项目采购管理包括合同管理和变更控制过程。通过这些过程，编制合同或订购单，并由具备相应权限的项目团队成员签发，然后再对合同或订购单进行管理。 项目采购管理还包括控制外部组织（买方）为从执行组织（卖方）获取项目可交付成果而签发的任何合同，以及管理该合同所规定的项目团队应承担的合同义务。 12.1规划采购管理——记录项目采购决策、明确采购方法、识别潜在卖方的过程。 12.2实施采购——获取卖方应答、选择卖方并授予合同的过程。 12.3控制采购——管理采购关系、监督合同执行情况，并根据需要实施变更和采取纠正措施的过程。 12.4结束采购——完结单次项目采购的过程。 16.1 采购规划的输出①: 采购工作说明书 16.2 采购规划的输入①: 干系人登记册 ②: 风险登记册 ③: 项目管理计划 16.3 关于合同:在编制项目采购计划时,根据采购类型的不同,需要不同类型的合同来配合. ①: 总价合同: 采用固定总价格,适用于产品范围较明确,买方风险小. ②: 成本补偿合同: 包括支付给卖方的实际成本, 加上一些通常作为卖方利润的费用,适合产品范围不明确,或项目存在较高风险,卖方风险小. ③: 工时和材料合同: 也称单价合同,是综合了固定总价和成本补偿的优点的合同,适用于 数量和时长不确定,工作规模或产品界定不甚明确.如聘请专家等 16.4 采购计划编制工具和技术:①: 自制/外购分析 ②: 专家判断 ③: 合同类型 十七、合同管理17.1 注意事项①: 如果合同中有附件,当附件和主合同产生矛盾时,应该以主合同为准. 17.2 合同描述:①: 合同不是解决两方或多方当事人分歧的 而是双方订立的一种约定 17.3 合同管理合同付款, 绩效测量 17.4 合同管理的目①: 审核并记录供应商的绩效以建立必须的纠正措施并作为将来选择供应商的参考 ②: 管理合同相关的变更利于项目客户的合同关系 ③: 十八、知识产权与标准规范18.1 标准代号①: GSB: 我国国家实物标准代号(国实标) ②: GB / T 推荐性国家标准(国标/推) ③: GA / T 我国公安部制定的推荐性标准 (国安/推) ——&gt; 属于行业标准,不属于国家标准 ④: GB / Z 国家标准指导性技术文件 ⑤: BS 英国国家标准 ⑥: ANSI: 美国国家标准 18.2 &lt;&lt;中华人民共和国政府采购法&gt;&gt;政府采购实行集中采购 和 分散采购 ①: 集中采购: 由省级以上人民政府公布的集中采购目录确定, 属于中央预算的政府采购项目,其集中采购目录 由国务院 确定并公布;属于地方预算的政府采购项目,其集中采购目录 由 省 自治区, 直辖市人民政府,或其授权的机构确定. ②: 分散采购: ③: 采购人,采购代理机构对政府采购项目每项采购活动的采购文件保存期限为 从采购结束之日起 至少保存 15年. ④: 采购文件: 中包含采购活动记录,采购预算,招标文件(由招标方准备),投标文件,评标标准,评估报告,合同文件等 ⑤: 竞争性谈判: 主要依据: 条件相当下的报价最低的原则 确定供应商, 而不是 根据综合实力 ⑥: 政府采购合同履行中,采购人需要追加与合同标的相同的货物等,在不改变合同其他条款前提下,可以与供应商协商签订 补充合同,但采购金额不得超过原合同采购金额的 10%. ⑦: 采购人采购纳入 集中采购目录的政府采购项目,必须委托集中采购机构代理采购;未纳入集中采购目录的政府采购项目,可以自行采购,也可以委托集中采购机构在委托的范围内代理采购. ⑧: 采购人有权自行选择采购代理机构, 任何单位和个人不能以任何方式为采购人指定采购代理机构 18.3 &lt;&lt;中华人民共和国 招标投标法&gt;&gt;①: 招标人设有标底的,标底必须保密. ②: 招标人不得向他人透露 已 获取招标文件的潜在投标人的名称,数量,以及可能影响公平竞争的有关招标投标的其他情况. ③: 中标人按照合同约定 或者经过 招标人同意,可以将 中标项目的部分非主体,非关键性工作分包给他人完成,接受分包的人应当具备相应的条件,并不得再次 分包. ④: 招标人对已发出的招标文件进行必要的澄清 或者修改的,应该在 招标文件要求提交投标文件的截止时间至少 15 日前,以书面形式通知所有招标文件收受者. ⑤: 30日内签订合同 ⑥: 评审委员会人数 必须 5人以上单数 ⑦: 确定中标人 后 要通知所有 投标人 ⑧: 招标人最迟应当在 书面合同签订后5日内向中标人,和未中标的投标人退换投标保证金及银行同期存款利息 ⑨: 评审委员会成员 中 技术,经济等方面专家不得少于成员总数的 2/3. ⑩: 开标由招标人主持,邀请所有投标人参加. ⑩: 招标人可以授权 评标委员会 直接确定中标人. ⑩: 招标人有权自行选择招标代理机构,委托其办理招标事宜. ⑩: 招标人具有编制招标文件和组织评标能力的,可以自行办理招标事宜. ⑩: 招标人收到投标文件后,应当签收保存,不得开启. ⑩: 合同中未说明时,合同生效日期,以邮戳为准 ⑩: 自招标文件开始发出之日起至投标人提交投标文件截止日为止,最短不得少于20日. ⑩: 开标 由招标人主持, 邀请所有投标人参加. 注意: 开标 由招标人主持, 而不是招标监督机构主持 注意: 几个数字: 签合同30, 截止20, 修改/ 投诉 / 质疑15, 推押金5,专家比例2/3 18.4 软件维护指南GB/T 14079-1993属于开发标准, 而不是文档标准. 18.5 软件文档三种类型: 18.5.1 开发文档描述开发过程本身. ①: 可行性研究和项目任务书 ②: 需求规格说明 ③: 功能规格说明 ④: 设计规格说明(包括程序和数据规格说明) ⑤: 开发计划 ⑥: 软件集成和测试计划 ⑦: 质量保证计划,标准,进度. ⑧: 安全和测试信息 18.5.2 产品文档① : 培训手册 ②: 参考手册和用户指南 ③: 产品手册 ④: 软件支持手册 18.5.3 管理文档记录项目管理的信息 ①: 开发过程的每个阶段的进度和 进度变更的记录. ②: 软件变更情况 的记录 ③: 相对于开发的判定记录 ④: 职责定义 口诀: 开计划,产手册,管变更 18.6 软件质量保证计划规范 GB/T12504-1990项目开发组组长或其代表 可作为评审组成员,但是不能 担任 评审组 组长 或副组长 ①: 验证(重点是: 是否达到需求) 确定软件开发周期中的一个给定阶段的额产品是否达到 上一阶段 确立的 需求 的过程 ②: 确认(重点是: 是否 与需求一致) 软件开发过程结束 时 对软件进行评价以确定它是否 和软件需求 相一致的过程. ③: 测试 通过执行程序 来有意识 地发现 程序设计 错误 和编码错误的过程. 18.7 质量管理①: 重要工作: 评价和改进 ②: 重点: 持续改进 18.8 软件保护条例包括 程序 和文档 ,但不包括 开发该软件所用的思想. 18.9 评标委员会 和 评标方法 暂行规定投标文件中 大写金额和 小写金额 不一致 的 ,以 大写金额 为准;总价金额 与 单价金额 不一致的 以单价金额为准.,但单价金额小数点有错误的除外,对不同文本发生异议的,以中文为准. 18.10 文档质量可按照文档形式 和 列出的要求划分为4级 ①: 最低限度文档(1级文档): 开发工作量低于 一个人月的开发者自用程序 ②: 内部文档(2级文档): 没有与其他用户共享资源的专用程序 ③: 工作文档(3级文档): 同一单位若干人联合开发的程序 ④: 正式文档(4级文档): 正式发行供普遍使用的软件产品. 18.11 软件质量属性①: 功能性: ②: 可靠性: 成熟,容错,易恢复 ③: 易用性: 使用的难易程度及规定 ④: 效率: 软件性能水平和所用资源之间的关系 ⑤: 维护性 ⑥: 可移植性 18.12 完整的综合布线系统(6个部分)①: 建筑群子系统: 实现建筑物之间的相互连接,通常介质是光缆. ②: 垂直干线子系统: 负责连接管理间子系统,到设备间子系统,使用光缆或UTP. ③: 水平配线子系统: 实现信息插座和管理子系统的连接. ④: 设备间子系统: 由设备中的电缆,连接器和相关支撑设备组成,与公共系统设备相连. ⑤: 工作区子系统: 终端设备连到信息插座 ⑥: 管理子系统: 是干线子系统和水平子系统的桥梁,同时又可为同层组网提供条件,为连接其他子系统提供连接手段,由配线架,HUB,机柜,电源灯组成. 18.13 &lt;&lt;中华人民共和国著作权法&gt;&gt;①: 改编,翻译,注释,整理已有作品而产生的作品,著作权由 改编,翻译,注释,整理人 享有.. ②: 作者的署名权,修改权,保护作品完整权的 保护期不受限制. ③: 公民的作品,其发表权,使用权和获得报酬权的保护期 为作者终生及其死亡 后 50 年, 截止 于 作者死亡后 第50年的12月31日. ④: 计算机软件和口述作品等受著作权保护 注: ①: 不适用于: 法律,法规,行政,司法性质的文件等 ②: 不适用于时事新闻 ③: 不适用于 历法,通用数表,通用表格和公式. 18.14 软件文档管理指南GB/T16680-1996文档评审:由软件开发小组成员,用户代表,软件开发单位负责人,标准化人员,科技管理人员组成评审小组. 注: 用户代表 必须参加. 18.15 电子计算机机房规范GB50174-1993四种接地方式: ①: 直流工作接地: 接地电阻 应按照计算机系统具体要求, 一般不大于1欧姆 ②: 交流工作接地: 接地电阻 不应大于4欧姆 ③: 安全工作接地: 接地电阻 不应大于4欧姆 ④: 防雷接地: 应该按照现行 国家标准 &lt;&lt;建筑防雷设计规范&gt;&gt;执行,一般不大于10 欧姆 注: 静电接地 可以经过限流电阻 及自己的连接线与接地装置相连,限流电阻的阻值宜为1M欧姆. 口诀: 1直男交4女友被雷劈10 18.16 合同法①: 当事人订立合同,采取方式 有 “要约”,和”承诺”方式. ②: 当事人 采用信件,数据电文等形式订立合同的,可以在合同成立之前要求签订确认书,签订确认书时合同成立. 18.16.1 要约表示自己希望和他人订立合同 例如: 投标人向招标人投递标书———提交的投标文件是 投标人希望同招标人订立合同 18.16.2 要约邀请表示希望他人向自己 发出要约,例如: 征婚广告,拍卖公告,招标公告,商业广告,寄送的价目表等都是要约邀请. 注: 要约到达受要约人时生效. 18.16.3 承诺表示受要约人同意要约 18.17 格式条款 与 非格式条款18.17.1 格式条款:①: 又称标准条款,指当事人为重复使用而预先拟定的,并在订立合同时未与对方协商的条款,如保险合同,拍卖成交确认书等都是格式合同. ②: 采用订立合同的,提供格式条款的一方应当遵循公平原则确定当事人之间的权利和义务,并采取合理的 方式提请对方注意免除或者限制其责任的条款. ③: 当格式条款与 非格式条款不一致时 应当 采用 非格式 条款. ④: 提供格式条款 一方免除其责任,加重对方责任,排除对方主要权利的该条款无效. 18.17.2 非格式条款18.18 有效性计算有效性 = ( 总运行时间 - 故障恢复时间 ) / 总运行时间 例题: 18.19 政府采购的招标程序①: 采购人 编制计划,报县级以上人民政府的财政部门批准 ②: 采购办与招标代理机构 办理委托手续,确定招标方式 ③: 建设单位委托 相关 的咨询公司进行 市场调查, 与采购人确认采购项目后,编制招标文件. ④: 发布招标公告,或招标邀请函 ⑤: 出售招标文件,对潜在的投标人资格预审 ⑥: 接受投标人标书 ⑦: 在公告或邀请函中规定的时间,地点公开开标 ⑧: 由评标委员对投标文件评标 ⑨: 依据评标原则确定中标人 ⑩: 向中标人发送中标通知书,并通知所有投标人 ⑩: 组织中标人与采购单位签订合同 18.20 软件工程术语GB/T11457-2006对于配置管理有以下三种基线: ①: 功能基线 ②: 分配基线 ③: 产品基线 18.21 机房工程设计原则①: 实用性和先进性: 满足当前业务需求,兼顾未来的业务需求,尽可能采用先进设备,技术. ②: 安全可靠性: 决不能出现单点故障 ③: 灵活可扩展性: 能根据业务不断深入发展的需要,扩大设备容量,提高可容纳用户数,支持多种网络传输,多种物理接口的能力等 ④: 标准化 ⑤: 经济性,投资保护 ⑥: 可管理性 18.22 著作权公民完成法人或其他组织工作任务所创作的作品是职务作品,其一般职务作品的著作权由作者享有,但法人或非法人单位有权在其业务范围内优先使用,作品完成两年内,未经过单位同意, 作者不得许可第三人使用. 18.23 合同法①: 法律,行政法规规定或当事人约定采用书面形式订立合同,当事人未采用书面形式,但一方已经履行主要义务,对方接受的,该合同成立 ②: 采用合同书形式订立合同,在签字或盖章前,一方已经履行了主要义务,对方接受的,该合同成立. ③: 标的物在订立合同之前已为买受人占有的,合同生效时间为交付时间. 18.24 关于政府采购的招标流程: 18.25 机房等级A 容错——-最高级别 B 冗余 C 需求 18.26 文档质量四个等级 18.27 软件生存周期过程 GB/T 8566-2001 十九、干系人管理19.1 干系人登记册为项目的沟通计划提供了干系人的信息,从干系人的登记册中,可知道项目中干系人的信息: 主要沟通对象,关键影响人,次要沟通对象. 19.2 管理干系人的参与 输入:①: 干系人管理计划 ②: 沟通管理计划 ③: 变更日志 ④: 组织过程资产 19.3 管理干系人的参与 输出:①: 问题日志 19.4项目干系人管理:主要内容: ①: 项目干系人分析: 识别干系人,并分析干系人兴趣,影响力理解关键干系人的希望期望需要. ②: 沟通管理: ③: 问题管理: 对沟通过程发现的问题,记录并采取行动解决. 19.5 项目干系人管理 与 人力资源管理 区别干系人管理 与 沟通管理: 如何与形形色色的人打交道 人力资源管理: 如何管人,带团队 二十、速记口诀口诀: 范进整狗子,成人风采. 对应的过程数: 676 3344 464 口诀: 两启两收先来记 口诀: 范进成风无执行 口诀: 人力资源无监控 范围管理口诀: 范围需要先收集，裁剪补充再定义； 拆分工作创WBS，审批输出一基准 控制范围先确认. 进度管理口诀: 进度先要定活动，然后才能排顺序； 资源 时间要估算，这样才能制计划。 风险管理口诀: 风险识别要靠前，定性定量分析全； 已知未知要了解，这样才能来应对。 口诀: 用逻辑进程实现部署, 静态实现构件图 口诀: 部队用包袱制品够累—–静态视图 口诀: 东西装信是交互——动态视图 口诀: 鸟翅组合强关联,相依为命同根生 口诀: 类与用例两不同,包含扩展类中无 口诀: 追漏回源—–追溯与回溯区别 四控,三管,一协调.———&gt;镜子投资变更控, 信安合管一协调, 口诀: 划分即实验—–生命周期 口诀: 窃可用,截机密,篡完整,伪合法 口诀: 一主二审三标四化五验证口诀: 验国防,化中央,标地方 口诀: 就是鱼丸—–软件维护四过程 口诀: 阶段组成熟(阶乘),连续组过能——-CMMI 口诀: 捉错误, 揍设编, 审标准, 评质量 口诀: 巫术忘传会彪鹰—–OSI七层模型 口诀: 汇策略,核骨干——汇聚层 口诀: 叫计验指纹—–教训、企业计划、经验、指导方针、文档等。——–组织过程资产 口诀: 孔雀忍受暴行 —————–&gt;质量控制正确性,范围确认可接受,质量保证信心. 大特性口诀: 功能靠用小护翼 小特性口诀：合准用一安，错译成，学姐操石源，试改定分，应装一T 口诀: 绩效日志组织入,变更请求是输出———-&gt;管理项目团队 赫兹伯格保激理论 马斯洛5层需求金字塔 塔克曼阶梯5阶段—&gt;形震规发终解散 项目评估的基本方法： 静态分析法：小偷偷偷2———–最小费用法，投资收益率法，投资回收期法，追加投资回收期法 动态分析法：投资回收期法 和 贱内 ———（净现值法，内部收益率法） 注: 投资回收期法 既是静态分析法, 也是 动态分析法. 口诀: 最小投收是静态 口诀: 重点管理双高, 权高利低满意即可 口诀: 开计划,产手册,管变更 总结: 上下相减是浮动,左右相减是工期——-关键路径口诀: 早开始,迟完成,紧前紧后来分析, 其他皆可推.——关键路径 项目收尾：包括管理收尾和合同收尾； 合同收尾过程涉及产品正式验收和管理收尾 口诀: 1直男交4女友被雷劈10次———机房中防雷、直流交流电阻相关知识 项目目标特性：口诀: 鲜橙多。优先性，层次性，多目标性； 项目特点：临时性、独特性、渐进性。 软技能：口诀: 勾引领导，激谈解决——有效的沟通，对组织施加影响，领导，激励，谈判与冲突管理，解决问题。 事前检查、事中评审、事后审计 项目阶段末可以进行一次审查，目的是取得对结束当前阶段并启动下一阶段的核准 五大过程组：启动，规划，执行，监控，收尾； PDCA：计划，执行，检查，行动。 可行性研究的内容：基金运疯计。技术，经济，运行环境，风险分析,项目计划, 其他方面（法律，社会）可行性分析。不包括项目评估方法 可行性研究的方法：惊世娘子。经济评价法，市场预测法，增量净效益法，投资估算法。 可行性研究的原则：客观公。科学性、客观性和公正性。 可行性研究的风险：急诊室。技术风险，政治风险，市场风险。 可行性研究的步骤：木桶鸡粗腿变焦。1）确定项目规模和目标，2）研究正在运行的系统，3）建立新系统的逻辑模型，4）导出和评价各种方案，5）推荐可行性方案，6）编写可行性方案，7）递交可行性方案。 投资前期四个阶段(可行性研究的顺序)：机会研究，初步可行性研究，详细可行性研究，可行性研究评估与决策; 实际工作中,前三个阶段依据项目规模和繁简程度可以把前两阶段省略或者合二为一,但详细可行性研究不可缺少.升级改造项目只做初步和详细研究,小项目只做详细可行性研究. 项目论证三个阶段：机会研究（寻求投资机会，鉴别投资方向，±30%），初步可行性研究（项目是否有生命力，是否盈利，±20%），详细可行性研究（详细技术经济论证，多方案中选择最优方案，±10%）。 项目论证：分为内部论证和外部论证，可以贯穿于可行性研究的整个阶段，项目论证费用属于立项前费用，不计入项目的总投资之内；注意: 项目评估由第三方进行；论证和评估可以同时进行,项目论证的核心是财务经济 项目建议书：包含项目必要性，市场，预测，不包含风险因素。 数据库和数据仓库：动态变化和不变，数据仓库4个特性：面向主题，稳定，集成，反映历史变化。 软件文档：开餐馆。 开，产，管。 程序流程图（设计阶段）、数据流程图DFD（分析阶段）是结构化方法使用的主要工具； 多路复用技术：贫富，薄雾，试题，马戏。频分FDMA，波分WDMA，时分TDMA，码分CDMA。 OLAP的实现方法3种：官多喝。ROLAP（关系数据库）、MOLAP（多维数据存储）、HOLAP（混合）。 CRM要素：1）以客户为中心，2）注重客户满意度，增加企业获利能力，3）针对不同客户采取不同措施。 CRM组成：触发中心，挖掘中心。 对象是一个封装，三要素：对象标识，对象状态，对象行为；对象是类的实例，类是对象的模板。 RUP四个阶段：粗细尖椒。 初始阶段，细化阶段，构建阶段，交付阶段。 软件架构模式：1）管道/过滤器模式，2）面向对象模式，3）事件驱动模式（典型的图形界面工具），4）分层模式，5）知识库模式（知识源，黑板，语音和识别），6）C/S模式（C/S需要客户端，B/S使用浏览器）。 分布式对象中间件：呕血，色，妈的。OMG的CORBA，SUN的EJB，MICROSOFT的DCOM。 数据库访问中间件：WINDOWS平台的ODBC，JAVA平台的JDBC。 面向消息中间件：IBM的MQSERIES。 物联网三层：敢裸泳。感知层 网络层 应用层。 云计算：IAAS（基础设施），SAAS（软件），PAAS（平台）。 IPV6：2的128次方，IPV4：2的32次方。 ERP：管理层面，设计层面用其他方法。 JAVA：单继承语言 WEB SERVICE：翻译，桥梁，异构，单机和局域网不适用，是实现SOA的最主要方法，SOAP（执行服务调用）,UDDI（发布查找服务）,WSDL（描述服务和接口）是基于XML的。SOAP使用XML进行编码，与应用平台完全无关。 J2EE和.NET：跨平台和不跨；J2EE运行环境包括：构件（应用逻辑的代码），容器（构件的运行环境），服务（功能接口）。 .NET开发框架：ADO.NET技术用于访问数据库；基础类库提供接口，基于下一代网络应用；通用语言运行环境处于.NET最底层，是基础。 工作流3个阶段：流程建模、仿真、改进或优化。 信息化知识点：鹰上鸡下人左龟右。应（龙头）资（核心）网，产人（成功之本）政（根本保障）。 电子商务：涉及4种流：戏子伤我（信息流、资金流、商流、物流），戏不可少。信息流是最基本必不可少的。 现代电子商务包括：1）基于因特网，2）多个参与方，3）活动范围扩大。 电子政务建设原则：1）统一规划，加强领导，2）需求主导，突出重点，3）整合资源，拉动产业，4）统一标准，保障安全。 B2B：阿里巴巴，B2C：京东、淘宝、一号店，C2C：淘宝网。 支付技术：电子钱包，电子现金，智能卡，支付形式：支付网关，第三方支付（淘宝），直接支付。协议SSL（传输层），SET（应用层）。 SSL、TLS是传输层安全协议；IPSEC是网络层安全协议；TTPT是链路层安全协议 PPTP和IPSEC协议用于虚拟专用网。 商业智能BI（要有决策有结果），数据挖掘（线性回归，描述，分类，预测），企业应用集成EAI （跟过程有关，核心ESB），CRM客户关系管理（一定要为企业盈利，不对）。 法律法规知识点：5天（退还保证金，资格预审），5个工作日（卖标书），7个工作日（质疑），15天（修改，确定中标人上报），15个工作日（投诉），20天（截止），28天（索赔），30天（签合同，暂停时间），30个工作日（书面通知投诉人），15年（采购文件保存）。 公司倒闭了合同无效。 著作权50年，发明专利权20年，新型、外观设计10年，商标保护10年；地域性无效，50年后失效。 国家标准有效期为5年。 计算机系统集成资质认证工作：根据认证和审批分离原则，先由认证机构认证，再由信息产业主管部门审批。 投标单位主要活动：1）收集招标信息，2）索购并填报资格预审文件，3）购买招标文件，4）提出问题，5）编制投标文件，6）提交投标文件，7）参加开标会议，8）讲解投标文件，9）回应招标方质疑或提交补充材料，10）如果中标，还需要签订书面合同。 监理知识点：1）监理合同是解决争议的依据；2）总监负责制；4）监理大纲是投标阶段方案性文件，监理规划是签合同后纲领性文件，监理实施细则是可操作性业务文件；5）监理不可参与验收方案的制订；6）总监负责人、工期、钱、规划；监理四级：甲乙丙暂定级，总监负责制，旁站隐蔽工程，索赔28天；7）内容：四控三管一协调。只见头变心何安8）分为咨询式、里程碑式和全过程监理。（质量、进度、投资和变更控制，信息、合同和安全管理，协调）； 连接2个以太网的设备是网桥。 网络规划：分界内的自己，分界外的运营商负责。 PING：看网络配置是否正确,127本机网卡是否正确。 UDP：面向无连接、不可靠的传输协议。 机房工程：2-3层，A（需要配备柴油发电机）BC三个等级，机房等电位连接方式，耐火材料不低于2级。 MAC地址：ARP协议转换的，MAC对于一个IP而言可以有多个，使用路由器时。 静电电压：1000V ；1**直交4个女友雷10。** 局域网3个网络协议：1）微软的NETBEUI；2）NOVELL的IPX/SPX；3）TCP/IP。 LAN分为：总线型（逻辑）、星型（物理，分带宽）、环型局域网。 RAID0（n），RAID1（n/2），RAID5（n-1）。 完全备份&gt;差分备份&gt;增量备份&gt;按需备份。 无线网络四类：WLAN，WMAN，WWAN，WPAN（无线个人网）。 无线接入：WIMAX（50千米）使用802.16协议，WI-FI（10-300米）使用802.11协议，Zigbee（10米）使用802.15.4属于WPAS，网络桥接器AP（100-300米），蓝牙10米。 802.11定义了3种物理层通信技术：直接序列扩频，窄带微波，漫反射红外线。 光纤接入方式：FTTR远端接点，FTTB大楼，FTTC路边，FTTZ小区，FTTH户，FTTD桌面。 打印服务器：采用TCP/IP协议。 信息插座到网卡之间使用无屏蔽双绞线，布线距离最大10米。 FTP基于TCP20和TCP21完成面向连接、可靠的数据传输；TFTP基于UDP69端口号；HTTP基于TCP80端口号；Serv-U是一种广泛运用的FTP服务器端软件。 交叉线：同种设备之间、ADSL MODEM和集线器HUB连接时；其余用直连线。 三层交换机：即核心交换机，具有组播功能。 3G标准4种：WCDMA\CDMA2000\TD-CDMA\WIMAX。 LTE比3G更好：高数据速率，分组传送，延迟降低，广域覆盖，向下兼容。 病毒是一些可以自我复制到可执行文件中的代码段； 蠕虫是一种可以自我复制传播且不需要宿主的完整的程序（熊猫烧香）； 木马是一种程序，可以隐藏在正常程序中执行破坏功能（灰鸽子）； DOS攻击破坏可用性。 范围管理： 规定贱人制，（范围规划，范围定义，创建WBS分解结构，范围确认，范围控制） 标杆分检查。（模板表格和标准，产品和干系人分析，分解，检查，变更控制系统和偏差分析）。项目范围和产品范围：项目范围强调过程，产品范围强调结果。项目范围是否完成以项目管理计划、项目范围说明书、WBS、WBS字典作为衡量标准，产品范围是否完成以产品需求说明书作为衡量标准。 范围管理计划内容：1）如何基于初步的项目范围说明书准备一个详细的项目范围说明书，2）如何从详细的项目范围说明书创建WBS， 3）如何对已完成项目的可交付物进行正式的确认和接受的，4）如何对详细的项目范围说明书申请变更，这个过程直接与整体变更控制过程相关联。 详细的范围说明书包括：标书求姐夫，厂家约疯子，北京惩治囚犯。1）项目目标，2）产品范围描述，3）项目需求，4）项目边界，5）项目的可交付物，6）产品可接受的标准，7）项目的假设条件，8）项目的约束条件，9）初始风险，10）初始的项目组织，11）进度里程碑，12）资金限制，13）成本估算，14）项目配置管理需求，15）已批准的需求，16）项目规范。 分级树型：直观而不容易修改，适合小中项目；表格形式：不直观而方便，适合大项目。 WBS三个方法：吃饺子。1）把主要的项目可交付物和子项目作为第一层，2）子项目作为第一层，3）把项目的生命期作为第一层，项目交付物作为第二层。WBS一般3到5层，它是组织的核心。 WBS八个原则：1）在各层次上保持项目的完整性，避免遗漏必要的组成部分，2）一个工作单元只能从属于某个上层单元，避免交叉从属，3）相同层次的工作单元应用相同性质，4）工作单元应能分开不同的责任者和不同工作内容，5）便于项目管理计划、控制的管理需要，6）最底层工作应该具有可比性，是可管理的，可定量检查的，7）应包括项目管理工作，包括分包出去的工作。 WBS主要步骤：1）识别项目交付物和相关项目工作，2）对WBS的结构进行组织，3）对WBS进行分解，4）对WBS中各级工作单元分配标识符或编号，5）对当前的分解级别进行检验，以确保它们是必须的，而且是足够详细的。 WBS\OBS\RBS：工作分解结构WBS根据可交付物进行分解，组织分解结构OBS根据组织的部门、单位或团队进行分解，资源分解结构RBS根据资源进行分解，风险分解结构RBS根据已识别的风险进行分解。 范围基线包括：已批准的项目范围说明书（详细）、WBS、WBS字典。它是创建WBS的输出。 范围确认和质量控制：范围确认是有关工作结果的可接受问题，而质量控制是有关工作结果是否满足质量需求的问题。质量控制通常在范围确认之前进行，也可以并行。 范围确认应该是贯穿项目的始终，采用检查，范围确认完成时，同时应当对确认中的WBS和WBS字典进行更新。 范围蔓延原因：三无。1）无基线2）需求挖掘不够3）无变更控制程序。 变更原因：1）项目外部环境发生变化，2）项目范围的计划编制不周密详细，有一定的错误或遗漏，3）世界上出现了或是设计人员提出了新技术、手段或方案，4）项目实施组织本身发生了变化，5）客户对项目、项目产品或服务的要求发生变化。 变更控制的焦点问题：1）对造成范围变更的因素施加影响，以确保这些变更得到更一致的认可，2）确定范围变更已经发生，3）当范围变更发生时，对实际的变更进行管理。 范围变更后，要更新基准、预算、项目管理计划。 范围管理中常见问题和建议：1）不完整的需求：得到完整的需求，2）缺乏用户参与：联系所有项目干系人，3）不现实的期望：加强沟通，4）需求改变：进行范围控制，5）缺乏计划：增强项目计划，6）在压力下放弃计划：增强项目计划，7）遗漏必要的任务：加强范围确认，8）开发人员的镀金：界定项目边界，9）功能蔓延：进行范围控制。 范围问题应想到建立变更控制管理流程，质量问题应想到建立质量管理体系，建立标准，基线，重新制定完善管理计划，对流程进行优化。 进度管理： 腚需圆，利画质。（活动定义，活动排序，活动资源估算，活动历时估算，制订进度计划，进度控制） 腚需圆（专替姑管下：专家判断法，替换方案确定，公开估算数据，项目管理软件，自下而上的估算），利（专流沧桑泪：专家判断，预留时间，参数式估算，历时的三点估算，类比估算法）画质 项目计划（进度）网络图：是活动排序的输出，进度计划编制的输入。 资源估算：输入（企业环境因素，组织过程资产，活动清单，活动属性，资源可用性，项目管理计划），工具（专家判断法，替换方案确定，公开估算数据，项目管理软件，自下而上的估算），输出（活动资源需求，更新的活动属性，资源分解结构RBS，更新的资源日历，变更请求），它不包括后备分析。 历时估算：输入（企业环境因素，组织过程资产，项目范围说明书，活动清单，活动清单属性，活动资源需求，资源日历，项目管理计划），工具（专家判断，预留时间，类比估算法，参数式估算，历时的三点估算），输出（活动历时估算结果，更新的活动清单属性）。 关键链：缓冲段防范风险。 进度估算工期方法：1）明确定义项目的WBS；2）根据以往经验，采用类比估算法；3）联系业界专家，采用德尔菲法；4）依据数据采用参数估算法和三点估算法。 加快进度的措施：新加支筷子。新技术，加班，增加资源，快速跟进，资源平衡。 进度压缩工期方法：1）缩小范围，2）外包，3）并行工作，4）明确奖惩机制，提高员工工作绩效，5）赶工，6）加强阶段性检查和控制，避免后期返工，7）加强沟通，争取客户能够对项目范围，以及需求、设计和验收标准进行确认，避免后期频繁出现变更。 进度跟踪方法：1）制定活动网络图和项目工作计划，2）建立监督和测量机制，3）建立评审机制，4）及时纠正和预防问题，进行有效的变更管理，5）使用有效的项目管理工具，提高工作效率。 整体管理： 章书记指空整薇，（制定项目章程，制定初步的项目范围说明书，制定项目计划，指导和管理项目执行，监控项目执行，整体变更控制，项目收尾。） 项目章程：正式批准一个项目或者批准项目是否进入下一阶段的文档，并对项目经理授权。由组织外的发起人或资助人发布。 项目章程内容：需需的任干碑，职假约翻概。 1）项目需求，反映干系人的要求和期望， 2）项目必须实现的商业需求，项目概述或产品需求， 3）项目的目的或论证结果， 4）任命项目经理并授权级别， 5）干系人的影响， 6）里程碑进度计划， 7）职能组织， 8）组织的、环境的和外部的假设， 9）组织的、环境的和外部的约束 10）论证项目的业务方案，包括投资回报率， 11）概要预算。 关于项目章程详细介绍: 项目由项目以外的人员批准，例如，发起人（可能不止一个人）、PMO 或项目组合指导委员会。项目启动者或发起人应该具有一定的职权，能为项目提供资金。他们亲自编制项目章程，或授权项目经理代为编制。项目章程经启动者签字，即标志着项目获得批准。可能因内部经营需要或外部影响而批准项目，故通常需要编制需求分析、商业论证或情况描述。通过编制项目章程，就可以将项目与组织的战略及日常运营工作联系起来。 项目章程是整个项目的宪法，PMBOK指南对项目章程的内容做了精简，以更加体现它作为项目宪法的原则性。根据PMBOK指南，项目章程应该包括的主要内容如下： 1、概括性的项目描述和产品描述。 2、概括性的项目描述，包括项目的总体范围和总体质量要求。 3、可测量的项目目标和相关的成功标准。 4、项目的主要风险，例如，可以列出项目的主要风险类别。 5、总体里程碑进度计划。 6、总体预算，可以是一个概算区间，例如，在100万元至130万元之间。 7、委派的项目经理及其职责和职权。 8、发起人或其他批准项目章程的人员的姓名和职权。 ​ 而信息系统项目管理师教程上说明项目章程的编制过程主要关注于记录建设方的商业需求、项目立项的理由与背景、对客户需求的现有理解和满足这些需求的新产品、服务或结果。项目章程应当包括以下直接列入的内容或援引自其他文件的内容。(1)基于项目干系人的需求和期望提出的要求。(2)项目必须满足的业务要求或产品需求。(3)项目的目的或项目立项的理由。(4)委派的项目经理及项目经理的权限级别。(5)概要的里程碑进度计划。(6)项目干系人的影响。(7)职能组织及其参与。(8)组织的、环境的和外部的假设。(9)组织的、环境的和外部的约束。(10)论证项目的业务方案，包括投资回报率。(11)概要预算。 由此可知，在项目章程发布时，已经做了一些设计和估算工作。 要注意的是，虽然项目经理可以参与甚至负责起草项目章程，但项目章程不是由项目经理发布的，而是由项目团队之外的管理层发布的，项目经理只是项目章程的实施者。作为项目的宪法，项目章程中的内容应该是一些原则性的、概括性的问题，通常不会因项目变更而需要修改，除非是发生了非常重要的变更（例如，考虑是否需要终止项目）。如果要修改项目章程（例如，当项目总体目标发生变化时），则只有管理层才有权进行（谁签发，谁修改的原则），也就是说，项目章程的修改不在项目经理的权责范围之内。 项目章程 的编制: 主要关注 记录商业需求,项目论证,对顾客需求的理解,和满足这些需求的新产品,服务或结果. 工作说明书SOW：对内部项目而言，由项目发起人提出；对外部项目而言，可以作为投标文档一部分从客户那里得到。包括：爷参战。业务需求，产品范围描述，战略计划。 组织过程资产：叫鸡验指纹。教训、企业计划、经验、指导方针、文档等。 项目管理计划内容：过失工期管制，控制机构责问 1）所使用的项目管理过程， 2）每个特定项目管理过程的实施程度， 3）完成这些过程的工具*和技术的描述， 4）选择的项目的生命周期和相关的项目阶段， 5）如何用选定的过程来管理具体的项目。 包括过程之间的依赖与交互关系和基本的输入输出等， 6）如何执行工作来完成项目目标， 7）如何监督和控制变更， 8）如何实施配置管理， 9）如何维护项目绩效基线的完整性， 10）与项目干系人进行沟通的要求和技术， 11）为项目选择的生命周期模型。对于多阶段项目，要包括所定义阶段是如何划分的， 12）为了解决某些遗留问题和未定的决策，对于其内容，严重程度和紧迫程度进行的关键管理评审。 工作绩效信息包括：进度进展，已（未）完成哪些交付物，已开始（完成）哪些活动，满足质量标准的程度，批准的预算与发生的成本，已开始活动的预计完成日期，当前项目活动所完成的百分比，已记录下的经验教训，资源使用情况。 变更：分别内部和外部变更。流程：生平绝食盐蛋。CCB一定要有，CCB不能提出变更申请，PM不担任CCB主席，主席一票否决权，在基准内不用走变更流程，是决策机构不是作业机构，不必是常设机构，可以一个人或者多人，甚至兼职人员，人员组成：高项配车子。CCB的职责之一。（高层经理、项目经理、配置管理负责人、测试负责人、质量保证负责人等），变更控制流程的作用不包括确定要批准还是否决变更请求，它是（变更申请，评估，决策，实施，验证，沟通存档）， 监理在变更中的工作：1）接受变更申请，2）评估变更，3）参与CCB评审，4）下达变更通知书，与PM共同发布变更，5）监控变更实施，6）对变更结果进行验证。 变更批准后项目经理工作：1）更新项目管理计划或其他管理计划文件，2）安排相应人员负责新的项目活动，3）更新WBS和WBS字典，4）编制新的或修订成本估算、活动排序、进度日期、资源需求和风险应对方案等。 项目收尾：包括管理收尾和合同收尾；合同收尾过程涉及产品验收和管理收尾。 沟通管理： 勾媳暴干。(沟通计划编制，信息分发，绩效报告，项目干系人管理) 高效会议：定期揭发，发誓归总记账。1）事先制定一个例会制度，2）放弃可开可不开的会议，3）明确会议的目的和期望结果，4）发布会议通知，5）在会议前将会议资料发给参会人员，6）可以借助视频设备，7）明确会议规则，8）会议后要总结，提炼结论，9）会议要有纪要，10）做好会议的后勤保障。 认知障碍：从源头；语义障碍：传递过程中。 沟通五个原则：早接住别生。1）尽早沟通，2）采用对方能接受的沟通风格，3）主动沟通， 4）内外有别， 5）沟通的升级原则。 绩效报告：1）进度和状态报告（进展报告需要分析原因，突出建议和决策），2）预测。 项目干系人管理的目的：避免他们在项目进行期间分崩离析，它贯穿始终。 质量管理： 鞭暴之，（质量计划编制，执行质量保证，执行质量控制） 鞭（小鸡公爵六十只/效益分析，基准分析，功能展开，过程决策，流程图，实验设计，质量成本）：成本 暴（济公审过鸡：质量计划工具和技术，质量控制工具和技术，质量审计，过程分析，基准分析） 之（老七：贱人只留三排孔6西格玛；新七：相亲数据有火锅：相互关系图、亲和图、树状图、矩形图、优先矩形图、活动网络图、过程决策图）：检查表、因果图、直方图、流程图、散点图、排列图、控制图；侧面桶抽六个马：测试、统计、抽样、 质量成本：分为一致成本（预防成本、评估成本）和不一致成本（故障成本）。 质量保证QA：项目经理不能担任QA，针对过程，质量控制QC针对结果。 QA职责：包括过程指导、过程评审、产品审计、过程改进和过程度量等（前期当导师，辅助PM制定项目计划、项目估算、设定质量目标、培训指导人员等；实施中当警察，选择性地参加项目技术评审，定期对产品和过程进行审计和评审；实施中还当医生，承担收集、统计和分析度量数据的工作，用于支持管理决策。） 全面质量管理TQM：四全：元芳过节（全员、全过程、全面方法、全面结果）；朱兰：娘子高（“质量规划、控制、提高”三部曲）；克鲁斯比（零缺陷源于预防）。 质量审计：是QA工具，可以是有计划的或者随机的，分为内审和外审。 预防（把错误排除在过程之外）和检查（把错误排除在到达客户之前）；特殊抽样（结果符合或不符合）和变量抽样（结果是在测量符合程度的连续坐标系表示）；特殊原因（异常事件）和随机原因（正常过程偏差）；许可的误差（如果在许可的误差规定范围内，结果是可以被接受的）和控制限度（如果结果是在控制限度内，表明过程是在控制之中）。 趋势分析图：继续测试，平稳后不用测试。 CMM5级：质量要保证，除虫定管用。初始级，可重复，已定义，已管理，优化级。 CMMI过程改进目标：保证产品及服务质量，项目时间控制，最低的成本。 CMMI评估：A类（全面综合的评估法），B类（较少综合，花费也少），C类（快速评估法）。 OPM3由过程组，知识领域和过程改进组成，其中过程改进四个阶段是标准化，可测量，可控制，持续改进。 6个质量特性和21个子特性：功能靠用小护翼（是准用一安，错译成，学姐操，石源，试改定分，应装一T）。 质量管理重点工作：1）制定切实可行的质量管理计划，2）应安排独立于项目组的QA人员负责质量保证工作，3）实施质量审计，4）注重技术评审工作，5）注重测试工作，6）对发现的缺陷进行统计分析，确保质量，7）为项目组成员提供质量管理要求方面的培训。 质量管理计划内容：1）描述组织的项目质量管理体系，2）质量控制的方法，工具与重点，3）设计、生产过程、安装、服务、检查和测试程序及文档，4）识别出的测量要求，5）特定阶段的审核要求，6）质量标准或验收标准。 软件需求：功能，非功能，设计约束。 软件质量评价：验证和确认，验证满足前面要求，确认是看结果是否正确。 软件配置：物理性，功能性。 评审与审计：评审是质量控制的，正式的，评审可以自己评审，内审和外审。审计或评估是第三方，QC和QA不能同时担任，项目经理不能担任QA。 评审过程包括：管理评审（监控进展）、技术评审（评价软件）、检查（检测异常）和走查（不正式）。 质量问题三无：无标准、无基线、无质量控制流程。 成本管理： 顾欲空，（成本估算，成本预算，成本控制） 顾（下官擂肥卖金子：自下而上的成本估算，项目管理软件，类别估算法，确定资源费率，卖方投标分析，准备金分析，质量成本） 欲（城管掺和：成本总计，管理储备，参数模型，支出的合理化原则） 空（成绩预计偏软：成本更变控制系统，绩效测量，预测技术，项目绩效评估，偏差管理，项目管理软件） 应急储备：已知的未知事件，用来处理预期但不确定的事件，项目经理可自由使用，是项目范围和成本基准的一部分。 管理储备：未计划但可能需要的范围和成本的潜在变化而预留的预算，项目经理使用前要得到批准，不是项目成本基线的一部分，但包含在项目预算中，不是挣值的一部分。 成本：直接（直接消耗的，涉密安防系统），间接（共同分担），可变，机会，沉没。 成本基准通常以S曲线形式显示。许多项目，特别是大项目，可能有多个成本基准。 成本失控的原因：1）对工程项目认识不足，2）组织制度不健全，3）方法问题，4）技术制约。 人力资源管理： 记住射里，（人力资源计划编制，组建项目团队，项目团队建设，管理项目团队） 记（组人组人：组织结构图和职位描述，人力资源模板，组织理论，人际网络） 住（仙谈虚构：事先分派，谈判，虚拟团队，采购） 射（公认你赔活鸡：同地办公，认可奖励，一般管理技能，培训，团队建设活动，基本原则） 里（关机图纹：观察与对话，项目绩效评估，冲突管理，问题日志） 责任分配矩阵RAM：工作和人员一一对应的关系，是WBS和OBS结合。 成功团队特征：标致公平女性。1）目标明确，2）组织结构清晰，岗位明确3）规范的工作流程和方法，4）有明确的考核和评价标准，5）组织纪律性强，6）相互信任，善于总结和学习。 绩效评估范围：包括进度控制，成本控制，质量控制，范围验证和过程审计的结果。 冲突的产生和类型：1）项目的高压环境，2）责任模糊，3）多个上级的存在，4）新科技的流行。 马斯洛需求层次五层：李安会重现。 生理，安全，社会，受尊重，自我实现。 双因素理论：一是保健卫生（无激励作用），二是激励需求（有激励作用）。 风险管理： 即时性，亮鞭奸。（风险管理计划编制，风险识别，定性风险分析,定量风险分析，风险应对计划编制，风险监控） 风险识别工具：文档评审，信息收集技术（脑儿烦死。 SWOT优劣机危分析），检查表，假设分析，图解技术（因果分析图，系统或过程流程图，影响图）。头脑风暴法，德尔菲法，访谈法， 风险属性：随机性、相对性、可变性。 定性风险分析工具：故居娘憧憬。风险概率及影响评估，概率及影响矩阵，风险数据质量评估，风险种类，风险紧急度评估。 定量风险分析工具：数据收集和表示技术（谈改嫁。EMV，决策树分析，建模和仿真）。访谈，概率分布，专家判断），定量风险分析和建模技术（灵气车模。灵敏度分析，期望货币价值分析 负面风险应对策略：避免（项目早期），转移（外包等），减轻（冗余等）接受(不做任何处理)。 采购管理： 鞭同膘，折管收。（采购计划编制，编制合同，招标，供方选择，合同管理，合同收尾） 自制/外购分析：技术达不到（外购），组织内长期使用或涉密（自制）。 采购工作说明书SOW输入：范围说明书，WBS，WBS字典。 投标人会议：是指在准备建议书之前与潜在供应商的碰头会。 建议书：是卖方准备的文件，用来说明卖方提供所需产品或服务的能力和意愿。 采购文件：用于向潜在的供应商征集建议书，由建设方准备。 采购审计的目标是找出采购过程中的成功和失败之处 20.1 输入+输出+工具和技术20.1.1范围管理:①: 章==计==业组==初范书==,专家==模表==范==需==划——&gt;规划范围管理(范围计划的编制)—-(计: 指的是项目管理计划,需: 指的是需求管理计划) 首尾相接②: 范需人划章程==册==,访问观察原标杆,交互引导群决策,需求文件==矩阵==出——&gt;收集需求——(交互: 系统交互图, 矩阵: 需求跟踪矩阵, 册: 干系人登记册) ③: 章程范划组==变更==,==产分==专家==引== 备案==,== 项划==更新出==详书==.——&gt; 定义范围——-(备案: 备选方案生成) XX范划开头, 首尾相接④: 详书范划需业组, ==工分模板====分解==术, 范划更新==WBS字典==出基准——-&gt;创建WBS—–(基准: 范围基准) ⑤: 范书 范划==交==字典,==检查== ==决策==工具术, 变更绩效==验可交==——&gt;确认范围——(交: 可交付物, 检查: 审查,产品评审,审计,走查,巡检,字典: WBS字典 验可交: 验收的可交付性成果) ⑦: 变更 范划 ==效==字典,==偏差分析==变更控, 计组字典齐更新,变更请求来输出———&gt;控制范围 注: ①: 范围基准需要 评审和审批; ②: 范围说明书不能有项目 经理一人编写; ③: WBS和范围基准应该由项目团队和所有关键干系人一起创建不应该由项目经理一人创建,导致工作遗漏 ④: 要做好整体变更控制,防止范围蔓延,范围变更应该和整体变更相结合,综合评估. ⑤: 范围变更要有规范的变更控制流程 ⑥: 变更结果一定要得到用户的确认和接受 20.1.2 进度管理①: 章程计划找业组,==分== ==家== ==会==上==进管子==——-&gt;规划进度管理—-(分: 分析技术; 家: 专家判断; 会: 会议; 进管子: 进度管理计划) ②: 业组进管炒 ==基范==, ==分== 家==滚==出 ==清== ==属== ==里==——–&gt;定义活动—-(分: 分解; 基范: 范围基准; 滚: 滚动式规则; 清: 活动清单; 属: 活动属性; 里: 里程碑清单) ③: 范书进计清属里, 前后紧赖网新文——&gt;排列活动顺序——(==前== 紧前关系绘图法; 后: 提前与滞后; 赖: 确定依赖关系) ④: 业组进管估成本,==清== ==属== ==资历== 有风册, 自选 ==软件== ==算== 专家, 活资 ==分解== ==新文件==——&gt;估算活动资源—(资历: 资源日历; 风册: 风险登记册; 软件: 项目管理软件; 算: 自下而上估算; 选: 自选方案分析; 分解: 资源分解结构; 新文件: 项目文件更新 ) ⑤: 业组资需分日进,清属范书有风险,==三== ==类== 专家数 策备, ==时间== 估算新文件.——&gt;估算活动持续时间—(三: 三点估算; 类 : 类比估算活动持续时间估算) ⑥: 业组资需分日进,清属范书有风险, 人员进, 压缩==网== ==路== 前后链, 优化建模靠工具, 进划基数日,新文划—–&gt;制定进度计划—(网: 进度网络分析; 路: 关键路径法; 链:关键链法; ) ⑦: 两数两划组日历, 优化建模需审查,前后压缩需软件, 进度预测 ==5大件==——&gt; 控制进度—(5大件: 项目管理计划更新,组织过程更新,项目文件更新,变更请求,工作绩效信息;,,) 20.1.3 整体管理①: 工商议事有组织,专家引导出章程——-&gt;制定项目章程—-(工: 项目工作说明书, 专家: 专家判断, 引导: 引导技术) 首尾相接②: 章程输出靠业组, 专家引导出计划——-&gt;制定项目管理计划—(输出: 其他过程的输出) 首字同绩效③: ==计== 变业组会专==项==, ==效== ==果== 变更 新文划——&gt;指导和管理项目的执行—–(变: 批准的变更请求, 项: 项目管理信息系统, 果: 可交付成果 ,效: 工作绩效数据; 变更: 变更请求) 首字同精确④: ==进== ==程== 预测计划后,==确认变更== ==效==业组(都是输入),会议分析项专家,计文更新==效报告==——-&gt;监控项目工作–(效: 工作绩效信息; 效报告: 项目绩效报告) 收尾相接⑤: 业组==计划==效变更,批准==日志==新文划——–&gt;实施整体变更控制—(批准: 批准的变更请求) 首字同宴会⑥: 验交 ==计划== 无事业,会议分析有专家,组织更新出产品——–&gt;结束项目或阶段—–(验收: 验收的可交付成果) 20.1.4 沟通管理①: 章程计划组范书,==沟技== ==沟需== ==人==分析, 最终输出沟计划——&gt;规划沟通管理(沟通计划的编制) 首尾相接②: 沟管计划==效==业组, 组==计== ==文件==齐更新——-&gt;管理沟通(信息分发,绩效报告,干系人管理) ③: ==问题日志==效计组,专家会议==信管==术,计组 ==文件==齐更新,==变更== ==绩效== 同输出.——&gt;控制沟通 20.1.5 质量管理①: 计干人册风险册,章程范书假日志,需求文件业组入, ==成收== 质成 ==标== ==实设==, ==质划== ==质测== ==质核== ==过改划==——&gt;规划质量管理(质量计划编制)—-(标: 基准分析) 规划质量管理: 是识别项目及其可交付成果的质量要求和标准,并准备对策来确保符合质量要求 的过程.作用: 为整个项目中如何管理和确认质量提供了指南和方向. 首尾相接②: 质划 质测 质控 过改划, ==质审== ==过分== ==七工具== , 计组 ==文件== 齐更新,变更请求来输出 ——&gt;实施质量保证——-(质审: 质量审计, 过分: 过程分析,七工具: 因果图流程图,帕累托图,核查图,直方图,控制图,散点图; 文件: 项目文件) ③: 质测 质核, 效计组, ==批变请== ==交== ==项文件== ,==统抽== , ==确变== ==核交== 绩效出, 计组项文齐更新,还有变更请求来输出——–&gt;控制质量——–(批变请: 批准的变更请求, 交: 可交付成果, 项文件: 项目文件) 20.1.6 成本管理 20.1.7 人力资源管理①: ==活资需求== 计业组, ==人模== ==人网==组理论, 人资管划一输出. ———-规划人力资源管理(人力资源计划的编制)(人模: 人力资源模板,人网: 人迹网络,组理论: 组织理论.) 首尾相接②: ==人资管划==业组入,谈判预派虚团队,招募多标决策术, 人员分派计更新,资源日历来输出—组建项目团队 ③: 计 ==资日历==人分派, 培训团建集办公,认可奖励==人== ==人测评==,团绩评价事业输出——&gt;建设项目团队—(人: 人际关系技能, 人测评: 人事测评工具 ) ④: 人资计划 ==人分派==,问题日志 ==绩报告==,组织过程 ==团绩评==, 观 ==谈== 绩评==冲== 人技. 文计业组齐更新,还有变更请求来输出——管理项目团队.—-(冲: 冲突管理 ) 20.1.8 项目干系人管理:①: 采购文件章业组, 干人分析专会议, 管理沟通人技能,干人登册独输出.———-&gt;识别干系人 首尾相接②: ==干人登册== 计业组, 干人管划来输出———–&gt;规划干系人管理 ③: ==干人计划== 沟计划,变更日志 组织入, 变更请求 ==问日志==,计组 ==文件==齐更新——-管理干系人 ④: 计 ==问日志== 绩 ==文件==,文组更新绩变更——-控制干系人参与 注: ①: 充分分析干系人的期望和要求 20.1.9风险管理:期望货币值–定量风险分析的技术 20.1.10 采购管理 20.2 总结:20.2.1 文件:项目工作说明书 项目章程 项目管理计划 需求管理计划 工作绩效报告 工作绩效数据 工作绩效信息 需求文件 项目文件 干系人管理计划 干系人登记册 范围管理计划 项目范围说明书 进度管理计划 风险登记册 资源日历 问题日志 变更日志 活动清单 活动属性 成本管理计划 人力资源管理计划 质量管理计划 过程改进计划 质量测量指标 批准的变更请求 团队绩效评价 事业环境因素 组织过程资产 采购管理计划 采购文件 采购工作说明书 变更请求 20.2.2 工具和技术 范: 专家判断——-会议——–引导技术——-分析技术——项目管理信息系统—–变更控制工具 访谈——问卷调查——观察——原型——标杆对照—–系统交互图——引导式研讨会——-群体决策技术=====================&gt;收集需求 产品分析——-备选方案生成==============================================&gt;定义范围 分解==============================================&gt;创建WBS 检查——-群体决策技术==============================================&gt; 确认范围 偏差分析==============================================&gt;控制范围 进: 滚动式规则——分解 ==============================================&gt; 定义活动 紧前关系绘图法PDM——-确定依赖关系提前量与滞后量============================================&gt;排列活动顺序 自下而上估算—–备选方案分析——项目管理软件============================================&gt;估算活动资源 类比估算———三点估算——-储备分析—–参数估算——-群体决策============================================&gt;估算活动持续时间 进度网络分析–关键路径法—-关键链法—-资源优化技术—建模技术–进度压缩—进度计划编制工具==========================&gt;制定进度计划 绩效审查==========================================&gt;控制进度 整: 专家判断——-会议——–引导技术——-分析技术——项目管理信息系统—–变更控制工具 沟: 沟通需求分析—-沟通技术—-沟通模型====================================&gt;规划沟通管理 报告绩效—–信息管理系统—-沟通方法—-沟通技术—-沟通模型==================================&gt;管理沟通 质: 成本效益分析法—-质量成本法—-实验设计–标杆对照—-七种基本质量工具—其他质量规划工具======================================&gt;规划质量管理 质量管理和控制工具—过程分析—-质量审计====================================&gt;实施质量保证 成: 类比估算—-质量成本—–三点估算—卖方投标分析—-储备分析—–参数估算——-群体决策—-自下而上估算============================================&gt;估算成本 成本汇总—-资源限制平衡—-储备分析—-历史关系==========================================&gt;制定预算 挣值管理—–完工尚需绩效指数—-绩效审查—–项目管理软件—储备分析==========================================&gt;控制成本 人: 责任分配矩阵—–组织图和职位描述—-人际交往—–组织理论—–专家判断—-会议========================================&gt;规划人力资源 预分派—谈判—招募—-虚拟团队—多标准决策分析======================================&gt; 组建项目团队 培训——团队建设活动—–基本规则——–集中办公——认可与奖励——-人事评测工具====================================&gt; 建设项目团队 观察和交谈——项目绩效评估—-冲突管理—-人机关系技能==================================&gt;管理项目团队 人: 干系人分析================================&gt; 识别干系人 沟通方法——人际关系技能—–管理技能================================&gt;管理干系人参与 风: 文档审查——-信息收集技术——–假设分析———图解技术———SWOT分析==============================&gt;识别风险 风险概率和影响评估—概率和影响矩阵—风险数据质量评估—风险分类—风险紧迫性评估============================&gt;实施定性风险分析 数据收集和展示—–定量风险分析和建模==========================&gt;实施定量风险分析==========================&gt; 实施定量风险分析 消极风险的应对策略—–积极风险的应对策略—-应急应对策略========================&gt; 规划风险应对 风险再评估—-风险审计—-偏差与趋势分析—-技术绩效测量======================&gt;控制风险 采: 自制和外购分析—-市场调研========================================&gt;规划采购管理 投标人会议—-建议书评价技术——-建立估算—–广告—-分析技术—-采购谈判========================================&gt;实施采购 合同变更控制系统—采购绩效审查—检查与审计—-报告绩效—-支付系统—索赔管理—记录管理系统========================================&gt;控制采购 采购审计—-采购谈判—-记录管理系统======================================&gt;结束采购 二十一、英语阅读题:词汇: Composition: 组成Decomposition: 分解 precedence : 优先权precedence diagramming method 前导图法 stakeholder : 利益相关者 Project stackholder : 项目干系人 numerical: 数字的 specification : n. 规格；说明书；详述 Call: 调用 extend: 扩展 generalize: 泛化 Integration: 整合,集成 Quantitative : 定量的；量的，数量的 probability : n. 可能性；机率；[数] 或然率 successor: 继承者；后续的事物 predecessor: 前任，前辈 program: 程序；计划；大纲 portfolio: 项目组合 interconnected: adj. 连通的；有联系的 v. 互相连接（interconnect的过去式） volume: adj. 大量的 n: 体积 velocity: n. 【物】速度 reflect: 反映；反射 revise 修正；复习；校订 reissued 再发行 presentation: 报告,展示；描述，陈述；介绍；赠送 redundant: adj. 多余的，过剩的；被解雇的，失业的；冗长的，累赘的 mitigation: n. 减轻；缓和；平静 ——risk mitigation 风险减轻 duration: n:持续,持续的时间 probability: 概率 possibility: 可能性 phase: 阶段,时期 project charter : 项目章程 confused: 困惑的；混乱的；糊涂的 overlap: 重叠；重复 metrics: 度量 benchmarking: 基准分析 look-in: 观察 check-in : 控制 inspected-in : 检查 dissever: 分裂 二十二、PMP/PMBOK 项目管理知识体系指南第五版 项目管理工具与技术 总表 工具与技术 过程 描述 专家判断 指导与管理项目工作 项目整合管理执行过程组规划风险应对 项目风险管理 规划过程组控制干系人参与 项目干系人管理监控过程组创建WBS 项目范围管理 规划过程组估算成本 项目成本管理 规划过程组实施整体变更控制 项目整合管理监控过程组识别风险 项目风险管理 规划过程组制定项目章程 项目整合管理 启动过程组估算活动资源 项目时间管理 规划过程组实施定量风险分析 项目风险管理规划过程组识别干系人 项目干系人管理 启动过程组规划成本管理 项目成本管理 规划过程组监控项目工作 项目整合管理 监控过程组定义活动 项目时间管理 规划过程组定义范围 项目范围管理 规划过程组规划干系人管理 项目干系人管理规划过程组实施定性风险分析 项目风险管理规划过程组规划人力资源管理 项目人力资源管理规划过程组估算活动持续时间 项目时间管理规划过程组结束项目或阶段 项目整合管理收尾过程组规划范围管理 项目范围管理 规划过程组规划采购管理 项目采购管理 规划过程组控制沟通 项目沟通管理 监控过程组规划风险管理 项目风险管理 规划过程组制定预算 项目成本管理 规划过程组制定项目管理计划 项目整合管理规划过程组实施采购 项目采购管理 执行过程组规划进度管理 项目时间管理 规划过程组 基于某应用领域、知识领域、学科和行业等的专业知识而做出的，关于当前活动的合理判断。这些专业知识可来自具有专业学历、知识、技能、经验或培训经历的任何小组或个人。 引导技术 制定项目章程 项目整合管理 启动过程组制定项目管理计划 项目整合管理规划过程组 引导技术广泛应用于各项目管理过程，可用于指导项目章程的制定。头脑风暴、冲突处理、问题解决和会议管理等，都是引导者可以用来帮助团队和个人完成项目活动的关键技术。 项目管理信息系统 监控项目工作 项目整合管理 监控过程组指导与管理项目工作 项目整合管理执行过程组 由收集、整合和传播项目管理过程成果的工具和技术所组成的信息系统。它为项目从启动到收尾的所有方面提供支持， 可以包括人工和自动系统。 会议 规划质量管理 项目质量管理 规划过程组实施整体变更控制 项目整合管理监控过程组规划沟通管理 项目沟通管理 规划过程组规划成本管理 项目成本管理 规划过程组监控项目工作 项目整合管理 监控过程组识别干系人 项目干系人管理 启动过程组规划干系人管理 项目干系人管理规划过程组规划人力资源管理 项目人力资源管理规划过程组结束项目或阶段 项目整合管理收尾过程组规划采购管理 项目采购管理 规划过程组规划范围管理 项目范围管理 规划过程组控制沟通 项目沟通管理 监控过程组规划进度管理 项目时间管理 规划过程组规划风险管理 项目风险管理 规划过程组指导与管理项目工作 项目整合管理执行过程组控制风险 项目风险管理 监控过程组控制干系人参与 项目干系人管理监控过程组 可以通过会议来讨论和解决项目的相关问题。参会者可包括项目经理、项目团队成员，以及与所讨论问题相关或会受该问题影响的干系人。应该明确每个参会者的角色，确保有效参会。 分析技术 规划成本管理 项目成本管理 规划过程组规划干系人管理 项目干系人管理规划过程组监控项目工作 项目整合管理 监控过程组结束项目或阶段 项目整合管理收尾过程组实施采购 项目采购管理 执行过程组规划进度管理 项目时间管理 规划过程组规划风险管理 项目风险管理 规划过程组 在项目管理中，根据可能的项目或环境变量的变化，以及它们与其他变量之间的关系，采用分析技术来预测潜在的后果。 变更控制工具 实施整体变更控制 项目整合管理监控过程组 为了便于开展配置和变更管理，可以使用一些手工或自动化的工具。工具的选择应基于项目干系人的需要，并考虑组织和环境情况和／或制约因素。 访谈 收集需求 项目范围管理 规划过程组 访谈是通过与干系人直接交谈来获取信息的正式或非正式的方法。 焦点小组 收集需求 项目范围管理 规划过程组 焦点小组是召集预定的干系人和主题专家，了解他们对所讨论的产品、服务或成果的期望和态度。 引导式研讨会 定义范围 项目范围管理 规划过程组收集需求 项目范围管理 规划过程组 引导式研讨会把主要干系人召集在一起，通过集中讨论来定义产品需求。研讨会是快速定义跨职能需求和协调干系人差异的重要技术。 群体创新技术 收集需求 项目范围管理 规划过程组 可以组织一些群体活动来识别项目和产品需求。 群体决策技术 收集需求 项目范围管理 规划过程组估算成本 项目成本管理 规划过程组估算活动持续时间 项目时间管理规划过程组确认范围 项目范围管理 监控过程组 群体决策技术就是为达成某种期望结果，而对多个未来行动方案进行评估的过程。本技术用于生成产品需求，并对产品需求进行归类和优先级排序。 问卷调查 收集需求 项目范围管理 规划过程组 问卷调查是指设计一系列书面问题，向众多受访者快速收集信息。问卷调查方法非常适用于以下情况：受众多样化，需要快速完成调查，受访者地理位置分散，并且适合开展统计分析。 观察 收集需求 项目范围管理 规划过程组 观察是指直接察看个人在各自的环境中如何执行工作（或任务）和实施流程。 原型法 收集需求 项目范围管理 规划过程组 原型法是指在实际制造预期产品之前，先造出该产品的实用模型，并据此征求对需求的早期反馈。 标杆对照 规划质量管理 项目质量管理 规划过程组收集需求 项目范围管理 规划过程组 标杆对照将实际或计划的做法（如流程和操作过程）与其他可比组织的做法进行比较，以便识别最佳实践，形成改进意见，并为绩效考核提供依据。标杆对照所采用的可比组织可以是内部的，也可以是外部的。 系统交互图 收集需求 项目范围管理 规划过程组 系统交互图是范围模型的一个例子，它是对产品范围的可视化描绘，显示业务系统（过程、设备、计算机系统等）及其与人和其他系统（行动者）之间的交互方式。 文件分析 收集需求 项目范围管理 规划过程组 文件分析就是通过分析现有文档，识别与需求相关的信息，来挖掘需求。 产品分析 定义范围 项目范围管理 规划过程组 对于那些以产品为可交付成果的项目（区别于提供服务或成果的项目），产品分析是一种有效的工具。 备选方案生成 定义范围 项目范围管理 规划过程组 备选方案生成是一种用来制定尽可能多的潜在可选方案的技术，用于识别执行项目工作的不同方法。 分解 创建WBS 项目范围管理 规划过程组定义活动 项目时间管理 规划过程组 分解是一种把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分的技术。 检查 控制质量 项目质量管理 监控过程组确认范围 项目范围管理 监控过程组 检查是指开展测量、审查与确认等活动，来判断工作和可交付成果是否符合需求和产品验收标准。检查有时也被称为审查、产品审查、审计和巡检等。在某些应用领域，这些术语具有独特和具体的含义。 偏差分析 控制范围 项目范围管理 监控过程组 偏差分析是一种确定实际绩效与基准的差异程度及原因的技术。 滚动式规划 定义活动 项目时间管理 规划过程组 滚动式规划是一种迭代式规划技术，即详细规划近期要完成的工作，同时在较高层级上粗略规划远期工作。 紧前关系绘图法 排列活动顺序 项目时间管理 规划过程组 紧前关系绘图法（PDM）是创建进度模型的一种技术，用节点表示活动，用一种或多种逻辑关系连接活动，以显示活动的实施顺序。 确定依赖关系 排列活动顺序 项目时间管理 规划过程组 依赖关系可能是强制或选择的，内部或外部的。 提前量和滞后量 控制进度 项目时间管理 监控过程组排列活动顺序 项目时间管理 规划过程组制定进度计划 项目时间管理 规划过程组 提前量是相对于紧前活动，紧后活动可以提前的时间量。 备选方案分析 估算活动资源 项目时间管理 规划过程组 备选方案分析：很多进度活动都有若干种备选的实施方案，如使用能力或技能水平不同的资源、不同规模或类型的机器、不同的工具（手工或自动的），以及自制、租赁或购买相关资源（见12.1.3.5 节）。 发布的估算数据 估算活动资源 项目时间管理 规划过程组 一些组织会定期发布最新的生产率信息与资源单位成本，涉及门类众多的劳务、材料和设备，覆盖许多国家及其所属地区。 自下而上估算 估算成本 项目成本管理 规划过程组估算活动资源 项目时间管理 规划过程组 自下而上估算是对工作组成部分进行估算的一种方法。首先对单个工作包或活动的成本进行最具体、细致的估算；然后把这些细节性成本向上汇总或“滚动”到更高层次，用于后续报告和跟踪。自下而上估算的准确性及其本身所需的成本，通常取决于单个活动或工作包的规模和复杂程度。 项目管理软件 估算成本 项目成本管理 规划过程组控制进度 项目时间管理 监控过程组控制成本 项目成本管理 监控过程组估算活动资源 项目时间管理 规划过程组 项目管理软件：项目管理应用软件、电子表单、模拟和统计工具等，可用来辅助成本估算。这些工具能简化某些成本估算技术的使用，使人们能快速考虑多种成本估算方案。 类比估算 估算活动持续时间 项目时间管理规划过程组估算成本 项目成本管理 规划过程组 类比估算是一种使用相似活动或项目的历史数据，来估算当前活动或项目的持续时间或成本的技术。 参数估算 估算活动持续时间 项目时间管理规划过程组估算成本 项目成本管理 规划过程组 参数估算是一种基于历史数据和项目参数，使用某种算法来计算成本或持续时间的估算技术。 三点估算 估算活动持续时间 项目时间管理规划过程组估算成本 项目成本管理 规划过程组 三点估算通过考虑估算中的不确定性与风险，使用三种估算值来界定活动成本的近似区间，可以提高估算的准确性 储备分析 制定预算 项目成本管理 规划过程组估算活动持续时间 项目时间管理规划过程组控制成本 项目成本管理 监控过程组估算成本 项目成本管理 规划过程组控制风险 项目风险管理 监控过程组 一种分析技术，用来明确项目管理计划各组成部分的基本特征及其相互关系，从而为项目的工期、预算、成本估算或资金需求设定储备。 进度网络分析 制定进度计划 项目时间管理 规划过程组 进度网络分析是创建项目进度模型的一种技术。 关键路径法 制定进度计划 项目时间管理 规划过程组 关键路径法是在进度模型中，估算项目最短工期，确定逻辑网络路径的进度灵活性大小的一种方法。 关键链法 制定进度计划 项目时间管理 规划过程组 关键链法（CCM）是一种进度规划方法，允许项目团队在任何项目进度路径上设置缓冲， 以应对资源限制和项目不确定性。关键链法( Critical Chain Method ) 是另一种进度网络分析技术，可以根据有限的资源对项目进度表进行调整。由艾利·高德拉特(Eliyahu M. Goldratt，1947年3月31日－2011年6月11日)提出， 资源优化技术 控制进度 项目时间管理 监控过程组制定进度计划 项目时间管理 规划过程组 资源优化技术是根据资源供需情况，来调整进度模型的技术。 建模技术 控制进度 项目时间管理 监控过程组制定进度计划 项目时间管理 规划过程组 建模技术包括（但不限于）：假设情景分析；模拟 进度压缩 控制进度 项目时间管理 监控过程组制定进度计划 项目时间管理 规划过程组 进度压缩技术是指在不缩减项目范围的前提下，缩短进度工期，以满足进度制约因素、强制日期或其他进度目标。 进度计划编制工具 制定进度计划 项目时间管理 规划过程组控制进度 项目时间管理 监控过程组 自动化的进度计划编制工具包括进度模型，它用活动清单、网络图、资源需求和活动持续时间等作为输入，使用进度网络分析技术，自动生成开始和结束日期，从而可加快进度计划的编制过程。进度计划编制工具可与其他项目管理软件以及手工方法联合使用。 绩效审查 控制进度 项目时间管理 监控过程组控制成本 项目成本管理 监控过程组 绩效审查是指测量、对比和分析进度绩效，如实际开始和完成日期、已完成百分比及当前工作的剩余持续时间。 质量成本（COQ） 估算成本 项目成本管理 规划过程组规划质量管理 项目质量管理 规划过程组 质量成本包括在产品生命周期中为预防不符合要求、为评价产品或服务是否符合要求，以及因未达到要求（返工），而发生的所有成本。失败成本常分内部（项目内部发现的）和外部（客户发现的）两类。失败成本也称为劣质成本。 卖方投标分析 估算成本 项目成本管理 规划过程组 在成本估算过程中，可能需要根据合格卖方的投标情况，分析项目成本。 成本汇总 制定预算 项目成本管理 规划过程组 成本汇总：先把成本估算汇总到WBS中的工作包，再由工作包汇总至WBS更高层次（如控制账户）， 最终得出整个项目的总成本。 历史关系 制定预算 项目成本管理 规划过程组 有关变量之间可能存在一些可据以进行参数估算或类比估算的历史关系。可以基于这些历史关系，利用项目特征（参数）来建立数学模型，预测项目总成本。 资金限制平衡 制定预算 项目成本管理 规划过程组 应该根据对项目资金的任何限制，来平衡资金支出。如果发现资金限制与计划支出之间的差异，则可能需要调整工作的进度计划，以平衡资金支出水平。这可以通过在项目进度计划中添加强制日期来实现。 挣值管理 控制成本 项目成本管理 监控过程组 挣值管理（EVM）是把范围、进度和资源绩效综合起来考虑，以评估项目绩效和进展的方法。 预测 控制成本 项目成本管理 监控过程组 随着项目进展，项目团队可根据项目绩效，对完工估算（EAC Cost Estimate at Completion）进行预测，预测的结果可能与完工预算（BAC）存在差异。 完工尚需绩效指数（TCPI） 控制成本 项目成本管理 监控过程组 完工尚需绩效指数（TCPI）是一种为了实现特定的管理目标，剩余资源的使用必须达到的成本绩效指标，是完成剩余工作所需的成本与剩余预算之比。 成本效益分析 规划质量管理 项目质量管理 规划过程组 达到质量要求的主要效益包括减少返工、提高生产率、降低成本、提升干系人满意度及提升赢利能力。 七种基本质量工具 控制质量 项目质量管理 监控过程组规划质量管理 项目质量管理 规划过程组 七种基本质量工具，也称7QC工具，用于在PDCA循环的框架内解决与质量相关的问题。 实验设计 规划质量管理 项目质量管理 规划过程组 规划质量管理过程中使用，以确定测试的数量和类别，以及这些测试对质量成本的影响。 统计抽样 规划质量管理 项目质量管理 规划过程组控制质量 项目质量管理 监控过程组 统计抽样是指从目标总体中选取部分样本用于检查（如从75张工程图纸中随机抽取10张）。 其他质量管理工具 规划质量管理 项目质量管理 规划过程组 为定义质量要求并规划有效的质量管理活动，也可使用其他质量规划工具。 质量管理和控制工具 实施质量保证 项目质量管理 执行过程组 实施质量保证过程使用规划质量管理和控制质量过程的工具和技术。 质量审计 实施质量保证 项目质量管理 执行过程组 质量审计是用来确定项目活动是否遵循了组织和项目的政策、过程与程序的一种结构化的、独立的过程。 过程分析 实施质量保证 项目质量管理 执行过程组 过程分析是指按照过程改进计划中概括的步骤来识别所需的改进。 审查已批准的变更请求 控制质量 项目质量管理 监控过程组 对所有已批准的变更请求进行审查，以核实它们是否已按批准的方式得到实施。 组织图和职位描述 规划人力资源管理 项目人力资源管理规划过程组 可采用多种格式来记录团队成员的角色与职责。大多数格式属于以下三类（见图9-4）： 层级型、矩阵型和文本型。 人际交往 规划人力资源管理 项目人力资源管理规划过程组 人际交往是指在组织、行业或职业环境中与他人的正式或非正式互动。 组织理论 规划人力资源管理 项目人力资源管理规划过程组 组织理论阐述个人、团队和组织部门的行为方式。 预分派 组建项目团队 项目人力资源管理执行过程组 如果项目团队成员是事先选定的，他们就是被预分派的。 谈判 组建项目团队 项目人力资源管理执行过程组 在许多项目中，通过谈判完成工作。 招募 组建项目团队 项目人力资源管理执行过程组 如果执行组织不能提供为完成项目所需的人员，就需要从外部获得所需的服务，这可能包括雇佣独立咨询师，或把相关工作分包给其他组织。 虚拟团队 组建项目团队 项目人力资源管理执行过程组 虚拟团队的使用为招募项目团队成员提供了新的可能性。虚拟团队可定义为具有共同目标、在完成角色任务的过程中很少或没有时间面对面工作的一群人。 多标准决策分析 组建项目团队 项目人力资源管理执行过程组 在组建项目团队过程中，经常需要使用团队成员选择标准。通过多标准决策分析，制定出选择标准，并据此对候选团队成员进行定级或打分。 人际关系技能 管理项目团队 项目人力资源管理执行过程组管理干系人参与 项目干系人管理执行过程组建设项目团队 项目人力资源管理执行过程组 项目经理通过项目团队和其他干系人来完成工作。有效的项目经理应在技术、人际关系和概念技能等方面维持均衡，以便正确分析形势并合理应对。 培训 建设项目团队 项目人力资源管理执行过程组 培训包括旨在提高项目团队成员能力的全部活动。培训可以是正式或非正式的。 团队建设活动 建设项目团队 项目人力资源管理执行过程组 团队建设活动既可以是状态审查会上的五分钟议程，也可以是为改善人际关系而设计的、 在非工作场所专门举办的体验活动。 基本规则 建设项目团队 项目人力资源管理执行过程组 用基本规则对项目团队成员的可接受行为做出明确规定。 集中办公 建设项目团队 项目人力资源管理执行过程组 集中办公，也被称为“紧密矩阵”，是指把许多或全部最活跃的项目团队成员安排在同一个物理地点工作，以增强团队工作能力。 认可与奖励 建设项目团队 项目人力资源管理执行过程组 在建设项目团队过程中，需要对成员的优良行为给予认可与奖励。 人事测评工具 建设项目团队 项目人力资源管理执行过程组 人事评测工具能让项目经理和项目团队洞察成员的优势和劣势。 观察和交谈 管理项目团队 项目人力资源管理执行过程组 可通过观察和交谈，随时了解项目团队成员的工作和态度。 项目绩效评估 管理项目团队 项目人力资源管理执行过程组 在项目过程中进行绩效评估的目的包括澄清角色与职责，向团队成员提供建设性反馈，发现未知或未决问题，制定个人培训计划，以及确立未来目标。 冲突管理 管理项目团队 项目人力资源管理执行过程组 在项目环境中，冲突可能导致项目产生不良结果。但是，如果主动管理，冲突可以帮助团队找到更好的解决方案。项目经理必须能够找到冲突的原因，然后积极地管理冲突，从而最大程度地降低潜在的负面影响。 沟通需求分析 规划沟通管理 项目沟通管理 规划过程组 通过沟通需求分析，确定项目干系人的信息需求，包括所需信息的类型和格式，以及信息对干系人的价值。 沟通技术 规划沟通管理 项目沟通管理 规划过程组管理沟通 项目沟通管理 执行过程组 可以采用各种技术在项目干系人之间传递信息。 沟通模型 规划沟通管理 项目沟通管理 规划过程组管理沟通 项目沟通管理 执行过程组 用于促进沟通和信息交换的沟通模型，可能因不同项目而异，也可能因同一项目的不同阶段而异。 沟通方法 规划沟通管理 项目沟通管理 规划过程组管理干系人参与 项目干系人管理执行过程组管理沟通 项目沟通管理 执行过程组 可以使用多种沟通方法在项目干系人之间共享信息。 信息管理系统 控制干系人参与 项目干系人管理监控过程组管理沟通 项目沟通管理 执行过程组控制沟通 项目沟通管理 监控过程组 信息管理系统用来管理和分发项目信息的工具。 报告绩效 控制采购 项目采购管理 监控过程组管理沟通 项目沟通管理 执行过程组 报告绩效是指收集和发布绩效信息，包括状况报告、进展测量结果及预测结果。应该定期收集基准数据与实际数据，进行对比分析，以便了解和沟通项目进展与绩效，并对项目结果做出预测。 文档审查 识别风险 项目风险管理 规划过程组 对项目文档（包括各种计划、假设条件、以往的项目文档、协议和其他信息）进行结构化审查。 信息收集技术 识别风险 项目风险管理 规划过程组 可用于风险识别的信息收集技术包括：头脑风暴，德尔菲技术，访谈，根本原因分析 核对单分析 识别风险 项目风险管理 规划过程组 可以根据以往类似项目和其他来源的历史信息与知识编制风险识别核对单。 假设分析 识别风险 项目风险管理 规划过程组 每个项目及其计划都是基于一套假想、设想或假设而构建的。 图解技术 识别风险 项目风险管理 规划过程组 风险图解技术可包括：因果图，系统或过程流程图，影响图 SWOT 分析 识别风险 项目风险管理 规划过程组 这种技术从项目的每个优势（Strength）、劣势（Weakness）、机会（Opportunity）和威胁（Threat）出发，对项目进行考察，把产生于内部的风险都包括在内，从而更全面地考虑风险。 风险概率和影响评估 实施定性风险分析 项目风险管理规划过程组 风险概率评估旨在调查每个具体风险发生的可能性。 概率和影响矩阵 实施定性风险分析 项目风险管理规划过程组 应该基于风险评级结果，对风险进行优先级排序，以便进一步开展定量分析和风险应对规划。 风险数据质量评估 实施定性风险分析 项目风险管理规划过程组 风险数据质量评估是评估风险数据对风险管理的有用程度的一种技术。 风险分类 实施定性风险分析 项目风险管理规划过程组 有助于为制定有效的风险应对措施而确定工作包、活动、项目阶段，甚至项目中的角色。 风险紧迫性评估 实施定性风险分析 项目风险管理规划过程组 可以把近期就需要应对的风险确定为更紧迫的风险。 数据收集和展示技术 实施定量风险分析 项目风险管理规划过程组 包括：访谈，概率分布 定量风险分析和建模技术 实施定量风险分析 项目风险管理规划过程组 用的技术有面向事件和面向项目的分析方法，包括：敏感性分析，预期货币价值分析，建模和模拟， 消极风险或威胁的应对策略 规划风险应对 项目风险管理 规划过程组 通常用规避、转移、减轻这三种策略来应对威胁或可能给项目目标带来消极影响的风险，第四种策略，即接受 积极风险或机会的应对策略 规划风险应对 项目风险管理 规划过程组 包括：开拓，提高，分享，接受 应急应对策略 规划风险应对 项目风险管理 规划过程组 可以针对某些特定事件，专门设计一些应对措施。对于有些风险，项目团队可以制定应急应对策略，即只有在某些预定条件发生时才能实施的应对计划。 风险再评估 控制风险 项目风险管理 监控过程组 风险再评估：在控制风险中，经常需要识别新风险，对现有风险进行再评估，以及删去已过时的风险。 风险审计 控制风险 项目风险管理 监控过程组 风险审计是检查并记录风险应对措施在处理已识别风险及其根源方面的有效性，以及风险管理过程的有效性。 偏差和趋势分析 控制风险 项目风险管理 监控过程组 很多控制过程都会借助偏差分析来比较计划结果与实际结果。 技术绩效测量 控制风险 项目风险管理 监控过程组 技术绩效测量是把项目执行期间所取得的技术成果与关于取得技术成果的计划进行比较。 自制或外购分析 规划采购管理 项目采购管理 规划过程组 自制或外购分析是一种通用的管理技术，用来确定某项工作最好由项目团队自行完成，还是应该从外部采购。 市场调研 规划采购管理 项目采购管理 规划过程组 市场调研包括考察行业情况和供应商能力。 投标人会议 实施采购 项目采购管理 执行过程组 投标人会议（又称承包商会议、供货商会议或投标前会议）就是在投标书或建议书提交之前，在买方和所有潜在卖方之间召开的会议。 建议书评价技术 实施采购 项目采购管理 执行过程组 对于复杂的采购，如果要基于卖方对既定加权标准的响应情况来选择卖方，则应该根据买方的采购政策，规定一个正式的建议书评审流程。 独立估算 实施采购 项目采购管理 执行过程组 对于许多采购，采购组织可以自行编制独立估算，或者邀请外部专业估算师做出成本估算，并将此作为标杆，用来与潜在卖方的应答做比较。 广告 实施采购 项目采购管理 执行过程组 在大众出版物（如报纸）或专业出版物上刊登广告，往往可以扩充现有的潜在卖方名单。 采购谈判 实施采购 项目采购管理 执行过程组结束采购 项目采购管理 收尾过程组 采购谈判是指在合同签署之前，对合同的结构、要求及其他条款加以澄清，以取得一致意见。最终的合同措辞应该反映双方达成的全部一致意见。 合同变更控制系统 控制采购 项目采购管理 监控过程组 合同变更控制系统规定了修改合同的过程。 采购绩效审查 控制采购 项目采购管理 监控过程组 采购绩效审查是一种结构化的审查，依据合同来审查卖方在规定的成本和进度内完成项目范围和达到质量要求的情况。 检查与审计 控制采购 项目采购管理 监控过程组 在项目执行过程中，应该根据合同规定，由买方开展相关的检查与审计，卖方应对此提供支持。 支付系统 控制采购 项目采购管理 监控过程组 通常，先由被授权的项目团队成员证明卖方的工作令人满意，再通过买方的应付账款系统向卖方付款。 索赔管理 控制采购 项目采购管理 监控过程组 如果买卖双方不能就变更补偿达成一致意见，甚至对变更是否已经发生都存在分歧，那么被请求的变更就成为有争议的变更或潜在的推定变更。 记录管理系统 控制采购 项目采购管理 监控过程组结束采购 项目采购管理 收尾过程组 项目经理采用记录管理系统来管理合同、采购文档和相关记录。它包含一套特定的过程、相关的控制功能，以及作为项目管理信息系统（见4.4.2.3节）一部分的自动化工具。 采购审计 结束采购 项目采购管理 收尾过程组 采购审计是指对从规划采购管理过程到控制采购过程的所有采购过程进行结构化审查。 干系人分析 识别干系人 项目干系人管理 启动过程组 干系人分析是系统地收集和分析各种定量与定性信息，以便确定在整个项目中应该考虑哪些人的利益。 管理技能 管理干系人参与 项目干系人管理执行过程组 项目经理应用管理技能来协调各方以实现项目目标。包括：引导；施加影响；谈判；调整组织行为 二十三、配置管理其中 版本控制的目的是按照一定规则 保存配置项的 所有版本,而不是仅保存基线版本,重要版本等, 这样做为了避免发生版本丢失或混淆,并可快速查找任何版本. 23.1 第一个过程是建方针 23.2 配置项：1）属于产品组成部分的工作成果， 2）属于项目管理和机构支撑过程域产生的文档。 测试报告、会议记要、工作记录不能作为配置项，因为不能修改。 23.3 配置管理有3种基线：功能、分配和产品基线。 产品的测试版本也可以看作基线。 3E审计：妓女笑。经济、效率和效果审计。 23.4 项目配置管理的任务：口诀: 技师变态神经 1）制定项目配置管理计划， 2）确定配置标识规则， 3）实施变更控制措施， 4）报告配置状态， 5）进行配置审核， 6）进行版本管理和发行管理。 不包括检测配置 23.5 配置管理活动：口诀: 是童颜。 1）配置识别（为产品配置的定义和验证、产品的标识和归档；变更的管理及其责任提供了基础）， 2）配置状况统计（收集、存储和访问配置信息，以维护产品的有效性）， 3）配置验证和审核（如相关的功能需求已经被设计文档实现，而且设计文档已纳入配置管理系统）。 配置管理员CMO才可以删除，CCB、PM、DEV（开发人员）不能删除。 版本管理与发布 应该由 配置管理员CMO 执行. 23.6 配置库的主要作用：口诀: 极品区。 1）记录与配置相关的所有信息，其中存放受控的软件配置项是很重要的内容， 2）利用库中的信息可评价变更的后果，这对变更控制有着重要的意义， 3）从库中可提取各种配置管理过程的管理信息，可利用库中的信息查询回答许多配置管理的问题。 23.7 配置库四类：1）开发库（动态库，较为频繁的修改） 2) 受控库（主库或系统库，管理基线和变更，二次开发,库内信息的读和写均受限制） 3) 产品库（静态库，最终产品存入库内）。 4) 备份库: 重要配置信息的备份,应急时恢复受损的配置库信息 二十四、组合管理可以将组织战略进一步细化到选择哪些项目来实现组织的目标 选择的主要依据: 平衡风险和收益 24.1 DIPP 二十五、战略管理25.1 战略管理的主要活动：战略制定，战略执行，战略评估。 25.2 战略五个步骤：口诀: 分离择姑配。 战略分析，战略梳理，战略选择，战略评估，战略匹配。 25.3 PEST宏观环境分析：口诀: 震惊社稷。 政治，经济，社会和文化，技术。 25.4 战略层次：公司战略，业务战略，职能战略。 25.5 战略组织类型：防御型（采用竞争性定价或高质量产品组织竞争对手进入），开拓型（寻找和开发新的产品和市场，声誉比利润更重要），分析型（介于前两者之间），被动反应型（消极无效的组织形态，总是不稳定）。 25.6 五种基本竞争力量: 25.7 产品与战略联系 25.8 战略组织类型 防御型: 竞争性定价,高质量产品 开拓型: 开发新产品 分析性: 最小风险最大利润 反应型: 消极的 25.9 SWOT:从项目的每个S优势,W劣势,O机会,T威胁出发,对项目进行考察,从而更全方面的考虑风险. 25.10 战略分析①: 内部分析 ②: 外部分析 ③: 内外环境结合分析 ④: 战略提出 25.11 常见综合战略①: 防御 ②: 扩张 ③: 加强 二十六、知识管理隐性知识的共享方法：编码化，面对面交流，人员轮换，网络；隐性知识是“惯例”。 二十七、需求管理需求管理： 需求工程：包括需求开发和需求管理，前者是主线、目标，后者是支持、保障。 需求开发四过程：需求捕获（用户访谈，用户调查，现场观摩，文档考古，联合讨论会）—《用户需求说明书》，分析，定义（《需求规格说明书》更详细），验证。 需求规格说明书SRS：精确地阐述了一个软件系统必须提供的功能和性能，以及它所考虑的限制条件。 需求跟踪性矩阵保存了需求与后续工作成果的对应关系。 需求验证后形成需求基线 需求开发的目的: 是通过调查与分析，获取用户需求并定义产品需求； 需求管理的目的： 1）确保各方对需求的一致理解， 2）管理和控制需求的变更， 3）从需求到最终产品的双向跟踪； 范围管理的目的确定项目包含且仅仅只包含项目所必须完成的工作。 需求管理包括：定义需求基线，处理需求变更，需求跟踪等。 二十八、外包管理外包是为了达到降低成本，提高效率，充分发挥自身核心竞争力，增强自身应变能力。 越来越多的企业回归核心业务。 如何以合适的方式监督供方是项目外包管理的一个重点，监控方式正确的是与供应商先确定评价的频次和方法，列出日程表，按照计划进行评价。 鞭子效应：是将单一的决策问题多阶段化以回避风险，提高决策效率，类似于分散投资。 二十九、流程管理29.1 组织链,组织学习, 29.2 价值活动 29.3 评估方法 29.4 BPR的实施3个层次 29.5 BPR原则 29.6 企业的流程管理 29.7 业务流程分类 三十、安全管理30.1 基于角色的访问控制]]></content>
      <categories>
        <category>考证</category>
      </categories>
      <tags>
        <tag>信息系统项目管理师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络编程之TCP-UDP]]></title>
    <url>%2Fjava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP%2Fjava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP.html</url>
    <content type="text"><![CDATA[一、网络编程基础1.1 网络编程有两个主要的问题:①: 如何准确定位网络上的一台或多台主机②: 定位后如何可靠高效的传输数据 在TCP/IP中,IP层主要负责网络主机的定位,数据传输的路由,由IP地址可以唯一的确定网络上的一台主机.而TCP层提供面向应用的数据传输机制,这是网络编程的主要对象. 1.2 基本概念:端口号: 网络通信时同一机器上的不同进程的标识（其中0~1023为系统保留的端口号）,端口范围: 0~65535套接字: IP : 端口号资源名: 是资源的完整地址,包括主机名,端口号,文件名,如http://www.sun.com （协议名://主机名）http://home.netscape.com/home/welcome.html（协议名：//机器名+文件名）协议名：指明获取资源时所使用的传输协议。 如http，ftp,gopher,file 1.3 关于UDP:UDP: 无连接的协议,每个数据报都是一个独立的信息,包括完整的源地址或目的地址,它在网络上任何可能路径传往目的地,不可靠性(发送方发送的数据报不一定以相同次序到达接收方),传输效率高,有大小限制(每个数据报大小不超过64KB),. 1.4 获取网络信息和资源:1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)java.net中很多类使用到了它,如ServerSocket, Socket , DatagramSocket等 1.4.2 常用方法:获取本机主机名: InetAddress.getLocalHost().getHostName()获取本机IP: InetAddress.getLocalHost().getHostAddress()获取本机端口: serverSocket = new ServerSocket(6666); serverSocket.getLocalPort(); 服务器端获取客户端IP: Socket socket = serverSocket.accept(); socket.getInetAddress().getHostAddress();服务器获取客户端端口: String.valueOf(socket.getPort()) 二、基于TCP的网络通信:2.1 通过套接字建立连接的过程: 2.2 实例:客户端: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267package com.zwq;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.*;import java.net.Socket;/** * Created by IntelliJ IDEA * @Author: zwq *///客户端public class Client extends JFrame implements ActionListener&#123; //程序入口 public static void main(String[] args) &#123; new Client(); &#125; Socket sock; //界面上显示的组件 JTextField txtMsgServerIP = new JTextField(20); JTextField txtMsgServerPort = new JTextField(5); JButton btnConnect = new JButton("连接服务器"); JButton btnDisConnect = new JButton("断开连接"); JTextArea txtMsgArea = new JTextArea(); JTextField txtMsgSend = new JTextField(20); JButton btnSend = new JButton("发送"); //数据输入输出流 DataOutputStream out; DataInputStream in; boolean canWaite = true; CWaiter waiter; /** * 构造器中完成初始化 */ public Client() &#123; //容器 Container container = this.getContentPane(); //初始状态时"连接服务器"按钮可点击 btnConnect.setEnabled(true); //初始状态时"断开连接"按钮不可点击 btnDisConnect.setEnabled(false); //初始状态时文本域不可编辑,只能用于显示通话信息 txtMsgArea.setEditable(false); //初始状态时发送消息的编辑框不可输入 txtMsgSend.setEditable(false); //初始状态时发送按钮不可点 btnSend.setEnabled(false); //创建面板 JPanel jp = new JPanel(new GridLayout(2,1)); JPanel jp_f1 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JPanel jp_f2 = new JPanel(new FlowLayout(FlowLayout.CENTER)); jp_f1.add(new JLabel("服务器IP")); jp_f1.add(txtMsgServerIP); jp_f1.add(new JLabel("服务器端口号")); jp_f1.add(txtMsgServerPort); jp_f2.add(btnConnect); jp_f2.add(btnDisConnect); jp.add(jp_f1); jp.add(jp_f2); //创建面板,并把组件添加到面板 JScrollPane jsp = new JScrollPane(txtMsgArea); JPanel jp2 = new JPanel(); //组件添加到面板 jp2.add(txtMsgSend); jp2.add(btnSend); //面板添加到容器 container.add(jp,"North"); container.add(jsp,"Center"); container.add(jp2,"South"); //窗口标题 setTitle("客户端"); //窗口大小 setSize(500,500); //是否可见 setVisible(true); //给组件添加监听器 txtMsgSend.addActionListener(this); btnSend.addActionListener(this); btnConnect.addActionListener(this); btnDisConnect.addActionListener(this); //添加窗口监听器 addWindowListener(new WindowAdapter() &#123; //窗口关闭事件 @Override public void windowClosing(WindowEvent e) &#123; try &#123; disconnect(); &#125; catch (Exception ee) &#123; dispose(); System.exit(0); &#125; &#125; &#125;); &#125; /** * 连接服务器 * @throws IOException */ private void connect(String ServerIP,Integer ServerPort) &#123; try &#123; //创建套接字,用于连接服务器 sock = new Socket(ServerIP,ServerPort); //由套接字获取输入输出流 InputStream is = sock.getInputStream(); OutputStream os = sock.getOutputStream(); //由输入输出流获取数据输入输出流 in = new DataInputStream(is); out = new DataOutputStream(os); //向输出流(向服务器端)写数据 out.writeUTF("客户进来"); //客户端的文本域中显示连接信息 txtMsgArea.append("连接成功\n"); //连接服务器按钮 设置为不可点击(因为现在已经连接了服务器,避免重复连接,所以按钮设置为不可点击) btnConnect.setEnabled(false); //断开连接按钮 设置为 可点击 btnDisConnect.setEnabled(true); //发送信息按钮 设置为 可点击 btnSend.setEnabled(true); //发送信息的编辑框 设置为可输入 txtMsgSend.setEditable(true); //启动线程 waiter = new CWaiter(); waiter.start(); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(null,"连接服务器失败!"); &#125; &#125; /** * 客户端发送消息到服务器 */ private void sendMsg() &#123; //发送的消息不为空 if(!txtMsgSend.getText().equals(""))&#123; try &#123; //通过输出流向服务器发消息 out.writeUTF(txtMsgSend.getText()); &#125; catch (IOException e) &#123; JOptionPane.showMessageDialog(null,"发送消息失败!"); &#125; &#125; else&#123; JOptionPane.showMessageDialog(null,"不能发送空消息!"); &#125; &#125; /** * 断开连接 */ private void disconnect()&#123; //设置组件权限 btnConnect.setEnabled(true); btnDisConnect.setEnabled(false); btnSend.setEnabled(false); txtMsgSend.setEditable(false); try &#123; //向服务器发消息,内容为disconnect,表示要断开连接 out.writeUTF("disconnect"); &#125; catch (Exception e) &#123; &#125; finally &#123; canWaite = false; try &#123; //关闭输入输出流 in.close(); out.close(); &#125; catch (Exception e)&#123; try &#123; //关闭套接字 sock.close(); &#125; catch (IOException e1) &#123; &#125; &#125; &#125; &#125; /** * 处理事件 * @param e */ @Override public void actionPerformed(ActionEvent e) &#123; //如果点击了发送按钮,就调用sendMsg函数,发送消息到服务器 if(e.getSource() == btnSend || e.getSource() == txtMsgSend)&#123; sendMsg(); txtMsgSend.setText(""); txtMsgSend.requestFocus(); &#125; else if(e.getSource() == btnConnect)&#123; //如果点击了连接按钮,就调用connect函数 //都不为空 if(!(txtMsgServerIP.getText().equals("") || txtMsgServerPort.getText().equals("")))&#123; canWaite = true; int ServerPort = Integer.parseInt(txtMsgServerPort.getText()); if(!(ServerPort &gt; 0 &amp;&amp; ServerPort &lt; 65535)) &#123; JOptionPane.showMessageDialog(null,"端口值必须在0~65535之间!"); &#125; connect(txtMsgServerIP.getText(),Integer.parseInt(txtMsgServerPort.getText())); &#125; else &#123;//不都为空 JOptionPane.showMessageDialog(null,"服务器IP或端口号不能为空!"); &#125; &#125; else if(e.getSource() == btnDisConnect)&#123; disconnect(); &#125; &#125; /** * 用于接收信息的线程 */ private class CWaiter extends Thread&#123; @Override public void run() &#123; String msg; while(canWaite) &#123; try&#123; //从输入流中读取服务器返回的数据 msg = in.readUTF(); if(msg.equals("serverStop"))&#123; txtMsgArea.append("服务器停止!\n"); break; &#125; txtMsgArea.append("服务器说: "+ msg + "\n"); &#125; catch (IOException e) &#123; break; &#125; &#125; txtMsgArea.append("客户离开\n"); disconnect(); &#125; &#125;&#125; 运行图: 服务器端: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316package com.zwq;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * Created by IntelliJ IDEA * @Author: zwq *///服务器端public class Server extends JFrame implements ActionListener &#123; //程序入口 public static void main(String[] args) &#123; new Server(); &#125; //定义界面组件 JTextField txtServerPort = new JTextField(5); JTextArea txtMsgArea = new JTextArea(); JTextField txtMsgSend = new JTextField(20); JButton btnSend = new JButton("发送"); JButton btnStart = new JButton("启动服务器"); JButton btnStop = new JButton("停止服务器"); //服务器端套接字 ServerSocket serverSocket; Socket socket; //数据流 DataOutputStream out; DataInputStream in; //控制线程的逻辑变量 boolean canWaiter = true; boolean canAccepter = true; Accepter accepter; SWaiter waiter; /** * 构造器中完成界面初始化 */ public Server() &#123; Container container = this.getContentPane(); txtMsgArea.setEditable(false); btnStart.setEnabled(true); btnStop.setEnabled(false); btnSend.setEnabled(false); txtMsgSend.setEditable(false); //网格布局 JPanel jp = new JPanel(new GridLayout(2,1)); //流式布局 JPanel jp_f1 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JPanel jp_f2 = new JPanel(new FlowLayout(FlowLayout.CENTER)); jp_f1.add(new JLabel("服务器端口号")); jp_f1.add(txtServerPort); jp_f2.add(btnStart); jp_f2.add(btnStop); jp.add(jp_f1); jp.add(jp_f2); JScrollPane jsp = new JScrollPane(txtMsgArea); JPanel jp2 = new JPanel(); jp2.add(txtMsgSend); jp2.add(btnSend); container.add(jp, "North"); container.add(jsp, "Center"); container.add(jp2, "South"); setTitle("服务器"); setSize(500, 500); setVisible(true); btnStart.addActionListener(this); btnStop.addActionListener(this); btnSend.addActionListener(this); txtMsgSend.addActionListener(this); addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; stopServer(); dispose(); System.exit(0); &#125; &#125;); &#125; /** * 启动服务器 */ private void startServer(Integer txtServerPort) &#123; try &#123; serverSocket = new ServerSocket(txtServerPort); btnStart.setEnabled(false); btnStop.setEnabled(true); accepter = new Accepter(); accepter.start(); //System.out.println(InetAddress.getLocalHost().getHostName()); //System.out.println(InetAddress.getLocalHost().getHostAddress()); txtMsgArea.append("服务器已成功启动...\n"); txtMsgArea.append("服务器主机名为: " + InetAddress.getLocalHost().getHostName()+"\n"); txtMsgArea.append("服务器IP地址为: " + InetAddress.getLocalHost().getHostAddress()+"\n"); txtMsgArea.append("服务器端口号为: " + serverSocket.getLocalPort()+"\n"); txtMsgArea.append("==============================================\n"); &#125; catch (IOException e) &#123; JOptionPane.showMessageDialog(null, "启动服务器失败"); &#125; &#125; /** * 发送消息到客户端 */ private void sendMsg() &#123; if (!txtMsgSend.getText().equals("")) &#123; try &#123; //向客户端写数据 out.writeUTF(txtMsgSend.getText()); txtMsgArea.append("服务器说: " + txtMsgSend.getText() + "\n"); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(null, "发送消息失败!"); &#125; &#125; else &#123; JOptionPane.showMessageDialog(null, "不能发送消息!"); &#125; &#125; /** * 停止服务器 */ private void stopServer() &#123; //设置组件的权限 btnStop.setEnabled(false); btnStart.setEnabled(true); //停止等待客户端请求的线程 canAccepter = false; try &#123; //向输出流写数据,通知客户端服务器已停止. out.writeUTF("serverStop"); &#125; catch (Exception e) &#123; &#125; finally &#123; try &#123; //关闭服务器端套接字 serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //断开连接 disconnect(); &#125; &#125; &#125; /** * 断开连接 */ private void disconnect() &#123; btnSend.setEnabled(false); txtMsgSend.setEditable(false); try &#123; //向输出流写数据,通知客户端服务器已停止. out.writeUTF("serverStop"); &#125; catch (Exception e) &#123; &#125; finally &#123; //停止接收信息的线程 canWaiter = false; try &#123; //关闭流 in.close(); out.close(); &#125; catch (IOException e) &#123; &#125; finally &#123; try &#123; //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 接收连接 */ private void acceptConnect() &#123; try &#123; //根据套接字获得输入输出流 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); //由输入输出流 建立数据输入输出流 in = new DataInputStream(is); out = new DataOutputStream(os); //从输入流读取客户端写入的数据,并显示 String msg = in.readUTF(); txtMsgArea.append(msg + "\n"); //设置组件的权限 btnSend.setEnabled(true); txtMsgSend.setEditable(true); canWaiter = true; //建立 和 启动线程 waiter = new SWaiter(); waiter.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 处理事件(如按钮被点击) * @param e */ @Override public void actionPerformed(ActionEvent e) &#123; if (e.getSource() == btnSend || e.getSource() == txtMsgSend) &#123; sendMsg(); //发送完消息后清空输入框,以便下一次输入 txtMsgSend.setText(""); //定位焦点到输入框,以便下一次输入 txtMsgSend.requestFocus(); &#125; else if (e.getSource() == btnStart) &#123; if(!(txtServerPort.getText().equals("")))&#123; int ServerPort = Integer.parseInt(txtServerPort.getText()); if(!(ServerPort &gt; 0 &amp;&amp; ServerPort &lt; 65535)) &#123; JOptionPane.showMessageDialog(null,"端口值必须在0~65535之间!"); &#125; canAccepter = true; canWaiter = true; startServer(ServerPort); &#125; &#125; else if (e.getSource() == btnStop) &#123; stopServer(); &#125; &#125; /** * 接收客户端请求的线程 */ private class Accepter extends Thread &#123; @Override public void run() &#123; while (canAccepter) &#123; try &#123; socket = serverSocket.accept(); acceptConnect(); //在服务器端窗口显示客户端的IP地址和端口格式为 "/192.168.56.1:9606" //txtMsgArea.append(socket.getRemoteSocketAddress().toString()+"\n"); //在服务器端窗口显示客户端的IP地址 txtMsgArea.append("客户端IP地址: "+socket.getInetAddress().getHostAddress()+"\n"); //服务器端窗口显示客户端端口 txtMsgArea.append("客户端端口号: "+ String.valueOf(socket.getPort())+"\n"); txtMsgArea.append("==============================================\n"); &#125; catch (IOException e) &#123; break; &#125; &#125; try &#123; //关闭服务器套接字 serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 等待消息的线程 */ private class SWaiter extends Thread &#123; @Override public void run() &#123; String msg = null; while (canWaiter) &#123; try &#123; msg = in.readUTF(); if (msg.equals("disconnect")) &#123; txtMsgArea.append("客户离开!\n"); break; &#125; txtMsgArea.append("客户说: " + msg + "\n"); &#125; catch (IOException e) &#123; break; &#125; &#125; txtMsgArea.append("断开连接\n"); txtMsgArea.append("==============================================\n"); disconnect(); &#125; &#125;&#125; 运行图: 客户端与服务器通信: 三、基于UDP的网络通信:3.1 实例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215package com.zwq;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.IOException;import java.net.*;/** * Created by IntelliJ IDEA * @Author: zwq */public class HostComputer extends JFrame implements ActionListener&#123; //程序入口 public static void main(String[] args) &#123; new HostComputer(); &#125; //文本域 JTextArea txtMsgArea = new JTextArea(); //输入框 JTextField txtMsgSend = new JTextField(20); //对方地址 JTextField txtToAddress = new JTextField(15); //对方端口 JTextField txtToPort = new JTextField(5); //本地端口 JTextField txtLocalPort = new JTextField(5); //按钮 JButton btnSend = new JButton("发送"); JButton btnStart = new JButton("开始"); //缓冲区大小 byte[]buf = new byte[1024]; //服务器地址 InetAddress toAddress; //服务器端口 int toPort; //本地端口 int localPort; //数据报套接字 DatagramSocket socket; //控制线程的逻辑变量 boolean canWaiter; /** * 构造器 */ public HostComputer() &#123; //设置组件权限 txtMsgArea.setEditable(false); txtMsgSend.setEditable(false); btnSend.setEnabled(false); Container container = this.getContentPane(); JPanel jp_G = new JPanel(new GridLayout(2,1)); JPanel jp_f1 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JPanel jp_f2 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JScrollPane jsp = new JScrollPane(txtMsgArea); JPanel jp = new JPanel(); jp_f1.add(new JLabel("对方地址")); jp_f1.add(txtToAddress); jp_f1.add(new JLabel("对方端口")); jp_f1.add(txtToPort); jp_f2.add(new JLabel("本地端口")); jp_f2.add(txtLocalPort); jp_f2.add(btnStart); jp_G.add(jp_f1); jp_G.add(jp_f2); jp.add(txtMsgSend); jp.add(btnSend); txtMsgSend.addActionListener(this); btnSend.addActionListener(this); btnStart.addActionListener(this); container.add(jp_G,"North"); container.add(jsp,"Center"); container.add(jp,"South"); setTitle("基于数据报的UDP通信"); setSize(500,300); setVisible(true); addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; try &#123; stop(); &#125; catch (Exception e1)&#123; &#125; dispose(); System.exit(0); &#125; &#125;); &#125; /** * */ private void start()&#123; try &#123; toAddress = InetAddress.getByName(txtToAddress.getText()); toPort = Integer.parseInt(txtToPort.getText()); localPort = Integer.parseInt(txtLocalPort.getText()); socket = new DatagramSocket(localPort); canWaiter = true; (new Waiter()).start(); //设置组件权限 txtToAddress.setEditable(false); txtToPort.setEditable(false); txtLocalPort.setEditable(false); txtMsgSend.setEditable(true); btnSend.setEnabled(true); btnStart.setText("停止"); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(null,"启动失败!"); &#125; &#125; /** * */ private void stop()&#123; //设置按钮权限 txtMsgSend.setEditable(false); txtLocalPort.setEditable(true); txtToPort.setEditable(true); txtToAddress.setEditable(true); //txtMsgArea.setEditable(false); btnSend.setEnabled(false); canWaiter = false; toAddress = null; socket.close(); btnStart.setText("开始"); &#125; private void send()&#123; if(!txtMsgSend.getText().equals("")) &#123; byte[] b = txtMsgSend.getText().getBytes(); DatagramPacket packet = new DatagramPacket(b,b.length,toAddress,toPort); try &#123; socket.send(packet); txtMsgArea.append("发送的数据: "+txtMsgSend.getText()+"\n"); txtMsgArea.append("发送到"+toAddress+"\n"); txtMsgArea.append("数据长度为: "+packet.getLength()+"\n"); txtMsgSend.setText(""); txtMsgSend.requestFocus(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; JOptionPane.showMessageDialog(null,"不能发送空消息!"); &#125; &#125;class Waiter extends Thread&#123; @Override public void run() &#123; while(canWaiter)&#123; DatagramPacket packet = new DatagramPacket(buf,buf.length); try &#123; socket.receive(packet); String received = new String(packet.getData(),0,packet.getLength()); txtMsgArea.append("收到的数据: "+received+"\n"); txtMsgArea.append("数据来自于: "+packet.getAddress()+"\n"); txtMsgArea.append("数据长度为: "+packet.getLength()+"\n"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; /** * * @param e */ @Override public void actionPerformed(ActionEvent e) &#123; if(e.getSource() == txtMsgSend || e.getSource() == btnSend)&#123; send(); &#125; else if(e.getActionCommand().equals("开始"))&#123; start(); txtMsgSend.requestFocus(); &#125; else if(e.getActionCommand().equals("停止"))&#123; stop(); &#125; &#125;&#125; 运行两次,出现两个窗口,在这两个窗口进行通信** 运行图:]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之UI]]></title>
    <url>%2FAndroid%E4%B9%8BUI.html</url>
    <content type="text"><![CDATA[一、如何编写程序界面:Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局. 二、常见控件的使用方法2.1 TextView主要用于在界面上显示一段文本信息,设置颜色,文本居中 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ....&gt; &lt;TextView //给当前控件定义了一个唯一标识符 android:id="@+id/text_view" //所有的控件都具有这两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content android:layout_width="match_parent" android:layout_height="wrap_content" //文本居中对齐 android:gravity="center" //设置字体大小 android:textSize="24sp" //设置字体颜色 android:textColor="#00ff00" android:text="This is TextView" /&gt;&lt;/LinearLayout&gt;//match_parent 由父布局来决定当前控件的大小//wrap_content 由控件内容决定当前控件的大小 2.2 Button:activity_main.xml 中添加代码: 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ....&gt; .... &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt; 在 MainActivity 中为 Button 的点击事件注册一个监听器 1234567891011121314public class MainActivity extends Activity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... button = (Button) findViewById(R.id.button); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 在此处添加逻辑 &#125; &#125;); &#125;&#125; 2.3 EditText它允许用户在控件里输入和编辑内容 修改 布局文件activity_main.xml 中的代码: 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ...&gt; .... &lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" //输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失 android:hint="Type something here" //通过 android:maxLines 指定了 EditText 的最大行数为两行，这样当输入的内容超过两行时，文本就会向 //上滚动，而 EditText则不会再继续拉伸 android:maxLines="2" /&gt;&lt;/LinearLayout&gt; 通过点击按钮来获取EditText 中输入的内容。修改 MainActivity 中的代码 123456789101112131415161718192021222324public class MainActivity extends Activity implements OnClickListener &#123; private Button button; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: String inputText = editText.getText().toString(); Toast.makeText(MainActivity.this, inputText, Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125; 2.4 ImageView修改 activity_main.xml 123456789101112&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt;.... &lt;ImageView android:id="@+id/image_view" //将 ImageView 的宽和高都设定为wrap_content，这样保证不管图片的尺寸是多少都可以完整地展示出来 android:layout_width="wrap_content" android:layout_height="wrap_content" //使用 android:src 属性给 ImageView指定了一张图片 android:src="@drawable/ic_launcher" /&gt;&lt;/LinearLayout&gt; 通过代码动态地更改 ImageView 中的图片。这里我准备了另外一张图片，jelly_bean.png，将它复制到 res/drawable-hdpi 目录下，然后修改 MainActivity 的代码，如下所示： 123456789101112131415161718192021222324252627public class MainActivity extends Activity implements OnClickListener &#123; private Button button; private EditText editText; // private ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); // imageView = (ImageView) findViewById(R.id.image_view); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: //调用 ImageView 的 setImageResource()方法将显示的图片改成 jelly_bean imageView.setImageResource(R.drawable.jelly_bean); break; default: break; &#125; &#125;&#125; 2.5 ProgressBar用于在界面上显示一个进度条 修改 activity_main.xml 中的代码: 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"... &gt;... &lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:layout_height="wrap_content" //指定成水平进度条 style="?android:attr/progressBarStyleHorizontal" //给进度条设置一个最大值,然后在MainActivity类中动态地更改进度条的进度 android:max="100" /&gt;&lt;/LinearLayout&gt; Android控件的可见属性。可以通过android:visibility进行指定，可选值有三种，visible、invisible 和 gone。visible 表示控件是可见的，这个值是默认值invisible 表示控件不可见，但是它仍然占据着原来的位置和大小gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 三种值。 点击一下按钮让进度条消失，再点击一下按钮让进度条出现的这种效果。修改 MainActivity 中的代码 123456789101112131415161718192021222324public class MainActivity extends Activity implements OnClickListener &#123; .... private ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... progressBar = (ProgressBar) findViewById(R.id.progress_bar); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: if (progressBar.getVisibility() == View.GONE) &#123; progressBar.setVisibility(View.VISIBLE); &#125; else &#123; progressBar.setVisibility(View.GONE); &#125; break; default: break; &#125; &#125;&#125; 12345678910111213141516//通过 activity_main.xml 中添加 android:max 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度public class MainActivity extends Activity implements OnClickListener &#123; ..... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: int progress = progressBar.getProgress(); progress = progress + 10; progressBar.setProgress(progress); break; default: break; &#125; &#125;&#125; 2.6 AlertDialog在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上,用于提示一些非常重要的内容或者警告信息 修改 MainActivity 中的代码 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity implements OnClickListener &#123; .... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: //通过 AlertDialog.Builder 创建出一个 AlertDialog 的实例 AlertDialog.Builder dialog = new AlertDialog.Builder (MainActivity.this); dialog.setTitle("This is Dialog"); dialog.setMessage("Something important."); dialog.setCancelable(false); //调用 setPositiveButton()方法为对话框设置确定按钮的点击事件 dialog.setPositiveButton("OK", new DialogInterface. OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); //调用 setNegativeButton()方法设置取消按钮的点击事件 dialog.setNegativeButton("Cancel", new DialogInterface. OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); //调用 show()方法将对话框显示出来 dialog.show(); break; default: break; &#125; &#125;&#125; 2.7 ProgressDialog在对话框中显示一个进度条,表示当前操作比较耗时，让用户耐心地等待 修改 MainActivity 中的代码: 12345678910111213141516171819public class MainActivity extends Activity implements OnClickListener &#123; …… @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle("This is ProgressDialog"); progressDialog.setMessage("Loading..."); /*注意如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取 消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的 dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。 */ progressDialog.setCancelable(true); progressDialog.show(); break; default: break; &#125; &#125;&#125; 三、详解四种基本布局布局是一种可用于放置很多控件的容器,布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套 新建一个UILayoutTest项目，并让 ADT 自动帮我们创建好活动，活动名和布局名都使用默认值 3.1 LinearLayout:称作线性布局，是一种非常常用的布局,它所包含的控件在线性方向上依次排列 3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐修改activity_main.xml 中的代码: 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" //指定了排列方向是 vertical(垂直方向), orientation(方向；定向；适应；情况介绍) android:orientation="vertical" &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button 1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button 2" /&gt; &lt;/LinearLayout&gt; 垂直对齐: android:gravity 是用于指定文字在控件中的对齐方式 android:layout_gravity 是用于指定控件在布局中的对齐方式 需要注意，当LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式,同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效. 修改 activity_main.xml 中的代码: 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... /*LinearLayout 的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向(即只能指定上,中,下,而不能指定左右)，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_vertical*/ android:orientation="horizontal" &gt; &lt;Button .... android:layout_gravity="top" android:text="Button 1" /&gt; &lt;Button .... android:layout_gravity="center_vertical" android:text="Button 2" /&gt; &lt;/LinearLayout&gt; 3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小编写一个消息发送界面，需要一个文本编辑框和一个发送按钮 修改activity_main.xml 中的代码 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/input_message" /*这里竟然将 EditText 和 Button 的宽度都指定成了 0，这样文本编辑框和按钮还能显示出来吗？不用担 心，由于我们使用了 android:layout_weight 属性，此时控件的宽度,就不应该再android:layout_width 来决定，这里指定成 0 是一种比较规范的写法 */ android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type something" /&gt; &lt;Button android:id="@+id/send" android:layout_width="0dp" android:layout_height="wrap_content" /* EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示EditText 和 Button 将在水平方向平分宽度*/ android:layout_weight="1" android:text="Send" /&gt;&lt;/LinearLayout&gt;/*为什么将 android:layout_weight 属性的值同时指定为 1 就会平分屏幕宽度呢？系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。*/ 修改activity_main.xml 中的代码 1234567891011121314151617181920/*仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服*/&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/input_message" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" ... /&gt; &lt;Button android:id="@+id/send" android:layout_width="wrap_content" .... /&gt;&lt;/LinearLayout&gt; 3.2 RelativeLayout通过相对定位的方式让控件出现在布局的任何位置 3.2.1 每个控件相对于父布局进行定位修改 activity_main.xml 中的代码: 1234567891011121314151617181920212223242526272829303132333435&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" .... &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" //Button 1和父布局的左上角对齐 android:layout_alignParentLeft="true" android:layout_alignParentTop="true" .../&gt; &lt;Button android:id="@+id/button2" .... android:layout_alignParentRight="true" android:layout_alignParentTop="true" ... /&gt; &lt;Button android:id="@+id/button3" .... android:layout_centerInParent="true" .... /&gt; &lt;Button android:id="@+id/button4" .... android:layout_alignParentBottom="true" android:layout_alignParentLeft="true" .... /&gt; &lt;Button android:id="@+id/button5" .... //Button 5 和父布局的右下角对齐 android:layout_alignParentBottom="true" android:layout_alignParentRight="true" .... /&gt;&lt;/RelativeLayout&gt; 3.2.2 控件相对于控件进行定位修改 activity_main.xml 中的代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt; &lt;Button android:id="@+id/button3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 1" /&gt; &lt;Button android:id="@+id/button1" .... //android:layout_above属性让一个控件位于另一个控件的上方 //@id/button3，表示让该控件位于 Button 3 的上方 android:layout_above="@id/button3" android:layout_toLeftOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button2" .... android:layout_above="@id/button3" android:layout_toRightOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button4" .... android:layout_below="@id/button3" android:layout_toLeftOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button5" .... android:layout_below="@id/button3" android:layout_toRightOf="@id/button3" .... /&gt;&lt;/RelativeLayout&gt;/*另外一组相对于控件进行定位的属性 如android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐 */ 3.3 FrameLayout没有任何的定位方式，所有的控件都会摆放在布局的左上角,它的应用场景并不多 修改 activity_main.xml 中的代码 1234567891011121314&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt; //按钮 &lt;Button android:id="@+id/button" .... /&gt; //图片 &lt;ImageView android:id="@+id/image_view" .... android:src="@drawable/ic_launcher" /&gt;&lt;/FrameLayout&gt; 3.4 TableLayout使用表格的方式来排列控件 设计一个登录界面，用户输入账号密码后登录 activity_main.xml 中的代码 123456789101112131415161718192021222324252627282930313233&lt;TableLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; // TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行 &lt;TableRow&gt; //在 TableRow中每加入一个控件，就表示在该行中加入了一列 //TableRow 中的控件是不能指定宽度的 &lt;TextView android:layout_height="wrap_content" android:text="Account:" /&gt; &lt;EditText android:id="@+id/account" android:layout_height="wrap_content" android:hint="Input your account" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;TextView android:layout_height="wrap_content" android:text="Password:" /&gt; &lt;EditText android:id="@+id/password" android:layout_height="wrap_content" android:inputType="textPassword" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;Button android:id="@+id/login" android:layout_height="wrap_content" //对单元格进行合并 android:layout_span="2" android:text="Login" /&gt; &lt;/TableRow&gt;&lt;/TableLayout&gt; android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列进行拉伸，以达到自动适应屏幕宽度的作用 修改 activity_main.xml 中的代码 123456789&lt;TableLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" // android:stretchColumns 的值指定为 1，表示如果表格不能完全占满屏幕宽度，就将第二列进行拉伸 //指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列 android:stretchColumns="1" &gt; ....&lt;/TableLayout&gt; 四、创建自定义控件 所有控件都是直接或间接继承自 View,所有布局都是直接或间接继承自 ViewGroup 创建一个 UICustomViews 项目: 4.1 引入布局1//android:background 用于为布局或控件指定一个背景 修改activity_main.xml 中的代码: 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; //引入标题栏布局 &lt;include layout="@layout/title" /&gt;&lt;/LinearLayout&gt; 别忘了在 MainActivity 中将系统自带的标题栏隐藏掉 修改MainActivity类: 12345678public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... requestWindowFeature(Window.FEATURE_NO_TITLE); .... &#125;&#125; 4.2 创建自定义控件引入布局确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码,这种情况最好是使用自定义控件的方式来解决 新建 TitleLayout类 继承自 LinearLayout，让它成为我们自定义的标题栏控件 123456789101112/*在布局中引入 TitleLayout控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借助 LayoutInflater 来实现了,LayoutInflater 的 from()方法可以构建出一个 LayoutInflater对象，然后调用 inflate()方法就可以动态加载一个布局文件*/public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); //第一个参数是要加载的布局文件的 id,第二个参数是给加载好的布局再添加一个父布局,这里我们想要指定为 TitleLayout，于是直接传入 this LayoutInflater.from(context).inflate(R.layout.title, this); &#125;&#125; 现在自定义控件已经创建好了，然后在布局文件中添加这个自定义控件 修改activity_main.xml 中的代码 123456789//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候我们需要指明控件的完整类名，包名在这里是不可以省略的&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.example.uicustomviews.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/com.example.uicustomviews.TitleLayout&gt;&lt;/LinearLayout&gt; 为标题栏中的按钮注册点击事件 修改 TitleLayout中的代码 123456789101112131415161718192021222324public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); // findViewById()方法得到按钮的实例 Button titleBack = (Button) findViewById(R.id.title_back); Button titleEdit = (Button) findViewById(R.id.title_edit); //分别调用 setOnClickListener()方法给两个按钮注册了点击事件 titleBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; ((Activity) getContext()).finish(); &#125; &#125;); titleEdit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getContext(), "You clicked Edit button", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 五、最常用最难用控件ListViewListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕 5.1 ListView 的简单用法首先新建一个 ListViewTest 项目,都默认 修改activity_main.xml 中的代码 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 修改 MainActivity 中的代码 12345678910111213141516public class MainActivity extends Activity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry","Cherry", "Mango" &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成 //android.R.layout.simple_list_item_1 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1,data); ListView listView = (ListView) findViewById(R.id.list_view); // setAdapter()方法，将构建好的适配器对象传递进去,这样 ListView和数据之间的关联就建立完成了 listView.setAdapter(adapter); &#125;&#125; 5.2 定制 ListView 的界面新建类 Fruit 1234567891011121314public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; layout 目录下新建fruit_item.xml 12345678910111213141516&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; // ImageView 用于显示水果的图片 &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; //TextView用于显示水果的名称 &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" /&gt;&lt;/LinearLayout&gt; 新建类 FruitAdapter 12345678910111213141516171819202122public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; // getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // getItem()方法得到当前项的 Fruit 实例 Fruit fruit = getItem(position); // 获取当前项的Fruit实例 //LayoutInflater 来为这个子项加载我们传入的布局， View view = LayoutInflater.from(getContext()).inflate(resourceId, null); // findViewById()方法分别获取到 ImageView 和 TextView 的实例 ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); // setImageResource()和 setText()方法来设置显示的图片和文字 fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125; &#125; 修改 MainActivity 中的代码 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends Activity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango" &#125;; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits() &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; ....&#125; 5.3 提升 ListView 的运行效率修改 FruitAdapter中的代码 12345678910111213141516171819202122232425/*getView()方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用*/public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; .... @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; //如果 convertView 为空，则使用LayoutInflater 去加载布局，如果不为空则直接对 convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候也可以表现出更好的性能。 if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); &#125; else &#123; view = convertView; &#125; ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125;&#125;/*虽然现在已经不会再重复去加载布局，但是每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个 ViewHolder来对这部分性能进行优化*/ 可以继续优化 修改 FruitAdapter 中的代码: 1234567891011121314151617181920212223242526272829303132333435public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; ... @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder 存储在View 中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; //ViewHolder，用于对控件的实例进行缓存 class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125;&#125;/*当 convertView为空的时候:创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View的 setTag()方法，将 ViewHolder 对象存储在 View 中。当 convertView 不为空的时候:则调用View的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了*/ 5.4 ListView 的点击事件修改 MainActivity 中的代码 123456789101112131415161718public class MainActivity extends Activity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; .... //通过 position 参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来 listView.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; ……&#125; 六、单位和尺寸布局文件中指定宽高的固定大小有以下常用单位可供选择：px、pt、dp 和 sp px 是像素的意思，即屏幕中可以显示的最小元素单元 pt 是磅数的意思，1 磅等于 1/72 英寸，一般 pt 都会作为字体的单位来使用 新建好一个 UISizeTest 项目 修改 activity_main.xml 中的代码 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" // android:layout_width 属性将按钮的宽指定为 200px android:layout_width="200px" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt; 接着创建一个 240*320 像素的低分辨率模拟器，在这个模拟器上重新运行程序 dp 是密度无关像素的意思，也被称作 dip，和 px 相比，它在不同密度的屏幕中的显示比例将保持一致。 sp 是可伸缩像素的意思，它采用了和 dp 同样的设计理念，解决了文字大小的适配问题 什么叫密度？Android 中的密度就是屏幕每英寸所包含的像素数，通常以 dpi为单位 比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果它的分辨率是 320480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640960，那这个屏幕的密度就是 320dpi 如何得知当前屏幕的密度值? 修改 MainActivity 中的代码 1234567891011public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); float xdpi = getResources().getDisplayMetrics().xdpi; float ydpi = getResources().getDisplayMetrics().ydpi; Log.d("MainActivity", "xdpi is " + xdpi); Log.d("MainActivity", "ydpi is " + ydpi); &#125;&#125; 根据 Android 的规定，在 160dpi 的屏幕上，1dp 等于 1px，而在 320dpi 的屏幕上，1dp就等于 2px。因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的显示比例保持一致 修改 activity_main.xml 中的代码 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" android:layout_width="200dp" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt;/*尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。*/ 七、编写界面的最佳实践:创建一个 UIBestPractice 项目 7.1 制作 Nine-Patch 图片Nine-Patch 图片,它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸而哪些区域不可以。 准备一张普通的气泡样式的png图片 message_left.png (google上直接搜索message_left.png就可找到) 将这张图片设置为一个 LinearLayout 的背景图片,修改 activity_main.xml 123456789&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/message_left" &gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差. 这时我们就可以使用 Nine-Patch 图片来进行改善 在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。绘制完成后效果如图: 注意：制作完成后，应该将原始文件删除，否则AS会分不清楚而报错。 重新运行程序 这样当图片需要拉伸的时候，就可以只拉伸指定的区域，程序在外观上也是有了很大的改进 7.2 编写精美的聊天界面再制作一张message_right.9.png作为发出消息的背景图 修改 activity_main.xml 1234567891011121314151617181920212223242526272829303132333435&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#d8e0e8" android:orientation="vertical" &gt;// ListView 用于显示聊天的消息内容 &lt;ListView android:id="@+id/msg_list_view" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"// android:divider属性，它可以指定 ListView分隔线的颜色，这里#0000 表示将分隔线设为透明色 android:divider="#0000" &gt; &lt;/ListView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt;//EditText用于输入消息 &lt;EditText android:id="@+id/input_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type somthing here" android:maxLines="2" /&gt;// Button 用于发送消息 &lt;Button android:id="@+id/send" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Send" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 定义消息的实体类，新建 Msg 1234567891011121314151617181920212223public class Msg &#123; //TYPE_RECEIVED 表示这是一条收到的消息 public static final int TYPE_RECEIVED = 0; //TYPE_SENT 表示这是一条发出的消息 public static final int TYPE_SENT = 1; //content 表示消息的内容 private String content; //type 表示消息的类型 private int type; public Msg(String content, int type) &#123; this.content = content; this.type = type; &#125; public String getContent() &#123; return content; &#125; public int getType() &#123; return type; &#125;&#125; 编写 ListView子项的布局，新建 msg_item.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="10dp" &gt;//让收到的消息居左对齐 &lt;LinearLayout android:id="@+id/left_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:background="@drawable/message_left" &gt; &lt;TextView android:id="@+id/left_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" android:textColor="#fff" /&gt; &lt;/LinearLayout&gt;//发出的消息居右对齐 &lt;LinearLayout android:id="@+id/right_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:background="@drawable/message_right" &gt; &lt;TextView android:id="@+id/right_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 创建 ListView 的适配器类，让它继承自 ArrayAdapter，并将泛型指定为 Msg类。新建类 MsgAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MsgAdapter extends ArrayAdapter&lt;Msg&gt; &#123; private int resourceId; public MsgAdapter(Context context, int textViewResourceId, List&lt;Msg&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Msg msg = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); viewHolder.rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); viewHolder.leftMsg = (TextView) view.findViewById(R.id.left_msg); viewHolder.rightMsg = (TextView) view.findViewById(R.id.right_msg); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; if (msg.getType() == Msg.TYPE_RECEIVED) &#123; // 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏 viewHolder.leftLayout.setVisibility(View.VISIBLE); viewHolder.rightLayout.setVisibility(View.GONE); viewHolder.leftMsg.setText(msg.getContent()); &#125; else if (msg.getType() == Msg.TYPE_SENT) &#123; // 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏 viewHolder.rightLayout.setVisibility(View.VISIBLE); viewHolder.leftLayout.setVisibility(View.GONE); viewHolder.rightMsg.setText(msg.getContent()); &#125; return view; &#125; class ViewHolder &#123; LinearLayout leftLayout; LinearLayout rightLayout; TextView leftMsg; TextView rightMsg; &#125;&#125; 修改 MainActivity 中的代码，来为 ListView初始化一些数据，并给发送按钮加入事件响应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends Activity &#123; private ListView msgListView; private EditText inputText; private Button send; private MsgAdapter adapter; private List&lt;Msg&gt; msgList = new ArrayList&lt;Msg&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); initMsgs(); // 初始化消息数据 adapter = new MsgAdapter(MainActivity.this, R.layout.msg_item, msgList); inputText = (EditText) findViewById(R.id.input_text); send = (Button) findViewById(R.id.send); msgListView = (ListView) findViewById(R.id.msg_list_view); msgListView.setAdapter(adapter); send.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取 EditText 中的内容 String content = inputText.getText().toString(); //如果内容不为空则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去 if (!"".equals(content)) &#123; Msg msg = new Msg(content, Msg.TYPE_SENT); msgList.add(msg); //调用了适配器的 notifyDataSetChanged()方法，用于通知列表的数据发生了变化 adapter.notifyDataSetChanged(); // 当有新消息时，刷新ListView中的显示 // 将ListView定位到最后一行,以保证一定可以看得到最后发出的一条消息 msgListView.setSelection(msgList.size()); inputText.setText(""); // 清空输入框中的内容 &#125; &#125; &#125;); &#125; private void initMsgs() &#123; //初始化几条数据用于在 ListView 中显示 Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED); msgList.add(msg1); Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SENT); msgList.add(msg2); Msg msg3 = new Msg("This is Tom. Nice talking to you. ", Msg.TYPE_RECEIVED); msgList.add(msg3); &#125; ......&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android之UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串]]></title>
    <url>%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[一、字符串的特性:String 被声明为 final，因此它不可被继承。 二、不同JDK版本中String的区别:①: 在 Java 8 中，String 内部使用 char 数组存储数据。 ②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 三、String 与StringBuffer,StringBuilder的区别：3.1 可变性:String的长度是不可变的，而StringBuffer和StringBuilder长度是可变的. 也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中. 3.2 线程安全:String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StringBuffer的常用方法: String常用方法: StringBuffer和StringBuilder和String的效率比较: 1234567891011121314151617181920212223242526272829@Testpublic void test2() &#123; long startTime = 0L; long endTime = 0L; String text = ""; StringBuffer buffer = new StringBuffer(""); StringBuilder builder = new StringBuilder(""); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuffer的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuilder的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println("String的执行时间：" + (endTime - startTime));&#125; 四、字符串与其他数据类型的转换: 4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)A ———&gt; B: 调用B的方法:①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法 4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)字符串———&gt;数组 调用字符串的方法数组————&gt;字符串 调用字符串的构造器 ③: 字符串——-&gt;字节数组 调用字符串的getBytes()④: 字符串——-&gt;字符数组 调用字符串的toCharArray() ⑤: 字节数组——&gt;字符串 调用字符串的构造器⑥: 字符数组——&gt;字符串 调用字符串的构造器 字符串to基本数据类型 （1）基本数据类型对应的包装类的parseXXX方法 （2）用字符串构造基本类型的封装对象，再调用封装对象的xxxValue方法 例：将字符串”20.5”转成double类型，Double d1 = new Double(“20.5”); double d2 = d1.doubleValue(); 基本数据类型to字符串 （1）String的valueOf方法 （2）”+“ 号连接 （3）将基本数据类型封装成相应的封装类型对象，采用 “基本数据类型对应包装类的对象.toString()“方法转换成字符串。 例：将double类型的425.0转成字符串，Double d = new Double(425.0); String s =d.toString(); 五、字符串常量池（String Pool）:①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 ②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 ③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 六、字符串字面量 和字符串对象:字面量指的是能够使用简单结构和符号创建对象的表达式。如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。 七、new String(“abc”)创建了几个对象?使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 八、关于”==” 和”equals”和String的intern()方法:①: “==”比较的是地址②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.③: String类重写了equals方法④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用； 关于intern(): 1234567891011121314151617String s0= “kvill”; String s1=new String(”kvill”); String s2=new String(“kvill”); System.out.println( s0==s1 ); System.out.println( “**********” ); s1.intern(); s2=s2.intern(); //把常量池中“kvill”的引用赋给s2 System.out.println( s0==s1); System.out.println( s0==s1.intern() ); System.out.println( s0==s2 );结果为： false ********** false //虽然执行了s1.intern(),但它的返回值没有赋给s1 true //说明s1.intern()返回的是常量池中”kvill”的引用 true 几个结论: 直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。 new出来的字符串是存放在堆里面。 对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况： 表达式右边是纯字符串常量，那么存放在常量池里面。 表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面 12345678910111213String str1 = "aaa"; //str1存放的值是字符串常量池中字符串aaa对象的地址.String str2 = "bbb";String str3 = "aaabbb";String str4 = str1 + str2; //str4存放的是堆中字符串aaabbb对象的地址String str5 = "aaa" + "bbb";System.out.println(str3 == str4); // falseSystem.out.println(str3 == str4.intern()); // trueSystem.out.println(str3 == str5);// true//分析:结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。其实Integer这种包装类型的-128 ~ +127也是存放在常量池里面，比如Integer i1 = 10;Integer i2 = 10; i1 == i2结果是true，估计也是为了性能优化。 九、五个关于字符串的算法题:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 * 1. 模拟一个trim方法，去除字符串两端的空格 。 * 2. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 * 3. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。 * 4. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = "abcwercvhelloobnm"。 * 5.对字符串中字符进行自然排序 // 1. 模拟trim方法，去除字符串两端的空格 public static String myTrim(String str) &#123; int start = 0; int end = str.length() - 1; // 判断字符串str前面是否有空格 while (start &lt;= end &amp;&amp; str.charAt(start) == ' ') &#123; start++; &#125; System.out.println(start); // 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常 while (start &lt;= end &amp;&amp; str.charAt(end) == ' ') &#123; end--; &#125; System.out.println(end); // 方法一： char[]a = new char[end-start+1]; int j = 0; for (int i = start; i &lt;= end; i++,j++) &#123; System.out.print(i+" "); a[j] = str.charAt(i); &#125; System.out.println(); //将字符数组转换为字符串 String str1 = new String(a); return str1; // // 方法二：// return str.substring(start, end + 1); &#125; // 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一) public static String myReverseString(String str, int start, int end) &#123; //字符串转换为字符数组 char[] c = str.toCharArray(); return myreverseArray(c, start, end); &#125; public static String myreverseArray(char[] c, int start, int end)&#123; for (int i = start,j = end; i &lt; j; i++,j--) &#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; &#125; //字符数组转换为字符串 return new String(c); &#125;&#125; // 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二） public static String reverseString2(String str, int start, int end) &#123; String str1 = str.substring(0,start); for (int i = end; i &gt;= start; i--) &#123; char c = str.charAt(i); str1 += c; &#125; str1 += str.substring(end + 1); return str1; &#125; // 3. 获取一个字符串在另一个字符串中出现的次数. // 判断str2 在 str1 中出现的次数 // 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取 public static int getTime(String str1, String str2) &#123; int count = 0; int length; while ((length = str1.indexOf(str2)) != -1) &#123; count++; str1 = str1.substring(length + str2.length()); &#125; return count; &#125; // 4. 获取两个字符串中最大相同字串。 public static List&lt;String&gt; getMaxSubString(String str1, String str2) &#123; String maxStr = (str1.length() &gt; str2.length())? str1:str2; String minStr = (str1.length() &lt; str2.length())? str1:str2; int length = minStr.length(); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; length; i++) &#123; for (int x = 0,y = length - i; y &lt;= length; x++,y++) &#123; String str = minStr.substring(x,y); if (maxStr.contains(str)) &#123; list.add(str); &#125; &#125; if (list.size() != 0) &#123; return list; &#125; &#125; return null; &#125; //5.对字符串中字符进行自然排序 public static String mySort(String str) &#123; char[]c = str.toCharArray(); Arrays.sort(c); return new String(c); &#125; public class StringDemo &#123; public static void main(String[] args) &#123; // @Test-myTrim String testString1 = " abc d "; // 特殊情况 String testString2 = " "; String str1 = StringDemo.myTrim(testString1); String str2 = StringDemo.myTrim(testString2); System.out.println("----" + str1 + "----"); System.out.println("----" + str2 + "----"); // 验证 String str3 = str1.trim(); String str4 = str2.trim(); System.out.println("----" + str3 + "----"); System.out.println("----" + str4 + "----"); // @Test-myReverseString and myReverseArray String str5 = "abcdefg"; String str6 = myReverseString(str5, 2, 5); System.out.println("原字符串：" + str5); System.out.println("指定部分反转-法一：" + str6); String str7 = "abcdefg"; String str8 = reverseString2(str7, 2, 5); System.out.println("指定部分反转-法二：" + str8); int count = getTime("abkkcadkabkebfkabkskab", "abk"); System.out.println("出现次数为：" + count); List&lt;String&gt; str9 = getMaxSubString("abcwerathelloyuiodef", "abcwercvhellobnm"); System.out.println(str9); String str10 = "aediewfn"; String str11 = mySort(str10); System.out.println(str11); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、数据链路层设备:①: 网桥或桥接器:②: 交换机: 实质: 是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器 特点: 全双工: 并行性: 即能同时连通多对接口，使多对主机能同时通信 自学习: 即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 优点: 对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s. ③: 网络适配器又称网络接口卡，网卡 网络适配器是什么? 网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。 网络适配器的主要作用： 它是主机与介质的桥梁设备 实现主机与介质之间的电信号匹配 提供数据缓冲能力 控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。) 网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。 二、数据链路层协议:2.1 PPP协议: Point-to-Point Protocal; （点到点）互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 2.1.1 特点:①: 简单②: 只检错,不纠错③: 不使用序号,不进行流量控制 2.1.2 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 2.2 PPPoE协议:是为宽带上网的主机使用的链路层协议 2.3 CSMA/CD协议:CSMA/CD 表示载波监听多点接入 / 碰撞检测。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 2.4 IEEE 802.3/.2协议2.5 ATM协议2.6 HDLC协议三、数据链路层基本单元:帧 四、数据链路层三个基本问题:4.1 封装成帧:将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 4.2 透明传输:透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 4.3 差错检测:循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算 五、数据链路层使用的信道:5.1 点对点信道:一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 5.2 广播信道:①: 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。③: 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用CSMA/CD 协议。 六、数据链路层功能：①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输②: 组帧（Framing）③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端④: 流量控制（Flow control）:避免淹没接收端⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权 七、数据链路层任务: 八、MAC 地址:MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 九、以太网:9.1 以太网是一种星型拓扑结构局域网。早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 9.2 特点:采用的协议: CSMA/CD采用无连接,半双工通信对数据帧不进行编号尽最大努力交付(不可靠)不要求对方确认发送的数据都以曼彻斯特编码收到错帧就丢弃 9.3 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 十、局域网:局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 十一、10BASE-T:10 代表 10Mbit/sBASE : 连接线上的信号为基带信号T: 双绞线 十二、数据链路层功能:将网络层接收到的数据分割成特定的可被物理层传输的帧]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown用法]]></title>
    <url>%2FMarkdown%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、常用操作:1.1 代码块:①: 添加代码块 :一行代码时: (也称行内代码) 使用一对单引号(ESC键下面的单引号键),代码放在这对单引号之间 效果图: 多行代码: 连按三个单引号(ESC键下面的单引号键) ,然后回车. 效果图: ②: 代码快速排版: 先把光标定位到代码块中，此时右下角会让你输入代码格式（如Java，C，C#等）,比选择Java， 然后Ctrl+ A选中所有代码, 最后 Shift + tab 拍版前: 排版后: 1.2 插入图片插入互联网上图片: ![这里写图片描述](这里写地址) ![这里写图片描述](http://img3.douban.com/mpic/s1108264.jpg) 1.3 超链接链接文字都是用 [方括号] 来标记,在方块括号后面紧接着圆括号并插入网址链接即可 [This link](http://example.net/) 1.4 分割线：在一行中输入三个连续的减号: 效果图: 1.5 换行方法1: 连续两个以上空格, 然后 回车 方法2：使用html语言换行标签：&lt;br&gt; 1.6 首行缩进：首行缩进两个字符：(每个表示一个空格，连续使用两个即可） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 1.7 字体,字体颜色,字体大小使用内嵌HTML的方法 123456&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;我是浅蓝色,黑体,7号字&lt;/font&gt;&lt;font color=red size=72&gt;我是红色&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 1.8 背景色Markdown本身不支持背景色设置，需要采用内置html的方式实现 借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下： 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=green&gt;背景色是：green&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果图: 背景色是：green 1.9 Markdown页内跳转实现方法markdown的语法本身支持URL链接跳转，但是如何实现页内跳转呢？在写比较长的文章是这还是一个不错的快速定位方法。 目前来看主要有两种方案：生成目录、使用html的锚点 方法一: HTML锚点跳转 实际语法比较简单，在需要跳转的位置添加锚点，语法如下：&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt; 在需要点击跳转的位置，使用上面的id，格式类似超链接的形式：[点击跳转](#jump) 这样就实现了上述功能。 方法二: 生成目录 方式一: 点击鼠标右键——&gt;选择插入—-&gt;选择内容目录即可自动生成(这种方法生成的是整个文件的目录) 方式二: 写代码 12345678910111213&lt;h2 id="1"&gt;1. 生成目录&lt;/h2&gt;这是一个自动生成目录的语法。下面是下一级目录：&lt;h3 id="1.1"&gt;1.1 第二级说明1&lt;/h3&gt;这是二级目录的一个测试文本。&lt;h3 id="1.2"&gt;1.2 第二级说明2&lt;/h3&gt;这是二级目录的第二个测试文本。&lt;h2 id="2"&gt;2. 结语&lt;/h2&gt;最终生成个目录：* [1. 生成目录](#1) * [1.1 第二级1](#1.1) * [1.2 第二级2](#1.2)* [2.结语](#2)]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown用法指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Android]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Android.html</url>
    <content type="text"><![CDATA[一、Android系统四大组件:1.1 活动（Activity）:凡是在应用中你看得到的东西，都是放在活动中的。 1.2 服务（Service）:你无法看到它，但它会一直在后台默默地运行 1.3 广播接收器（Broadcast Receiver）:接收来自各处的广播消息，比如电话、短信等 1.4 内容提供器（ContentProvider）:为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现 二、创建并运行HelloWorld程序:2.1 创建程序 Application Name 代表应用名称，此应用安装到手机之后会在手机上显示该名称:Project Name 代表项目名称，在项目创建完成后该名称会显示在 Eclipse 中Minimum Required SDK 是指程序最低兼容的版本Target SDK 是指你在该目标版本上已经做过了充分的测试，系统不会再帮你在这个版本上做向前兼容的操作了Compile With是指程序将使用哪个版本的 SDK 进行编译最后一个 Theme是指程序 UI 所使用的主题，我个人比较喜欢选择 None 2.1.1 创建活动:选择一个你想创建的活动类型，这里我们就选择 Blank Activity 了 2.2 启动模拟器:点击 Eclipse 导航栏中的 Window→Open Perspective→DDMS如果你的 Devices 窗口中有一个设备显示是 Online 的，那就说明目前一切正常，你的模拟器是在线的 2.3 执行程序代码:右击 HelloWorld 项目→Run As→Android Application 三、程序的目录结构:3.1 gen自动生成的，主要有一个 R.java 文件,你在项目中添加的任何资源都会在其中生成一个相应的资源 id,永远不要手动去修改它。 3.2 bin存放编译时自动产生的文件, 目录下有HelloWorld.apk，把这个文件拷到手机上就可以直接安装了 3.3 libs存放第三方 Jar包, 会被自动添加到构建路径里去 3.4 assets存放一些随程序打包的文件,所有网页相关的文件也都存放在这个目录下 3.5 res: (resources即资源目录)图片、布局、字符串等资源都要存放在这个目录下图片放在 drawable 目录下布局放在 layout 目录下字符串放在 values 目录下 3.6 AndroidManifest.xml整个 Android 项目的配置文件，四大组件都需要在这个文件里注册,还可以添加权限声明,版本兼容修改 3.7 project.properties指定编译程序时所使用的 SDK 版本 四、程序的运行流程分析:4.1 AndroidManifest.xml 文件:1234567891011//对 HelloWorldActivity 这个活动进行注册,没有在 AndroidManifest.xml 里面注册的活动是不能使用的。&lt;activity android:name="com.test.helloworld.HelloWorldActivity" android:label="@string/app_name" &gt; //主活动，在手机上点击应用图标，首先启动的就是这个活动。 &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 4.2 再来看src/HelloWorldActivity.java文件1234567public class HelloWorldActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 调用了setContentView()方法，给当前的活动引入了一个 hello_world_layout 布局 setContentView(R.layout.hello_world_layout); &#125; Activity 是 Android 系统提供的一个活动基类，项目中所有的活动都必须要继承它才能拥有活动的特性 onCreate()方法是一个活动被创建时必定要执行的方法 Android程序的设计讲究逻辑和视图分离,在布局文件中编写界面，然后在活动中引入进来。 4.3 看 res/layout/hello_world_layout.xml 布局文件:12345678&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"....... &lt;TextView android:layout_width="wrap_content" ...... android:text="@string/hello_world" /&gt;&lt;/RelativeLayout&gt; TextView，这是 Android 系统提供的一个控件，用于在布局中显示文字的hello_world_layout.xml布局文件中就是通过引用了 hello_world这个键，才找到了相应的值 4.4 查看res/values/strings.xml 文件:12345&lt;resources&gt; &lt;string name="app_name"&gt;Hello World&lt;/string&gt; .... &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;&lt;/resources&gt; 一 般 是 把 字 符 串 定 义 在res/values/strings.xml 里，然后可以在布局文件或代码中引用Hello world!字符串就是定义在这个文件里的可以在这里通过修改 app_name 对应的值，来改变此应用程序的名称,在哪儿引用了app_name 这个键呢？在AndroidManifest.xml查找. 五、关于资源目录res:drawable开头的文件夹都是用来放图片的values开头的文件夹都是用来放字符串layout 文件夹是用来放布局文件menu 文件夹是用来放菜单文件 之所以有这么多 drawable开头的文件夹，是为了让程序能够兼容更多的设备, 最好能够给同一张图片提供几个不同分辨率的副本只有一份图片时,所有图片都放在 drawable-hdpi下即可 六、如何引用资源? strings.xml 中的 Hello world!字符串，有两种方式引用它： ①: 代码中通过 R.string.hello_world 可以获得该字符串的引用；②: 在 XML 中通过@string/hello_world可以获得该字符串的引用。 string 部分是可以替换的,如果是引用的图片资源就可以替换成 drawable,如果是引用的布局文件就可以替换成 layout,以此类推 七、日志:7.1 打印日志:打开 HelloWorldActivity，在 onCreate()方法中添加一行打印日志的语句， 1234protected void onCreate(Bundle savedInstanceState) &#123; .... Log.d("HelloWorldActivity", "onCreate execute");&#125; Log.d 第一个参数是 tag，一般传入当前的类名，主要用于对打印信息进行过滤。第二个参数是 msg，即想要打印的具体的内容。 7.2 日志过滤器: 给过滤器起名叫 data，并且让它对名为 data 的 Tag进行过滤 在 onCreate()方法中把打印日志的语句改成 Log.d(“data”,”onCreate execute”)，然后再次运行程序，你就会在 data 过滤器下看到这行日志了。 7.3 日志级别:选中debug级别，这时只有使用 debug 及以上级别方法打印的日志才会显示出来如果你把LogCat 中的级别选中为 info、warn 或者 error 时，我们在 onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是 Log.d()方法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>初识Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PV操作]]></title>
    <url>%2FPV%E6%93%8D%E4%BD%9C%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[一、什么是PV操作?PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：P（S）：①将信号量S的值减1，即S=S-1；②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 V（S）：①将信号量S的值加1，即S=S+1； 二、PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。 三、什么是信号量？信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关: ①: 当信号量的值大于0时，表示当前可用资源的数量②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数注意，信号量的值仅能由PV操作来改变。 四、使用PV操作注意事项：①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。③: 互斥信号量的初值一般为1。 五、PV操作实例:5.1 例题1: 吃苹果问题: 解题过程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344 semaphore empty=2； //定义empty对应盘子的剩余放水果的位置个数初值为2( 空缓冲区个数 ) semaphore apple=0； //定义信号量apple对应盘子里的苹果数量初值为0 semaphore orange=0； //定义信号量orange对于盘子里的橘子数量初值为0 semaphore mutex=1： //定义信号量mutex来保护盘子被互斥地访问 father()&#123; //爸爸进程 while(1)&#123; P(empty)； //盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放苹果 P(mutex)； 在盘子里放一个苹果 V(mutex)； V(apple)；//盘中苹果数加一 &#125;&#125;mother()&#123; //妈妈进程 while(1) &#123; P(empty)； //盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放橘子 P(mutex)； //互斥变量减一，如果&lt;0，则说明有进程在临界区。则当前进程必须等待。 在盘子里放一个橘子 V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。 V(orange)； //盘中橘子数加一 &#125; &#125; son()&#123; //用这段程序产生两个儿子进程 while(1) &#123; P(orange)； //盘中橘子个数减一，如果结果&gt;=0时,说明盘中有橘子，可以取 P(mutex)； 从盘子里拿一个橘子 V(mutex)； V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一 &#125;&#125;daughter()&#123; //用这段程序产生两个女儿进程 while(1 ) &#123; P(apple)； //盘中苹果个数减一，如果结果&gt;=0时,说明盘中有苹果，可以取 P(mutex)； 从盘子里拿出一个苹果 V(mutex)； V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一 &#125; &#125; 5.2 : 和尚打水: 分析: 解题过程: 12345678910111213141516171819202122232425262728293031323334353637Semaphore mutexA = 1; //保护井被互斥地访问 Semaphore mutexB = 1; //保护缸被互斥地访问 Semaphore Count = 3； //桶总数为3Semaphore full = 0; //控制出水，刚开始，缸是空的，能取出0桶水Semaphore empty = 10 ; //控制入水，刚开始，缸是空的，能倒入10桶水//小和尚打水：Progress（小和尚）&#123; while（1）&#123; P（empty） //判断缸是否满了（结果如果&gt;=0,未满），决定是否需要打水 P（count） //拿桶（判断是否有空闲的桶，结果如果&gt;=0,有桶） P（mutexA）&#123; //对井互斥访问 从井中打水； V（mutexA） //互斥 &#125; P（mutexB）&#123; //对缸互斥访问 向缸中倒水； V（mutexB） //互斥 &#125; V（count）//还桶，空闲桶的数量加一 V（full） //缸中水的数量加一，（通知老和尚取水） &#125;&#125;//老和尚取水：progress（老和尚）&#123; while（1）&#123; P（full） //判断缸中是否有水，（结果如果&gt;=0,说明缸中有水，可取水） P（count）//拿桶 P（mutexB) //互斥 从缸中取水； V（mutexB）//互斥 V(count) //还桶 V（empty）//缸中还能容纳的水数量加一，（通知小和尚打水） &#125;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>PV操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F%E6%AD%BB%E9%94%81.html</url>
    <content type="text"><![CDATA[一、什么是死锁:是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去. 二、产生死锁的原因: ①: 因为系统资源不足②: 进程运行推进顺序不合适③: 资源分配不当等 三、产生死锁的必要条件:①: 互斥：一个资源每次只能被一个进程使用②: 占有和等待(请求与保持)：一个进程因请求资源而阻塞时，对已获得的资源保持不放。③: 不剥夺: 进程已获得的资源，在使用完之前，不能强行被抢占,它只能被占有它的进程显式地释放。④: 环路等待: 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 注: 只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 四、处理死锁的方法:主要有以下四种方法： 4.1 鸵鸟策略4.1.1 原理: 把头埋在沙子里，假装根本没发生问题, 也就是忽略死锁4.1.2 什么时候用?当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 4.2 死锁检测与死锁恢复4.2.1 原理: 不试图阻止死锁，而是当检测到死锁发生时，再采取措施进行恢复。4.2.2 死锁检测:4.2.2.1 每种类型一个资源的死锁检测:通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 4.2.2.2 每种类型多个资源的死锁检测:每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。①: 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。②: 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。③: 如果没有这样一个进程，算法终止。 4.2.3 死锁恢复:①: 利用抢占恢复②: 利用回滚恢复③: 通过杀死进程恢复 4.3 死锁预防4.3.1 原理:在程序运行之前预防发生死锁 4.3.2 采取方法:破坏死锁的四个必要条件①: 破坏互斥：②: 破坏占有和等待(请求与保持):一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 ③: 破坏不剥夺:④: 破坏环路等待:给资源统一编号，进程只能按编号顺序来请求资源。 4.4 死锁避免在程序运行时避免发生死锁 五、银行家算法:例题:]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之活动]]></title>
    <url>%2FAndroid%E4%B9%8B%E6%B4%BB%E5%8A%A8.html</url>
    <content type="text"><![CDATA[一、活动的基本用法:项目名可以叫做 ActivityTest ,为了手动创建活动 不再勾选 Create Activity 1.1 手动创建活动:src 目录下先添加一个包,使用的默认包名com.example.activitytest新建FirstActivity 类继承自 Activity任何活动都应该重写 Activity 的 onCreate()方法 1.2 创建布局每一个活动对应一个布局，布局就是用来显示界面内容在res/layout 目录下新建 名为first_layout.xml的文件(菜单中点击Android XMLFile),根元素就默认选择为 LinearLayout 添加一个按钮: 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"&gt;... &lt;Button android:id="@+id/button_1" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; XML 中引用一个 id，就使用@id/id_name 这种语法XML 中定义一个 id，则要使用@+id/id_name 这种语法android:layout_width 指定了当前元素的宽度，match_parent表示让当前元素和父元素一样宽。android:layout_height 指定了高度， wrap_content，表示当前元素的高度只要能刚好包含里面的内容就行。android:text 指定了元素中显示的文字内容 1.3 在活动中加载这个布局:FirstActivity类的 onCreate()方法中加入如下代码： 1234567public class FirstActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... setContentView(R.layout.first_layout); &#125;&#125; 项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id，因此我们刚才创建的 first_layout.xml 布局的 id 现在应该是已经添加到 R 文件中了。在代码中引用布局文件: R.layout.first_layout 注意: 这里我们使用的 R，是com.example.activitytest 包下的 R 文件Android SDK 还会自动提供一个 android 包下的 R 文件，千万别使用错了。 1.4 在 AndroidManifest 文件中注册:所有的活动都要在 AndroidManifest.xml 中进行注册才能生效 在AndroidManifest.xml 来给 FirstActivity 注册: 12345678910111213141516171819202122232425262728&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.activitytest" &gt; .... &lt;/application&gt; .... &lt;activity /*.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity 的 缩写由于最外层的&lt;manifest&gt;标签中已经通过 package 属性指定了程序的包名是 com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity */ android:name=".FirstActivity" android:label="This is FirstActivity" &gt; /* 如果你想让 FirstActivity 作为我们这个程序的主活动，即点击桌面应用程序图标时首先打开的就是这 个活动，那就一定要加入下面这两句声明。 */ &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;/*如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他的应用在内部进行调用的，如支付宝快捷支付服务。*/ 活动的注册声明要放在&lt;application&gt;标签内, 通过&lt;activity&gt;标签来对活动进行注册的android:name 来指定具体注册哪一个活动android:label指定活动中标题栏的内容 1.5 隐藏标题栏FirstActivity类的 onCreate()方法中加入如下代码： 123456protected void onCreate(Bundle savedInstanceState) &#123; ... //注意这句代码一定要在 setContentView()之前执行，不然会报错 requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.first_layout);&#125; 1.6 在活动中使用 Toast:toast是什么?界面弹出短小的信息通知给用户，这些信息会在一段时间后自动消失 首先需要定义一个弹出 Toast 的触发点, 如点击按钮的时候弹出一个 Toast FirstActivity类的 onCreate()方法中加入如下代码： 123456789101112131415161718protected void onCreate(Bundle savedInstanceState) &#123; .... // findViewById()方法获取在布局文件中定义的元素，传入 R.id.button_1，来得到按钮的实例 Button button1 = (Button) findViewById(R.id.button_1);//findViewById返回的是一个 View 对象 //注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法 button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; /* makeText()创建出一个 Toast对象, show()是将 Toast 显示出来 第一个参数是 Context，也就是 Toast 要求的上下文，活动本身就是一个 Context 对象 第二个参数是Toast显示的文本内容 第三个参数是Toast显示的时长 */ Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 1.7 在活动中使用 Menu在 res 目录下新建一个 menu 文件夹新建一个 main.xml 文件(点击Android XML File) 12345678&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt; //&lt;item&gt;标签就是用来创建具体的某一个菜单项 &lt;item //给这个菜单项指定一个唯一标识符， android:id="@+id/add_item" //给这个菜单项指定一个名称 android:title="Add"/&gt;&lt;/menu&gt; 然后打开 FirstActivity类，重写 onCreateOptionsMenu()方法 12345678910public boolean onCreateOptionsMenu(Menu menu) &#123; /* inflate()方法就可以给当前活动创建菜单 第一个参数:通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main 第二个参数:用于指定我们的菜单项将添加到哪一个 Menu对象当中，这里直接使用 onCreateOptionsMenu()方法中传 入的 menu参数 */ getMenuInflater().inflate(R.menu.main, menu); //返回 true，表示允许创建的菜单显示出来 return true;&#125; 定义菜单响应事件: FirstActivity 中重写 onOptionsItemSelected() 12345678910111213public boolean onOptionsItemSelected(MenuItem item) &#123; // item.getItemId()来判断我们点击的是哪一个菜单项 switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125; 1.8 销毁一个活动:Activity 类提供了一个 finish()方法: 打开 FirstActivity类,onCreate方法中, 修改按钮监听器中的代码: 1234567button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125;&#125;);//重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一样的。 二、使用 Intent 在活动之间穿梭:2.1 使用显式 Intent:Intent的“意图”非常明显，因此我们称之为显式 Intent 在 ActivityTest 项目中再创建一个活动。新建一个 second_layout.xml 布局文件 12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" &gt; ... //定义了一个按钮，按钮上显示 Button 2 &lt;Button android:id="@+id/button_2" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 2" /&gt;&lt;/LinearLayout&gt; 新建活动 SecondActivity 继承自Activity 12345678public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); &#125;&#125; 最后在 AndroidManifest.xml 中为 SecondActivity 进行注册。 1234567891011121314&lt;application ...&gt; &lt;activity android:name=".FirstActivity" android:label="This is FirstActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; // SecondActivity 不是主活动，因此不需要配置&lt;intent-filter&gt;标签里的内容 &lt;activity android:name=".SecondActivity" &gt; &lt;/activity&gt;&lt;/application&gt; Intent 一般可被用于启动活动、启动服务、以及发送广播等场景Intent 是 各组件之间进行交互的一种重要方式，它可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据 Intent(Context packageContext, Class&lt;?&gt; cls):这个构造函数接收两个参数，第一个参数: 启动活动的上下文，第二个参数 指定想要启动的目标活动 Activity 类中 startActivity()方法，用于启动活动的，它接收一个Intent参数 修改 FirstActivity 中按钮的点击事件: 12345678button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //在FirstActivity活动的基础上打开 SecondActivity活动,startActivity()方法来执行这个Intent Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125;&#125;); 2.2 使用隐式 Intent:不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 action和 category等信息,由系统去分析Intent，并找出合适的活动(响应隐式 Intent的活动)去启动 AndroidManifest.xml添加如下代码: 123456789&lt;activity android:name=".SecondActivity" &gt; &lt;intent-filter&gt; //指明当前活动可以响应 ACTION_START这个 action &lt;action android:name="com.example.activitytest.ACTION_START" /&gt; // 精确地指明当前的活动能够响应的 Intent 中还可能带有的 category &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;//只有&lt;action&gt;和&lt;category&gt;中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。 修改 FirstActivity 中按钮的点击事件，代码如下所示： 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //使用了Intent 的另一个构造函数,传入action的字符串,表明要启动能够响应ACTION_START这个action的活动 Intent intent = new Intent("com.example.activitytest.ACTION_START"); startActivity(intent); &#125;&#125;);//注: &lt;action&gt;和&lt;category&gt;同时匹配上才能响应,而这里没有指定category,这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中 每个 Intent 中只能指定一个 action，但却能指定多个 category 修改 FirstActivity 中按钮的点击事件,增加一个category 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.activitytest.ACTION_START"); // addCategory()方法来添加一个 category intent.addCategory("com.example.activitytest.MY_CATEGORY"); startActivity(intent); &#125;&#125;); 在AndroidManifest.xml中 SecondActivity的&lt;intent-filter&gt;中再添加一个 category 的声明: 123456&lt;activity android:name=".SecondActivity" &gt; &lt;intent-filter&gt; .... &lt;category android:name="com.example.activitytest.MY_CATEGORY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.3 更多隐式 Intent 的用法修改 FirstActivity 中按钮点击事件的代码，如下所示： 1234567891011//应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器来打开这个网页就行了button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // Intent.ACTION_VIEW，这是一个 Android 系统内置的动作 Intent intent = new Intent(Intent.ACTION_VIEW); // Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象 intent.setData(Uri.parse("http://www.baidu.com")); startActivity(intent); &#125;&#125;); 还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地指定当前活动能够响应什么类型的数据。&lt;data&gt;标签中主要可以配置以下内容: android:scheme用于指定数据的协议部分，如上例中的 http 部分 只有&lt;data&gt;标签中指定的内容和 Intent 中携带的 Data完全一致时，当前活动才能够响应该 Intent。如上面浏览器示例中，其实只需要指定 android:scheme 为 http，就可以响应所有的 http 协议的 Intent 了。 2.4 自己建立一个活动，让它也能响应打开网页的Intent新建 third_layout.xml 布局文件: 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;Button android:id="@+id/button_3" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 3" /&gt;&lt;/LinearLayout&gt; 新建活动 ThirdActivity 类继承自 Activity将布局添加到活动中 12345678public class ThirdActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.third_layout); &#125;&#125; 最后在 AndroidManifest.xml 中为 ThirdActivity 进行注册 12345678&lt;activity android:name=".ThirdActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; //数据的协议必须是 http协议 &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 调用系统拨号界面 除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示拨打电话 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_DIAL); // data部分指定了协议是 tel，号码是 10086 intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;&#125;); 2.5 向下一个活动传递数据: Intent 还可以在启动活动的时候传递数据, putExtra()的重载，可把想要传递的数据暂存在 Intent 中，启动另一个活动后，只需把这些数据从Intent 中取出就可 SecondActivity 类中,修改代码: 1234567891011// FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity中button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String data = "Hello SecondActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //第一个参数是键,用于后面从 Intent中取值，第二个参数才是真正要传递的数据。 intent.putExtra("extra_data", data); startActivity(intent); &#125;&#125;); 123456789101112public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... // getIntent()方法获取到用于启动 SecondActivity 的 Intent Intent intent = getIntent(); //如果传递的是布尔型数据，则使用 getBooleanExtra()方法 //getStringExtra()方法，传入相应的键值，就可以得到传递的数据了 String data = intent.getStringExtra("extra_data"); Log.d("SecondActivity", data); &#125;&#125; 2.6 返回数据给上一个活动:Activity 中 startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 修改 FirstActivity 中按钮的点击事件 12345678button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //第一个参数还是 Intent,第二个参数是请求码，用于在之后的回调中判断数据的来源,请求码只要是一个唯一值就可以了 startActivityForResult(intent, 1); &#125;&#125;); SecondActivity 中给按钮注册点击事件并在点击事件中添加返回数据的逻辑: 123456789101112131415161718192021public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); Button button2 = (Button) findViewById(R.id.button_2); button2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); //setResult()专门用于向上一个活动返回数据的 //第一个参数用于向上一个活动返回处理结果,第二个参数则是把带有数据的 Intent 传递回去 setResult(RESULT_OK, intent); //销毁当前活动 finish(); &#125; &#125;); &#125;&#125; 由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据， 123456789101112131415//第一个参数 requestCode，启动活动时传入的请求码,//第二个参数 resultCode，返回数据时传入的处理结果//第三个参数 data，即携带着返回数据的 Intent@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode == RESULT_OK) &#123; String returnedData = data.getStringExtra("data_return"); Log.d("FirstActivity", returnedData); &#125; break; default: &#125;&#125; 由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到 onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作 如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下Back 键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通过重写 onBackPressed()方法来解决这个问题，代码如下所示： SecondActivity 类中修改代码: 12345678//这样的话，当用户按下 Back 键，就会去执行 onBackPressed()方法中的代码，我们在这里添加返回数据的逻辑就行了@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); setResult(RESULT_OK, intent); finish();&#125; 2.7 活动的生命周期:返回栈Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack） 活动状态每个活动在其生命周期中最多可能会有四种状态。运行状态:位于返回栈的栈顶时暂停状态:不再处于栈顶位置，但仍然可见停止状态:不再处于栈顶位置，并且完全不可见销毁状态:从返回栈中移除后就变成了销毁状态 活动的生存期Activity 类中定义了七个回调方法: onCreate():每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。 onStart():在活动由不可见变为可见的时候调用 onResume():在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。 onPause():准备去启动或者恢复另一个活动的时候调用 onStop():在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。 onDestroy():活动被销毁之前调用 onRestart():活动由停止状态变为运行状态之前调用 2.6 活动被回收了怎么办Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。 onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，第二个参数是真正要保存的内容。在 MainActivity 中添加如下代码就可以将临时数据进行保存： 123456@Overrideprotected void onSaveInstanceState(Bundle outState) &#123;super.onSaveInstanceState(outState);String tempData = "Something you just typed";outState.putString("data_key", tempData);&#125; 数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一直使用的 onCreate()方法其实也有一个 Bundle类型的参数。这个参数在一般情况下都是null，但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。修改 MainActivity 的 onCreate()方法，如下所示： 123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... if (savedInstanceState != null) &#123; String tempData = savedInstanceState.getString("data_key"); Log.d(TAG, tempData); &#125; ……&#125; 2.7 活动的启动模式启动模式一共有四种，分别是 standard、singleTop、singleTask 和 singleInstance​ AndroidManifest.xml 中通 过给&lt;activity&gt; 标签 指定android:launchMode属性来选择启动模式 standard 活动默认的启动模式,系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。 singleTop 在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。 修改 AndroidManifest.xml 中 FirstActivity 的启动模式，如下所示： 123456&lt;activity android:name=".FirstActivity" android:launchMode="singleTop" ... ...&lt;/activity&gt; singleTask 很好地解决重复创建栈顶活动的问题 singleInstance 在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android之活动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是适配器模式?适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 二、 分类:2.1 类的适配器模式:使用步骤:步骤1： 创建Target接口步骤2： 创建源类（Adaptee）步骤3： 创建适配器类Adapter (适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。)步骤4： 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 2.2 对象的适配器模式:原理:与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。步骤:①: 创建Target接口②: 创建源类（Adaptee）③: 创建适配器类（Adapter）（不适用继承而是委派）④: 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 2.3 对象的适配器模式与类的适配器模式比较:与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 2.4 什么时候用类的适配器模式? ①: 仅仅希望使用方便时对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。对于对象适配器，需要额外的引用来间接得到Adaptee。②: 需要重新定义Adaptee的部分行为对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 2.5 什么时候用对象的适配器模式?①: 灵活使用时类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。②: 需要同时配源类和其子类对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了； 2.6 总结:建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。 三、主要作用:把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。 三、优点:①: 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。②: 解耦性: 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码③: 符合开放-关闭原则: 同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类④: 更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。⑤: 透明、简单: 客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接, 过多的使用适配器，会让系统非常零乱，不易整体进行把握 四、应用场景:系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 五、实例:背景：小成买了一个进口的电视机冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容解决方案：设置一个适配器将插头输出的220V转变成110V 使用类的适配器模式解题: 12345//步骤1： 创建Target接口；public interface Target &#123; //将220V转换输出110V（原有插头（Adaptee）没有的） void Convert_110V();&#125; 123456//步骤2： 创建源类（Adaptee）public class PowerPort220V &#123; //原有的插口只能输出220V void OutPut_220V()&#123; &#125;&#125; 12345678910111213//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter220V extends PowerPort220V implements Target &#123; //期待的插头要求调用Convert_110v()，但原有插头没有 //因此适配器补充上这个方法名 //但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容 //所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已 @Override public void Convert_110V() &#123; this.OutPut_220V(); &#125;&#125; 1234567891011121314151617181920//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标//通过Adapter类从而调用所需要的方法public class AdapterPattern &#123; public static void main(String[] args) &#123; //用户拿着进口机器插上适配器（调用Convert_110v()方法） //再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V） //适配器只是个外壳，对外提供110V，但本质还是220V进行供电 Target target = new Adapter220V(); target.Convert_110V(); ImportMachine importMachine = new ImportMachine(); importMachine.work(); &#125;&#125;//进口机器类class ImportMachine &#123; void work()&#123; System.out.println("进口机器正常工作!"); &#125;&#125; 类的适配器模式: 12345//步骤1： 创建Target接口；public interface Target &#123; //源类Adapteree没有的方法 void Request();&#125; 12345//步骤2： 创建源类（Adaptee） ；public class Adapteree &#123; public void specificRequest() &#123; &#125;&#125; 12345678910111213//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）//适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。public class Adapter extends Adapteree implements Target &#123; //目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request() //因此适配器补充上这个方法名 //但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容 //所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已 @Override public void Request() &#123; this.specificRequest(); &#125;&#125; 12345678//Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标public class AdapterPattern &#123; public static void main(String[] args) &#123; Target adapter = new Adapter(); adapter.Request(); &#125;&#125; 对象的适配器模式: 1234public interface Target &#123; //这是源类Adapteee没有的方法 void request();&#125; 1234public class Adapteree &#123; void specificRequest()&#123; &#125;&#125; 123456789101112131415public class Adapter implements Target&#123; private Adapteree adapteree; //直接关联被适配类Adapteree // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter(Adapteree adapteree)&#123; this.adapteree = adapteree; &#125; @Override public void request() &#123; //这里是使用委托的方式完成特殊功能 this.adapteree.specificRequest(); &#125;&#125; 123456public class AdapterPattern &#123; public static void main(String[] args) &#123; Target target = new Adapter(new Adapteree()); target.request(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层]]></title>
    <url>%2F%E5%BA%94%E7%94%A8%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、应用层协议:应用层的许多协议是基于客户服务器方式的 1.1 DNS:1.1.1 是什么? DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 1.1.2 作用:用于域名解析服务,将域名(机器名) 转换为 IP地址1.1.3 原理: 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。1.1.4 特点:基于UDP服务，该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。端口号53DNS 可以使用 UDP 或者 TCP 进行传输，大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性1.1.5 在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 1.2 : HTTP:1.2.1 是什么? 这是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页1.2.2 特点: 本身是无连接，无状态的,使用TCP连接进行可靠的传送 1.3 : FTP:1.3.1 是什么? 文件传输协议1.3.2 特点: 提供交互式的访问 ,基于客户服务器模式，面向连接 ,使用TCP可靠的运输服务 ,使用21端口1.3.3 主要功能:减少/消除不同操作系统下文件的不兼容性 1.3.4 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。端口号20 1.3.5 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 1.4 : 简单文件传送协议TFTP:1.4.1 特点: 客户服务器模式 ,使用UDP数据报 ,只支持文件传输，不支持交互 ,TFTP代码占内存小 1.5 : TELNET:1.5.1 作用:用于远程登陆1.5.2 特点:客户服务器模式 使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务,TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 1.6 : 简单网络管理协议（SNMP）:1.6.1 SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议1.6.2 SNMP代理：运行SNMP管理进程的被管理结点对象：描述设备的变量管理信息库（MIB）：保存所有对象的数据结构 1.7 : DHCP:1.7.1 什么是DHCP? 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。1.7.2 DHCP 工作过程如下： ①: 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。②: DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。③: 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。④: DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 1.8 :电子邮件协议:一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1.8.1 : SMTP:1.8.1.1 是什么? 简单邮件传输协议1.8.1.2 作用: 用于发送邮件。1.8.1.3 特点: Client/Server模式，面向连接 ,服务器开放的是25号端口。SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。1.8.1.4 基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件 1.8.2 : POP3:1.8.2.1 是什么? 它是和SMTP对应1.8.2.2 作用: 用于接收邮件1.8.2.3 特点: ①: 只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。②：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”。POP3协议所用的是110端口。 1.8.3 : IMAP:1.8.3.1 作用: 读取邮件1.8.3.2 特点: IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信。 二、关于域名:2.1 域名规范:DNS规定:①: 域名中标号必须是英文或数字②: 不区分大小写③: 除连字符外不能用其他标点④: 级别最低的域名写在最左边⑤: 域名总长度不超过255个字符. 2.2 域名分类:顶级域名(TLD: TOP Level Domain):①: 国家顶级域名: cn代表中国 ,US代表美国②:通用顶级域名: com(公司,企业) net(网络服务机构) edu(教育机构) mail.cctv.com: 其中com为一级域名(即顶级域名), cctv是二级域名,mail是三级域名.域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 2.3 域名管理:①: 在国家顶级域名下注册的二级域名均由该国家自由确定.②: 各级域名由其上一级域名管理机构管理③: 最高的顶级域名由ICANN管理注: 域名中的点与点分十进制IP地址中的点无一一对应的关系 2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?原因: IP地址长度固定(32位)而域名长度不固定,机器处理起来困难. 三、关于域名服务器:一个域名服务器所负责管理的范围叫做区,每个区 设置相应的权限域名服务器为了减轻根域名服务器的压力,域名服务器中广泛使用高速缓存. 3.1 域名服务器分类:①: 根域名服务器: 所有根域名服务器都知道所有顶级域名服务器的域名和IP地址②: 顶级域名服务器: 管理在该顶级域名服务器下注册的所有二级域名,当收到查询请求,就给出查询结果,或者下一步应当找的域名服务器地址③: 权限域名服务器: 负责一个区的域名服务器,当它不能给出最后的查询结果时,就告诉客户下一步应当查找哪个权限域名服务器④: 本地域名服务器: 离用户较近,一般不超过几个路由器的距离 迭代查询: 递归查询: 四、常用端口: 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP HTTPS 443 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP 五、Web 页面请求过程:5.1 DHCP 配置主机信息:假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。①: 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。②: 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。③: 该数据报则被放置在MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。④: 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。⑤: 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。⑥: 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 5.2 ARP 解析 MAC 地址①: 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。②: 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。③: 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中④: 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。⑤: DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。⑥: 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。⑦: 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 5.3 DNS 解析域名:①: 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。②: 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。③: 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。④: 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。⑤: 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 5.4 HTTP 请求页面:①: 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。②: 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。③: HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。④: 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。⑤: HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。⑥: 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 六、应用层功能:负责对软件提供接口以使程序能使用网络服务]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层]]></title>
    <url>%2F%E4%BC%A0%E8%BE%93%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、传输层协议:TCP协议,UDP协议,SPX协议 10.1 关于TCP协议:特点:①: 面向连接②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点 使用场合: 一般用于传输数据量少,且对可靠性要求高的场合. 注: 这2个端点并不是主机,也不是主机的IP地址,不是应用进程,也不是运输层协议端口, 而是指 套接字 ③: 提供可靠交付服务: 无差错 , 不丢失 , 不重复 , 按序到达④: 全双工⑤: 拥塞控制,流量控制⑥: 检错, 分用复用⑦: 面向字节流: (把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)套接字socket = IP地址 ：端口号 10.2 使用TCP协议的各种应用层协议：SMTP: 简单邮件传送协议TELNET: 远程终端协议HTTP: 超文本传输协议FTP: 文件传送协议 10.3 TCP首部格式: 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 10.4 关于UDP协议:特点: ①: 无连接: 发数据前不需要建立连接(即不需要使用套接字(即 IP: 端口号)来建立连接)②: 交互通信: 一对多,一对一,多对一,多对多等③: 尽最大努力交付(不可靠)④: 首部开销小,8字节 而TCP是20字节⑤: 无拥塞控制⑥: 检错, 分用复用⑦: 面向报文: UDP一次交付一个完整报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部) 10.5 UDP首部格式: 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 使用场合: 一般用于传输数据量大,且对可靠性要求不是很高,但要求速度快的场合. 二、传输层数据单元:数据段 三、关于端口:运输层用16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口 四、传输层功能:①: 负责源-目的（端-端）（进程间）完整报文传输②: 分段与重组③: SAP寻址: 确保将完整报文提交给正确进程，如端口号④: 连接控制⑤: 流量控制⑥: 差错控制⑦: 确保数据可靠,顺序,无错地从A点传输到B点 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 五、TCP 可靠传输:TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。 六、TCP 滑动窗口:窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 七、TCP 流量控制:流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 八、TCP 拥塞控制:如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。拥塞窗口的大小取决于网络的拥塞程度判断网络拥塞的依据是出现了超时.发送方的发送窗口 = 拥塞窗口. TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 8.1 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 8.2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 拥塞控制的具体流程: ①: 初始拥塞窗口 cwnd = 1 ②: 发送方每收到一个确认就使cwnd = cwnd + 1;如果按照传输轮次考虑就是指数增长: 第一轮: cwnd = 1, 第二轮: cwnd = 2, 第三轮: cwnd = 4, …….第N轮: cwnd = 2^N cwnd &lt; ssthresh 时,使用慢开始 cwnd = ssthresh 时,既可以使用慢开始,也可以使用拥塞避免算法 cwnd &gt;= ssthresh 时,使用拥塞避免算法 ③: 网络超时时: 使ssthresh = cwnd / 2然后令 cwnd = 1 然后进入慢开始阶段,步骤同上④: 直到连续接收到三个重复确认,启动快重传(立即重传) ⑤: 启动快恢复算法 ssthresh = cwnd / 2 和cwnd=ssthresh 拥塞避免: 拥塞窗口控制为按照线性增长(每个传输轮次结束时,cwnd就增加1) 快重传优点: 可以使整个网络的吞吐量提高20%尽早让发送方知道发生了个别报文段的丢失 规定: 发送方只要一连收到3个重复确认,就知道接收方确实未收到某个报文,应当立即重传(即快重传),这样就不会出现超时,发送方也就不会误认为出现了网络拥塞. 快恢复: 调整ssthresh = cwnd / 2同时设置cwnd = ssthresh;然后执行拥塞避免.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换机的基本配置]]></title>
    <url>%2F%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[一、交换机的基本配置与管理：10.1 交换机的管理方式：基本分为两种: 带内管理和带外管理。带外管理: 通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置带内管理: 通过远程Telnet，拨号等方式属于带内管理 二、交换机的命令行操作模式分类：①: 用户模式: Switch&gt;②: 特权模式: Switch#③: 全局配置模式: Switch(config)#④: 端口模式: Switch(config-if)# 三、交换机命令行:进入特权模式: en命令自动补齐: Tab进入全局配置模式: configure terminal命令简写：conf t进入交换机端口视图模式: int f 0/1返回上一级操作模式: exit从全局以下级别直接返回到特权模式: end帮助信息: ？，co? ,copy ?修改交换机名称: hostname X配置交换机端口参数: speed，duplex查看交换机版本信息: show version查看当前生效的配置信息: show run 四、换机的Telnet远程登录配置: 新建packet tracer 拓扑图 配置交换机管理IP地址 switch&gt; enable 回车 switch#configuration terminal 回车 switch（config）#interface vlan 1 回车 默认情况下交换机所有端口都处于VLAN1中 switch(config-if) ip address xxxx.xxxx.xxxx.xxxx 回车 switch(config-if) no shutdown 回车 开启interface vlan 1的工作状态 switch(config-if)# exit 返回上一级 配置用户登录密码 Switch(config)# enable password xxxx 设置进入特权模式的密码 Switch(config)# line vty 0 4 Switch(config-line)# password xxxxxxx 设置远程登录密码 Switch(config-line)# end Switch# show run]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>交换机的配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、网络层协议:1.1 什么是协议（protocol）?通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”. 1.2 什么是实体（entity）?表示任何可发送或接收消息的硬件或软件进程 1.3 通信协议的三要素：语法,语义,时序语义 :语义是指对协议中各协议元素的含义的解释，例如：在HDLC协议中，标志Flag(7EH)表示报文的开始和结束；在BSC协议中，SOH(01H)表示报文的开始，STX(02H)表示报文正文的开始，ETX(03H)表示报文正文的结束。语法 :语法是指协议元素与数据的组合格式，也就是 报文格式，如下图所示：时序 :时序是指在通信过程中，通信双方操作的执行顺序与规则，如本节开头的图示。总的来说，语法是语义的载体，而时序又是对语义的有序组织。正是基于这种关系，计算机在通信时才得以保持高度默契。 1.4 通信模型: 我们在网络中的任何一个系统都是按照上图中的层次结构模型来组织的，该模型具有以下特点：①: 同一网络中，任意两个端系统必须具有相同的层次；②: 每层使用其下层提供的服务，并向其上层提供服务；③: 通信只在对等层间进行，当然这里所指的通信是间接的、逻辑的、虚拟的，非对等层之间不能互相“通信”；④: 实际的物理通信只在最底层完成；⑤: Pn代表第n层的协议，即第n层对等实体间通信时必须遵循的规则或约定。 1.5 网络层有哪些协议?①: IP协议: 这种不可靠的、无连接的传送机制称为Internet协议(网际协议)与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protcol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP协议三个定义： IP定义了在TCP/IP互联网上数据传送的基本单元和数据格式。IP软件完成路由选择功能，选择数据传送的路径。IP包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。 ②: ICMP协议: 网际控制报文协议作用：用于在IP主机、路由器之间传递控制消息,更有效的转发IP数据报和提高交付成功的机会,应用: ICMP的一个重要应用就是分组网间探测PING（Package Internet Grouper）用来测试两台主机的连通性,,Ping是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP详解见下文 ③: IGMP:网际组管理协议 ④: ARP协议:地址解析协议自动把IP地址解析为数据链路层所需要的硬件地址(MAC地址)IP —–&gt;MAC 地址工作原理: 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据,如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 ⑤: RARP协议:逆地址解析协议, 与ARP相反:MAC地址——&gt;IP地址作用: 是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP 地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 ⑥: RIP协议:内部网关协议基于距离向量的路由选择协议, 距离是指跳数，直接相连的路由器跳数为 1,跳数最多为 15(即允许一条路径最多包含15个路由器)，超过 15 表示不可达。可见RIP只适用于小型互联网 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 优点:实现简单，开销小。缺点:①: RIP 能使用的最大距离为 15，限制了网络的规模。②: 并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。③: 路由器间交换的信息是完整的路由表,随着网络规模的增大,开销也增大. ⑦: OSPF协议: 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示, 而RIP只包含距离,和下一跳路由器地址. 只有当链路状态发生变化时，路由器才会发送信息, 而 RIP不管有无变化,总是定期更新. 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 ⑧: BGP：外部网关协议: BGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息 1.6 网络层特点:向上只提供 :①: 无连接的②: 尽最大努力交付③: 不提供服务质量的保证(不保证分组交付的时限,所传送的分组有可能出错丢失,重复失序)⑤: 进程间通信可靠性由传输层负责 二、网络层设备:①: 路由器 三、网络层基本单元:3.1 什么是协议数据单元?协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。 3.2 每一层协议数据单元分别是什么?从下层到上层:物理层的 PDU是数据位,又称比特（bit），数据链路层的 PDU是数据帧,又称帧（frame），网络层的PDU是数据包又称IP数据报（packet/datagram），传输层的 PDU是数据段（segment），在报文中加一个运输层的头其他更高层次(即会话层,表现层,应用层)的PDU是报文（message）。 从下层往上层是拆封. 四、网络层功能:①: 负责源主机到目的主机数据分组（Packet）交付(可能穿越多个网络)逻辑寻址（Logical addressing ）②: 全局唯一的逻辑地址，确保数据分组被送到目的主机，如IP地址③: 路由（Routing）:路由器（或网关）互连网络，并路由分组至最终目的主机路径选择④: 分组转发⑤: 网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 ⑥: 将网络地址(例如IP地址)翻译为对应的物理地址(例如,网卡地址),并决定如何将数据从发送方路由到接收方 4.1 核心功能:分组转发 与 路由选择（forwarding) 4.1 什么是转发?将分组从路由器的输入端口转移到合适的输出端口转发表确定在本路由器如何转发分组 4.2 转发表是怎么得到的呢？路由算法（协议）确定通过网络的端到端路径 4.3 什么叫路由呢？路由（routing）：确定分组从源到目的经过的路径 五、网络层任务: 六、为什么需要数据封装?增加控制信息—构造协议数据单元（PDU—protocol Data Unit）控制信息主要包括：地址：标志发送端/接收端差错检测编码（error-detecting code）：用于差错检测或纠正协议控制（Protocol control）：实现协议功能的附加信息，如优先级（priority），服务质量（QoS）和安全控制等 七、IP 数据报格式: 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 八、地址解析协议 ARP:ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 九、网际控制报文协议 ICMP:ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 9.1 ICMP协议的应用:PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理: 是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute:用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。Traceroute的工作原理: 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 十、IP 地址编址方式:10.1 IP 地址的编址方式经历了三个历史阶段：①: 分类②: 子网划分③: 无分类 分类: 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 网络号:用于识别主机所在的网络；主机号: 用于识别该网络中的主机IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} IP地址分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。 IP地址类别: 高八位 占总IP地址数的比例: A类：前一位固定为0 第一个八位的范围是0-127目的: 保证了最小为0,最大为127 即255(全一)-128(最高位为1,其他为0)=127 (127-0+1）/ 256=50% B类：前两位固定为10 第一个八位的范围是：128-191前两位固定为10的目的是：为了让前八位表示的数最小为128 (191-128+1) / 256=25% C类：前三位固定为110 第一个八位的范围是：192-223前两位固定为110的目的是：保证最小192 (223-192+1) / 256=12.5% D类：前四位固定为1110 不分网络地址和主机地址 第一个八位的范围是：224-239 (239-224+1) / 256=6.25% E类：前四位固定为1111 不区分网络地址和主机地址 第一个八位的范围是：240-255 (255-240+1) / 256=6.25% A类地址:1）A类地址第1字节为网络地址，其它3个字节为主机地址。它的第1个字节的第一位固定为0，因此只有7位可供使用.可指派的网络号为126个（即2^7-2=126），减2 的原因：第一： IP地址中的全0表示“这个（或者本）”，全1表示所有的。 网络号字段全0 的IP地址是个保留地址， 意思是本网络第二： 网络号为127（即01111111）保留作为本地软件环回测试（loop back test）本主机的进程之间的通信之用。2）A类地址可指派网络号范围：1—1263）A类地址中的私有地址和保留地址：① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址),且范围是（10.0.0.0—10.255.255.255）② 127.X.X.X是保留地址，用做循环测试用的。A类地址主机号占三个字节，因此每个A类网络中最大主机数： 2^24-2=16777214这里减2 的原因： 全0的主机号字段， 表示该IP地址 是”本主机“所连结到的单个网络地址，（例如： 一主机的IP地址为5.6.7.8 ，则该主机所在的网络地址就是5.0.0.0）， 而全1表示”所有的“ ，因此主机号全1表示该网络上的所有主机，4）IP地址空间共2^32 个地址，整个A类地址2^31,占整个IP地址空间的50%. 关于全0全1 还可以再举两个例子：例如： B类地址： 128.7.255.255 表示在网络128.7.0.0 上的所有主机， 而A类地址0.0.0.35 则表示 在这个网络上主机号为35 的主机； B类地址: B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。它的第1个字节的前两位固定为10，只剩下16-2=14位可以分配， 因为网络号字段后面的14位无论取什么值， 也不可能出现使整个2字节的网络号字段成为全0或全1， 所以这里就不存在网络总数减2的问题。 但是实际上B类网络地址的128.0.0.0 是不指派的，而可以指派的B类最小网络地址是128.1.0.0 ， 因此B类地址可指派的网络数为 2^14-1=16383. B 类地址的每个网络上的最大主机数2^16-2=65534这里减2 的原因： 要扣除主机号全0全1的。 （全0表示该IP地址 是”本主机“所连结到的单个网络地址，全1 作为广播地址）整个B类地址空间2^30, 占整个IP地址空间的25%. 2） B类地址可指派网络号范围：128.1—191.255。 3） B类地址的私有地址和保留地址 ① 172.16.0.0—172.31.255.255是私有地址 ② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。 191.255.255.255是广播地址，不能分配。 C类地址 1）C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110, 还有21位可以分配，C类网络地址192.0.0.0也是不分配的， 可以指派的C类最小网络地址192.0.1.0，因此C类 地址可指派的网络总数 ， 2^21-1=2097151 , 每一个C类网络地址的最大主机数2^8-2=254, 整个C类地址空间2^29 个地址，占整个IP地址空间的12.5%。 2）C类地址网络号范围：192.0.1—223.255.255。 3） C类地址中的私有地址： 192.168.X.X是私有地址。（192.168.0.0—192.168.255.255) 10.2 特殊IP地址： 10.3 私有（Private）IP地址:实体IP:在网络的世界里，为了要辨识每一部计算机的位置，因此有了计算机 IP 位址的定义。一个 IP 就好似一个门牌！例如，你要去微软的网站的话，就要去『 64.4.11.42 』这个 IP 位置！这些可以直接在网际网络上沟通的 IP 就被称为『实体 IP 』了。 虚拟IP:不过，众所皆知的，IP 位址仅为 xxx.xxx.xxx.xxx 的资料型态，其中， xxx 为 1-255 间的整数，由于计算机的成长速度太快，实体的 IP 已经有点不足了，好在早在规划 IP 时就已经预留了三个网段的 IP 做为内部网域的虚拟 IP 之用。这三个预留的 IP 分别为：除去主机段全零/全一: 由于是虚拟 IP ，所以当您使用这些地址的时候﹐当然是有所限制的，限制如下：私有位址的路由信息不能对外散播使用私有位址作为来源或目的地址的封包﹐不能透过Internet来转送关于私有位址的参考纪录（如DNS）﹐只能限于内部网络使用 由于虚拟 IP 的计算机并不能直接连上 Internet ，因此需要特别的功能才能上网。不过，这给我们架设IP网络提供了很大的方便﹐比如﹕您的公司还没有连上Internet﹐但这不保证将来不会。使用公共IP的话﹐如果没经过注册﹐在以后真正连上网络的时候﹐就很可能和别人冲突了。也正如前面所分析的﹐到时候再重新规划IP的话﹐将是件非常头痛的问题。这时候﹐我们可以先利用私有位址来架设网络﹐等到真要连上internet的时候﹐我们可以使用IP转换协定﹐如 NAT (Network Addresss Translation)等技术﹐配合新注册的IP就可以了。 10.4 组播地址注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机， 224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP（Internet路由发现协议，使用组播功能）功能，那么你的主机路由表中应该有这样一条路由: 169.254.x.x 如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Windows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。 10.5 受限广播地址广播通信是一个主机对所有主机的通信方式。若一个IP地址的2进制数全为1，也就是255.255.255.255，则这个地址用于定义整个互联网。如果设备想使IP数据报被整个Internet所接收，就发送这个目的地址全为1的广播包，但这样会给整个互联网带来灾难性的负担。因此网络上的所有路由器都阻止具有这种类型的分组被转发出去，使这样的广播仅限于本地网段。 10.6 直接广播地址一个网络中的最后一个地址为直接广播地址，也就是HostID全为1的地址。主机使用这种地址把一个IP数据报发送到本地网段的所有设备上，路由器会转发这种数据报到特定网络上的所有主机。注意：这个地址在IP数据报中只能作为目的地址。另外，直接广播地址使一个网段中可分配给设备的地址数减少了1个。 10.7 源IP地址:若IP地址全为0，也就是0.0.0.0，则这个IP地址在IP数据报中只能用作源IP地址，这发生在当设备启动时但又不知道自己的IP地址情况下。在使用DHCP分配IP地址的网络环境中，这样的地址是很常见的。用户主机为了获得一个可用的IP地址，就给DHCP服务器发送IP分组，并用这样的地址作为源地址，目的地址为255.255.255.255（因为主机这时还不知道DHCP服务器的IP地址）。 10.8 环回地址:127网段的所有地址都称为环回地址，主要用来测试网络协议是否工作正常的作用。比如使用ping.127.0.0.1就可以测试本地TCP/IP协议是否已正确安装。另外一个用途是当客户进程用环回地址发送报文给位于同一台机器上的服务器进程，比如在浏览器里输入127.1.2.3，这样可以在排除网络路由的情况下用来测试IIS是否正常启动。 10.9 NetID为0的地址:当某个主机向同一网段上的其他主机发送报文时就可以使用这样的地址，分组也不会被路由器转发。比如12.12.12.0/24这个网络中的一台主机12.12.12.2/24在与同一网络中的另一台主机12.12.12.8/24通信时，目的地址可以是0.0.0.8。 10.10: 关于子网掩码:为了标识IP地址的网络部分和主机部分，要和地址掩码（Address Mask）结合，掩码跟IP地址一样也是32 bits，用点分十进制表示。IP地址网络部分对应的掩码部分全为“1”，主机部分对应的掩码全为“0”。 缺省状态下，如果没有进行子网划分，A类网络的子网掩码为255.0.0.0，B类网络的子网掩码为255.255.0.0，C类网络的子网掩码为255.255.255.0。利用子网，网络地址的使用会更加有效。 有了子网掩码后，IP地址的标识方法如下：例：192.168.1.1 255.255.255.0或者标识成192.168.1.1/24（掩码中“1”的个数） 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 无分类 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 十一、虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 共有2的24次方个地址 172.16.0.0 ~ 172.31.255.255 共有2的20次方个地址 192.168.0.0 ~ 192.168.255.255 共有2的16次方个地址 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 十二、网络地址转换 NAT:专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 十三、路由器的结构:13.1 路由器的功能：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 13.2 路由器分组转发流程: 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 13.3 路由选择协议:路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、关于进程:1.1 什么是进程?进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。有挂起状态 1.2 进程的组成部分: 进程由四个部分组成: ①: 程序块②: 数据块: 程序和数据刻画的是静态特征③: 进程控制块 (Process Control Block, PCB) : 每个进程只有一个进程控制块Process Control Block (进程描述符), 包含管理进程所需的全部信息.④: 核心栈: 进程运行过程中产生中断或者执行系统调用时又要运行操作系统内核函数 , 核心栈就是存放内核函数在工作时产生的信息 PCB包含三类信息: ①: 标识信息: 数值型进程号0~32767 是进程存在的唯一标识②: 现场信息: 包括通用寄存器, 控制寄存器, 栈指针, 程序状态字 进程让出处理器时,必须将此时的现场信息保存到PCB③: 控制信息: 用于管理和调度进程 1.3 进程状态的切换:进程的三种基本状态: 运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着 阻塞状态：等待资源; 由于进程等待某种条件（如等待I/O操作的完成，或等待另一个进程发来消息(即进程同步)），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行 就绪状态：等待被调度 ; 进程已获得除CPU外的所需资源，由于其他进程占用CPU而暂时无法运行的一种状态 注意: ①: 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的CPU 时间片用完之后就会转为就绪状态，等待下一次调度。②: 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 1.4 进程的特点:动态性: 程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。共享性: 多个不同的进程,可以执行相同的程序, 进程和程序不是一 一对应的异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进独立性: 每个进程是操作系统中的一个独立的实体, 有独立的虚存空间,程序计数器,内部状态并发性: 在单处理器系统中可并发执行, 多处理器环境中并行执行. 1.5 进程的挂起:目的: 平滑系统负荷什么时候挂起? 当系统资源尤其是内存资源已经不能满足进程运行的要求时,必须把某些进程挂起.特点: 将不参与低级调度, 直到它们被对换到内存, 该进程不能立即执行如何结束挂起状态? 只能由操作系统或者父进程发出 1.6 进程挂起和激活:挂 起 原 语 既 可 以 由 进 程 自 己 也 可 以 由 其 他 进 程 调 用, 激 活 原 语 只 能 由 其 他 进 程 调 用 1.7 进程阻塞和唤醒:阻塞: 进程让出处理器,转而等待一个事件,如等待资源,等待IO操作完成, 等待事件发生.进程通常调用阻塞原语来阻塞自己, 因此阻塞是自主行为唤醒: 等待事件完成时会产生中断,激活操作系统,在操作系统控制下,与其相关的另一个进程调用唤醒原语将阻塞进程唤醒. 二、关于线程:1.1 什么是线程?是进程中能并发执行的实体, 是进程的组成部分,有时被称为轻量级进程(Lightweight Process，LWP）, 是处理器调度和分派的基本单位, 是一条执行路径,有独立的程序计数器 无挂起状态 1.2 线程的重要特征:①: 一个进程中可以有多个线程，它们共享进程资源。②: 线程是轻量级的进程③: 线程是由进程创建的(寄生在进程)④: 线程没有独立的地址空间(内存空间)⑤: 线程是系统独立调度和分配的基本单位⑥: 可并发执行⑦: 线程是一种轻型实体线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息： 线程状态 存放每个线程的局部变量主存区 访问同一个进程中的主存和其它资源 当线程不运行时，被保存的现场资源 1.3 创建线程的不同方式:有4种方式可以用来创建线程：①继承Thread类②实现Runnable接口③应用程序可以使用Executor框架来创建线程池实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。④还有一种方式是实现Callable接口 1.4 进程状态的切换: 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。 阻塞的情况分三种： (一). 等待阻塞： 运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。 (二). 同步阻塞： 运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。 (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 1.4 优点:快速切换 : 同一个进程中的多线程只需要改变堆栈和寄存器, 地址空间不变通信容易: 不必经过内核, 可自由访问全局数据,自动共享进程的内存和文件减少管理开销: 线程的创建和撤销工作比进程少很多,并且无需再分配存储空间,和各种资源并发程度提高: 三、进程与线程的区别:3.1 就资源而言:进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 3.2 就调度而言:线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 3.3 就系统开销而言:由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 3.4 就通信而言:线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。但是进程通信需要借助 IPC。 3.5 就组成而言:进程可分为两部分: 资源集合 和 线程集合进程封装管理信息,线程封装执行信息 四、进程的调度算法:不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 4.1 批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 ①: 先来先服务 first-come first-serverd（FCFS）按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 ②: 短作业优先 shortest job first（SJF）按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 ③: 最短剩余时间优先 shortest remaining time next（SRTN）按估计剩余时间最短的顺序进行调度。 4.2 交互式系统:交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。④: 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 ⑤: 优先级调度 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 ⑥: 多级反馈队列 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 4.3 实时系统实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 五、进程同步:临界区:对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步与互斥:同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量:信号量（Semaphore）是一个整型变量，可以对其执行 P 和 V 操作。 P: 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； V ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P 操作。 P, V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; P(&amp;mutex); // 临界区 V(&amp;mutex);&#125;void P2() &#123; P(&amp;mutex); // 临界区 V(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE) &#123; int item = produce_item(); P(&amp;empty); P(&amp;mutex); insert_item(item); V(&amp;mutex); V(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE) &#123; P(&amp;full); P(&amp;mutex); int item = remove_item(); consume_item(item); V(&amp;mutex); V(&amp;empty); &#125;&#125; 六、关于管程:使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。c 语言不支持管程 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 七、进程的通信:进程同步与进程通信很容易混淆，它们的区别在于：进程同步：控制多个进程按一定顺序执行；进程通信：进程间传输信息 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 八、关于管道:管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 九、同步方法和同步代码块的区别是什么？①: 同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；②: 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰；]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理层]]></title>
    <url>%2F%E7%89%A9%E7%90%86%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、传输模式:单工（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户半双工（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信全双工（full-duplex）:发送的同时也可以接收数据 二、信道复用技术:2.1 频分复用:频分复用的所有主机在相同的时间占用不同的频率带宽资源。 2.2 时分复用:时分复用的所有主机在不同的时间占用相同的频率带宽资源。 2.3 波分复用:光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 2.4 码分复用:广泛应用于无线链路共享（如蜂窝网，卫星通信等）每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示各用户使用相同频率载波，利用各自的码片序列编码数据各用户码片序列相互正交码片序列与编码信号的内积 2.5 统计时分复用:是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 三、物理层的主要任务:确定与传输媒体的接口有关的一些特性(机械,电气,功能,过程特性) 四、物理层设备:转发器:集线器: 它的每个接口,是简单的转发比特,不进行碰撞检测中继器: 是一种简单的增加局域网传输距离的设备，如作为信号放大器，可使实际的网络跨越更大的距离，它工作在物理层 五、物理层基本单元:比特 六、常用编码方式:不归零: 与比特流一致归零: 到了高/低电平后,将回到低电平曼彻斯特: 中心向下为1差分曼彻斯特: 位开始无跳变为1,位中心始终跳变 七、物理层规范:物理层定义的是规范，不能说是协议例如: EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTTP]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EHTTP.html</url>
    <content type="text"><![CDATA[一、区分URI,URL,URN:URI 包含 URL 和 URN。 二、关于HTTP协议:2.1 是什么?是一个基于(客户端/服务器)请求与响应模式的、无连接, 无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 2.2 HTTP协议的主要特点?①: 无连接： 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 ②: 无状态： HTTP协议是无状态协议, 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 ③: 传输数据类型灵活： HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 ④: 传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2.3 HTTP请求报文:请求行,请求头,请求空行,请求体 2.4 HTTP响应报文:状态行,响应头,响应空行,响应体 2.5 HTTP方法:客户端发送的 请求报文 第一行为请求行，包含了方法字段。 有九种方法: get,post,put,delete,head,patch,options,connect,trace HEAD:①: 作用: 获取报文首部②: 和 GET 方法类似，但是不返回报文实体主体部分。③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST: 作用: 传输实体主体POST 主要用来传输数据，而 GET 主要用来获取资源。 PUT:①: 作用: 上传文件②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PATCH:①: 作用: 对资源进行部分修改②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 OPTIONS:①: 作用: 查询支持的方法②: 查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT:①: 要求在与代理服务器通信时建立隧道②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 TRACE:①: 追踪路径②: 服务器会将通信路径返回给客户端。③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 2.6 关于HTTP状态码:服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理100 ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应 2XX Success（成功状态码） 请求正常处理完毕200 OK 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求301 ：永久性重定向302：临时性重定向 4XX Client Error（客户端错误状态码） 服务器无法处理请求403 Forbidden ：请求被拒绝。404 Not Found 5XX Server Error（服务器错误状态码） 服务器处理请求出错500 Internal Server Error ：服务器正在执行请求时发生错误。503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 2.7 : 连接管理:2.7.1 短连接与长连接:①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2.7.2 流水线:①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。 2.7.3 Cookie:①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 ②: Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 ③: Cookie有什么用途? 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） ④: Cookie的创建过程: 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry ⑤: Cookie的分类: 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; ⑥: HttpOnly: 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。 跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly ⑦: Secure: 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 2.7.4 Session:①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 ③: 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 ④: 浏览器禁用 Cookie: 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 2.7.5 Cookie 与 Session 选择: Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 2.8 常见端口:Http端口80, HTTPS端口443 DNS端口 53 FTP 端口21 SMTP端口 25 三、HTTP/1.1 新特性:①: 默认是长连接②: 支持流水线③: 支持同时打开多个 TCP 连接④: 支持虚拟主机⑤: 新增状态码 100⑥: 支持分块传输编码⑦: 新增缓存处理指令 max-age 四、GET 和 POST 比较:从作用上来说: GET 用于获取资源，而 POST 用于传输实体主体。 从参数来说:GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 从缓存来说: 如果要对响应进行缓存，需要满足以下条件： ①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest: 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 ①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。②: 而 GET 方法 Header 和 Data 会一起发送。 五: 关于HTTPS:5.1 HTTP 有以下安全性问题：①: 使用明文进行通信，内容可能会被窃听；②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；③: 无法证明报文的完整性，报文有可能遭篡改。 5.2 什么是HTTPS?HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改） 5.3 什么是SSL?SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 5.4 什么是TLS?TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 5.5 HTTPS的缺点: ①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐②: HTTPS 降低用户访问速度（多次握手）③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密） 六、关于加密:6.1 对称密钥加密:(Symmetric-Key Encryption)①: 有流式、分组两种，加密和解密都是使用的同一个密钥。例如：DES、AES-GCM、ChaCha20-Poly1305等 优点：运算速度快；缺点：无法安全地将密钥传输给通信方。 6.2 非对称密钥加密:①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、DH、ECDHE ②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(发消息: 公钥加密,私钥解密)③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(签名: 私钥加密,公钥解密) 优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。 6.3 哈希算法:将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 6.4 数字签名:签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP 6.3 HTTPS 采用的加密方式:HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率. 七、关于认证:通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 签名: 签名者的私钥加密, 认证: 使用签名者公钥解密 八、完整性保护:①: SSL 提供报文摘要功能来进行完整性保护。②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 九、关于代理:9.1 代理服务器接受客户端的请求，并且转发给其它服务器。9.2 使用代理的主要目的是：①: 缓存②: 负载均衡③: 网络访问控制④: 访问日志记录 9.3 代理服务器分为正向代理和反向代理两种：举例: 十、关于缓存:10.1 优点:①: 缓解服务器压力；②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 10.2 实现方法①: 让代理服务器进行缓存；②: 让客户端浏览器进行缓存。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>关于HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2Fjava%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[一、先来看两张图: 二、集合的分类:2.1 Collection接口:List接口：存储有序，可重复的元素 ,也就是遍历出来的顺序与添加顺序相同 Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的位置无序))，不可重复的元素(不可 重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都 是Collection下定义的 2.2 Map接口:注：Map接口不是Collection接口的子接口, 两者是并列关系 需要特别注意的一点: 我们经常听说List是有序且重复的， Set 是无序不重复的。这里有个误区，这里说的顺序有两个概念: 一是按添加的顺序排列，二是按自然顺序 a-z 排列。 Set 并不是无序的，传统说的Set 无序是指 HashSet, 它不能保证元素的添加顺序，更不能保证自然顺序，而Set 的其他实现类是可以实现这两种顺序的。 三、关于List接口:3.1 List接口特点：存储有序，可重复的元素 遍历出来的顺序与添加顺序相同 3.2 具体的实现类:①: ArrayList(主要的实现类)②: LinkedList(对于频繁的插入，删除操作 较适用) —-&gt;不适合查找③: Vector(古老的实现类，线程安全的，但效率低于ArrayList) 四、关于Set接口:4.1 需要注意的是:①: 通常说的” Set是无序的, 不可重复的 “ 这句话中的无序是指的存储无序(指的是元素在底层存放的位置无序). ②: 无论是HashSet,还是LinkedHashSet 存储都是无序, 且不可重复的元素③: 遍历出来的顺序是分为有序和无序的 , HashSet遍历是无序的,不是添加的顺序, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历. 4.2 如何保证set中元素不可重复?要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),重写hashCode（）方法让同一个对象能算出相同的hashCode值,, 进而保证Set中元素的不可重复性, 注意:List只用重写equals方法就可以了 4.3 Set中元素是如何存储的呢？使用了哈希算法当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复). 要求：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false; ) 万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此） 4.4 具体的实现类:①: HashSet(主要的实现类)②: LinkedHashSet(HashSet的子类)③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口) 注: 一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer 又存储String类型) 4.4.1 关于TreeSet:当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）②定制排序：（实现Comparator接口，重写compare方法） 两种排序的区别: 前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法. 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 注: 只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 compareTo()与hashCode()以及equals()三者保持一致！ 五、关于Map接口:5.1 Map接口元素的存储原理: Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，需要重写hashCode和equals方法, 进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复 例如:向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(后面的会覆盖前面的,这个与HashSet不同,HashSet是后面的那个不能添加进来)。 5.2 遍历Map:有三类，分别是遍历key，遍历value，遍历key-value对 1234567891011121314151617181920//1.遍历key集Set set = map.keySet();//2.遍历value集Collection values = map.values();//3.遍历key-value对Set set2 = map.entrySet(); //所有entry的集合就是entrySetfor (Object obj:set2) &#123; //遍历entrySet得到entryMap.Entry entry = (Map.Entry)obj; //获取entry//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键 和 值 System.out.println(entry);&#125; 5.3 Map的初始化:不能初始化为: Map&lt;String,List&gt;map=null;而要用new对象的方式：Map&lt;String,List&gt;map=newHashMap&lt;String,List&gt;();否则会报错 5.4 从map中取值:正确方法: 123456方法一: String str = String.valueOf(map.get("键名"));方法二: String str = (String) map.get("ACCEPT_CHANNEL");if (null != str &amp;&amp; !"".equals(str)) &#123;…………&#125; 错误的取值方法： 1String str = map.get("键名").toString; //如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常 注: Map中的Key value可以是任何引用类型的数据 5.5 Map接口的具体实现类:①: HashTable : 古老的实现类，线程安全，不建议使用②: HashMap:③: LinkedHashMap(是HashMap的子类)④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口) 5.5.1 Properties介绍:Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的 123456789101112131415读取属性文件jdbc.properties: Properties pros = new Properties();FileInputStream fi = new FileInputStream(new File("jdbc.properties"));pros.load(fi);读取xml配置文件config.xml: Properties properties = new Properties();InputStream configInputStream = new FileInputStream("config/config.xml");properties.loadFromXML(configInputStream); 六、关于Collections 工具类:6.1 作用: 操作Collection以及Map 6.2 注意: 区分Collection与Collections 6.3 实现list的复制: 12345678910//错误的方式：出现java.lang.indexOutOfBoundsException//List list1=new ArrayList();//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1//System.out.println(list1); //正确的方式List list2 = Arrays.asList(newObject[list.size()]);Collections.copy(list2,list);System.out.println(list2);//[123,456,12,78,456] 6.4 考虑线程安全问题: List 是线程不安全的, synchronizedList方法可以保证List线程安全 123//通过如下的方法保证list的线程安全List list3=Collections.synchronizedList(list);System.out.println(list3); 6.5常用函数: 123456reverse(List)：反转List中元素的顺序shuffle(List)：对List集合元素进行随机排序sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序swap(List,int,int)：将指定list集合中的i处元素和j处元素进行交换void copy(List dest,List src)://将src中的内容复制到dest中 七、集合的遍历方法：四种①使用Iterator迭代器 ②增强型for循环 ③普通for循环 ④Iterator迭代器的”古老版本”Enumeration 接口 123456789//Enumeration 接口是Iterator迭代器的"古老版本"public class TestEnumeration &#123; public static void main(String[] args) &#123; Enumeration enu = new StringTokenizer("ab-c*-df-g", "-"); while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement()); &#125; &#125;&#125; 12345678910111213//面试题@Testpublic void test5()&#123; //结果: 输出MM MM MM AA BB DD String[]str=new String[]&#123;"AA","BB","DD"&#125;; //表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值 for(String s:str)&#123; //每循环一次, s都是一个新的局部变量 s="MM"; System.out.println(s); &#125; for(int i=0;i&lt;str.length;i++)&#123; System.out.println(str[i]); &#125;&#125; 八、关于数组:存储对象可以考虑：①数组，②集合数组存储对象的特点：Student[] stu = new Student[20]; stu[0]=new Student();…..弊端：①一旦创建，其长度不可变. ②真实的数组存放的对象的个数是不可知的 九、总结:①: 单类型: 一个TreeSet对象必须存储同一种数据类型,例如: 不能既存储Integer 又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型. ②: 一致性: 使用TreeSet时: compareTo()与hashCode()以及equals()三者保持一致！ ③: 执行流程： 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 ④: 顺序性: Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)Set而言: 遍历是分为有序和无序的 , 其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[一、数据类型:1.1 基本数据类型：1.1.1 整数类型：byte（1个字节,占8位） -128（-2^7）——– 127 (2^7-1)short（2个字节,占16位） -32768 (-2^15)——- 32767 (2^15-1)int（4个字节,占32位） （-2)^31 —— 2^31-1long(8个字节,占64位) （-2)^63 —— 2^63-1 整数有三种表示形式： 八进制：以0开头，如012，-027 十进制： 十六进制：以0x 或0X开头，如0x123,-0X12 1.1.2 浮点类型：float（4字节） 6或7位有效数字double（8字节） 15位有效数字带小数点的数默认为：双精度浮点型（double），数字后带“d 或 D”，如“2.3d”，“d 或 D”可以省略注意：要表示单精度浮点型（float），必须在数字后面加“f 或 F”，如“13.23f”,“f 或 F”不可省略 1.1.3 字符类型：char（2字节） 1.1.4 布尔类型boolean：false（4字节）必须小写true（4字节）必须小写 JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 1.2 引用数据类型：①: 类(class) 如String类,Integer类②: 接口(interface)③: 数组④: 枚举（enum） 1.3 包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int -----&gt;Integerint y = x; // 拆箱Integer-----&gt;int 二、常量与变量①: 常量：由final修饰的 ②: 变量： 局部变量（位于方法（一般方法，构造方法，程序入口方法）中） 全局变量（１.实例变量（无static修饰），２.类变量也称静态变量（有static修饰）） 三、强制类型转换:3.1 自动转换小的转换为大的，系统会自动完成强制类型转换如：short i = 10; int j; j=i; (系统自动完成j = (int)i ) 3.2 手动转换大的转换为小的，必须进行手动完成强制类型转换如：int i = 10; short j; j = (short)i; 四、构造方法:4.1 特点：①: 构造方法只能由new操作符调用，即建立对象时自动调用；②: 构造方法可以重载，即在同一个类中可以有多个构造方法③: 构造方法没有返回类型，甚至连void也没有④: 构造方法与类同名 注: 如果没有在类中写构造方法，系统会生成一个默认的无参构造方法，并使用默认值初始化对象的属性（int变量初始化为0，boolean 变量初始化为false）,如果写了有参构造方法,那么系统不会再自动生成无参构造方法,如果此时我们要用无参构造方法,需要我们手动写无参构造方法. 4.2 作用：初始化对象，如给数据成员赋值注意：一旦创建了一个有参数的构造方法，系统就不会自动添加默认的无参构造方法，要想用无参构造方法，需要人为的去创建一个无参构造方法 五、注释:①: 文件注释：在包名之上，“/*……*/”，描述文件名(java工程名)，版权信息②: 类注释：“/**……*/”，描述类的作用，版本version ，日期，作者③: 私有成员：“/*……*/” 或“//”；如局部变量，某一个语句的功能作用 * @param 描述方法的参数 * @return 描述返回值，对于无返回值的方法或构造方法，@return可以省略 * @throws 描述在什么情况下抛出什么类型的异常 * @author 描述作者 * @version 描述版本 * @since 描述该类可以运行的JDK版本 * @see 参考转向，也就是相关主题 * @link 转向成员的超链接。label为链接文字。package.class#member将被自动转换为指向package.class的member文件的URL ④: 共有成员：“/**……..*/”；如构造方法 六、继承（extends）6.1 含义:其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正每次调子类的时候都会“自动运行”它父类的构造函数，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”。 6.2 java中子类能不能继承父类构造方法？答案是不能*理由：其实每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。所以父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法 注意“调用”和继承不是一个含义，实质上是“自动运行”。 七、关于JavaBean:符合如下标准的Java类：①: 实现serializable接口（这个不是必须的）②: 必须有一个无参的公共的构造器（public修饰）③: 必须属性用private修饰，且有get，set方法 八、权限修饰符： 九、抽象类：特点：必须含抽象方法，其他的和一般类一样抽象方法：只有声明没有实现的方法 十、接口：10.1 特点：只含常量和抽象方法①: 接口中的常量都是public static final 类型(可以省略)，这是系统默认的②: 接口中的方法都是public abstract类型(可以省略)，这是系统默认的③: 接口 作为一种引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的该接口中的方法一个类要实现接口，必须实现这个接口中的所有方法 注意：通过一个接口变量只能调用该接口所声明的方法。 十一、重载和重写区别:方法重载（Overload）：一个类中有多个方法，名字相同，参数不同（如参数个数，种类，参数顺序不同），与返回值无关；方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同 十二、面向对象编程的四个基本特征:①：抽象:②：封装：把对象的数据和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节③：继承：④：多态性：多态的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。 多态的举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态的作用：消除类型之间的耦合关系 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 重载和重写都是多态的体现. 十三、异常与错误:12.1 异常:12.1.1 编译异常： 由于程序语法不合规范，编译不通过 12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）： 编译通过，运行时出现异常。如数组下标越界，除数为零，数字格式错误，空指针异常 12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）： 如类没找到，IO操作错误 12.1.4 逻辑异常： 输出的结果不符合预期的要求 12.1.5 try ,catch ,finally只有三种组合：​ a. try…catch…finally ​ b. try…catch ​ c. try…finally ①: 异常发生时，如果匹配的catch语句中抛出（有throw关键字）了异常，则finally之外的语句将不能被执行 ②: finally中的语句无论什么情况都会执行 ③: 得到有关异常信息：getMessage() ④: 用来跟踪异常事件发生时执行堆栈的内容：printStackTrace（） 12.1.6 throws 和 throw 的区别：throws 关键字用于方法的声明部分，说明方法可能抛出的异常类型throw 关键字用来抛出异常，如果抛出了检查性异常（非运行时异常），还必须在方法头部声明方法可能抛出的异常类，该方法的调用者还必须捕获处理抛出的异常,如果抛出非检查性异常（运行时异常），该方法的调用者可捕获可不捕获异常 12.2 错误（Error）：①：虚拟机错误（Virtual Machine Error）②：连接错误（LinkageError）③：图形界面错误（AWTError） 十四、日期与时间:13.1 java中主要使用三个类来处理日期和时间:①: java.util.Date(日期) , ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的毫秒数 ②: java.util.Calendar（日历） , ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分 ③: java.text.DateFormat（日期格式化）————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写有要求 13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 150658200000013.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 201713.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识java]]></title>
    <url>%2F%E5%88%9D%E8%AF%86java.html</url>
    <content type="text"><![CDATA[一、发展历史①: java语言前身是oak（橡树）语言②: java于1995年诞生于sun公司③: 1996第一个JDK诞生④: 1999 Sun发布J2SE，J2EE ,J2ME 二、语言特点①: 面向对象②: 分布式多线程③: 健壮性(异常处理)④: 安全⑤: 可移植性 三、Java技术体系分四个平台:①: Java Card: java小程序运行在小内存设备(智能卡)上的平台.②: Java ME: 移动终端(手机)③: JavaSE: 桌面级(Windows下的应用程序)④: JavaEE : 以前称J2EE ,企业级 四、JDK和JREJDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器) JDK目录结构:①: bin目录：包含编译器（javac.exe（c是compile（编译）的缩写）），解释器（java.exe），帮助文档生成器（javadoc.exe），打包工具（jar.exe），小应用程序浏览工具（appletviewer.exe） ②: lib目录：包含类库文件 ③: demo目录：包含各种演示例子 ④: include目录：包含C语言头文件，支持java本地接口 ⑤: jre目录：包含java虚拟机，java应用启动器，运行时的类包 ⑥: sample目录：sun配带的帮助学习者学习的java例子 ⑦: src.zip:源码压缩文件 JDK: Java程序设计语言 + Java 虚拟机 + JavaAPI类库 JRE : JavaAPI中的Java SE API + Java虚拟机 因此 JDK包含JRE 五、java虚拟机是什么？(Java Virtual Machine) 简称JVM Java语言写的代码是.java文件，它会被特定程序编译(javac.exe，它会被Eclipse之类的IDE调用)成字节码(bytecode)，字节码不能直接在CPU上运行，需要另一个程序读取并执行，这个部件就是java虚拟机，它像机器一样运行编译好的java字节码，就像机器直接执行机器码一样……java虚拟机的外部接口在windows下主要是jvm.dll这个文件……简言之：jvm是Java开发语言中，用来运行Java字节码文件的平台；提供对Java字节码的解释及运行，位于JRE中JRE: java运行环境,包含java虚拟机和java程序所需的核心类库(javaSE API) 。如果只是想跑java程序，那么只需安装JRE，如果要写java程序，那就需要JDK了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之内存分配和回收]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6.html</url>
    <content type="text"><![CDATA[一、内存分配策略:1. 对象优先在 Eden 分配:大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 2. 大对象直接进入老年代:①: 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。②: 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。⑤: -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 3. 长期存活的对象进入老年代:①: 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。②: -XX:MaxTenuringThreshold 用来定义年龄的阈值。 4. 动态对象年龄判定:虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保:在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Minor GC 的触发条件: 当 Eden 空间满时，就将触发一次 Minor GCFull GC 的触发条件:①: 老年代空间不足: 解决方案： ①：尽量不要创建过大的对象以及数组 ②：通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 ③：通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 ②: 空间分配担保失败 ③: 调用 System.gc(): 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 ④：JDK 1.7 及以前的永久代空间不足 解决方案： ①：可采用的方法为增大永久代空间 ②：转为使用 CMS GC。 二、内存回收：2.1 GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。2.1.1 Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。 2.1.2 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-3无重复字符的最长子串]]></title>
    <url>%2FLeetCode-3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    <content type="text"><![CDATA[题目:给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "kew"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 分析:给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。 我们先不考虑代码怎么实现，如果给一个例子中的例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉第一次出现的b，以此类推，最终发现最长的长度为3。 所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。 进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。 参考链接:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之垃圾收集]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[一、垃圾收集:1.1哪些区域需要垃圾收集:①: 垃圾收集主要是针对堆和方法区进行。②: 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 二、判断一个对象是否可被回收:2.1 引用计数算法:为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011121314public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); &#125;&#125; 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。 2.2 可达性分析算法:以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： ①: 虚拟机栈中局部变量表中引用的对象 ②: 本地方法栈中 JNI 中引用的对象 ③: 方法区中类静态属性引用的对象 ④: 方法区中的常量引用的对象 2.3 方法区的回收①: 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 ②: 主要是对常量池的回收和对类的卸载。 ③: 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 ④: 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 2.4. finalize()类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 三、引用类型:无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型:3.1 强引用被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 3.2 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.3 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的: 是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 四、垃圾收集算法:4.1 标记 - 清除: 标记要回收的对象，然后清除。不足：标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 4.2 标记 - 整理:让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 4.3 复制: 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足: 是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 4.4 分代收集:现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 五、垃圾收集器:HotSpot 虚拟机中的 7 个垃圾收集器: 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 5.1 Serial 收集器:Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 5.2ParNew 收集器:它是 Serial 收集器的多线程版本。 它是Server场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 5.3 Parallel Scavenge 收集器:与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值 5.4 Serial Old 收集器:是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5.5 Parallel Old 收集器:是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 5.6 CMS 收集器:CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 具有以下缺点：①: 吞吐量低：②: 无法处理浮动垃圾: 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。③: 标记 - 清除算法导致空间碎片 5.7 G1 收集器:G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA.html</url>
    <content type="text"><![CDATA[一、JVM是什么?JVM是Java Virtual Machine（Java虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 二、JVM的作用?JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码字节码，就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 三、从进程的角度解释JVM我们知道，虚拟机是运行在操作系统之中的，那么什么东西才能在操作系统中运行呢？当然是进程，因为进程是操作系统中的执行单位。可以这样理解，当它在运行的时候，它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放于文件系统中），可以把它叫做程序。 对命令行比较熟悉的同学，都知道其实一个命令对应一个可执行的二进制文件，当敲下这个命令并且回车后，就会创建一个进程，加载对应的可执行文件到进程的地址空间中，并且执行其中的指令。 四、Java版HelloWord程序的编译和执行形式:①: 首先编写源文件HelloWord.java ： 12345 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; ②: 编译Java版的HelloWorld程序：$ javac HelloWorld.java ③: 运行Java版的HelloWorld程序：$ java -classpath . HelloWorld 4.1 从上面的过程可以看到， 我们在运行Java版的HelloWorld程序的时候， 敲入的命令并不是 ./HelloWorld.class 。 因为class文件并不是可以直接被操作系统识别的二进制可执行文件 。 我们敲入的是java这个命令。 这个命令说明， 我们首先启动的是一个叫做java的程序， 这个java程序在运行起来之后就是一个JVM进程实例. 4.2 上面的命令执行流程是这样的： java命令首先启动虚拟机进程，虚拟机进程成功启动后，读取参数“HelloWorld”，把他作为初始类加载到内存，对这个类进行初始化和动态链接，然后从这个类的main方法开始执行。 也就是说我们的.class文件不是直接被系统加载后直接在cpu上执行的，而是被一个叫做虚拟机的进程托管的。首先必须虚拟机进程启动就绪，然后由虚拟机中的类加载器加载必要的class文件，包括jdk中的基础类（如String和Object等），然后由虚拟机进程解释class字节码指令，把这些字节码指令翻译成本机cpu能够识别的指令，才能在cpu上运行. 4.3 从这个层面上来看，在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。 五、JVM体系结构简介: 根据上图表达的内容，我们编译之后的class文件是作为Java虚拟机的原料被输入到Java虚拟机的内部的，那么具体由谁来做这一部分工作呢？其实在Java虚拟机内部，有一个叫做类加载器的子系统，这个子系统用来在运行时根据需要加载类。注意上面一句话中的“根据需要”四个字。在Java虚拟机执行过程中，只有他需要一个类的时候，才会调用类加载器来加载这个类，并不会在开始运行时加载所有的类。就像一个人，只有饿的时候才去吃饭，而不是一次把一年的饭都吃到肚子里。一般来说，虚拟机加载类的时机，在第一次使用一个新的类的时候。 由虚拟机加载的类，被加载到Java虚拟机内存中之后，虚拟机会读取并执行它里面存在的字节码指令。虚拟机中执行字节码指令的部分叫做执行引擎。就像一个人，不是把饭吃下去就完事了，还要进行消化，执行引擎就相当于人的肠胃系统。在执行的过程中还会把各个class文件动态的连接起来。 Java虚拟机会进行自动内存管理。具体说来就是自动释放没有用的对象，而不需要程序员编写代码来释放分配的内存。这部分工作由垃圾收集子系统负责。 一个Java虚拟机实例在运行过程中有三个子系统来保障它的正常运行，分别是类加载器子系统， 执行引擎子系统和垃圾收集子系统。 如下图所示： 虚拟机的运行，必须加载class文件，并且执行class文件中的字节码指令。它做这么多事情，必须需要自己的空间。就像人吃下去的东西首先要放在胃中。虚拟机也需要空间来存放个中数据。首先，加载的字节码，需要一个单独的内存空间来存放；一个线程的执行，也需要内存空间来维护方法的调用关系，存放方法中的数据和中间计算结果；在执行的过程中，无法避免的要创建对象，创建的对象需要一个专门的内存空间来存放。 5.1 Java虚拟机 运行时数据区: 5.1.1程序计数器:①: 是一块较小的内存空间, 当前线程执行的字节码的行号指示器(记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。)②: 指向下一条需要执行的指令③: 每条线程都需要一个独立的程序计数器,彼此互不干扰(线程私有的内存) 5.1.2Java虚拟机栈:①: 线程私有的,生命周期与线程相同②: 描述java方法执行的内存模型,每个方法执行时都会创建一个栈帧,用来存放局部变量表,操作数栈,常量池引用等信息.③: 每个方法从调用到执行完成 就对应着栈帧在虚拟机栈帧中入栈和出栈.④: 两种异常: StackOverFlow异常 : 线程所请求的栈深度大于虚拟机允许的则抛出 OutOffMemoryError异常: 扩展时无法申请到足够的内存则抛出⑤: 我们常说的栈 和堆 中的栈就是Java虚拟机栈,更具体来说是Java虚拟机栈中的局部变量表部分.⑥: 局部变量表: 存放编译期可知的各种基本数据类型,对象引用类型 所需要的内存空间在编译期完成分配, 在方法运行期间不会改变其大小 64位长度的long 和 double 类型数据会占用2个局部变量空间(Slot) ,其余占一个. ⑦: 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：java -Xss512M HackTheJava 5.1.3本地方法栈:本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 上面三个区域随线程而生, 随线程而灭; 5.1.4Java堆( Java Heap) : 也称GC堆(Garbage Collected Heap )①: 是Java虚拟机管理的内存中最大的一块②: 被所有线程共享,的一块内存空间, 在虚拟机启动时候创建,③: 唯一目的: 存放对象实例, 几乎所有的对象实例 和 数组 都在这里这里分配内存.④: 是垃圾收集器管理的主要区域 ,所以也称GC堆⑤: 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M HackTheJava⑥: 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。 5.1.5方法区(永久代):①: 被所有线程共享,的一块内存空间②: 用来存储Class的相关信息如已经被Java虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。③: 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。④: 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。⑤: HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 5.1.5运行时常量池①: 运行时常量池是方法区的一部分。②: .Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。③: 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。④: 常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 参考链接:https://baike.baidu.com/item/JVMhttps://blog.csdn.net/zhangjg_blog/article/details/20380971https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.mdhttps://blog.csdn.net/gyqjn/article/details/49848473]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是策略模式?定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp;让算法可在不影响客户端的情况下发生变化简单来说：准备一组算法 &amp; 将每一个算法封装起来，让外部按需调用 &amp; 使得互换 二、如何使用?使用步骤?步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员步骤4：客户端调用-让销售员进行促销活动的落地 三、优点:①: 策略类之间可以自由切换,由于策略类都实现同一个接口，所以使它们之间可以自由切换②: 易于扩展,增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码③: 符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。 四、缺点:①: 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。②: 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 五、应用场景:动态选择多种复杂行为 六、实例:背景：小成有一家百货公司，最近在定年度的促销活动冲突：每个节日用同一个促销活动太枯燥，没吸引力解决方案：针对不同节目使用不同促销活动进行促销 123456789101112131415161718192021222324252627282930313233343536373839404142434445//步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口abstract class Strategy &#123; public abstract void show();&#125;//步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动//为春节准备的促销活动Aclass StrategyA extends Strategy &#123; @Override public void show() &#123; System.out.println("为春节准备的促销活动A"); &#125;&#125;//为中秋节准备的促销活动Bclass StrategyB extends Strategy &#123; @Override public void show() &#123; System.out.println("为中秋准备的促销活动A"); &#125;&#125;//为国庆准备的促销活动Cclass StrategyC extends Strategy &#123; @Override public void show() &#123; System.out.println("为国庆准备的促销活动C"); &#125;&#125;//步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员class Context_SaleMan &#123; //持有抽象策略角色的引用 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * * @param strategy 具体策略对象 */ public Context_SaleMan(Strategy strategy) &#123; this.strategy = strategy; &#125; //向客户展示促销活动 public void Sale_ManShow() &#123; strategy.show(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//步骤4：客户端调用-让销售员进行促销活动的落地public class StrategyPattern &#123; //程序入口 public static void main(String[] args) &#123; Context_SaleMan saleMan; // 选择并创建需要使用的策略对象 // 例如现在要做春节的活动 Strategy strategyA = new StrategyA(); System.out.println("对于春节："); // 创建环境 saleMan = new Context_SaleMan(strategyA); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做中秋节的活动 Strategy strategyB = new StrategyB(); System.out.println("对于中秋节："); // 创建环境 saleMan = new Context_SaleMan(strategyB); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做国庆节的活动 Strategy strategyC = new StrategyC(); System.out.println("对于国庆节："); // 创建环境 saleMan = new Context_SaleMan(strategyC); saleMan.Sale_ManShow(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[什么是抽象工厂模式?抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。 抽象工厂模式与工厂方法模式最大的区别?抽象工厂中每个工厂可以创建多种类的产品, 而工厂方法每个工厂只能创建一类. 使用步骤:(根据下图来理解:)步骤1： 创建抽象工厂类，定义具体工厂的公共接口；步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；步骤4： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例 优点:①: 降低耦合: 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来， 可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；②: 更符合开-闭原则: 新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 而简单工厂模式需要修改工厂类的判断逻辑 ③: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品， 而简单工厂中的工厂类存在复杂的switch逻辑判断④: 不使用静态工厂方法，可以形成基于继承的等级结构， 而简单工厂模式的工厂类使用静态工厂方法 缺点:①: 抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。②: 对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。 应用场景:①: 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。②: 这个系统有多个系列产品，而系统中只消费其中某一系列产品③: 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。 实例:背景： 小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂所在地的客户 也需要模具类产品，B厂所在地的客户也需要容器类产品；冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂.解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。 1234567//步骤1： 创建抽象工厂类，定义具体工厂的公共接口abstract class Factory &#123; public abstract Product ManufactureContainer();//容器 public abstract Product ManufactureMould();//模型&#125; 123public class Product &#123; public void show()&#123;&#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//步骤2： 创建抽象产品族类 ，定义具体产品的公共接口；abstract class AbstractProduct extends Product&#123; public abstract void show();&#125;//步骤3： 创建抽象产品类 ，定义具体产品的公共接口；//容器产品抽象类abstract class ContainerProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//模型产品抽象类abstract class MouldProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//步骤4： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；//容器产品Aclass ContainerProductA extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品A"); &#125;&#125;//容器产品Bclass ContainerProductB extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品B"); &#125;&#125;//模具产品Aclass MouldProductA extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品A"); &#125;&#125;//模具产品Bclass MouldProductB extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品B"); &#125;&#125;//步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//A厂 - 生产模具+容器产品class FactoryA extends Factory &#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductA(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductA(); &#125;&#125;//B厂 - 生产模具+容器产品class FactoryB extends Factory&#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductB(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductB(); &#125;&#125; 12345678910111213141516//步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例public class AbstractFactoryPattern &#123; public static void main(String[] args) &#123; Factory myfactoryA = new FactoryA(); Factory myfactoryB = new FactoryB(); //A厂当地客户需要容器产品A myfactoryA.ManufactureContainer().show(); //A厂当地客户需要模具产品A myfactoryA.ManufactureMould().show(); //B厂当地客户需要容器产品B myfactoryB.ManufactureContainer().show(); //B厂当地客户需要模具产品B myfactoryB.ManufactureMould().show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-2两数相加]]></title>
    <url>%2FLeetCode-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html</url>
    <content type="text"><![CDATA[题目:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例: 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析:建立一个新链表，然后把输入的两个链表从头往后遍历，每两个相加，添加一个新节点到新链表后面。为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后，由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点。好，可以开始让两个链表相加了，这道题好就好在最低位在链表的开头，所以我们可以在遍历链表的同时按从低到高的顺序直接相加。while循环的条件两个链表中只要有一个不为空行，由于链表可能为空，所以我们在取当前结点值的时候，先判断一下，若为空则取0，否则取结点值。然后把两个结点值相加，同时还要加上进位carry。然后更新carry，直接 sum/10 即可，然后以 sum%10 为值建立一个新结点，连到cur后面，然后cur移动到下一个结点。之后再更新两个结点，若存在，则指向下一个位置。while循环退出之后，最高位的进位问题要最后特殊处理一下，若carry为1，则再建一个值为1的结点，代码如下： 123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //l1,l2相当于指向两个链表表头的指针 //为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后 ListNode dummy = new ListNode(-1); //由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点 ListNode cur = dummy; //进位 int carry = 0; //至少有一个结点不为空 while (l1 != null || l2 != null) &#123; //结点为空,那么值就设置为0,不为空取出结点所存放的值 int d1 = l1 == null ? 0 : l1.val; int d2 = l2 == null ? 0 : l2.val; //两个链表中对应结点的值求和 int sum = d1 + d2 + carry; carry = sum &gt;= 10 ? 1 : 0; //sum不会超过二十,所以最多进1位 cur.next = new ListNode(sum % 10);//造一个新结点,将两个链表对应结点的两数之和,存到新链表的新结点 cur = cur.next;//移动cur指针,指向下一个结点 if (l1 != null) &#123; l1 = l1.next;//移动l1指针 &#125; if (l2 != null) &#123; l2 = l2.next;//移动l2指针 &#125; &#125;//循环结束 //如果最高位相加,产生进位,需要再造一个结点 if (carry == 1) &#123; cur.next = new ListNode(1); &#125; return dummy.next;&#125; 12345678910111213141516171819202122232425public class addTwoNumbers &#123; //程序入口函数 public static void main(String[] args) &#123; //建立第一个链表 ListNode listNode1 = new ListNode(2); ListNode listNode2 = new ListNode(4); ListNode listNode3 = new ListNode(3); listNode1.next=listNode2; listNode2.next=listNode3; listNode3.next=null; //建立第二个链表 ListNode listNode4 = new ListNode(5); ListNode listNode5 = new ListNode(6); ListNode listNode6 = new ListNode(4); listNode4.next=listNode5; listNode5.next=listNode6; listNode6.next=null; //调用方法 ListNode listNode = new addTwoNumbers().addTwoNumbers(listNode1,listNode4); //打印结果: ListNode&#123;val=7, next=ListNode&#123;val=0, next=ListNode&#123;val=8, next=null&#125;&#125;&#125; System.out.println(listNode); &#125;&#125; 参考链接:http://www.cnblogs.com/grandyang/p/4129891.htmlhttps://leetcode-cn.com/problems/two-sum/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是工厂方法模式?①: 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口(抽象方法)，而子类重写接口(抽象方法)则负责生成具体的对象。③: 简言之:工厂里面造对象,对象所属类里面造产品 二、如何使用?使用步骤?步骤1： 创建抽象工厂类，定义具体工厂的公共接口(抽象方法)；步骤2： 创建抽象产品类 ，定义具体产品的公共接口(抽象方法)；步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤4： 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例(对象)的方法；步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 三、优点:①: 更符合开-闭原则: 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可, 而简单工厂模式需要修改工厂类的判断逻辑②: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品, 而简单工厂中的工厂类存在复杂的switch逻辑判断, 它不使用静态工厂方法，可以形成基于继承的等级结构。 而简单工厂模式的工厂类使用静态工厂方法 四、缺点:①: 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；②: 同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；③: 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。④: 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；⑤: 一个具体工厂只能创建一种具体产品 五、应用场景:①: 当一个类不知道它所需要的对象的类时②: 当一个类希望通过其子类来指定创建对象时③: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。④: 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 六、实例:背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；解决方案：小成决定置办塑料分厂B来生产B类产品； //步骤1： 创建抽象工厂类 123abstract class Factory &#123; abstract Product Manufacture();&#125; //步骤2： 创建抽象产品类 ，定义具体产品的公共接口； 123abstract class Product &#123; public abstract void show();&#125; //步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下://步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下: //具体产品A类class ProductA extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品A"); &#125;&#125;//具体产品B类class ProductB extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品B"); &#125;&#125;//步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; @Override Product Manufacture() &#123; return new ProductA(); &#125;&#125;//工厂B类 - 生产B类产品class FactoryB extends Factory&#123; @Override Product Manufacture() &#123; return new ProductB(); &#125;&#125;//生产工作流程public class FactoryPattern &#123; public static void main(String[] args) &#123; //客户要产品A FactoryA myfactoryA = new FactoryA(); myfactoryA.Manufacture().show(); //客户要产品B FactoryB myFactoryB = new FactoryB(); myFactoryB.Manufacture().show(); &#125; 七、总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是简单工厂模式?①: 简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法） ②: 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。 二、如何使用?使用步骤?:①: 创建抽象产品类 &amp; 定义具体产品的公共接口；②: 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；③: 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；④: 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例 三、优点:①: 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；②: 把初始化实例时的工作放到工厂里进行，使代码更容易维护。③: 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。 四、缺点:①: 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；②: 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。③: 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 五、应用场景:①: 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；②: 当工厂类负责创建的对象（具体产品）比较少时。 六、实例:背景：小成有一个塑料生产厂，用来做塑料加工生意目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产 //步骤1. 创建抽象产品类，定义具体产品的公共接口 123abstract class Product &#123; public abstract void show();&#125; //步骤2.创建具体产品类（继承抽象产品类），定义生产的具体产品, 代码如下://步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//具体产品类Aclass ProductA extends Product &#123; @Override public void show() &#123; System.out.println("生产出A产品!"); &#125;&#125;//具体产品类Bclass ProductB extends Product &#123; @Override public void show() &#123; System.out.println("生产出B产品!"); &#125;&#125;//具体产品类Cclass ProductC extends Product &#123; @Override public void show() &#123; System.out.println("生产出C产品!"); &#125;&#125;//步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例public class SimpleFactoryPattern &#123; public static void main(String[] args) &#123; //客户要A产品 try &#123; Factory.Manufacture("A").show(); &#125; catch (NullPointerException e) &#123; System.out.println("没有A产品"); &#125; //客户要B产品 try &#123; Factory.Manufacture("B").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有B产品"); &#125; //客户要C产品 try &#123; Factory.Manufacture("C").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有C产品"); &#125; //客户要D产品 try &#123; Factory.Manufacture("D").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; &#125;&#125; //步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例 12345678910111213141516public class Factory &#123; public static Product Manufacture(String productName) &#123;//工厂类里用switch语句控制生产哪种商品；//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化 switch(productName) &#123; case "A": return new ProductA(); case "B": return new ProductB(); case "C": return new ProductC(); default: return null; &#125; &#125;&#125; 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-三次握手和四次挥手]]></title>
    <url>%2FTCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[一、字段说明: 字段: 含义: SYN,seq 同步报文段 ACK,ack 确认报文段 ack 确认号 seq 序列号 SYN 同步位 FIN 终止位 ACK 确认位 二、三次握手:第一次: 连接请求报文段: SYN=1(请求连接) 初始序号seq=x(客户端初始序号)第二次: 确认报文段(同意连接): SYN =1(请求连接) seq= y(服务器自己的初始序号) ACK = 1(确认收到) ack = x+1(确认号)第三次: 确认报文段:ACK=1(确认收到) seq=x+1 (客户端序号) ack=y+1(确认号) 确认号ack是上一次的序号seq加1 总结: ack的值等于对方上一次发送的报文段中的seq的值加一,​ seq的值等于自己上一次发送的报文段中的seq的值加一(第一次seq值任意取) 简图: B 处于 LISTEN（监听）状态，等待来自 A 的连接请求。 A 向 B 发送连接请求报文 SYN。 B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN ACK。 A 收到 SYN ACK 后，还要向 B 发出确认报文 ACK。 B 收到 ACK 后，连接建立。 应该注意到，接收了 SYN 之后的所有报文都存在 ACK 字段。 三、三次握手的原因:三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手(也就是只进行二次握手)，那么服务器就会打开两个连接(每收到一个请求就打开一个连接)。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四、四次挥手: 简图: 第一次: 连接释放报文段: 请求断开A—B FIN=1 seq=u(u为前面已经传送过的数据的最后一个字节的序号加一) 第二次: 连接释放确认报文段: 确认只断开A—B ACK= 1(确认收到) ack=u+1(确认号) seq=v(v为为前面已经传送过的数据的最后一个字节的序号加一) 第三次: 连接释放确认报文段: 断开B—-A FIN = 1 ACK =1 ack=u+1 seq=w(seq=v后还发送了数据, w是前面已经传送过的数据的最后一个字节的序号加一) 第四次: 连接释放确认报文段 : 确认断开B—A ACK=1 ack = w+1 seq=u+1 A 发送连接释放报文 FIN。 B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文 FIN。 A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。 B 收到 ACK 后释放连接。 五、四次挥手的原因:客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。 六、为什么还要设置一个Time-WAIT ?客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP-三次握手和四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1两数之和]]></title>
    <url>%2FLeetCode-1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析:这道题给了我们一个数组，还有一个目标数target，让我们找到两个数字，使其和为target，乍一看就感觉可以用暴力搜索(遍历所有的两个数字的组合，然后算其和), 但是时间复杂度是O(n^2)。能否想个O(n)的算法来实现，一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢，我们可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，我们都知道HashMap是常数级的查找效率，这样，我们在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。代码如下： 法一: 暴力搜索(不采用) 123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int i = 0, j = 0, t = 0; int result[] = new int[2]; for (i = 0; i &lt; nums.length - 1; i++) &#123; //0 1 2 for (j = i; j &lt; nums.length - 1; j++) &#123; t = nums[i] + nums[j + 1]; if (t == target) &#123; result[0] = i; result[1] = j + 1; return result; &#125; &#125; &#125; return result; &#125; 法二: 使用HashMap 1234567891011121314151617public class TwoSum &#123; public int[] twoSum(int[] sums,int target) &#123; HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;Integer,Integer&gt;(); int[] result = new int[2]; for(int i = 0;i &lt; sums.length;i++)&#123; hashMap.put(sums[i],i);//把值存到HashMap,数作为键,下标作为值 &#125; for(int i = 0;i &lt; sums.length;i++) &#123; int t = target - sums[i]; if(hashMap.containsKey(t) &amp;&amp; hashMap.get(t) != i) &#123; result[0] = i; result[1] = hashMap.get(t); break;//一旦找到了,就立刻终止循环 &#125; &#125; return result; &#125; 1234567891011public class TwoSum &#123; //程序入口函数 public static void main(String[] args) &#123; int []nums = new int []&#123;2, 7, 11, 15&#125;; int target = 9; int[] result = new int[2]; result = new TwoSum().twoSum(nums,target); //打印结果: [0,1] System.out.println("["+result[0]+","+result[1]+"]"); &#125; 参考链接:https://leetcode-cn.com/problems/two-sum/http://www.cnblogs.com/grandyang/p/4130379.html]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是单例模式? 实现1个类只有1个实例化对象并提供一个全局访问点. 二、工作原理: 保证在内存中只有一个对象存在. 在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的， 要是想实现一个类只有一个实例化对象，就要对类的构造方法下功夫 三、如何去保证内存中只有一个对象存在? ①: 构造函数私有化 ②: 自己创建当前类的对象 ③: 对外提供公共的方法(获取已经创建好的对象) 四、使用步骤: 创建私有变量 OurInstance,（用以记录 Singleton 的唯一实例）,内部进行实例化 把类的构造方法私有化，不让外部调用构造方法实例化(构造方法只能在本类中调用) 定义公有方法提供该类的全局唯一访问点外部通过调用newInstance()方法来返回唯一的实例 五、优点: 提供了对唯一实例的受控访问； 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能； 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式； 六、缺点: 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失。 七、单例模式的实现方式:可分为2大类、6种实现方式: 第一大类: 初始化单例类时 即 创建单例 实现方式1: 饿汉式 实现方式2: 枚举类型 第二大类: 按需,延迟创建单例 实现方式3: 懒汉式的基础实现 实现方式4: 懒汉式的改进—&gt;同步锁 实现方式5: 懒汉式的改进—&gt;双重检验锁 实现方式6: 静态内部类 八、饿汉式和懒汉式的区别: 饿汉式: 随类的加载而创建对象 懒汉式: 上来不创建对象,当调用的时候,再创建对象,以后使用的就是同一个对象了 懒汉式: 懒加载,延迟加载 九、实现方式详解:9.1 实现方式1: 饿汉式 ①: 这是 最简单的单例实现方式 ②: 原理: 依赖 JVM类加载机制，保证单例只会被创建1次，即 线程安全 JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化 ③: 应用场景: 除了初始化单例类时 即 创建单例外，继续延伸出来的是：单例对象 要求初始化速度快 &amp; 占用内存小 ④: 具体实现: 1234567891011121314class Singleton &#123; // 1. 加载该类时，单例就会自动被创建 private static Singleton ourInstance = new Singleton(); // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 通过调用静态方法获得创建的单例 public static Singleton newInstance() &#123; return ourInstance; &#125; &#125; 9.2 实现方式2: 枚举类型 ①: 原理: 根据枚举类型的下述特点，满足单例模式所需的 创建单例、线程安全、实现简洁的需求 ②: 具体实现: 12345678910public enum Singleton&#123; //定义1个枚举的元素，即为单例类的1个实例 INSTANCE; // 隐藏了1个空的、私有的 构造方法 // private Singleton () &#123;&#125; &#125; // 获取单例的方式： Singleton singleton = Singleton.INSTANCE;注：这是 最简洁、易用 的单例实现方式，借用《Effective Java》的话：单元素的枚举类型已经成为实现 Singleton的最佳方法 9.3实现方式3: 懒汉式（基础实现） ①: 原理: 与饿汉式 最大的区别是：单例创建的时机 饿汉式：单例创建时机不可控，即类加载时 自动创建 单例 懒汉式：单例创建时机可控，即有需要时，才 手动创建 单例 ②: 具体实现: 123456789101112131415161718class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 需要时才手动调用 newInstance（） 创建 单例 public static Singleton newInstance() &#123; // 先判断单例是否为空，以避免重复创建 if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; return ourInstance; &#125; &#125; ③: 缺点: 基础实现的懒汉式是线程不安全的，具体原因如下: 可能存在多个线程并发 调用 newInstance ( ),从而重复创建单例对象 ④:具体实例: 一个线程A执行到singleton=new Singleton( ); 但还没有获得对象(因对象初始化需要时间),此时,第2个线程也在执行,执行到if (singleton == null) 判断 (判断为真,于是继续运行,创建单例对象),最终线程A ,B 同时获得了一个单例对象, 在内存中就出现两个单例类的对象,造成单例模式失效. 9.4实现方式4: 懒汉式的改进—&gt;同步锁 ①: 原理: 使用同步锁 synchronized锁住创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建 即，getInstance（）方法块只能运行在1个线程中．若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待，而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下单例对象的唯一性． ②: 具体实现: 12345678910111213141516171819202122232425262728293031323334353637 // 写法1(同步方法)class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 加入同步锁 public static synchronized Singleton getInstance()&#123; // 先判断单例是否为空，以避免重复创建 if ( ourInstance == null ) ourInstance = new Singleton(); return ourInstance; &#125; &#125; // 写法2 (同步代码块) // 该写法的作用与上述写法作用相同，只是写法有所区别 class Singleton&#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; // 加入同步锁 synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; return instance; &#125; &#125; ④: 缺点: 每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能） 注: 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步 9.5 实现方式5: 懒汉式的改进—&gt;双重检验锁 ①: 原理: 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能 ②: 具体实现: 1234567891011121314151617181920212223242526272829303132class Singleton &#123; private static Singleton ourInstance = null； private Singleton() &#123; &#125; public static Singleton newInstance() &#123; // 加入双重校验锁 // 校验锁1：第1个if if( ourInstance == null)&#123; // ① synchronized (Singleton.class)&#123; // ② // 校验锁2：第2个 if if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; &#125; &#125; return ourInstance; &#125; &#125; // 说明 // 校验锁1：第1个if // 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作 // 即直接跳到执行 return ourInstance // 校验锁2：第2个 if // 作用：防止多次创建单例问题 // 原理 // 1. 线程A调用newInstance()方法，当运行到②位置时，此时线程B也调用了newInstance()方法, // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕 // 3. 当线程A释放同步锁时，单例已创建，即instance已非空 // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 为非空（单例已创建），因此也不会创建多余的实例 ③: 缺点: 实现复杂 = 多种判断，易出错 9.6 实现方式6: 静态内部类 ①: 原理: 根据 静态内部类 的特性，同时解决了按需加载、线程安全的问题，同时实现简洁 在静态内部类里创建单例，在装载该内部类时才会去创建单例 线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例 ②: 具体实现: 123456789101112131415161718192021222324class Singleton &#123; // 1. 创建静态内部类 private static class Singleton2 &#123; // 在静态内部类里创建单例 private static Singleton ourInstance = new Singleton()； &#125; // 私有构造函数 private Singleton() &#123; &#125; // 延迟加载、按需创建 public static Singleton newInstance() &#123; return Singleton2.ourInstance; &#125; &#125; // 调用过程说明： // 1. 外部调用类的newInstance() // 2. 自动调用Singleton2.ourInstance // 2.1 此时单例类Singleton2得到初始化 // 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例； // 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性 // 3. 最终只创建1个单例 参考文章:https://www.jianshu.com/p/b8c578b07fbc]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识设计模式]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[前言: 我们学习程序设计语言，有必要学习它的设计模式吗？当然是有必要的，程序里有一些“模式”可以发掘的。因为你可以借鉴以往的经验，避免走很多弯路，更快的构造新的程序，提高开发效率。 一、设计模式是什么？ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 简言之：模式：在某些场景下，针对某类问题的某种通用的解决方案。 二、设计模式历史背景? 埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides，后以“四人帮”（Gang of Four，GoF）著称，简称 GoF ，在 95年的时候整理归纳出 23 种最常用的设计模式，并编写成一本书 Design Patterns: Elements of Reusable Object-Oriented Software 就是：《设计模式：可复用面向对象软件的基础》 。 三、设计模式的六大原则:开闭原则（Open Close Principle)：模块应尽量在不修改原代码(闭)的情况下进行扩展(开)。即在程序需要进行拓展的时候，不能去修改原有的代码（闭），实现一个热插拔的效果。 里氏替换原则（Liskov Substitution Principle）：如果调用的是父类的话，那么换成子类也完全可以运行。 派生类能够在基类的基础上增加新的行为。只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒置原则（Dependence Inversion Principle）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。2、抽象不应该依赖于具体实现，具体实现应该依赖于抽象。要求对抽象/接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 接口隔离原则 (Interface Segregation Principle)：每一个接口应该是一种角色，不干不该干的事，该干的事都要干。降低类之间的耦合度。 合成复用原则 (Composite Reuse Principle)：要尽量使用组合/ 聚合，尽量不要使用继承。只有“Is - A” 关系才符合继承关系，“Has- A” 关系应当使用聚合来描述。 迪米特法则 (Demeter Principle)（也称最少知识原则）：一个对象应对其它对象有尽可能少的了解。即一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。简言之：只与直接的朋友通信 四、设计模式的三大分类:创建型模式：共5种, 对象实例化的模式，创建型模式用于解耦对象的实例化过程。 结构型模式：共7种, 把类或对象结合在一起形成一个更大的结构。 行为型模式：共11种, 类和对象如何交互，及划分责任和算法。 五、23种设计模式:单例模式：某个类只能有一个实例，提供一个全局的访问点。 工厂方法(Factory Method)：定义一个创建对象的接口，让子类决定实例化那个类。 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。 普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象 静态工厂方法模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。 原型模式：通过复制现有的实例来创建新的实例。 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。 组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。 装饰模式：动态的给对象添加新的功能。 代理模式：为其他对象提供一个代理以便控制这个对象的访问。 享元模式：通过共享技术来有效的支持大量细粒度的对象。 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。 观察者模式：对象间的一对多的依赖关系。 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。 中介者模式：用一个中介对象来封装一系列的对象交互。 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。 参考文章: https://zhuanlan.zhihu.com/p/28737945https://www.cnblogs.com/pony1223/p/7608955.htmlhttps://juejin.im/post/59b78dfe5188257e7e115caehttps://www.jianshu.com/p/72764b69d6cf]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子网划分的经典实例]]></title>
    <url>%2F%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[案例:例1:一家集团公司有12家子公司，每家子公司又有4个部门。上级给出一个172.16.0.0/16的网段，让给每家子公司以及子公司的部门分配网段。 例2:某集团公司给下属子公司甲分配了一段IP地址192.168.5.0/24，现在甲公司有两层办公楼（1楼和2楼），统一从1楼的路由器上公网。1楼有100台电脑联网，2楼有53台电脑联网。如果你是该公司的网管，你该怎么去规划这个IP？ 例3:请问 192.168.10.0/26 有多少子网?每个子网有多少主机?有多少合法子网?每个子网的广播地址是多少?哪些是合法主机号? 分析:例1：通过子网数来划分子网，未考虑主机数。 例2：通过计算主机数来划分子网。 例1 思路：既然有12家子公司，那么就要划分12个子网段，但是每家子公司又有4个部门，因此又要在每家子公司所属的网段中划分4个子网分配给各部门。 例1步骤：A. 先划分各子公司的所属网段。 有12家子公司，那么就有2的n次方≥12，n的最小值=4。因此，网络位需要向主机位借4位。那么就可以从172.16.0.0/16这个大网段中划出2的4次方=16个子网。 详细过程： 先将172.16.0.0/16用二进制表示 10101100.00010000.00000000.00000000/16 借4位后（可划分出16个子网）： 1) 10101100. 00010000 . 00000000.00000000/20【172.16.0.0/20】 2) 10101100.00010000.00010000.00000000/20【172.16.16.0/20】 3) 10101100.00010000.00100000.00000000/20【172.16.32.0/20】 4) 10101100.00010000.00110000.00000000/20【172.16.48.0/20】 5) 10101100.00010000.01000000.00000000/20【172.16.64.0/20】 6) 10101100.00010000.01010000.00000000/20【172.16.80.0/20】 7) 10101100.00010000.01100000.00000000/20【172.16.96.0/20】 8) 10101100.00010000.01110000.00000000/20【172.16.112.0/20】 9) 10101100.00010000.10000000.00000000/20【172.16.128.0/20】 10) 10101100.00010000.10010000.00000000/20【172.16.144.0/20】 11) 10101100.00010000.10100000.00000000/20【172.16.160.0/20】 12) 10101100.00010000.10110000.00000000/20【172.16.176.0/20】 13) 10101100.00010000.11000000.00000000/20【172.16.192.0/20】 14) 10101100.00010000.11010000.00000000/20【172.16.208.0/20】 15) 10101100.00010000.11100000.00000000/20【172.16.224.0/20】 16) 10101100.00010000.11110000.00000000/20【172.16.240.0/20】 我们从这16个子网中选择12个即可，就将前12个分给下面的各子公司。每个子公司最多容纳主机数目为2的12次方-2=4094。 B. 再划分子公司各部门的所属网段 以甲公司获得172.16.0.0/20为例，其他子公司的部门网段划分同甲公司。 有4个部门，那么就有2的n次方≥4，n的最小值=2。因此，网络位需要向主机位借2位。那么就可以从172.16.0.0/20这个网段中再划出2的2次方=4个子网，正符合要求。 详细过程： 先将172.16.0.0/20用二进制表示 \10101100. 00010000. 00000000.00000000/20 借2位后（可划分出4个子网）： ① 10101100.00010000.00000000.00000000/22【172.16.0.0/22】 ② 10101100.00010000.00000100.00000000/22【172.16.4.0/22】 ③ 10101100.00010000.00001000.00000000/22【172.16.8.0/22】 ④ 10101100.00010000.00001100.00000000/22【172.16.12.0/22】 将这4个网段分给甲公司的4个部门即可。每个部门最多容纳主机数目为2的10次方-2=1024 例2思路:我们在划分子网时优先考虑最大主机数来划分。在本例中，我们就先使用最大主机数来划分子网。101个可用IP地址，那就要保证至少7位的主机位可用（2的m次方-2≥101，m的最小值=7）。如果保留7位主机位，那就只能划出两个网段，剩下的一个网段就划不出来了。但是我们剩下的一个网段只需要2个IP地址并且2楼的网段只需要54个可用IP，因此，我们可以从第一次划出的两个网段中选择一个网段来继续划分2楼的网段和路由器互联使用的网段。 例2 步骤：根据需求，画出下面这个简单的拓扑。将192.168.5.0/24划成3个网段，1楼一个网段，至少拥有101个可用IP地址；2楼一个网段，至少拥有54个可用IP地址；1楼和2楼的路由器互联用一个网段，需要2个IP地址。 A. 先根据大的主机数需求，划分子网因为要保证1楼网段至少有101个可用IP地址，所以，主机位要保留至少7位。 先将192.168.5.0/24用二进制表示： 11000000.10101000.00000101.00000000/24 主机位保留7位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.00000000/25【192.168.5.0/25】 ② 11000000.10101000.00000101.10000000/25【192.168.5.128/25】 1楼网段从这两个子网段中选择一个即可，我们选择192.168.5.0/25。 2楼网段和路由器互联使用的网段从192.168.5.128/25中再次划分得到。 B. 再划分2楼使用的网段2楼使用的网段从192.168.5.128/25这个子网段中再次划分子网获得。因为2楼至少要有54个可用IP地址，所以，主机位至少要保留6位（2的m次方-2≥54，m的最小值=6）。 先将192.168.5.128/25用二进制表示： 11000000.10101000.00000101.10000000/25 主机位保留6位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.10000000/26【192.168.5.128/26】 ② 11000000.10101000.00000101.11000000/26【192.168.5.192/26】 2楼网段从这两个子网段中选择一个即可，我们选择192.168.5.128/26。 路由器互联使用的网段从192.168.5.192/26中再次划分得到。 C. 最后划分路由器互联使用的网段路由器互联使用的网段从192.168.5.192/26这个子网段中再次划分子网获得。因为只需要2个可用IP地址，所以，主机位只要保留2位即可（2的m次方-2≥2，m的最小值=2）。 先将192.168.5.192/26用二进制表示： 11000000.10101000.00000101.11000000/26 主机位保留2位，即在现有基础上网络位向主机位借4位（可划分出16个子网）： ① 11000000.10101000.00000101.11000000/30【192.168.5.192/30】 ② 11000000.10101000.00000101.11000100/30【192.168.5.196/30】 ③ 11000000.10101000.00000101.11001000/30【192.168.5.200/30】 ………………………………… ④ 11000000.10101000.00000101.11110100/30【192.168.5.244/30】 ⑤ 11000000.10101000.00000101.11111000/30【192.168.5.248/30】 ⑥ 11000000.10101000.00000101.11111100/30【192.168.5.252/30】 路由器互联网段我们从这16个子网中选择一个即可，我们就选择192.168.5.252/30。 D. 整理本例的规划地址1楼：网络地址：【192.168.5.0/25】 最小地址为11000000 10101000 00000101 00000000 即 192.168.5.0 最大地址为11000000 10101000 00000101 01111111 即 192.168.5.127 主机位全0全1的不能作为主机IP，因为主机位全1 的要用来作 广播地址即192.168.5.127 剩下的可以分配作为主机的IP 主机IP地址：【192.168.5.1/25—192.168.5.126/25】 广播地址：【192.168.5.127/25】 2楼：网络地址：【192.168.5.128/26】 主机IP地址：【192.168.5.129/26—192.168.5.190/26】 广播地址：【192.168.5.191/26】 路由器互联： 网络地址：【192.168.5.252/30】 两个IP地址：【192.168.5.253/30、192.168.5.254/30】 广播地址：【192.168.5.255/30】 快速划分子网确定IP: 以例2为例：题目需要我们将192.168.5.0/24这个网络地址划分成能容纳101/54/2个主机的子网。因此我们要先确定主机位，然后根据主机位决定网络位，最后确定详细的IP地址。 ① 确定主机位 将所需要的主机数自大而小的排列出来：101/54/2，然后根据网络拥有的IP数目确定每个子网的主机位：如果2的n次方-2≥该网段的IP数目，那么主机位就等于n。于是，得到：7/6/2。 ② 根据主机位决定网络位 用32减去主机位剩下的数值就是网络位，得到：25/26/30。 ③ 确定详细的IP地址 在二进制中用网络位数值掩盖IP前面相应的位数，然后后面的为IP位。选取每个子网的第一个IP为网络地址，最后一个为广播地址，之间的为有效IP。得到： 【网络地址】 【有效IP】 【广播地址】 【192.168.5.0/25】【192.168.5.1/25-192.168.5.126/25】【192.168.5.127/25】 【192.168.5.128/26】【192.168.5.129/26-192.168.5.190/26】【192.168.5.191/26】 【192.168.5.192/30】【192.168.5.193/30-192.168.5.194/30】【192.168.5.195/30】 例3: 分析首先就是要理解/26的意思。首先一看就是个C类地址，所以其默认子网掩码是255.255.255.0。这个子网掩码是由3个.来分隔的，而且这是10进制表示出来的，把它化为2进制=11111111.11111111.11111111.00000000前面是24个1。所以默认的C类子网掩码被写成/24。 这道题是/26，也就是有26个1，写出来就是11111111.11111111.11111111.11000000。把它划成10进制就是255.255.255.192, 现在知道了子网掩码就可以回答那5个问题了 1.有多少个子网？ 这有个公式的。子网数目=2的X次方，这里的X是指掩码位数，掩码为数可以用我们现在的子网掩码的1的为数减去默认的1的位数。这道题有子网掩码有26个1，而C类默认有24个1，所以就是26-24=2。子网数=2的2次方=4 2.每个子网的主机数？ 这还是由公式的。子网主机数=2的Y次方-2，这里的Y是非掩码位的位数，即子网掩码中0的个数，刚才已经知道有26个1了，那剩下的就都是0了，一共有32位，现在有26个1剩下的就只有6个0。所以子网主机数=2的6次方-2=62 3.哪些是合法子网？ 这里牵扯了块这个概念，块=256 - 子网掩码。这里就是 - 192 ，所以这道题块=64 ，知道了块就把块从0开始加，一直加到256，这之间的数就是合法子网。0+64=64 64+64=128 128+62=192 192+64=256 所以合法子网就是0 64 128 192 4.每个子网的广播地址是多少？ 广播地址=下一个子网号-1 所以0子网的广播地址是63；64子网的广播地址是127；128子网的广播地址是191；192子网的广播地址是255 5.哪些是合法主机号？ 合法主机号是那些介于个子网之间的取值，并要减去全0和全1的主机号，例如：64是子网号码，127是广播地址，那么65–126就是合法地址。 所以0子网的合法地址是1–62；64子网的合法地址是65–126；128子网的合法地址是129==190；192子网的合法地址是193–254 总结:子网划分无非涉及到这些内容: 1.有多少子网 2.每个子网有多少主机 3.有多少合法子网 4.每个子网的广播地址是多少: 广播地址下一个子网号-1 5.哪些是合法主机号]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>子网划分实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识计算机网络]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[前言: 计算机网络可以说是连通世界的桥梁，推动发展的催化剂，正是计算机网络技术让信息传播速度更快，让我们能随时随地在线看视频、听音乐、查资料、看新闻、分享资源,试想一下如果没有计算机网络这门学科，我们的世界还会有今天这么繁荣吗？ 一、计算机网络是什么？ 计算机网络技术是通信技术与计算机技术相结合的产物。计算机网络是按照网络协议，将地球上分散的、独立的计算机相互连接的集合。连接介质可以是电缆、双绞线、光纤、微波、载波或通信卫星。计算机网络具有共享硬件、软件和数据资源的功能，具有对共享数据资源集中处理及管理和维护的能力． 二、发展历史：其发展经历了四个阶段: ①:20世纪50~60年代，出现以单个计算机为中心的远程连机系统，构成面向终端的计算机网络； ②:20世纪60~70年代，出现了多个主计算机通过通信线路互连的计算机网络。ARPANET投入使用； ③:20世纪70~80年代，出现具有统一的网络体系结构，遵循国际标准化协议的计算机网络。 ④:从90年代算起，网络互联与高速网络。 我国在1980年开始进行计算机联网实验，1989年，我国第一个分组交换网CNPAC建成运行. 三、特点：①: 连通性 ②: 共享 四、分类：4.1 按作用范围分类:①: WAN（Wide Area Network）广域网：几十到几千KM ②: MAN（Metropolitan Area Network）城域网：一个城市（5~50KM） ③: LAN（Local Area Network）局域网：1KM左右 ④: PAN（Personal Area Network）个人区域网：10m左右 4.2 按传输介质分类:①: 有线网：是采用同轴电缆或双绞线连接的计算机网络。同轴电缆网是常见的一种连网方式，它比较经济，安装较为便利，传输率和抗干扰能力一般，传输距离较短。双绞线网是目前最常见的连网方式。它价格便宜，安装方便，但易受干扰，传输率较低，传输距离比同轴电缆要短。 ②: 光纤网：也是有线网的一种，但由于其特殊性而单独列出。光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。但其成本较高，且需要高水平的安装技术。 ③: 无线网：用电磁波作为载体来传输数据，目前无线网联网费用较高，还不太普及。但由于联网方式灵活方便，是一种很有前途的连网方式。 局域网通常采用单一的传输介质，而城域网和广域网采用多种传输介质。 4.3 按通信方式分类:①: 点对点传输网络：数据以点到点的方式在计算机或通信设备中传输。星型网、环形网采用这种传输方式。 ②: 广播式传输网络：数据在公用介质中传输。无线网和总线型网络属于这种类型。 五、应用:①: 通信服务: 如在线聊天（飞信,MSN、QQ等）、E-mail 、IP 电话等服务 ②: 多媒体信息服务: 包括网上娱乐、网络电视、电视会议、WWW服务、远程教育和音乐点播等。 ④: 办公自动化: 将一个单位的其它办公设备与办公用计算机连接成网络, 加强了外部和单位内部的沟通与联系，加快单位内部的信息流动，提高工作效率，并有利于减少日常开支。 ⑤: 网上交易: 在线购物,转账等 六、什么是ISP:ISP(互联网服务提供商) 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。如中国移动,中国联通,中国电信就是ISP 七、主机之间的通信方式:7.1 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 7.2 对等（P2P）： ①：不区分客户和服务器。这里使用数字2，是因为英文的2是two，读音与to相同，所以to缩写为2②：任意端系统/节点之间可以直接通讯③：节点可能改变IP地址节点间歇性接入网络没有永远在线的服务器 八、电路交换与分组交换,报文交换:8.1 电路交换:①: 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 ②: 复用：时分多路复用：频分多路复用：在不同的频带（载波）上传输不同频道码分多路复用：广泛应用于无线链路共享（如蜂窝网，卫星通信等）每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示各用户使用相同频率载波，利用各自的码片序列编码数据各用户码片序列相互正交码片序列与编码信号的内积 8.2 分组交换:每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。报文分拆出来的一系列相对较小的数据包需要报文的拆分与重组会产生额外开销又称统计多路复用(按需共享链路) 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 8.3 报文交换:报文：源发送信息整体，比如一个文件 九、时延:总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 9.1 排队时延:分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 9.2 处理时延:主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 9.3 传输时延: 主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 9.4 传播时延:其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。 十、计算机网络体系结构 10.1 OSI模型:其中表示层和会话层用途如下：表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。会话层 ：建立及管理会话 10.2 五层协议模型:应用层 ： 为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ： 为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ： 负责源主机到目的主机数据分组（Packet）交付,可能穿越多个网络 功能: 分组转发,路由 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ： 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ： 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 10.3 TCP/IP模型: 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 十一、数据在各层之间的传递过程:在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、初始化配置:1.1 指定客户端用户名和邮箱，为了标记是谁向远程库传送数据 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 1.2查看用户名：$ git config user.name 1.3查看邮箱： $ git config user.email 1.4修改用户名：$ git config --global user.name &quot;cyx&quot; 1.5修改邮箱： $ git config --global user.email &quot;328978553@qq.com&quot; 1.6查看配置是否生效： $ git config --list 二、目录文件相关:2.1创建目录： $ mkdir /d/softwear/Program （“mkdir” 是“make Directory”; “/d/softwear/”是要创建目录的位置 “Program” 是新创建的目录） 2.2定位到Program指定目录： $ cd /d/软件/Program 2.3输出当前目录地址： $ pwd 2.4让之前创建的目录作为git可操作的仓库，此时再去刚才创建的program目录下会发现多了一个.git目录： $ git init 2.5查看当前仓库的隐藏目录，以及文件： $ ls –ah 2.6查看当前仓库的文件： $ ls 三、本地仓库关联远程库:3.1关联Github远程库：$ git remote add origin git@server-name(服务器名即github用户名)/repo-name.git(远程仓库名.git) 如：$ git remote add origin git@zzwwqq/blog.git； 3.2关联码云远程库：$ git remote add origin git@gitee.com:zwqzeq/Login_Register.git 四、操作远程仓库:4.1显示远程库的详细信息： $git remote -v 4.2本地master分支内容推送到远程库的master分支： 第一次$ git push -u origin master 以后 直接$ git push origin master 4.3删除远程库： $ git remote rm origin (origin远程库默认名称，建议不改) 4.4从远程库克隆： $ git clone git@github.com:zwqzeq/gitskills.git 4.5将本地仓库指定分支合并到远程仓库指定分支： $ git push origin dev_branch : dev_branch 4.6强行让本地分支覆盖远程分支： $ git push 远程库名 远程库的分支名 -f 4.7将远程仓库的某个分支合并到当前本地分支： $ git pull 远程仓库名 远程仓库的分支名 五、文件保存和提交:5.1将文件从工作区添加到暂存区： $ git add &lt;file&gt; 将所有文件从工作区添加到暂存区：$ git add . 5.2将文件从暂存区提交到版本库： $ git commit -m “提交说明” 5.3随时查看当前仓库的状态： $ git status 5.4查看修改了具体修改了那些内容： $ git diff &lt;file&gt; 六、日志相关：6.1查看提交历史（只有commit过的才能查到），以便确定要回退到哪个版本： $ git log 6.2如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline 6.3如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline --abbrev-commit 6.4查看命令历史（包括reset，commit，checkout），以便确定要回到未来的哪个版本（不包括从工作区添加（add）到暂存区的命令）： $ git reflog 七、版本回退:7.1退回到上一个版本： $ git reset --hard HEAD^ //针对版本库 7.2退回到上上个版本： $ git reset --hard HEAD^^ 7.3退回到上100个版本： $ git reset --hard HEAD~100 7.4退回到指定版本： $ git reset --hard commit_ID 7.5只丢弃暂存区修改： $ git reset HEAD &lt;file&gt; //针对暂存区，让暂存区恢复之前的状态 7.6只丢弃工作区的修改： $ git checkout --&lt;file&gt; //针对工作区，让工作区恢复之前的状态，即让工作区和暂存区一致，如果没有暂存区，则让工作区和版本库一致，如果该文件既没有添加到暂存区也没有提交到版本库，则工作区中该文件的修改不能被丢弃 八、分支相关:8.1查看分支： $ git branch 8.2创建分支： $ git branch &lt;name&gt; 8.3切换分支： $ git checkout &lt;name&gt;（注意与恢复文件的区别，此处checkout后面没有“–”） 8.4创建+切换分支： $ git checkout -b &lt;name&gt; 8.5合并某分支到当前分支： $ git merge &lt;name&gt; 8.6删除分支： $ git branch -d &lt;name&gt; 8.7重命名分支： $ git branch -m old_branch new_branch 8.8看到分支合并情况： $ git log --graph --pretty=oneline --abbrev-commit 8.9可以禁用快速合并dev方式： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev 8.10删除一般的分支： $ git branch -d &lt;name&gt; 8.11丢弃一个没有被合并过的分支，可以通过： $ git branch -D &lt;name&gt; //强行删除 九、标签相关：9.1默认标签是打在当前分支最新提交的commit上: $ git tag &lt;name&gt; 9.2指定一个commit id，给其打上标签，即以后标签可代表commit id: $ git tag &lt;name&gt; commit_id 9.3查看所有标签名： $ git tag 9.4查看标签信息： $ git show &lt;tagname&gt; 9.5指定标签信息： $ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; commit_ID 9.6删除本地标签： $ git tag -d v0.1 9.7推送某个标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin &lt;tagname&gt; 9.8推送所有标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin --tags 9.9删除远程标签：如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除： $ git tag -d v0.9 $ git push origin :refs/tags/v0.9 十、临时保存工作现场：10.1前工作现场“储藏（或称隐藏）”起来，等以后恢复现场后继续工作： $ git stash 10.2查看某个分支上隐藏工作区： $ git stash list 10.3恢复工作现场：两种方式： 方式一：用$ git stash apply恢复,但是恢复后,stash内容并不删除,你需要用$ git stash drop来删除； 方式二：用$ git stash pop,恢复的同时把stash内容也删了 10.4 何时需要使用git stash临时保存工作现场? 在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。 可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。 该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Git]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Git.html</url>
    <content type="text"><![CDATA[前言: 你是否有这样的经历：写word文档时,想删除一部分内容，又怕将来想恢复找不回来怎么办？常见办法就是先把当前文件“另存为”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件.改到最后你自己都分不清,哪个文件里面是修改了什么. 如果有，那么恭喜你，以后不会再有这种事情发生了，git能帮你管理文件. 一、git是什么?Git是目前世界上最先进的分布式版本控制系统（没有之一）. 二、git的历史背景: 很多人都知道，Linus（李纳斯）在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。直到2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 三、分布式的git和集中式的CVS/SVN对比: 3.1 联网： 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式版本控制系统最大的毛病就是必须联网才能工作． 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。 3.2 安全性： 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 四、如何安装？在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，(或者鼠标右键,可以找到git Bash)蹦出一个类似命令行窗口的东西，就说明Git安装成功. 五、工作流:新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。 Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 中存有所有分支，使用一个 HEAD 指针指向当前分支。 git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset – files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。 git commit -a 直接把所有文件的修改添加到暂存区然后执行提交 git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作 六、冲突:当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。 Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 七、Fast forward:“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。 可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。 1$ git merge --no-ff -m "merge with no-ff" dev 八、分支管理策略:master 分支应该是非常稳定的，只用来发布新版本； 日常开发在开发分支 dev 上进行。 九、.gitignore 文件:忽略以下文件： 操作系统自动生成的文件，比如缩略图； 编译生成的中间文件，比如 Java 编译产生的 .class 文件； 自己的敏感信息，比如存放口令的配置文件。 不需要全部自己编写，可以到 https://github.com/github/gitignore 中进行查询。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>初识Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[前言:​ 为了方便查阅,这里将常用指令汇总. 简写指令:hexo n &quot;我的博客&quot; 等价于 hexo new &quot;我的博客&quot; 还等价于 hexo new post &quot;我的博客&quot; #新建一篇文章hexo p 等价于 hexo publishhexo g 等价于 hexo generatehexo s等价于 hexo serverhexo d 等价于 hexo deployhexo deploy -g 等价于 hexo deploy --generatehexo generate -d等价于hexo generate --deploy 注: hexo clean 没有 简写, git –version 没有简写 指令说明:hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。hexo server -s #以静态模式启动hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)hexo d #将本地数据部署到远端服务器(如github)hexo init 文件夹名称 #初始化XX文件夹名称npm update hexo -g#升级npm install hexo -g#安装node-v #查看node.js版本号npm -v #查看npm版本号git --version #查看git版本号hexo -v #查看hexo版本号 hexo publish [layout] &lt;title&gt; #通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 hexo new aaa &quot;bbb&quot; # 新建一篇文章,文章名称和标题分别为bbb.md 和 bbb. 文章采用aaa布局, 此时会在站点根目录下的—-&gt;source—–&gt;_post文件夹下生成bbb.md文件, bbb.md文件的顶部(—–分割线上方区域,也称作Front matter区),生成 layout: aaatitle:date:]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化配置]]></title>
    <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[前言: 如果你觉得我的博客界面不错，你可以参考这篇文章，在这篇文章中总结了几十个个性化配置，并不是都要安装，取你所需即可． 一、常用的个性化配置汇总： １．更换主题 ２．设置语言 ３．字数统计和阅读时长(网站底部/文章内) ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量） ５．本站已安全运行 XX天 XX小时XX分XX秒 ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例 ７．添加热度（文章阅读次数） ８．为博客加上宠物 ９．鼠标点击出现桃心效果 １０．网页底部的动态桃心图像 １１．添加顶部加载条 １２．设置网站的图标Favicon １３．DaoVoice 在线联系 １４．添加AddThis分享 １５．添加打赏 １６．文章加密访问 １７．在文章底部增加版权信息 １８．修改文章底部的那个带#号的标签 １９．在每篇文章末尾添加“本文结束”标记 ２０．修改作者头像并旋转 ２１．隐藏网页底部powered By Hexo / 强力驱动 ２２．在右上角或者左上角实现fork me on github ２３．修改代码块自定义样式（设置代码高亮主题） ２４．开启代码块复制 ２５．侧边栏社交链接 ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２７．修改背景图,以及侧边栏顶部颜色 ２８．侧边栏添加网易云音乐 ２９．底部添加公网安备 ３０．取消“文章目录”的自动编号 ３１．封面模式 １．更换主题: (以next主题为例)注: next 主题的 github仓库地址迁移了 １．１ 下载主题:旧版本next主题地址: 5以下的版本包含5: 旧版本5以下 安装指令: 首先打开git bash进入根目录即 “ /blog/“ 执行命令:git clone https://github.com/iissnan/hexo-theme-next themes/next 此时会从next主题的作者的github仓库克隆next主题到 我们本地的 /blog/theme/next文件夹下 最新版在这里下载: 新版本6开始 安装指令: 同上 git clone https://github.com/theme-next/hexo-theme-next themes/next 安装完成后，打开 站点配置文件,找到 theme 字段，并将其值更改为 next, 一定要保存 依次执行git clean，git g,git s 然后查看运行结果: nexT主题有四种选择，上面这个只是最简洁的一种，我选择的是Gemini布局。 １．２ 修改主题配置文件： 然后重新git clean，git g，git s查看效果: ２．设置语言：在站点配置文件中设置语言: 12language: zh-Hans next5以下版本(包含)language: zh-CN next6以上版本(包含) ３．字数统计和阅读时长(网站底部/文章内):３．１ 首先安装插件: $ npm install hexo-symbols-count-time --save ３．２ 然后修改主题配置文件如下: 123456symbols_count_time: separated_meta: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_post: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true ＃底部footer是否显示字数统计属性文字(如站点总字数,站点阅读时长 ≈ 1 分钟) awl: 4 ＃计算字数的一个设置,没设置过 wpm: 275 ＃一分钟阅读的字数 ３．３ 站点配置文件中添加： 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 注意: 配置文件中的空格** ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量）打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站总访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;| &lt;/span&gt;&lt;span id="busuanzi_container_site_pv"&gt; &amp;nbsp;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; ５．本站已安全运行 XX天 XX小时XX分XX秒打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910111213141516&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250);&lt;/script&gt; ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例:先注册leancloud账号,获取自己的appid,appkey 打开主题配置文件,修改如下: 1234567891011valine: enable: true # 为true时启用评论 appid: # 这里填写上面得到的APP ID 注意空一格再输入ID和key, appkey: # 这里填写上面得到的APP KEY notify: false # 邮件通知 verify: false # 验证码 placeholder: #评论框中预设的文字,随意填写 avatar: mm # gravatar style 头像,采用gravatar头像,到http://cn.gravatar.com/了解 guest_info: nick,mail,link # custom comment header 访客信息,显示在评论框上面,三者可随意选择或全选 pageSize: 10 # pagination size 评论分页大小 visitor: false # ７．添加热度（文章阅读次数）修改主题配置文件 1234leancloud_visitors: enable: true app_id: #填入你leancloud账号的appid app_key: #填入你leancloud账号的appkey 打开/blog/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/blog/themes/next/languages/zh-Hans.yml,将画红框的改为热度就OK了 ８．为博客加上宠物８．１ 在hexo根目录下安装插件: $ npm install -save hexo-helper-live2d ８．２ 安装需要的宠物插件:宠物样式 源码地址 $ npm install {packagename} 其中{packagename} 替换为你要安装的宠物名,如live2d-widget-model-shizuku 具体指令: $ npm install live2d-widget-model-shizuku ８．３ 在站点配置文件中加上如下代码: 1234567891011live2d: enable: true #开启宠物 scriptFrom: local model: use: live2d-widget-model-shizuku display: position: right #指定宠物显示的位置 width: 70 #指定宠物显示的宽度 height: 120 #指定宠物显示的高度 mobile: show: true #是否在手机上显示 ９．鼠标点击出现桃心效果并且将代码复制进去，然后保存 在/themes/next/source/js/src里面 新建click-love.js文件: 粘贴如下代码: 12&lt;!-- 页面点击小桃心--&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 然后打开\themes\next\layout\_layout.swig文件,在末尾添加以下代码： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); １０．网页底部的动态桃心图像修改主题配置文件: 1234icon: name: heart #如果name的值为heart表示引用fontawesome网站上的心形图标 animated: true #如果想用动态图标应该将animated的值设为true color: "#ff0000" #图标的色--用16进制数 １１．添加顶部加载条在根目录打开git bash执行以下指令: 1git clone https://github.com/theme-next/theme-next-pace source /lib/pace 修改主题配置文件: 12pace: true #启用顶部加载条pace_theme: pace-theme-flash #指定顶部加载条样式 １２．设置网站的图标Favicon１２．１ 下载一个32*32的图片，并改名为favicon.ico, 然后放到/blog/themes/next/source/images目录 １２．２ 修改主题配置文件 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg １３． DaoVoice 在线联系１３．１ 注册地址: ,获取app_id １３．２ /blog/themes/next/layout/_partials/head/head.swig 添加下面的代码: 123456789101112131415&#123;% if theme.custom_file_path.head %&#125; &#123;% set custom_head = '../../../../../' + theme.custom_file_path.head %&#125;&#123;% else %&#125; &#123;% set custom_head = '../../_custom/head.swig' %&#125;&#123;% endif %&#125;&#123;% include custom_head %&#125;&#123;% if theme.daovoice %&#125; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0eeeae6f.js","daovoice") daovoice('init', &#123; app_id: "06289ecd"&#125;);daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; １３．３ 修改主题的配置文件 12daovoice: truedaovoice_app_id: 我们注册获取的id １４．添加AddThis分享１４．１ 在网站 AddThis 上注册账号。 可以使用 Google/Facebook/Twitter 账号进行第三方登陆 １４．２ 设置分享按钮的样式:(显示位置, 显示样式为扩展式,悬浮式等) １４．３ 修改主题配置文件 你Addthis账号ID ```123456789## １５．添加打赏:```javascript reward: enable: true ＃开启 comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ ＃图片上方显示的文本 wechatpay: ＃图片地址 alipay: ＃图片地址 １６．文章加密访问１６．１ 在 /blog/themes/next/layout/_partials/head/head.swig 文件中添加： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; １６．２ 在需要加密的文章的页面顶部(Front matter区域)加入 “password : 设置密码值” １７．在文章底部增加版权信息１７．１ 在/blog/themes/next/layout/_macro/ 下添加 my-copyright.swig文件： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;版权声明:&lt;/span&gt;本博客所有文章除特别声明外，均采用 &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt;BY-NC-SA &lt;/a&gt;许可协议。转载请注明出处!&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; １７．２ 在目录/blog/themes/next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; １７．３ 修改/blog/themes/next/layout/_macro/post.swig，在下面位置添加: 代码如下: 12345 &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １７．４ 修改/blog/themes/next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： @import &quot;my-post-copyright 保存重新生成即可。１７．５ 如果要在文章下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: hexo个性化配置date: 2017-05-22 22:53:53tags: hexo美化categories: Hexocopyright: true--- 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： １８．修改文章底部的那个带#号的标签修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; １９．在每篇文章末尾添加“本文结束”标记１９．１ 在路径 /blog/themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; １９．２ 接着打开/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer之前添加,即在如下位置添加 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １９．３ 然后打开主题配置文件（_config.yml),在末尾添加： 123#文章末尾添加“本文结束”标记passage_end_tag: enabled: true ２０．修改侧边栏作者头像并旋转：２０．１ 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; ２１．隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： ２2．在右上角或者左上角实现fork me on github点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 /blog/themes/next/layout/_layout.swig文件中进行配置. next表示的是当前你使用的主题的样式. 注意的是: href 后面是自己的github的地址,记得修改哦! ２３．修改代码块自定义样式修改主题配置文件 highlight_theme: night bright #可选值: normal | night | night eighties | night blue | night bright ２４．开启代码块复制123codeblock: enable: true show_result: true ２５．侧边栏社交链接修改主题配置文件: 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址 123456789101112131415161718#设置侧边栏社交链social: GitHub: https://github.com/zzwwqq || github E-Mail: mailto:zwq13264860490@gmail.com || envelope Weibo: https://weibo.com/u/5564810309/home?wvr=5 || weibo 知乎: https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities || snapchat#这里键的值必须和上面social中的 "||" 后面指定的名称一致，在fontawesome官网找喜欢的小图标，将名字复制在如下位置，如E-Mail:对应的图标名称为envelope。social_icons: enable: true # `enable` 选项用于控制是否显示图标 icons_only: false transition: false #图标 GitHub: github E-Mail: envelope Weibo: weibo 知乎: snapchat ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２６．１ 七牛是什么? 七牛 是一个云存储服务商，注册并实名认证之后1后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。七牛的定位不是像百度云一样的 网盘 ，也不是同坚果云一般的 同步云 ，而是 CDN 2 ，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源。对于个人博主来说，你可以把博客中的图片、音频、视频等媒体上传到七牛，在博客中引用；也可以将站点需要加载的CSS、JS等文件上传到七牛，以加速网站。 ２６．２ 与其他上传站点相比： 更稳定：七牛毕竟是老牌服务商，数据的安全性和稳定性都较有保证。如果上传到什么小网站，哪天发现图片都打不开了才是人间惨剧~ 更灵活：配合 hexo-qiniu-sync 插件4，就算是七牛以后更改了空间域名，也不用一篇一篇地去改外链地址，只要在配置文件中修改外链前缀即可。 更方便：配合 hexo-qiniu-sync 插件，不必”上传→复制链接→引用外链“，直接按照本地路径引用，然后键入一条命令同步到七牛就好。会自动识别哪些是新增、修改的文件需要上传，哪些是原有的文件不需改动，十分方便。 ２６．３ 七牛并非尽善尽美： 在线文件管理不支持目录 本地删除文件，云端不能同步删除文件 ２６．４ 开始安装： １．点击 这里 申请七牛账户 ２．创建存储空间（七牛叫作”Bucket“），注意添加的空间为”对象存储“，访问控制选择”公开空间“： ３．点击页面右上角头像→进入”密钥管理“→复制当前使用中的AK和SK，待会设置插件时会用到。 ４．安装插件：在hexo主目录下运行以下命令： npm install hexo-qiniu-sync --save ５．站点配置文件中添加下面内容: 1234567891011121314151617181920qiniu: offline: false #是否离线. 离线状态将使用本地地址渲染 sync: true #是否同步 bucket: blog #这里替换为你存储空间的名称 #secret_file: sec/qn.json or C: access_key: 2rRw0dG-jQYCoqs9rvsltVQqzSBVpwS #上传密钥AccessKey,替换为你自己的 secret_key: OCBcCU3tqKiBdOza9PlLoR6AcA-fV_u #上传密钥SecretKey,替换为你自己的 dirPrefix: static #上传的资源子目录前缀.如设置为static，那么urlPrefix后面也要加static urlPrefix: http://cdn.zzwwqq.xyz/static/ #这里替换为你自己的外链域名,如何获取,查看下面图示 up_host: http://upload.qiniu.com #这里不用改 local_dir: static #本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的static 文件夹（也就是与 source 目录平级）中。 update_exist: true #是否更新已经上传过的文件 #运行程序后,会自动在本地根目录生成static目录,static目录下生成三个文件夹,js,css,images image: folder: images extend: js: folder: js css: folder: css ６．如何引用七牛上的图片? 引用地址：urlPrefix＋dirPrefix＋images+ 相对于/blog/static/images/ 的文件路径 例如: http://cdn.zzwwqq.xyz/static/images/hexo/hexo-1.jpg ２７．修改背景图,以及侧边栏顶部颜色，主／副标题颜色效果图： 123456789101112131415161718192021//添加背景图片body &#123; background:url(http://cdn.zzwwqq.xyz/%E6%98%9F%E7%A9%BA.jpg)&#125;//改掉题头颜色.site-meta &#123;background:url(http://cdn.zzwwqq.xyz/static/images/hexo/hexo-0-site-meta.jpg) &#125;//主标题颜色.brand&#123; color: #4dfc23 &#125;//副标题颜色.site-subtitle&#123; color: #4dfc23&#125;.footer&#123; font-size: 14px; color: #ededed;&#125; ２８．侧边栏添加网易云音乐效果图: 打开网易云音乐官网，进入想插入的音乐的界面 点击“生成外链播放器” 复制代码 ##２９．底部添加公网安备 12345 &lt;div class="BbeiAn-info" style="color:#4dfc23"&gt; &#123;&#123; __('鄂ICP备') &#125;&#125; - &lt;a target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#4dfc23;" rel="nofollow"&gt;18025394&lt;/a&gt; &lt;!--a标签中增加nofollow属性，避免爬虫出站。--&gt;| &lt;a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42090202000295" style="text-decoration:none;color:#4dfc23;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow"&gt;&#123;&#123; __('鄂公网安备 42090202000295') &#125;&#125;&lt;/a&gt; &lt;!--这里将图标作为了背景，以使得能和后面的文字在同一行--&gt;&lt;/div&gt; ３０．取消“文章目录”的自动编号 修改如下 修改后: ３１．封面模式需要安装一个小插件是：hexo-less，安装指令: $ npm install --save hexo-less 该插件解决了什么问题呢？ 手动设置文章概要，但不影响章内䆟。只需在文章中写 &lt;!-- less --&gt; 作为分割线， &lt;!-- less --&gt; 上面的内容会作为摘要，但不作为文章内容的一部分。 举例，我想让这篇文章在主页列表中，只显示一张美图。 效果图： 文章中代码如下: 二、说明:修改hexo的站点配置文件,需要重启服务器(即执行 $ hexo s命令),才能生效. 修改其他文件如主题配置文件,不必重启服务器(即执行 $ hexo s命令), 直接刷新页面即可生效. 参考链接: http://theme-next.iissnan.com/getting-started.html https://www.jianshu.com/p/f054333ac9e6 https://www.jianshu.com/p/d0fe52c73950 https://xian6ge.cn/posts/40ba2cba/ https://me.idealli.com/post/e8d13fc.html http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/ https://www.jianshu.com/p/805bd0b65d98]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo发布文章]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[前言: 经过前面两节的操作，hexo的整个框架以及和github关联已经配置好了,现在我们要考虑的就是 如何用指令去创建一篇文章,然后发布? .我们先来看一下hexo的目录结构,了解每个目录的作用,这将让我们对hexo的运行原理有一个大概的认识,对于我们后面美化主题是有帮助的, 然后再来创建文章,并发布到本地服务器,最后查看效果. 一、Hexo的目录分析: １．.deploy_git: 这个目录是执行 hexo d 命令 后生成的,主要存放部署的信息. ２．node_modules: 这个目录存放的是一些插件包 ３．public : 这个目录是执行 hexo g后生成的, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下 ４．scaffolds: 用来存放模板文件。模板文件的正文部分一般为空，一般在模板文件顶部有一个区域 ( 以 --- 分隔的区域) 称作Front-matter,在这里配置的变量主要有title(即文章标题), date(即文章创建日期),comment(是否开启评论), tags(文章标签), categories(文章所属分类)等. 当你新建文章时，Hexo 会根据 scaffold 来建立文件，也就是说会在你创建的每个文件顶部自动加上模板文件中配置的这些内容. ５．source: 存放你的文章(.md后缀的文件) ６．static: 这个目录是我自己创建的，专门用来存放图片的 ７．themes: 这个目录是存放主题的(默认主题是landscape, 目前使用最多的是next主题) ８．.gitignore: 这个文件和git有关, 在这个文件里面可以配置哪些文件不被提交(例如: 配置 *.log ,那么在hexo d命令的时候, 任何以.log为后缀的文件将不会被提交到github) ９．_admin-config.yml: 这个文件是安装了hexo 后台管理插件后生成的,这里暂时不作介绍,后面再说 １０．_config.yml: 这个文件是hexo的核心配置文件(也称站点配置文件) １１．_config.yml.back.yml: 这个文件是我自己创建的,是站点配置文件的备份. 以防哪一天老眼昏花把内容改错了,到时可以恢复. １２．package.json: 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 １３．db.json： １４．package-lock.json: 二、使用Hexo指令创建一篇文章:​ $ hexo new [layout] &lt;title&gt; 这里有必要对指令作一些说明: 就[layout]即＂布局＂ 而言:Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局: 路径: 说明: post source/_posts 如果你输入的指令中[layout]参数空着,那么默认是post;例如:hexo new 我的第一篇文章;等价于:hexo new post 我的第一篇文章; 产生的作用就是: 在source/_posts路径下生成 “我的第一篇文章.md” 文件,这个就是你要写文章的那个文件. page source draft source/_drafts 你可以通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 就&lt;title&gt;而言:默认是指定文章的标题和.md文件名称, 你可以任意指定一个名称来取代指令中的&lt;title&gt;参数. 注: 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 三、举例: 需求: 我要创建一篇文章,文件名为 “使用hexo发布文章” 文章标题为”使用hexo发布文章” 并且自动在文件顶部(Front-Matter区域),添加文章分类,标签 的键, 键对应的值由我们自己添加.最后发布到本地服务器查看效果. 首先修改模板文件: 打开git bash 执行指令: 查看生成文件所在目录以及文件名: 查看生成的文章, 文章标题,分类,标签等是否自动添加了: 给文章添加分类,和标签: 发布文章到本地服务器: $ hexo clean $ hexo g $ hexo s 查看效果: 四、给文章添加多个标签有两种方式: 第一种： tags: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39; ] 第二种： 1234tags: - abc- def- xxx 注意空格 五、说明: 通过上面的操作后，你可能会感到奇怪，为什么自己的界面和图示的不一样呢？这里我得解释下，在第一节安装hexo时,hexo默认给我们安装了ｌａｎｄｓｃａｐｅ主题. 这个主题可以在 “/blog/themes” 路径下找到. 而我安装的是next主题,并做了些个性化配置. 所以和你的界面不同. 如果你和我一样对默认主题不满意,喜爱折腾,追求完美,那么请关注下一节内容.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>使用hexo发布文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署到GitHub]]></title>
    <url>%2Fhexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub.html</url>
    <content type="text"><![CDATA[前言: 上一节我们已经将hexo部署到本地了，但是只有在你自己主机上才能查看博客，如果你想让任何人随时随地都能访问到你的博客，那么你可以考虑将hexo部署到github(属于国外,所以访问速度要慢一些)或者codying(国内),如果你是一个程序员,那么推荐你选择github, 你要是不知道GitHub， 那就太说不过去了， 我可能遇到了一个假的程序员！ 步骤: １．注册一个github账号: 注册 ２．回到你的本地机,打开git bash,设置用户名和邮箱:(目的是:上传文件的时候告诉github,是谁向远程仓库上传数据) $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 注: 这里”Your Name” 替换为你的GitHub的用户名,”email@example.com“替换为你的GitHub的邮箱 输入完后,通过以下命令检查你的设置是否正确: (如果你比较懒,那就忽略吧!) $ git config user.name $ git config user.email ３．生成ＳＳＨ密钥并添加到github： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 此时它会告诉你已经生成了.ssh的文件夹, 在你的电脑中找到它,复制id_rsa.pub 文件中的内容. 此时回到GitHub页面 ​ 然后回到gitbash中，输入指令查看是否添加成功: $ ssh -T git@github.com ；如果你看到以下内容，恭喜你配置成功了． ４．创建github仓库: ​ ​ 选择一个主题: (临时测试用,等会会覆盖的) 浏览器地址栏输入用户名.github.io：如果出现下面的界面说明你的域名已经生效 ５．将Hexo部署到github: 经过上面的操作后,此时我们就可以将hexo和GitHub关联起来了,也就是将hexo生成的文章部署到github 打开站点配置文件(/blog/_config.yml), 翻到最后,找到deploy: 修改为:​ 123deploy: type: git repo: github: git@github.com:zzwwqq/zzwwqq.github.io.git,master 说明: master 表示 部署到远程仓库的master分支上 git@github.com:zzwwqq/zzwwqq.github.io.git 改为你的仓库地址, 你可以去github网页上拷贝 安装deploy-git, 也就是部署的命令,这样你才能用命令部署到GitHub. $ npm install hexo-deployer-git --save 然后执行下述命令: hexo clean hexo g hexo d 执行了hexo d后 ,如果最后一行显示如下内容,说明部署成功, 现在你可以去浏览器地址栏输入 你的域名进行访问了.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo部署到GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[１．帮助：(查看指令的详细信息)1.1 xxx --help (xxx -h) 1.2 man xxx ２．查看哪个程序占用了特定端口？占用某个端口的进程是谁?2.1 lsof -i -n -P | grep :80 //查看哪个程序占用了特定端口 2.2 lsof -i//显示所有打开的端口 2.3 lsof -i:80 //显示所有打开80端口的进程 2.4 lsof -n //不将IP转换为hostname，缺省是不加上-n参数 -P //port numbers to port names; ３．查看磁盘使用情况： 查看磁盘中指定目录的使用情况：du -ach --max-depth=1 指定目录的路径 查看系统磁盘占用情况：df -lh ４．进程相关操作： 查看系统执行的进程（不包括父进程）：ps -aux | more (ps -aux | grep xxxx) 查看当前所有进程，包括父进程：ps -ef | more (ps -ef | grep xxxx) 查看系统负载：w 动态查看负载: top 在 top 状态下: 按shift + m，可以按照内存使用大小排序。 按数字 1 可以列出各颗 cpu 的使用状态。 静态查看系统负载：top -bn1 和 top 命令唯一的区别就是，它一次性全部把所有信息输出出来而非动态显示。 查看系统当前剩余多少内存： free -h (-h及human，以方便人阅读方式显示) 杀死进程：kill 进程号 强制杀死进程：kill -9 进程号 按照进程名强制杀死该进程名的所有进程：pkill -9 进程名 按照进程名杀死进程：killall 进程名 ５．查看系统信息： 查看内核版本号：uname -r 查看系统内核版本，gcc编译器版本详细信息： cat /proc/version 查看系统信息：cat /etc/redhat-release 查看操作系统版本所有信息: lsb_release -a 查看内存信息 cat /proc/meminfo 查看网卡信息 dmesg | grep -i eth 查看机器型号 dmidecode | grep &quot;Product Name&quot; 查看硬盘信息命令 : fdisk -l 查看主板信息 dmidecode |grep -A16 &quot;System Information$&quot; 查看CPU信息（型号) cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看CPU的主频 cat /proc/cpuinfo |grep MHz|uniq 查看当前CPU运行在32bit还是64bit模式下 getconf LONG_BIT 查看是否支持64bit cat /proc/cpuinfo | grep flags | grep &#39;lm&#39; | wc -l (如果结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit) 查看CPU是几核: cat /proc/cpuinfo |grep &quot;cores&quot;|uniq 逻辑CPU个数：cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l 物理CPU个数： cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l 每个物理CPU中Core的个数： cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l ６．查看网络： 查看当前主机的ip地址和网卡信息: ifconfig （附加网卡的启用ifup eth0与停用stop eth0命令） 查看IP地址信息：ip addr (注：安装minimal版的CentOS系统时，ifconfig等网络相关的指令用不了，暂时可以用ip addr) 测试网络的连通性 : ping (网络统计)命令显示连接信息,路由表信息等: netstat 通常配合使用参数，这里只演示一个参数。netstat -? 打印网络连接状况：netstat -anp （-p表示显示进程名和进程ID） 当前系统启动哪些端口：netstat -lnp （-l表示显示正在监听的端口)netstat指令无效时：使用yum install net-tools安装 路由跟踪命令: traceroute 可以查看到你从源到目的的所经过的路由 查询DNS相关信息记录,CNAME,MX记录等等: dig 这个命令主要用于解决相关DNS查询； ​ nslookup 也具备查询DNS的功能，还可以显示一个ip地址的记录！ 查找到IP的名称或IP的名字在IPv4和IPv6 DNS记录和查询: host IP地址 例如host www.baidu.com 查看主机名: hostname 或者你可以到/etc/sysconfig/network中修改主机名。 查看路由表信息: route 增加和删除路由条目: root add -net 192.168.199.129/24 gw 192.168.199.1 查看默认的表使用: arp 为地址解析协议 查看网络模式和网络速度等信息: ethtool 有关配置可以到/etc/sysconfig/network-scripts/ifcfg-eth0下进行修改。 ７．任务调度： 编辑定时任务：crontab -e 删除：crontab -r 查询：crontab -l 重启：service crond restart ８．压缩/解压缩： 解压到当前目录：tar -zxvf xxx.tar.gz 解压到指定目录：tar -zxvf xxx.tar.gz -C 目标目录 压缩：tar -zcvf 打包后的文件名（以.tar.gz为后缀） 要压缩的文件名 tar里面没有针对xz格式的参数比如 -z是针对 gzip，-j是针对 bzip2） 解压tar.xz文件： 先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。 创建tar.xz文件： 先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件， 然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz ９．rpm：安装/查询/删除rpm包： 安装本地的rpm包：rpm -ivh rpm包全路径名 查询是否安装了某个rpm包：rpm -qa | grep 软件名 删除rpm方法安装的某个rpm包： rpm -e 软件包名 升级某个rpm包：rpm -Uvh 软件包名 １０．yum：安装/查询/删除rpm包： 查询公网的yum服务器中是否有我们要安装的某个软件源：yum list | grep 软件名 (或者用yum search 软件名) 安装最新版的某个软件（默认）：yum -y install 软件名 安装指定版本的某个软件：yum -y install 软件名-版本号 升级某个rpm包： yum update -y 软件名 （查看是否有新版本及版本号 yum update |grep 软件名） 删除yum方式安装的rpm包：yum remove 软件名 当要使用一个指令，系统提示不存在，于是用yum安装它但又不知道它属于哪个rpm包时：yum provides 指令名（以ifconfig为例：yum provides ifconfig） 查看包的关系：repoquery --nvr --whatprovides 包名 （ repoquery是yum扩展工具包yum-utils中的一个工具，所有如果你没有repoquery命令的话，可以先 sudo yum install yum-utils 安装yum-utils包） １１．防火墙： CentOS7查看防火墙状态：systemctl status firewalld (CentOS6查看防火墙状态:service iptables status) 临时关闭防火墙：systemctl stop firewalld 启动防火墙：systemctl start firewalld １２．关机/重启/注销linux： 关机：halt （或者shutdown -h 1 表示一分钟后关机；shutdown -h now立刻关机） 重启：reboot 注销：logout １３．文件/目录操作： 创建目录（父目录不存在时创建父目录，即级联创建目录）：mkdir -pv 目录名（目录名如./aaa/bbb/ccc/ddd） 创建文件：touch 文件名 递归且强制删除目录/文件：rm -rf 目录名 显示目录下的文件/目录：ls -a (-a 表示列出所有文件，包括隐藏文件) ls -d (-d表示针对目录的，只列出目录本身) 浏览小文件并显示行号：cat -n 文件名 （浏览大文件：cat -n 文件名 | more） 浏览大文件 并显示行号，百分比：less -mN 文件名 追加：向文件的内容后面追加内容：echo &quot;内容&quot; &gt;&gt; 文件名 覆盖：用文件1的内容覆盖文件2里面的内容 ： cat 文件1 &gt; 文件2 控制台打印内容：echo “xxxx” 查看文件后5行：tail -n 5 文件名 （查看前5行：head -n 文件名） 创建快捷方式（软链接）：ln -s 原文件 快捷方式名称 文件重命名 ： mv 原文件名/目录名 新文件名/目录名 剪切（移动）：mv 原文件名/目录 新的路径 复制：cp -r 原文件/目录 目标文件/目录 （注意：复制目录必须加-r，表递归复制） １４．搜索文件/目录： 按照名称查询某个目录下是否有某个文件：find 搜索的目录 -name 要搜索的文件名 查询某个目录下属于某个用户的所有文件： find 搜索的目录 -user 用户名 １５．用户操作： 切换为某个用户：su -用户名 切换为管理员用户即root用户：su - 以管理员权限执行一条命令 ：sudo 要执行的命令 创建用户/组：useradd/groupadd useradd -g 所属的组名 用户名（注意：指定用户所属的组（前提：组存在）） 改变文件所属用户/组：chown/chgrp 改变用户所属组：usermod 改权限：chmod 改运行级别：chkconfig --level 0到6的数字 服务名 on （on 表开启，off表关闭） 查看用户所属组：id 用户名 查看有哪些用户：cat /etc/passwd 查看有哪些组：cat /etc/group 设置密码 passwd 用户名 １６．查看以前敲过的所有命令：history （常与管道连用，history | more）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的安装]]></title>
    <url>%2FLinux%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[前言: 上一节我们了解了Linux的一些基本概念,这一节我们将开始安装Linux系统,Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习. 什么是虚拟机? 安装虚拟机软件VMware:Vmware 下载地址 VMWare10 创建虚拟机空间:安装好 vmware 后，就可以创建虚拟机空间了: 点击新建虚拟机 安装CentOS系统:安装系统之前，需要先去下载一个镜像文件: CentOS下载地址： ​ 网易镜像：网易镜像​ 搜狐镜像：搜狐镜像 ​ 阿里云CentOS7镜像: 可以选择第一个：CentOS-7-x86_64-DVD-1708.iso 进行下载即可。 这里找到Ｌｉｎｕｘ系统的iso镜像(即.iso后缀)文件 这里如果选择OK,此时会联网检查系统的完整性,会等待很久,所以这里选择skip.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux的安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Linux.html</url>
    <content type="text"><![CDATA[前言: 根据JoblabXTM整理，使用Linux操作系统占据了整个操作系统的绝大数量，已经接近99%！立志于互联网行业的工程师们掌握Linux这门技术对自身的职业发展，一定会起到事半功倍之效果,所有我们有必要学习Linux操作系统. 一、Linux是什么,怎么读? linux是一个开源、免费的类Unix操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目都会部署到Linux/unix系统上。 Linux 读作[里纽克斯, 利尼克斯,里纳克斯] 二、Linux 的历史背景: 最初是由芬兰赫尔辛基大学学生Linus Torvalds (林纳斯-托瓦斯)由于自己不满意教学中使用的MINIX操作系统,所有在1990年底由于个人爱好设计出了LINUX系统核心,后来发布于芬兰最大的ftp服务器上,用户可以免费下载,所有它的周边的程序越来越多,Linux本身也逐渐壮大起来,之后Linux在不到三年的时间里成为了一个功能完善,稳定可靠的操作系统. 三、Linux的版本和分类:3.1 Linux 版本分两种: 内核版本 和发行版本: 内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号. 发行版本是一些组织和公司根据自己发行版的不同而自定. 3.2 一般来说著名的linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等 Debian系列：Debian、Ubuntu(乌班图)等 RedHat(红帽)系列 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 包管理工具 yum 支持tar包 Debian(蝶变)系列 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 包管理工具 apt-get 支持tar包 四、Unix简介: Unix是一个强大的多用户、多任务操作系统.于1969年在AT&amp;T(美国电话电报公司)的贝尔实验室开发. UNIX的商标权由国际开放标准组织所拥有. UNIX操作系统是商业版,需要收费,价格比Windows正版要贵一些. 五、Linux和Unix的关系: 六、Linux和Windows的比较: 比较 Window Linux 免费与收费 收费且很贵 Linux 免费或少许费用 软件与支持 数量和质量的优势，不过大部分为收费软件；由微软官方提供支持和服务； 开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。 安全性 三天两头打补丁安装系统安全更新，还是会中病毒木马； 要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比Windows 平台要更加安全 使用习惯 普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易入门简单； 兼具图形界面操作和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高。 可定制性 封闭的，系统可定制性很差； 开源，可定制化非常强。 应用场景 桌面操作系统主要使用的是window。 支撑百度，谷歌，淘宝等应用软件和服务的，是后台成千上万的Linux服务器主机。世界上大部分软件和服务都是运行在Linux之上的。 七、Linux 在计算机中的位置: 八、Linux的目录结构: 目录 说明 / 根目录: 一般根目录下只存放目录,不存放文件 /bin (binaries) 存放二进制可执行文件，常用命令一般都在这里(如: ls,cat,mkdir等)。 /boot 存放用于系统启动时使用的各种文件 /dev (devices) 类似Windows的设备管理器, 把所有的硬件用文件的形式存储。 /etc (etcetera) 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /usr 用于存放系统应用程序，比较重要的目录 /usr/local [重点] : 一般通过编译源码方式安装的程序就存放在这里 /usr/sbin 超级用户的一些管理程序 /usr/share/man 帮助文档 /usr/bin 众多的应用程序 /var [重点] 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 /tmp 用于存放各种临时文件，是公用的临时文件存储点。 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统。 /opt 下载的未安装的软件一般放到这里 /media linux会自动识别一些设备,例如U盘,光驱等,当识别后会把识别的设备挂载到这个目录下 /lost+found 这个目录平时是空的，系统非正常关机会留下一些文件（windows下叫什么.chk）就存放在这里 ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>初识Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建Hexo基本框架]]></title>
    <url>%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[前言: 之前自己敲代码纯手工打造了一个博客,并成功部署到了阿里云服务器上,虽然界面不忍直视吧,但还是有一丝小小的成就感.最近看到朋友用Hexo框架搭建的一个博客,界面看起来很美观,于是乎爱折腾的我心动了,决定放手干,好了废话不多说,进入正题,先说一下我的思路:个人认为无论学习什么技术,首先要做的就是要了解这个技术是什么?然后为什么要用它,它有什么优势,特点?最后就是我该怎么用? 一、Hexo是什么? Hexo 是一款基于Node.js的静态博客生成程序，作者是中国台湾tommy351。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容． 二、Hexo有什么用,优势在哪? 如果你一直想拥有一个界面美观的,能在上面记录一些学习心得,个人日记,一些内容公开发布,一些内容私密访问,属于自己的博客平台,但是又愁于自己没有一定的编程能力难以实现这个想法,那么Hexo将会给你带来福音, 即使你没有一定的编程基础,你也可以快速使用Hexo打造一个你自己喜欢的博客,因为不需要你敲大量的代码,你要做的仅仅是不断的Ctrl+C,Ctrl+V改一改配置文件. 简单吧! 是不是有点心动了,心动就行动吧! ​ 三、如何安装?以Windows机为例:１．首先要安装的就是Git和Node.js这两个工具：（如果之前安装过,那么跳过这一步） Git下载地址: Git Node.js下载地址: Node.js ２．安装hexo: 打开git软件,通过node.js工具的npm命令来安装hexo: $ npm install -g hexo-cli ３．检测上述工具是否安装成功,如果成功会显示版本号：(如果你嫌麻烦可以忽略) node-v npm -v git --version hexo -v ４．在任意位置创建一个文件夹,例如:blog, 并进入该目录: 我这里是创建在E盘 $ cd /e/blog ５．运行下面的命令,hexo 将会在blog文件夹中生成所需要的文件 $ hexo init 会生成以下目录内容: ​ 注意: 将来自定义博客样式的时候别把站点配置文件和主题配置文件弄混淆了. ５．生成静态文件(hexo会将/blog/source/ 下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下): $ hexo g ６．启动服务器: $ hexo s 默认情况下，访问网址为： http://localhost:4000/ 在浏览器地址栏输入上面的地址: 如果看到下面这个界面，那么恭喜你安装成功了，这个就是hexo默认的博客主题,如果你不喜欢还有更酷炫的主题，如何操作，下节我们继续．现在你已经可以在这个主题下写博客了。 四、说明: $ hexo g 是 $ hexo generate 的简写形式,产生的作用是一样的 $ hexo s是 $ hexo server的简写, 表示启动本地服务器,让hexo在本地运行 $ hexo d 是 $ hexo deployed的简写, (这个指令是部署到远程服务器的,后面会讲到) $ hexo clean 没有简写,别写成了$ hexo c $ hexo server -p 5000 #更改端口 参考文档： Hexo]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo的安装</tag>
      </tags>
  </entry>
</search>
