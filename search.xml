<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[信息系统项目管理师之论文部分]]></title>
    <url>%2F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E4%B9%8B%E8%AE%BA%E6%96%87%E9%83%A8%E5%88%86.html</url>
    <content type="text"><![CDATA[十大知识领域、五大项目管理过程组、47个过程启动过程组 2个规划过程组 24个执行过程组 8个监控过程组 11个收尾过程组 2个 一、整体管理1.1 可以从以下方面去写:①: 6个过程 (命题概率较大) ②: PDCA (命题概率较大) ③: 5大过程组 注: PDCA是质量管理和项目管理的基本模型。PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Action(行动)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。 1.2 写作思路: 过程 通俗解释 写作要点(举例: 根据子题目写) 1 制定项目章程 正式批准项目的启动,为项目经理授权 不用写太多,一句话带过,如项目发起人发布了这个文件,项目启动了,我被授权了. 2 制定项目管理计划 和大家一起编制项目管理计划,为项目的执行奠定基础 可写计划编写的原则,工具,步骤等内容,列举项目管理计划包含了什么内容 3 指导和管理项目执行 按照项目管理计划来指定项目的执行 如何按照计划来指导和管理项目, 如: 根据计划做了什么安排,怎么安排等 4 监督和控制项目工作 做好项目的纠偏控制 如何设置监控点,如何进行监控和捕获项目信息,什么时候发现项目状态有问题,分析什么原因造成的,如何解决的. 5 整体变更管理 变更不可避免,当发生变更时严格按照变更流程进行项目变更管理工程. 具体举例,如何进行变更控制(6个流程) 6 项目收尾 项目通过验收,交付了产品,还要召开项目总结会议,进行项目总结和评估审计等工作. 写验收情况,项目总结会议的作用,内容,最后更新组织过程资产等 1.3 过程,输入,输出,工具和技术 过程+输入 工具/技术 输出 1.3.1 制定项目章程 (启动过程组) ①: 项目工作说明书 专家判断 项目章程 ②: 商业论证 引导技术 ③: 协议 ④: 事业环境因素 ⑤: 组织过程资产 口诀: 工商议事有组织,专家引导出章程(工:工作说明书,商: 商业论证,议: 协议,事: 事业环境因素,) 1.3.2 制定项目管理计划 (规划过程组) ①: 项目章程 专家判断 项目管理计划 ②: 其他过程的输出 引导技术 ③: 事业环境因素 ④: 组织过程资产 ⑤: 初步项目范围说明书 口诀: 章程输出靠业组,专家引导出计划 1.3.3 指导与管理项目执行 (执行过程组) ①: 项目管理计划 专家判断 可交付性成果 ②: 批准的变更请求 项目管理信息系统 工作绩效数据 ③: 事业环境因素 会议 变更请求 ④: 组织过程资产 项目管理计划更新 口诀: 计变业组会专项, 效果变更新文划( 计: 项目管理计划, 业: 事业环境因素,专: 专家, 项: 项目管理信息系统,效:绩效,果:可交付性成果,变:变更请求,新:更新,文: 文件,划:计划) 项目文件更新 1.3.4 监控项目工作 (监控过程组) ①: 项目管理计划 专家判断 变更请求 ②: 进度预测 项目管理信息系统 工作绩效报告 ③: 成本预测 会议 项目管理计划更新 ④: 确认的变更 项目文件更新 ⑤: 工作绩效信息 ⑥: 事业环境因素 ⑦: 组织过程资产 口诀: 计划进成预测后,业组确认变更信(输入而言) 1.3.5 实施整体变更控制 (监控过程组) ①: 项目管理计划 专家判断 批准的变更请求 ②: 工作绩效报告 会议 变更日志 ③: 变更请求 变更控制工具 项目管理计划更新 ④: 事业环境因素 项目文件更新 ⑤: 组织过程资产 口诀: 计划变更效业组,批准日志新文划 1.3.6 结束项目或阶段 (收尾过程组) ①: 项目管理计划 专家判断 最终产品,服务或成果移交 ②: 验收的可交付成果 分析技术 组织过程资产更新 ③: 组织过程资产 会议 管理收尾规程 口诀: 计划验收无事业,会议分析有专家 合同收尾规程 1.4 论文格式:第一部分: 摘要部分: 300字左右 第二部分: 正文部分: 2700字左右 总共3000字左右. 1.5 范文: 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 论信息系统工程项目的整体管理摘要: 2005 年 3 月我作为项目经理参与了某市的公安部人口管理信息系统，该项目是为了实现该市平安城市的 5 年规划。它投资 800 万元。工期为 1 年。目标是采用统一的技术路线和架构体系构建开放的、集成的、一体化的信息化的应用环境.该项目主要实现了常住人口户籍办公管理、二代身份证管理、暂住人口户籍管理、租赁房屋管理等。2006 年 3 月通过了甲方的验收，获得了甲方的一致好评。本文以我的实际经验讨论了有关大型整体管理的体会，主要从制定项目章程、制定项目范围说明书(初步)、制定项目管理计划、指导和管理 项目执行、监督和控制项目工作、整体变更控制、项目收尾方面做了论述。正文: 为了实现某市平安城市的 5 年规划，某市决定开发一个公安系统的人口管理信息系统。工期为 1 年，投资 800 万元。我公司在 2005 年 2 月中标了该市的公安部人口管理信息系统项目，签署了建设合同。2006 年 3 月通过了甲方的验收。项目分为平台开发和项目部署 2 个阶段。软件方面考虑到各区县地理位置分布的不集中，计算机硬件和软件存在较大的差异等问题，我们决定采用 J2EE 框架的 3 层 BS 模式，解决了各种应用系统中应用的不兼容问题， 提高了该系统的易用性。数据库采用了 Oracle 9g 来管理各项数据。服务器操作软件采用比较通用的 Windows Server 2003。硬件方面采用 IBM System X 系列的服务器提高了系统的稳定性和高性能。在应用层面上我们实现了常住人口户籍办公管理、二代身份证管理、暂住人口户籍管理、租赁房屋管理等功能。由千该项目工期紧，工作量大，在制定项目章程的时候 决定了多个分项的项目经理和总经理。我作为项目总经理参与了该项目的管理。接下来我将结合实际工作从制定项目章程，制定项目范围说明书(初步)，制定项目管理计划，指导和管理项目执行，监督和控制项目工作，整体变更控制及项目收尾来讨论大型项目的整体管理。一、制定项目章程 项目章程是实施项目开发的前提和确定项目开发什么产品的依据。经过公司领导的授权 我被任命为该项目的总经理。由千项目的规模比较大、工期较紧，我们根据合同、项目工作 说明书等过程资产确认了另外 3 名项目经理。我作为总经理统一协调。二、制定项目管理计划 俗话说得好，“磨刀不误砍柴工”，在实施项目开发之前，做好应有的准备工作是很有必要的。完备的计划是项目实施的根本前提。为此我组织召开了“项目工作计划的会议”，会议邀请了各团队的项目经理、业务专家和技术专家。 在制定范围控制管理计划进行 WBS 分解的时候，我发现由千涉及的人员较多，个人的知识水平也参差不齐，信息尚不够明确。因此我们决定采用滚动波式计划。对于即将开展的活动进行详细的分析和计划，对于后期的活动尽量粗略地估计，避免出现大范围的变更。 在制定进度控制计划的历时估算时因为我有过许多类似项目管理的经验。因此大部分的活动我采用了类比估算法，从而节约了时间。此外我们还考虑了活动存在的风险情况。在与负责二代身份证管理的经理讨论的过程中，我们发现身份证采集的设备驱动程序来自第三方，驱动的连接是否正常直接影响到了信息采集活动的开展。因此相关的业务、技术专家和团队成员调整了估算方法，采用了三点估算法。该方法主要有 3 个数据，分别是最乐观历时估算 a、最悲观历时估算 c、最有可能历时估算 b，而后利用 T=(a+4b+c)取其平均值。经过个专家和开发团队成员的讨论，认为最乐观的时间为 2 个工作日、最悲观的时间为 6 个工作日、最有可能的时间为 4 个工作日。最后该活动的历时为 4 个工作日。为项目的按时完工打下了基础。 在制定质量控制管理计划的时候我们发现客户的有些要求与相关的法律法规相冲突。为此我及时通知了客户，与客户进行了沟通，最后我们修改了相关质量标准，使项目的质量得到了保证。 在制定人力资源计划的时候为了保证有充足的资源去完成项目。团队的所有项目经理、 相关业务专家和技术专家经过讨论决定采用自下而上的方式进行估算，对每一层下面工作所需的资源进行估算，最后将所有的资源进行汇总。比如二代身 份证信息管理可以分解为身份证信息的采集、信息的存储、信息的修改、信息的存储。信息采集工作需要忱卡器一台、能够在 Java 中成功调用 DLL 动态库一个以及 Java 程序开发人员 2 名；信息存储工作需要通用数据库存储过程一个、Java 程序开发人员 2 名。暂住人口户籍管理、租赁房屋管理的分项经理这时提出也需要Java 的开发人员各 2 名。我们检查公司的人力资源表后发现缺少 2 名Java 程序员，我及时向公司领导汇报了情况，经领导同意我们又招聘了 2 名程序员，完成了资源的合理分配。通过讨论我还制作了活动资源日历，保证每个活动都有后备的资源考虑。 我们还制定了项目成本控制管理计划、沟通管理计划、采购管理计划、风险管理计划等。三、指导和管理项目执行“懂业务的不懂技术，懂技术的不懂业务”，在这种情况下项目的风险很大，一旦开发人 员没有理解业务去开发，将导致严重的返工，最终影响项目进度。因此在开发的时候我要求 每个开发的具体功能必须要求项目经理组织相关干系人对开发人员进行交底，避免返工的发 生。开发这一阶段在每完成一个里程碑式的可交付物时，我都会邀请客户来进行确认签字，保证了我们开发产品的有效性，减少了无谓的变更。四、监督和控制项目工作 在项目执行的过程中总会遇到各种各样的问题。那么怎样才能预防和控制各种问题的发生呢？每周我会根据绩效信息与计划进度表进行比较，进行偏差分析，利用挣值技术计算进度偏差情况，及时采取纠正和预防措施。比如负责二代身份证信息管理项目的丁工还负责其他项目的系统需求分析和设计，因其他项目上的事情比较多，二代身份证管理的需求分析 和详细设计迟迟不能开始，已落后千计划，SV=-3。如果再不提交将会影响到编码阶段。届时，我与丁工进行了沟通，与他协商决定，我负责帮他完成一部分其他项目的工作，他加班负责把马上要进行编码阶段的二代身份证信息管理的需求分析和设计提交出来，最终二代身份证信息管理的编码工作按计划开展。五、整体变更控制 项目开发的过程中客户的需求经常会有变更。为了防止频繁的变更对项目进度等带来的 不利影响。项目的初期我们成立了由客户方、开发方和监理方组成项目控制委员会 CCB。客户或者开发方每个需要的变更都要经 CCB 的批准才能实行。六、项目收尾 经过项目全体人员的共同努力，2006 年 2 月终千完成了压力测试，2006 年 3 月项目一次性通过了甲方的验收。回顾项目的进度管理工作的过程中，项目能成功通过验收得益千在 事前进行了充分的计划和准备工作。我觉得项目管理的能力和项目开发的能力是有很大的区 别的。一个成功而高效的项目开发必须要有一个能统筹管理和善千沟通的项目经理。特别是 作为大型项目经理，我们的主要工作就是平衡各种资源的利用，使其达到最佳的效率。怎样才能达到这个最佳。这个是我在今后的工作中需要长期实践和摸索的内容。虽然项目成功通过了验收没有大的事故发生，但仍然存在许多问题，主要有以下几点：(1) 在需要客户确认时，与客户的沟通方式比较单一，只是一味等待，导致某些工作落后 千计划进度，影响了整体计划。(2) 需求分析还不够全面，某些功能没有能够很完善地实现。(3) 软件测试不系统，用例准备仍不够充分，忽视了压力测试。系统实际运行后随着参保 职工和定点结算的增加，运行速度下降很快，达不到设计要求。虽然通过升级硬件缓解了这个问题，但造成资金的额外投入。 1.6 模板:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 项目整体管理是项目管理的必要条件，是项目管理的有效基础，是项目管理的重要内容。为了保障项目的持续进展，确保项目的有序进行，保证项目能够顺利的上线，我从制定项目章程、制定初步范围说明书、制定项目管理计划、管理和指导项目执行、监控项目工作、整体变更控制和合同收尾等六个方面加强项目的整体管理。第一，制定项目章程。 制定项目章程是项目整体管理的第一步。通过制定项目章程明确项目的整体目标，通过收益法判断整体的项目收益。整个项目采用项目型管理方式。正式任命我作为项目经理。假定某某省某某市的计划生育政策具有延续性，不会有大的变更，这样保障需求不会发生实质的变更。假定项目开发人员中的主力开发人员不会在项目开发过程离职。系统的人口信息表的存放数据量为600万条，系统的响应时间不超过6秒，系统的从需求分析到系统试运行时间为1年，系统的并发用户为50个。系统的项目干系人分为四类：甲方的领导层，关心整体项目进度情况；甲方的业务人员，关心项目的具体业务的实现；乙方的领导层，关心项目的成本、质量及合同的收款情况；乙方的项目团队曾元，关心项目的需求、设计、编码、测试、实施上线。第二，制定初步范围说明书。 项目初步范围说明书是项目整体管理的第二步。项目初步范围说明书是项目各个阶段提交的交付物和为提交交付物所做的工作。我初步制定了项目初步范围说明书包括需求分析报告、系统概要设计、系统详细设计、模块开发卷宗、测试规范、系统集成规范、系统验收规范、系统产品说明书、系统代码。制定了初步工作分解结构。第三、制定项目管理计划。 制定项目管理计划是项目整体管理的第三步。项目管理计划包括成本管理计划、质量管理计划、时间管理计划、风险识别册、人力资源沟通计划等。通过制定项目管理计划，整个项目按照制定的计划预期稳步向前推进。第四，管理和指导项目执行。 采用工具sourceSafe建立配置管理系统，对所有的文档及变更记录进行管理。采用OA系统作为所有项目干系人的沟通工具，所有的变更文档记录及相关的项目文档资料通过OA的流程管理进行处理。比如，有的程序员对J2EE比较熟悉，这次开发采用.NET路线，因此请对.NET精通的专家对不熟悉J2EE的程序员进行培训。要求质量管理人员按照编码规范对代码进行走查，不符合要求责令修改。第五，监控项目工作。 监控项目工作是项目整体管理的第五个步骤。对整个项目在成本、风险、质量、进度等方面进行监控。在每个里程碑的节点上开面对面沟通会议，对前一阶段的工作进行审核把关，同时对出现的问题进行记录，寻找解决办法；通过每周的项目例会，对这一周的工作进行总结，出现的问题进行记录，及时把问题解决。通过每天的项目组成员的工作日志，记录成员每天的工作情况，以便于及时的把问题查找出来。通过每天的工作日志、每周的项目例会及里程碑节点的会议及时的与项目计划进行比对，找出偏差，及时处理。第六、整体变更控制。 成立变更控制管理委员会，对整个项目的需求变更进行管理控制。变更管理委员会对申请的变更要审核、评估。批准后的变更要按计划执行，同时对执行后的项目进行追踪。第七，项目收尾。 项目收尾包括管理收尾和合同收尾。通过项目范围说明书、合同等文档的要求，对提交给用户的可交付物进行比对。对已完成的可交付请求客户确认签字，对用户确定需要进一步完善的可交付物要及时的按照文档资料要求处理。最后整体验收。例如，按照合同要求，我们用惠普的loadrunner对系统进行了50并发用户的压力测试，同时在开发的过程也组织了人力对人口的基础数据进行了录入，响应时间小于6秒。同时提交的文档资料整体提交完毕，人员培训已经完成，系统试运行三个月情况良好，满足用户需求。 二、范围管理2.1 可以从以下方面去写:①: 6个过程 (命题概率较大) ②: PDCA (命题概率较大) ③: 范围结合需求 ④: 问题解决的角度 注: 其中 1 命题概率大，建议 6 个过程的角度必须准备 2.2 写作思路: 过程 通俗解释 写作要点 1 范围规划 编写项目范围管理计划 写我组织相关人员进行了项目范围管理计划的编制,在编制之前做了什么准备,通过什么方法进行编制,编制后的计划包含什么内容. 2 收集需求 记录并管理干系人的需要和需求过程 哪些类型的需求, 输入,输出,工具技术,该过程的重要性,遇到什么问题,如何解决,需求文件,建立需求跟踪矩阵等. 3 范围定义 对项目和产品详细描述,并写到详细的范围说明书中,形成详细的范围说明书. 举例描述,本项目的某个功能原来是怎么定义,现在是如何详细的表示,最终说明书包含什么 4 创建工作分解结构WBS 项目的可交付物和项目管理的工作进行分解,分解为更小更易于管理的单元. 为什么要分解,是采用树形还是列表型,以什么作为第一层,分解的五个步骤是什么,遵循什么原则 5 范围确认 阶段性的接受项目的可交付物,对不可接受的说明理由,重新整改. 具体通过什么方式进行范围确认,哪些进行了确认,哪些没有,是什么原因,怎样整改. 6 范围控制 管理好变更,避免出现范围蔓延 写范围管理的重要性,如何进行范围控制的,如何防止范围蔓延 2.3 过程,输入,输出,工具和技术 过程+输入 工具/技术 输出 2.3.1 范围规划 (规划过程组) ①: 项目管理计划 专家判断 范围管理计划 ②: 项目章程 会议 需求管理计划 ③: 事业环境因素 模板,表格,标准 ④: 组织过程资产 ⑤: 初步项目范围说明书 口诀: 章程计划找业组, 专家会议两计划 2.3.2 收集需求 (规划过程组) ①: 范围管理计划 访谈 需求文件 ②: 需求管理计划 问卷 需求跟踪矩阵 ③: 干系人管理计划 观察 ④: 项目章程 标杆 ⑤: 干系人登记册 原型 口诀: 范需人划章程册, 需求文件矩阵出(划: 管理计划), 文件分析 系统交互图 焦点小组 引导式研讨会 群体创新技术 群体决策技术 2.3.3 范围定义 (规划过程组) ①: 范围管理和计划 专家判断 项目范围说明书(详细) ②: 项目章程 产品分析 项目管理计划更新 ③: 需求文件 可选方案识别 ④: 组织过程资产 引导式研讨会 口诀: 范划章程需文组, 文件更新出范书 2.3.4 创建工作分解结构WBS (规划过程组) ①: 范围管理计划 分解技术 范围基准 ②: 详细项目范围说明书 专家判断 项目管理计划更新 ③: 需求文件 WBS分解结构模板 WBS和WBS字典 ④: 事业环境因素 ⑤: 组织过程资产 口诀: 范划范书需业组,文件更新出基准 2.3.5 范围确认 (监控过程组) ①: 项目管理计划 检查 验收的可交付性成果 ②: 需求文件 群体决策 变更请求 ③: 需求跟踪矩阵 工作绩效信息 ④: 核实的可交付性成果 项目文件更新 ⑤: 工作绩效数据 口诀: 计划需文效成果,文件变更绩效出 2.3.6 范围控制 ①: 项目管理计划 偏差分析 工作绩效信息 ②: 需求文件 变更控制系统 变更请求 ③: 需求跟踪矩阵 配置管理系统 项目管理计划更新 ④: 工作绩效数据 重新规划 项目文件更新 ⑤: 组织过程资产 组织过程资产更新 口诀: 计划需文效矩组,计组文件齐更新 2.4 范文:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 论信息系统工程项目的范围管理摘要: 2009 年 5 月，我作为项目经理，参与了××物流公司条形码项目。该项目是为了提升××物流公司日常业务运作中货物流转交换的准确性和及时性，解决该公司现有业务运作中的货物差错率高、装卸效率低、记录颗粒度粗等问题，进而提升整体运营服务质量，实现×× 物流公司由低端运输向高端公路快运转型的战略目标。 作为该公司的重点战略项目，项目总投资 2000 万元，项目工期为 2 年，系统主要实现了以下功能：CD对货物流转交换过程中的每一个环节的扫描，实现货物运输全过程跟踪处理功能；＠基千计划与实际扫描结果的比对，实现装卸差错及时发现、及时解决；＠货物异常处理；＠提送货任务的指派与管理。 2011 年 6 月，该项目通过了客户的验收，顾得了甲方的好评，成为公路运输行业实施条码技术的成功案例；得到业内的一致认可。本文结合作者的实际经验讨论了项目的范围管理，主要从制定范围计划、定义范围、创建 WBS，以及核实范围、控制范围这几个方面进行论述。正文: 2009 年 5 月，我参与了××物流公司条形码项目建设，该项目应××物流公司由低端运输向高端公路快运转型的战略而立项，是 2009 年该公司的重点项目。项目建设周期为 2年，由 2009 年 5 月开始，到 2011 年 6 月验收结束，项目总投资为人民币 2000 万元。其目标是建立一套高效实用的条码系统，全面提高流转交换的准确性和及时性，降低差错，提升运营服务质量，实现由低端运输向高端公路快运转型的战略目标。 系统采用 C/S 架构，服务端应用采用 J2EE+Oracle 的模式开发，服务器使用 HP 的 580G7， 操作系统为Redhat 企业版 Linux 5.4，数据库使用 Oracle 11g R2 并做 RAC，中间件采用 IBM 的 WebSphere 并做集群，终端应用基千 Microsoft 的Windows CE 平台，采用 C#语言开发， 运行千 PDA 上。项目采用矩阵型组织结构，从各职能部门抽调主干成员，组成专门的项目团队。我被任命为该项目的项目经理，负责项目的管理工作，直接向项目总监汇报。下面我将结合本项目从制定范围管理计划、定义范围、创建工作分解结构、核实范围、控制范围这几个方面对项目的范围管理进行介绍。一、制定范围计划 作为一名合格的项目管理者，做任何事之前都应该先做好计划。好的计划，是成功实施项目的基础。有些人为做项目范围计划花费了太多时间，不如把它们用千执行工作，项目将会更快更好地完成，我认为这是一个错误的想法，通过省略范围计划制定，虽然能短暂时间内节省一定的时间，但在长期来看，常常会因缺乏管理计划指导而使得范围定义不清、范围蔓延，以致无法完成项目。因此，在该项目中，我非常重视范围计划的制定，在正式做计划之前，我先查找了公司组织过程资产，找出制定范围管理计划的模板，再结合以往项目的经验，制定出一份初步的计划，然后召集项目团队成员讨论，对计划进行修改和完善，在全体参与下，最终完成一份详细的、科学的范围管理计划，用千指导项目如何定义、分解以及核实和控制范围。二、定义范围 一个成功的项目，应该做且只做成功完成项目所需的全部工作。为了保证这一点，就需要在项目前期定义一个明确的项目范围。在项目的早期阶段，我带领团队，到了客户现场收集需求，我组织了客户的运营部门、服务质量部门、IT 部门以及我的需求团队，召开需求讨论会，共同商讨项目范围。在收集需求的时候，客户有时候需求描述得不是很清楚，造成了双方对需求理解有歧义，甚至有时候客户对千其需求自己都不清楚，只有一个模糊的概念； 针对这种情况，我采用原型法将收集到的需求，做成模型供客户参考确认，以此消除彼此的歧义，充分挖掘用户的需求，并基千团队自身的经验以及专业水平，对客户的需求进行引导、细化，将其模糊的概念形象化，粗糙的需求具体化。 基于需求文件，我召集项目的主要干系人进行开会讨论，同时邀请了系统的最终用户代表（包括甲方的业务员，装卸工、调度等）对系统功能做评价，通过用户的角度，去发现和改进系统的功能，以此最终形成了完整的项目范围说明书，主要包含：CD条码项目的产品范围描述（包括取派件管理、装卸管理、异常管理等）；＠项目的主要可交付成果（用户文档、应用系统、源代码等）；＠产品验收标准（系统运行稳定、功能满足业务需求、相关文档齐全等）；＠项目的除外责任（该项目涉及的仓库环境改造，强电、弱电改造不包含在该项目范围中）；＠项目制约因素（之前的预算和系统设计仅针对定日达产品进行，如果扩展到零担，必须追加投入、延长项目时间）；＠项目假设条件（假设项目涉及的场站改造、人员素质提高可以配合条码项目进行持续改进，假设甲方的业务系统满足条码项目上线后给其增加的负载）；＠项目的目标、总预算、资源，以及主要里程碑等。三、创建 WBS 基于项目范围说明书，我和我的团队开始对项目范围进行分解，以形成该项目的 WBS。在分解过程中，我按照以下原则进行分解。在各层次上保持项目的完整性，我将该项目涉及的需求调研、系统设计、开发、测试等完整的模块都一一列出，避免遗漏必要的组成部分。一个工作单元只从属千某个上层单元。对千该项目中的数据库设计，我就只将其归入系统设计单元中，在其他单元不再重复出现，避免了交叉从属。相同层次的工作单元应有相同性质。对千系统设计单元下的数据库设计、接口设计、系统设计等设计内工作，它们从属性上来讲， 都属千设计，因此我将其一并归入系统设计单元下。工作单元应能分开不同的责任者和不同的工作内容。对千该项目中每个工作包，我都指定唯一的负责人和其负责的工作内容，便千项目管理进行计划和控制的管理。对千该项目的每个工作包，我都对其进行编号，并与组织结构图和成本控制点深度融合，便千项目的日后管理。应包括项目管理工作，包括分包出去的工作。对千该项目，我将项目管理和外包的 AP 部署也一并纳入 WBS 中，并逐层分解。WBS 的最低层次的工作单元是工作包；对千该项目中工作单元，我参照 8/80 小时原则细化成具体的工作包，并指定具体的负责人。同时制作 WBS 词典，对工作包做具体描述。四、核实范围 范围确认并不是件容易的事情，在与客户的沟通上，我们希望客户尽快确认以便尽快开展后续的开发阶段工作，而客户则可能认为自己什么也没看到，怎么确认呢？针对这种情况， 我在提交文档给客户的相关干系人后，重点对客户的 IT 人员进行沟通培训，详细介绍系统的设计，然后用他们的声音去向客户的业务部门做出介绍，这样既有益千专业人员之间的技术沟通，也有益千客户业务部门对系统范围的认可与信任。同时，在与客户的业务部门沟通时，我重点强调，虽然范围确认是正式的，但这并不意味着项目的范围就是铁板一块，不能再修改了，只要走标准的变更流程，且审批通过的，都是可以进行变更的。这样就消除了客户的顾虑，便千快速、高效地完成范围确认。五、控制范围控制范围就是监督项目的范围状态，管理范围基础变更的过程。因此在项目中，我定期组织召开项目状态审查会，审查项目的范围，通过对照范围基础，找出范围偏差，并做分析，严格杜绝一切的范围蔓延以及锁金。 例如，在一次状态审查会上，我发现项目的功能模块中，系统管理以及库存管理模块多了登录日志以及盘库两块功能，我查了一下系统变更日志，未找到有类似的变更记录，千是我参照责任分配矩阵，分别找到这两个模块开发的负责人询问原因，A 成员告诉我，他增加登录日志这个功能，是因为客户在一次电话中，向他提过希望在系统管理模块中加一个登录日志的功能，B 成员则是因为在开发库存管理模块时，发现整个库存管理没有库存盘点的功能，他认为做库存管理，肯定需要用到盘点功能，而且这是个亮点，所以他私自增加了这一功能。针对这两种情况，我首先向这两名成员强调了范围基准以及变更流程的重要性；其次， 针对这两项多出来的功能，我要求相关人员提交正式的变更申请，走正常的变更控制流程。从事项目管理工作的我深知，项目范围不是一经定义，就一成不变的，项目干系人出千项目利益以及各种情况考虑，总会有一些需求变更，管理这些变更，需要在项目规划时，就制定好变更控制流程以及成立一个专门的需求变更控制委员会（CCB）。 因此，我和我的团队在项目早期就制定了一套标准的变更流程：CD提交变更申请；＠评估变更；＠报 CCB 审批；＠实施变更并调整基准；＠将变更信息通知相关干系人；＠对变更的结果进行追踪与审核。有了这些流程以及 CCB 的控制，项目的需求变更得以良性发展，变更带来更多的是项目利益以及效率的提升。 经过我和我的团队不懈努力，该项目最终千 2011 年 5 月试运行成功，并在同年 6 月通过了客户验收小组的验收，得到了甲方的好评，使得××物流公司运营的货物差错率降低了50%，客户投诉率降低了 20%，理赔损失降低了 20%，提升了该公司的整体运营服务水平、客户满意度及公司形象，为××物流公司由低端运输向高端公路快运转型提供强有力的保障。项目最终能成功完成，得益千我在项目中有效的范围管理，采用科学的范围管理方法、工具和技术，为项目的范围管理带来了事半功倍的效果。同时，在该项目的实施过程中，也出现了一些问题，本人觉得处理得不是很好，主要在千项目中的冲突管理以及项目风险识别方面还存在不足，后续我将加强这两个方面的学历与知识积累，不断提升自身项目管理水平，为中国物流行业的信息化发展添砖加瓦 2.5 模板1234567891011121314151617181920212223242526项目范围管理是项目管理的核心部分，是项目管理的必要条件，是项目管理持续发展的基础，是项目管理有效进行的前提。我从范围规划、范围定义、工作分解结构、范围确认、范围控制等五个方面开展了项目范围管理的工作。第一，范围规划。范围规划是项目范围管理的第一个环节。范围规划确保范围定义、工作分解结构、范围确认和范围控制如何开展。第二，范围定义。范围定义是制定项目范围说明书的过程，项目范围说明书是确定整个项目工作中的可交付物及提交可交付物所做的工作。本项目采用快速原型结合面向对象开发的方法。先根据甲方沟通，确定甲方的重要项目干系人分类。一类是甲方的领导层确定系统要达到的整体目标，另一类是甲方的业务人员，他们的要求是系统的具体功能。我方人员通过与各类项目干系人进行沟通，通过制作界面原型与甲方不断确认，把需求确定下来，把范围确定下来。第三，创建工作分解结构。创建工作分解结构项目范围管理的重要环节。通过工作分解结构把项目的整体工作分解成工作包。通过滚动式规划，把近期的工作分解较为详细，远期的工作分解较为初略。根据工作分解结构，初步整个项目分解成业务需求、用户需求、功能需求、概要设计、详细设计、系统编码、单元测试、整体测试、集成测试、安全测试、压力测试、系统培训、系统试运行。第四，范围确认。范围确认是我方与甲方对项目说明书确认的一个过程，对于系统开发过程中所提交的文档、资料、软件等可交付物及为这些交付物所做的工作的确认。整个范围确认是贯穿整个过程的始终。我方和用户方商定，所有的提交的可交付物，用户必须制定项目联系人签字盖章，如果拒绝提交，也要提出书面说明。第五，范围控制。范围控制是保证整个项目有效实施的重要内容。我方与用户方成立变更控制委员会。对用户方提出的范围变更请求必须提交书面申请，由变更控制委员会进行审核，审核通过后执行，并对执行的结果进行跟踪。建立sourcesafe软件配置管理系统。把所有的文档用配置管理系统管理起来，对整个项目的管理及范围变更有非常清晰的认识。 三、进度管理3.1 可以从以下方面去写:①: 7个过程 (命题概率较大) ②: PDCA (命题概率较大) 3.2 写作思路: 过程 通俗解释 写作要点(举例: 根据子题目写) 1 制定进度管理计划 写一个叫做进度管理计划的文档 我组织相关人员进行了进度管理计划的编制工作，在进行编制前做了什么准备,通过什么方法进行了编制，编制后的计划包含什么内容等，计划的重要性等等 2 定义活动 看项目里面到底有多少活动需要完成，识别出来并记录下来 活动定义和 WBS 的关系，举例写下结合本项目有哪些活动？ 3 排列活动顺序 明确各活动之间的顺序等相互的依赖关系，并记录下来 举例描述下活动的逻辑关系 4 估算活动资源 估算下每个活动到底需要多少材料、人员、设备等等资源 某某活动需要什么资源，需要多少资源，什么时候需要等等。是通过什么方式进行估算的等内容 5 估算活动持续时间 估算下完成某活动所需要的持续时间 什么方法对本项目中的一些活动进行了历时估算，是多少时间等。 6 制定进度计划 分析这些活动的顺序、历时、资源需求和相关的一些进度约束等内容来编制项目的进度计划 通过什么方法进行进度计划的制定的 7 进度控制 监控项目的具体状态， 如果发现有偏差，我们需要进行纠偏 进度控制的重要性、工作内容，举例挣值分析，发现项目进度怎么样了，分析为什么，进行纠偏 3.3 过程,输入,输出,工具和技术 过程+输入 工具/技术 输出 3.3.1 规划进度管理 ①: 项目管理计划 专家判断 进度管理计划 ②: 项目章程 分析技术 ③: 事业环境因素 会议 ④: 组织过程资产 口诀: 章程计划找业组,分家会上进管子 3.3.2 定义活动 ①: 进度管理计划 分解 活动清单 ②: 范围基准 滚动式规则 活动属性 ③: 事业环境因素 专家判断 里程碑清单 ④: 组织过程资产 口诀: 业组进管炒基范,分家滚出清属里 3.3.3 排列活动顺序 ①: 进度管理计划 紧前关系绘图法PDM 项目进度网络图 ②: 活动清单 确定依赖关系 项目文件更新 ③: 活动属性 提前与滞后 ④: 里程碑清单 ⑤: 项目范围管理书 ⑥: 事业环境因素 ⑦: 组织过程资产 口诀: 范进业组清属里, 前后紧赖网新文 3.3.4 估算活动资源 ①: 进度管理计划 自下而上估算 资源分解结构 ②: 活动清单 备选方案分析 活动资源需求 ③: 活动属性 项目管理软件 项目文件更新 ④: 资源日历 发布的估算数据 ⑤: 风险登记册 专家判断 ⑥: 活动成本估算 ⑦: 事业环境因素 ⑧: 组织过程资产 口诀: 业组进管估成本,清属资历有风险 自选软件算专家 分解需求新文件 3.3.5 估算活动持续时间 ①: 进度管理计划 专家判断 活动持续时间估算 ②: 活动清单 类比估算 项目文件更新 ③: 活动属性 参数估算 ④: 活动资源需求 三点估算 ⑤: 资源日历 群体决策技术 ⑥: 项目范围说明书 储备分析 ⑦: 风险登记册 ⑧: 资源分解结构 ⑨: 事业环境因素 ⑩: 组织过程资产 口诀: 业组资需分日进,清属范书有风险 3.3.6 制定进度计划 ①: 进度管理计划 进度网络分析 进度基准 ②: 活动清单 关键路径法 项目进度计划 ③: 活动属性 关键链法 进度数据 ④: 项目进度网络图 资源优化技术 项目日历 ⑤: 活动资源需求 建模压缩技术 项目管理计划更新 ⑥: 资源日历 提前与滞后 项目文件更新 ⑦: 活动持续时间估算 进度压缩 ⑧: 项目范围说明书 进度计划编制 ⑨: 风险登记册 ⑩: 项目人员分配 ⑩: 资源分解结构 ⑩: 事业环境因素 ⑩: 组织过程资产 口诀: 业组资需分日进,清属范书有风险,人员进 3.3.7 控制进度计划 ①: 项目管理计划 绩效审查 工作绩效信息 ②: 进度管理计划 项目管理软件 进度预测 ③: 工作绩效数据 资源优化技术 变更请求 ④: 项目日历 建模技术 项目管理计划更新 ⑤: 进度数据 提前与滞后 项目文件更新 ⑥: 组织过程资产 进度压缩 组织过程资产更新 进度计划编制工具 口诀: 两数两划组日历 3.4 范文: 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 论项目进度管理【摘要】2008 年 10 月，XX 发展股份有限公司作为系统集成项目的总包商承接了 XX 市人力资源和社会保障局所委托的XX市基本臣疗保险门诊实时结算信息系统建设项目，我作为项目经理负责全程管理该项目，该项目的主要业务目标是建设覆盖全市 1800 家臣保定点臣疗机构的门诊实时结算系统;在实施该项目过程中，项目在时间管理方面具有以下特点:项目业务功能复杂，涉及到 XX 市 1800 家臣保定点臣疗机构和 1300 万臣保参保人，同时该项目工期较长历时一年多，涉及的项目干系人众多，并目_项目属千 2009 年 XX 市政府折子土程，要求必须在 2009 年底完成。因而该项目的时间管理是项目成功的关键。在充分分析了该项目特点的基础上，在时间管理方面我对项目的所有活动通过活动分解进行了定义，使用前导图的方法对项目活动进行了排序，经过对项目活动的资源估算、项目活动历时估算并制订了项目进度计划，形成了项目进度甘特图，在项目执行过程中依据项目甘特图，进行项目绩效测量，根据绩效测量的结果以及通过项目进度变更控制系统对项目进度进行了很好的控制。在项目的各个里程碑阶段都很好地在确保项目质量和成本的基础上， 按照项目时间进度计划完成了项目。最终，在 2009 年底由 XX 市政府正式宣布系统一次性上线成功。该项目在时间管理过程中还存在一些不足，例如在活动历时估算时我们还应该更多的安排预留时间，为项目风险做好时间方面的准备;在制订顷目进度计划时，我们还应该更多考虑资源平衡方面的问题，使项目资源得到更充分的利用;在进度控制阶段，我们在各个里程碑评审过程中还应该增加用户参与，与用户更好地进行项目进度沟通。争取在今后的项目管理过程中百尺竿头、更进一步。【正文】2008 年 10 月，XX 发展股份有限公司作为系统集成总承包商承接了 XX 市人力资源和社会保障局所委托的 XX 市基本臣疗保险门诊实时结算项目，我作为项目经理负责全程项日管理，并参与了业务需求讨论和系统分析等工作。该项目覆盖了全市 18 个区县、1800 家臣保定点臣疗机构和 1300 万参保人。在参保人门诊就臣费用结算时，使用社保片实时计算臣保基金和个人支付金额，参保个人只需负担个人支付金额即可完成结算过程，将门诊费用报销支付时间由几个月缩短为儿秒钟，极大地方便了参保人。该项目从 2008 年 10 月开工，到2009 年 12 月验收结束，历时一年多，项目涉及 XX 市和 18 区县人社局、1800 家定点臣疗机构，项目干系人众多，项目业务需求内容繁多。由千项目属千 XX 市政府折子工程，项目时间进度要求必须在 2009 年底完成，项目管理过程中的时间管理尤为重要，是项目是否成功的重要评价标准。在具体管理过程中，我根据项目实际情况，遵循时间管理的主要方法， 对项目活动进行了定义、排序，资源估算、历时估算并制订了项目进度计划，在项目执行过程中，通过项目进度变更控制系统对项目进度进行很好的控制，最终在既定的时间完成了所有项目工作，取得了良好的效果。2009 年底由 XX 市政府正式宣布一次性上线成功，目前运行情况良好。一、活动定义首先，我们根据项目范围说明书以及项目的 WBS 对项目的所有活动进行了定义。我们将项目先进行了阶段定义，包括项目的需求获取、需求分析、系统设计、系统开发、系统测试、用户测试、系统试点、系统正式上线阶段，然后，我根据项目进展的不同阶段，采用滚动规划方法，将项目涉及到的所有活动逐步进行了定义。对千近期需要完成的工作在工作分解结构最下层详细规划，远期需要完成的工作则表现在工作分解结构相对高的层次上。通过滚动规划方式随着项目工作的开展，项目活动也逐层逐步清晰。二、活动排序根据活动定义，我将所有活动进行了排序，通过前导图的方法，将所有活动之间的依赖关系整理形成项目网络图。在此阶段中最重要的就是明确各个活动之间的依赖关系，例如在系统测试试阶段，我们通过与用户沟通，最终明确先进行我们公司内部的自测工作，然后由用户代表在公司的实验室环境下进行用户测试，最后再选择两家试点臣院在臣院实地环境下进行现场测试;而对千公司内部测试阶段，我们将臣院端系统与区县经办机构端的系统进行同步闭环测试。三、活动的资源估算为了做好所有项目活动在所需资源上面的准备工作，我们还对项目活动的资源进行了估算，通过自下而上的估算方法我们整理了整个项目所需要的相关资源。例如在测试阶段，我们针对所需要测试的系统数量、每个系统的测试人员数量，以及试点测试臣院的数量，我们估算了所需要测试用忱卡机具以及测试卡的数量，在系统测试之前要求机具和卡片提供商必须按时提供测试用的设各以保证测试工作的顺利进行。四、活动的历时估算对千活动历时估算我们使用了活动历时二点估算法，由千在系统开发过程中业务算法相对比较复杂，具体开发过程中可能会遇到很多不确定因素，为此，我要求项目人员估算了最乐观、最悲观以及最可能的时间的开发时间，使用三点估算法计算公式计算出项目活动的历时估算。例如对千系统测试工作，无法很准确地估算测试 bug 的修改时间，为此我要求测试人员进行了三点估算，最乐观的时间为 3 周，最悲观的时间为 8 周，最可能的时间为 G 周，通过三点估算公式计算出估算时间为 5.9 周。通过使用三点估算法设置统计权重，运用统计规律降低了项目历时的不确定性。五、制订进度计划在前期时间管理工作的基础上，我制订了项目进度计划，通过项目甘特图全面反映了项目进度状况。在制订进度计划过程中，使用了关键路径法，根据各项目活动之间的依赖关系以及项目活动所使用的资源情况，我们分析并寻找了项目的关键活动，并形成了项目的关键路径。通过平衡与协调项目资源使用情况，最终制订了项目计划甘特图。为了使项目干系人都了解和掌握项目进度计划，我们还将项目计划甘特图印刷成册，形成了项目手册，下发给项目参与各方，得到了用户方以及项目监理方的好评。六、进度控制在项目执行过程中，每周各子项目组根据项目进展报告进行挣值分析，并形成项目跟踪甘特图，并与项目计划甘特图进行比对，如果发现有滞后现象则安排项目组进行赶工。每两周项目整体进行绩效测量通过挣值分析以及项目跟踪甘特图进行绩效评估。如果出现进度变更，则通过项目组以及公司两级进度变更控制系统进行变更评审。对千项目工作重大的变更则由项目监理公司主持召开项目监理会，与用户方和监理方共同沟通项目进度变更情况，对千批准的变更申请，在监理会后形成项目进度变更报告，发送项目相关各方。【结束语】在门诊实时结算项目管理过程中，我全面应用了项目时间管理的方法，使得该项目在时间管理方面较好地达到了预期目的，确保了 2009 年底系统上线。鉴千我们在项目初期通过项目工作分解进行了活动定义，使用了前导图法对项目活动进行了排序，并使用了自下而上的估算方法对项目活动进行了资源估算，使用了项目历时三点估算法降低了历时估算的不确定性，最终形成项目进度计划，并在项目执行过程中很好地运用了绩效测量以及项目组与公司两级进度控制系统，对项目进度进行了控制，并且在项目监理方的组织下与用户进行了有效的沟通，最终确保了在 2009 年底完成了项目所有工作，并由 XX 市政府正式宣布一次性上线成功。通过总结，对千项目在时一间管理方面我认为还存在一些不足:第一，在项目活动历时一估算时还应该更多的安排预留时间，为项目风险做好时间方面的准备。第二，在制订进度计划方面还应该更多考虑资源平衡方面的问题，使项目在确保时间进度不变的情况下更好地减少成本。第三，在项目执行过程中，各个里程碑评审过程还应该加强用户参与，在项目进度方面增加与用户的沟通。如果对千以上方面能够进行更好的总结与提高，在今后的项目管理过程中时间管理的水平将得到不断提高，真正达到“百尺竿头、更进一步”的目标。 3.5 模板12345678910111213141516171819202122232425262728293031323334353637项目时间管理是项目管理的一个非常重要的环节，是项目管理的必要条件之一，是保障项目的有序的进行的基础，确保项目的持续发展的前提。因此，我从活动定义、活动排序、活动资源评估、活动历时评估、制定进度表和进度控制等六个方面对项目时间管理进行了把握。第一，活动定义。根据项目范围说明书、项目管理计划、组织过程资产等资料，我对整个项目进行活动定义。通过四个步骤控制账户、规划定义、工作包、活动对整个项目进行分解。通过滚动式规划对近期发生的工作进行详细分解，把分解活动放在工作分解结构的最下层。把远期发生的工作暂时放在工作分解结构的上层。根据整个项目情况，工作包分解成需求分析、概要设计、详细设计、系统编码、系统测试、系统培训、系统试运行、系统上线。然后在把每个工作包在进行详细分解成活动。例如系统测试分解成单元测试、整体测试、集成测试、安全测试、压力测试。定义好后列出活动清单及活动属性。第二，活动排序。活动排序是时间管理的第二个步骤。根据活动清单用前导图的方法对活动进行排序。例如系统编码工作中，某程序员负责基础信息采集的子系统的编码，他所进行的工作分解后，按照活动顺序依次为行政区采集的编码，户人口信息的采集编码、户成员基础信息采集编码、已婚育龄妇女基础信息的采集编码、已婚育龄妇女指纹接口对接的编码、手术人员基础信息的采集编码、新生儿基础信息的采集编码。第三，活动资源估算。活动资源估算是每个活动占用的资源进行估算。根据活动的资源估算汇总成工作包所占的资源估算。例如，编码的活动定义和排序完成以后，根据活动的数量及难易程度，判断开发这些活动所需的高级程序员以及普通程序员的人数，某某省某某市人口计划和生育系统需要4个高级程序员和2个普通程序员。第四，活动历时估算。活动历时估算是估算每个活动所占用的时间。根据活动开发的工作量的大小判断活动的时间。根据过去开发项目的经验，我对这次项目开发进行了估算。例如权限管理和用户管理功能因过去有开发项目的源代码，因此编码及单元测试的时间估算为2天。第五，制定进度表。制定进度表是项目时间管理中关键的一环，因此根据前导图，通过关键路径法制定出真个个开发过程的时间。需求分析1个月、系统设计1个月、系统编码6个月、系统测试1个月、系统培训1个月、系统试运行3个月。因此从系统需求分析到系统正式上线的周期大概为1年零1个月。第六，进度控制。进度控制对于项目时间管理来说是非常重要的环节。根据项目实际开发的时间与进度表的时间的偏差进行计算，判断项目时间进展情况。在开发的过程中，由于统计报表管理中人口计划生育国统七张表的统计口径根据政策发生了变更，然后活动重新进行了定义排序估算，根据新的时间，开发周期将会超期。为此，我们利用赶工的方法，加班加点把统计报表子系统在预计的周期内完成。 四、成本管理五、质量管理六、人力资源管理七、沟通管理八、风险管理九、采购管理十、干系人管理]]></content>
      <categories>
        <category>考证</category>
      </categories>
      <tags>
        <tag>信息系统项目管理师</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息系统项目管理师常考知识点]]></title>
    <url>%2F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[十大知识领域、五大项目管理过程组、47个过程启动过程组 2个 规划过程组 24个执行过程组 8个监控过程组 11个收尾过程组 2个 项目管理过程组 与 知识领域： 序号 十大知识领域 启动过程组 规划过程组 执行过程组 监控过程组 收尾过程组 1 项目整合管理 1. 制定项目章程 2. 制定项目管理计划 3. 指导与管理项目工作 4. 监控项目工作5. 管理控制变更 6. 结束项目或阶段 2 项目范围管理 7. 规划范围管理8. 收集需求9. 定义范围10. 创建WBS 11. 确认范围12. 控制范围 3 项目时间管理 13. 规划进度管理14. 定义活动15. 排列活动顺序16. 估算活动资源17. 估算活动持续时间18. 制定进度计划 19. 控制进度 4 项目成本管理 20. 规划成本管理21. 估算成本22. 制定预算 23. 控制成本 5 项目质量管理 24. 规划质量管理 25. 实施质量保证 26. 控制质量 6 项目人力资源管理 27. 规划人力资源管理 28. 组件项目团队29. 建设项目团队30. 管理项目团队 7 项目沟通管理 31. 规划沟通管理 32. 管理沟通 33. 控制沟通 8 项目风险管理 34. 规划风险管理35. 识别风险36. 实施定性风险分析37. 实施定量风险分析38. 规划风险应对 39. 控制风险 9 项目采购管理 40. 规划采购管理 41. 实施采购 42. 控制采购 43. 结束采购 10 项目干系人管理 44. 识别干系人 45. 规划干系人管理 46. 管理干系人参与 47. 控制干系人参与 记忆技巧: ①: 只有两个启动过程组,两个收尾过程组————-&gt;启动过程组只位于 整体管理 和 项目干系人管理; 收尾过程组只位于 整体管理 和 采购管理 ②: 范围,时间,成本,风险 没有 执行过程组(口诀: 范进成风无执行) ③: 人力资源管理 没有 监控过程组(口诀: 人力资源无监控) 范围管理——范 6时间管理(又称进度管理)——进 7整体管理——整 6沟通管理——狗 3质量管理——子 3成本管理——成 4人力资源管理 , 项目干系人管理——人 4,4风险管理——风 6采购管理——采 4 口诀: 范进整狗子,成人风采. 对应的过程数: 676 3344 464 口诀: 两启两收先来记 口诀: 范进成风无执行 口诀: 人力资源无监控 范围管理口诀: 范围需要先收集，裁剪补充再定义； 拆分工作创WBS，审批输出一基准 控制范围先确认. 进度管理口诀: 进度先要定活动，然后才能排顺序； 资源 时间要估算，这样才能制计划。 风险管理口诀: 风险识别要靠前，定性定量分析全； 已知未知要了解，这样才能来应对。 PMBOK五大过程组是什么？PMBOK五大过程组是：启动过程、规划过程、执行过程、监控过程、收尾过程。各用一句话概括项目管理知识体系五大过程组：1、启动过程组：作用是设定项目目标，让项目团队有事可做；2、规划过程组：作用是制定工作路线，让项目团队“有法可依”；3、执行过程组：作用是“按图索骥”，让项目团队“有法必依”；4、监控过程组：作用是测量项目绩效，让项目团队“违法必究”，并且尽量做到“防患于未然”；5、收尾过程组：作用是了结项目（阶段）“恩怨”，让一切圆满。 PMBOK十大知识领域是什么？PMBOK十大知识领域是：整合管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理、干系人管理。各用一句话概括项目管理知识体系十大知识领域：1、整合管理：其作用犹如项链中的那根线；2、范围管理：做且只做该做的事；3、时间管理：让一切按既定的进度进行；4、成本管理：算准钱和花好钱；5、质量管理：目的是满足需求；6、人力资源管理：让团队成员高效率地和你一起干；7、沟通管理：在合适的时间让合适的人通过合适的方式把合适的信息传达给合适的人；8、风险管理：“无事找事”，从而让项目“无险事”；9、采购管理：当好甲方；10、干系人管理：和项目干系人搞好关系并令其满意。 一、UML相关知识:UML: 统一的建模语言(Unified Modeling Language),独立于软件开发过程,它不是可视化的程序设计语言而是一种可视化建模语言 1.1 五种结构视图:①: 用例视图(用例图) ②: 逻辑视图 (类图 / 对象图): 又称设计视图描述系统的功能需求,表示了设计模型中在架构方面具有重要意义的部分,即类,子系统,包和用例实现的自己. ③: 进程视图(协作图,状态图,序列图,活动图): 并发问题, 关注进程,线程,对象等运行时概念,及并发,同步,通信 ④: 实现视图(构件图): 描述软件结构 构件图: 描述各种软件构件之间的依赖关系,是一种说明了系统静态实现视图 ⑤: 部署视图(部署图): 分布问题 部署图: 显示系统软硬件之间的物理架构, 是一种说明了系统体系结构的静态实施视图 口诀: 用逻辑进程实现部署, 静态实现构件图 1.2 UML2.0 中的14种图静态视图: ①: 部署图—&gt;部②: 对象图—–&gt;队③: 用例图——&gt;用④: 包图——-&gt;包⑤: 复合图(组合结构图)—-&gt;袱⑥: 制品图: 描述系统的物理结构,制品包括文件,数据库等—-&gt;制品⑦: 构件图—–&gt;够⑧: 类图—–&gt;累 口诀: 部队用包袱制品够累 动态视图: ①: 活动图—–&gt;东 ②: 顺序图—-&gt;西也称顺序图,按照时间顺序描述对象间的交互,强调对象间消息发送的顺序,显示对象间动态的合作关系. ②: 状态图—–&gt;装 ④: 通信图(UML1.0中 称 协作图)—-&gt;信描述对象间的交互和链接,显示对象间如何发送消息,其中顺序号指明消息的嵌套关系,和发生顺序. ⑤: 定时图: 是一种交互图,强调消息跨越不同对象或参与者的实际时间,而不仅仅只是关心消息的相对顺序.—–&gt;是⑥: 交互概览图(活动图和顺序图的混合物)—-&gt;交互 口诀: 东西装信是交互 1.3 类之间的关系四种:①: 关联(组合,聚合)②: 泛化③: 依赖④: 实现 【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门,鸟和翅膀的关系 口诀: 鸟翅组合强关联,相依为命同根生 【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 1.4 用例图:从用户的角度描述系统功能,描述的是系统用户与系统,系统与外部系统的交互,是开发者与用户交流的工具. 用例是系统的一个功能单元 1.4.1 用例图中用例之间的关系:①: 关联(association)②: 泛化(generialize)关系.③: 包含include(或使用User)④: 扩展(extends) 口诀: 类与用例两不同,包含扩展类中无 二、计算机组成原理相关2.1 关于总线:总线: 计算机中各个部件相连的通信线, 2.1.1 总线分以下4类:①: 中央处理器内部总线 寄存器与寄存器, 寄存器与运算器 ②: 部件内总线 一块插卡的内部总线(片级总线), 如显卡,多功能卡等插卡都使用了~实现本卡上各芯片互联 ③: 系统总线 各个功能部件(中央处理器,存储器,外设)之间互连的总线. 分为: 数据总线 ,地址总线 , 控制总线 ④: 外部总线 计算机系统之间,或者是计算机和其他设备 2.2 Cache:高速缓冲存储器,介于中央处理器和主存之间. 如果不命中则从主存中取出需要的块,同时送往CPU 和 Cache 写回法: 先写cache,并用标志位加以说明,直至经过重写的字块被从cache中替换出来时再写入主存 三、信息系统:一般指采集,处理,分析,存储,传输,检索信息的具有完整功能的集合体. 3.1 信息库存储大量数据,文档的资料库 包含内容:①: 网络目录(存放了电子表格软件,项目信件和数据等)②: 打印的文档③: 一个或多个Case工具目录②: 到上述组织的内联网网站接口 3.2 ERPERP: 是一个软件ERP项目: 管理变革项目,不像传统财务核算软件,只是替代用户的手工业务 强调 事前计划,事中控制,事后分析的管理理念和及时调整的管理策略 3.3 建立企业信息系统原则:自上而下的规划, 自下而上的分布实现 3.4 计算机的数据环境类型:按照管理层次从低到高排列: 数据文件—&gt;应用数据库—&gt;主题数据库—-&gt;信息检索数据库 3.5 总监理工程师代表 不能拥有的职权:①: 不能主持编写项目监理规划②: 不能签发工程开工报审表,工程竣工监理报告, 工程款支付证书③: 不能调解合同争议,处理索赔,审批工程延期④: 不能调换人员总结: 不能拥有与规划,开工,支付,索赔,人员,相关的职权 3.6 WebService协议和技术:WebService体系结构是一种面向服务的体系结构(SOA),这种体系结构设置了3个角色和3种操作. 3个角色: 服务提供者、服务请求者、服务注册中心(服务提供者在这里发布他们的服务描述)3种操作: 发布服务描述、查询或查找服务描述、根据服务描述绑定或调用服务. ①: XML : 是WebService平台中表示数据的基本格式. ②: SOAP: Simple Object Access Protocol 简单对象访问协议, 实现系统间能用“软件-软件对话的方式相互调用”,打破了软件应用,网站,和各种设备之间格格不入的状态,实现基于Web无缝集成的目标 ③: UDDI: 是一种规范,提供基于Web服务的注册和发现机制,目的是为电子商务建立标准. UDDI它为Web服务提供3个重要的技术支持: ①: 标准,透明,专门描述Web服务的机制 ②: 调用Web服务 ③: 访问Web服务注册中心 3.7 网络接入技术广义上说跟网络接入相关的都可以算是网络接入技术,如: LAN方式,拨号接入方式,DSL方式,光纤接入,Cabel Modem线缆调制解调器接入,IEEE802.11 无线局域网接入,GPRS和3G,HFC,XDSL,DDN,PSTN,ISDN ①: HFC: Hybrid Fiber Coaxial 混合光纤同轴电缆网,经济实用的综合数字服务宽带网接入技术,光纤干线,同轴电缆,用户配线网络三部分组成,有线电视台出来的节目信号,先变成光信号在干线上传输,到用户区后把光信号转为电信号,经过分配器分配后通过同轴电缆送到用户. ②: XDSL :数字用户线路 (Digital Subscribe Line)是各种DSL的总称,如ADSL,VDSL,SDSL等 ADSL: Asymmetric Digital Subscribe Line 非对称数字用户环路.所谓非对称指的是上行和下行带宽不对称. VDSL: Very Speed Digital Subscriber Line 超高速数字用户线路 CDMA: Code Division Multiple Access 码分多址 ③: DDN: (Digital Data NetWork)专线上网方式,传输速率高,质量好,延时小等特点,将数万或数十万条光缆为主体的数字电路,通过数字电路管理设备构成的数据传输基础网络. 注: NetBEUI: 不属于网络接入技术,它用于本地局域网,不能与其他网络的计算机进行沟通 3.8 数据仓库数据仓库的用户为管理层,它的数据随业务持续增长. 面向主题的,集成的,相对稳定的反映历史变化的数据集合,用于支持管理决策 是对多个异构数据源(包括历史数据)的有效集成,集成后按照主题重组,其中的数据一般不再修改. 3.9 SAN(存储区域网络)包括FCSAN 和 IPSAN FCSAN 使用数据传输协议中的 FiberChannel(FC: 一种高速网络技术标准,千兆位数据传输的技术标准) 3.10 ISCSIInternet Small Computer System Interface, 它基于TCP/IP协议 3.11 信息化项目监理分三种: ①: 咨询式监理 ②: 里程碑式监理 ③: 全程式监理 3.12 软件构件(软件中间件)的标准:①: OMG组织(对象管理组织)提出的CORBA 为解决分布式处理环境中软硬件的互连而提出. ②: 微软提出的COM 组件架构** ③: SUN提出的EJB: 用于封装业务, 中间层业务功能由EJB构件实现,JSP用于实现业务逻辑处理结果的动态发布,构成动态的HTML页面,中间层也可用servlet实现更为灵活的动态页面. 3.13 信息系统工程监理活动主要内容::四控,三管,一协调. 四控: 信息系统工程的质量控制进度控制投资控制变更控制 三管: 信息系统工程的合同管理信息管理安全管理 一协调: 协调有关单位间的工作关系. 3.14 监理文件3.14.1 监理规划在监理委托合同签订后,由总监理工程师主持编写,监理单位技术负责人书面批准的指导监理开展工作的纲领性文件 作用: ①: 监理项目部职能的具体体现②: 指导监理项目部开展工作③: 信息系统工程监理管理部门进行监督 监理单位的主要内容和依据④: 建设单位 检查 监理单位是否能认真,全面履行信息系统工程监理委托合同的重要依据 3.14.2 监理实施细则在监理规划指导下,由专业监理工程师针对项目具体情况制定的更具有可实施,可操作的业务性文件,指导具体监理业务的开展. 3.14.3 监理大纲 :是社会监理单位为了获得监理任务,在投标前由监理单位编制的项目监理方案性文件,是投标书的重要组成部分, 3.16 进度控制技术手段:①: 甘特图②: 网络图单代号网络图: 箭头是关系, 结点是活动双代号网络图: 箭头是活动, 结点是事件.③: 香蕉 曲线图法两条S型曲线组合而成的闭合曲线:ES曲线是: 计划以各项工作的最早开始时间安排进度而绘制LS曲线是: 计划以各项工作的最迟开始时间安排进度而绘制ES各点均在LS各点的左边,ES和LS起点和终点相同,所以ES与LS围成的图形像香蕉. 注: ABC分析法:帕累托分析法,把分析的对象分成A,B,C三类,从而有区别地确定管理方式 3.17 旁站监理:是监理单位控制工程质量的重要手段,主要在关键部位或关键工序施工过程中,由监理人员在现场进行的监督活动.网络综合布线,设备开箱检验,机房建设等活动涉及隐蔽工程,需要进行旁站监理,确保这些活动的过程质量. 3.18 信息系统常用开发方法:①: 结构化方法 三部分组成: 结构化方法.结构化设计,结构化程序设计. 基本思想: 用户至上(开发人员始终与用户保持联系),自顶向下设计,自底向上逐步实现,模块化设计 按照信息系统生命周期,应用结构化系统开发方法,将整个系统开发过程分为若干阶段,然后一步一步依次进行,前一阶段是后一阶段的依据. 包括数据流的分析方法: 数据流图,数据字典 缺点: 开发周期长, 难以适应需求变化,不适合开发大规模的复杂的系统 ②: 原型方法 需求不清, 快速开发一个原型系统, 通过反复修改来实现最终系统需求 ③: 面向对象方法OO 面向对象法分三个阶段: 分析: 分析模型由 用例模型,类-对象模型,对象-关系模型,对象-行为模型组成. 设计 概要设计(软件基础架构),详细设计(完整的类架构) 主要是类设计,用例设计,子系统设计 实现 ④: 面向服务的方法SO 跨构件的功能调用,进一步将接口定义和实现解耦,使信息系统快速响应需求与环境变化 3.19 信息系统的生命周期:3.19.1 项目的生命周期分四个阶段:①: 启动②: 计划③: 执行④: 收尾 3.19.2 信息系统的生命周期分四个阶段:①: 立项②: 开发③: 运维④: 消亡 开发阶段细分为5个阶段 划——总体规划阶段分——系统分析阶段即——系统设计阶段实——系统实施阶段验——系统验收阶段 口诀: 划分即实验 ①: 系统规划阶段 (初步调查,可行性分析和项目开发计划)———-&gt;划 做系统调查和可行性分析 对现行系统的状况进行初步调查,研究建设新系统的必要性和可能性,拟定系统的备选方案,对这些方案进行可行性研究,写出可行性研究报告,可行性研究报告审议通过后,将新系统建设方案及实施计划编写成系统设计任务书 可行性研究: 操作可行性,技术可行性,经济可行性. 经济可行性分析: 包括 支出分析, 收益分析, 收益投资比, 投资回收期,敏感性分析. 该阶段最终形成可行性研究报告 系统设计任务书 可行性研究方法: 经济评价法,市场预测法,投资估算法,增量净收益法等. ②: 系统分析阶段(需求分析) 又称逻辑设计阶段——–做什么———&gt;分 根据系统设计任务书所确定的范围,对现行系统进行详细调查,描述缺陷和不足,然后确定新系统的目标和逻辑功能. 为设计阶段提供新系统的逻辑模型,内容包括组织结构及功能分析,业务流程分析,数据和数据流程分析数据流图DFD 系统说明书: 既是给用户看的,也是下一阶段的工作依据,也是将来验收系统的依据,用户通过它了解未来系统的功能,判断是否为要求的系统 该阶段最终形成系统说明书 ③: 系统设计阶段(概要设计,详细设计)————-怎么做——–&gt;即 根据系统说明书中规定的功能要求,考虑实际条件,具体设计实现逻辑模型的技术方案. 系统架构设计,数据库设计,功能模块设计,安全控制方案设计等 E-R图描述现实世界概念模型,用于数据库设计 ④: 系统实施阶段(编码,测试)——-&gt;实 将设计的系统付诸实施,这一阶段包括 计算机等设备的购置,安装和调试,程序的编写和调试,人员培训,系统调试等系统实施按实施计划分阶段完成,每阶段写出实施进展报告,系统测试后写出系统测试分析报告. 该阶段最终形成实施进展报告,系统测试分析报告 ⑤: 系统维护阶段(或验收运行维护)———&gt;验 口诀: 划分即实验 易错点: ①: 规划阶段产生 系统设计任务书 而不是设计阶段产生 ②: 分析阶段 产生 逻辑模型,设计阶段来实现, 而不是实施阶段来实现. 3.20 企业中信息系统的分类:3.20.1 根据服务对象而言分为:①: 面向作业处理: OA办公自动化系统,DAMS数据采集与监测*系统 ②: 面向管理控制 KM知识管理系统,CIMS计算机集成制造系统 ③: 面向决策计划 MES管理专家系统,DSS决策支持系统,SIS战略信息系统 3.21: 网络存储3.21.1 现有存储的三大模式:①: 直接附加存储DAS,不带任何存储操作系统 ②: 网络附加存储NAS 支持多种TCP/IP协议,支持即插即用,类似于文件服务器 ③: 存储区域网络 SAN :易扩展的存储技术 注: 哈希散列表存储: 不是网络存储结构, 它是根据关键码值而直接进行访问的数据结构(也就是把关键码值映射到表中一个位置来访问记录,以加快查找速度) 3.22 .NET一般的高级程序语言(C#,VB)会直接将代码编译为机器语言,而编译.NET是不同的,多了一个环节,就是先将高级语言编译成为中间语言(IL),中间语言最终编译为机器代码.这些中间语言是.NET框架中所有语言编译后的结果,比如C#,VB语言编写的两个类,编译后中间语言看起来一样,这就显示了.NET跨平台的事实. 3.23 常见产品与语言:.NET Framework —&gt;可用于C#,C++,VBWASP是web应用框架—–&gt;使用PHP5开发DelPhi是集成开发环境IDE—-&gt;使用PascalGLUE是一种java扩展包 3.24 CRM是集成化的信息管理系统, 存储了企业现有和潜在客户的信息,并且对这些信息进行自动的处理从而产生更人性化的市场管理策略. 它是以客户为中心的商业策略,而不是传统的以产品或市场为中心将业务中心转移到客户,根据不同的客户有重点的采取不同的策略 3.25 工作流工作流技术不是开发过程管理的技术,所以它不能提升开发过程的灵活性 主要提供业务流程建模,管理,控制功能. 3.26 2G/3G/4G标准GSM 是2G标准 GPRS是2G移动数据业务 四种国际3G标准: WCDMA,CDMA2000,WinMAX,TD-SCDMA(时同步码分多址,由中国自主研发) LTE是4G标准 3.27 电子商务:原始电子商务: 使用电子信息技术工具进行商务活动凡使用诸如电报,电话,广播,点水,传真以及计算机,计算机网络等手段,工具进行商务活动,都可称之为电子商务. 3.27.1 第四方物流为第一,二,三方提供物流规划,咨询,物流信息系统,供应链管理等活动.它是一个供应链的集成商,是供需双方及第三方物流的领导力量. 3.27.2 第三方物流:生产经营企业为集中搞好业主,把原来属于自己处理的物流活动,以合同方式委托给专业物流服务企业,同时提供信息系统与物流企业保持密切联系,以达到对物流全程管理控制的一种物流运作和管理方式. 3.28 经济计量分析:工作程序顺序:设定模型—&gt;估计参数—&gt;检验模型—&gt;应用模型 3.29 关于GCCGNU Compiler Collection , 即GNU编译器套件 , 它是以GPL许可证所发行的自由软件,也是GNU计划的关键部分. 3.30 文件审批流程承建方提交的&lt;&lt;项目质量管理计划&gt;&gt;先由建设方技术总监对内容,范围审核后,再送交监理方批准 3.31 关于监理①: 当专业监理工程师需要调整时,总监理工程师应该 书面通知 建设单位和承包单位. ②: 当总监理工程师需要调整时,监理单位应该征得建设单位同意并书面通知建设单位 监理单位应该于委托监理合同签订后10个工作日内将监理项目部的组织形式,人员构成及对总监理工程师的任命书书面形式通知建设单位. 建设单位应该将委托的监理单位,监理内容,书面通知承建单位. 3.32 企业信息化结构分类: ①: 产品层②: 作业层③: 管理层④: 决策层 3.33 云计算是一种服务关键技术:虚拟化 : 是一种资源管理技术, 包括服务器虚拟化 和 应用虚拟化分布式系统: 分布式存储 和 分布式计算 3.34 操作系统安全①: 切断: 可用性的威胁: 如非法用户破坏硬盘,破坏系统资源等 ②: 截取 机密性的威胁:非法窃取和拷贝文件等 ③: 篡改 完整性的威胁,非法用户修改网络中正在传送的消息等 ④: 伪造 合法性的威胁,如非法用户把伪造的消息插入系统中等 口诀: 切可用,截机密,篡完整,伪合法 3.35 信息安全:①: 设备安全: 是信息系统安全的首要问题,稳定,可靠,可用性 ②: 数据安全: 秘密,完整,可用性 ③: 内容安全: 政治,法律,道德层次 ④: 行为安全 ⑤: 物理安全: 机房出入口应该安排专人值守,控制,鉴别和记录进入的人员. 注: 不包括人员安全 3.36 物联网两项关键技术: ①: 传感器技术: 感受被测量的信息,将模拟信号转换为 ②: 嵌入式技术 3.37 智能 特点①: 感知能力 ②: 记忆,思维能力: 能存储感知到的外部信息,及由思维产生的知识,同时能利用已有的知识对信息进行分析、计算、比较、判断、联想、决策. ③: 学习,自适应能力: 通过与环境的相互作用,不断学习积累知识,使自己能适应环境. ④: 行为决策能力 注: 思维能力 和 学习能力自适应能力概念容易混淆, 所以 只要记住 出现 学习和自适应就是学习自适应能力 3.38 区块链:3.38.1 定义:是分布式数据存储 、点对点传输、共识机制、机密算法等计算机技术的新型应用机制. 3.38.2 区块链2.0 技术架构自下而上分为数据层: 网络层: 包括 P2P组网机制, 数据传播机制,数据验证机制 共识层: 激励层: 智能合约层: 3.39 IaaS 、PaaS 、SaaS云服务只是一个统称，可以分成三大类: IaaS: Infrastructure-as-a-service 基础设施即服务——-&gt;向用户提供计算机能力、存储空间,等基础设施方面的服务 PaaS: Platform-as-a-service 平台即服务——–&gt;向用户提供虚拟的操作系统、数据库管理系统、Web应用等平台化的服务. SaaS: Software-as-a-service 软件即服务—–&gt;向用户提供应用软件如CRM、办公软件等, 简言之: IAAS就是服务器，也就是硬件PAAS就是开发工具SAAS就是码农做出来的网站 三者的区别详解: 请设想你是一个餐饮业者，打算做披萨生意。 （1）方案一：IaaS 他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。 （2）方案二：PaaS 除了基础设施，他人还提供披萨饼皮。 你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。 （3）方案三：SaaS 他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。 SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。 IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。 3.40 EAI 企业应用集成作用: 消除消息孤岛,将多个信息系统连接起来,实现无缝集成. ①: 控制集成: 在业务逻辑层上 ②: 业务流程集成: 或称 过程集成, 超越了数据 和 系统, 由一系列的标准的统一的数据格式的工作流组成. ③: 数据集成是白盒集成 ④: 表示集成: 也称 界面集成 属于黑盒集成. 注: 控制集成 与 业务流程集成 概念上易混淆, 所以只记住 控制集成: 在业务逻辑层上就Ok. 3.41 设备安全①: 稳定性: 一定时间内不出故障的概率 ②: 可靠性: 一定时间内能正常执行任务的概率 ③: 可用性: 随时可以正常使用的概率 3.42 网络安全①: 防火墙: 将内部网和公众访问网分开.阻挡对网络的非法访问和不安全数据的传递,使得本地系统和网络免于受许多网络安全威胁 ②: 入侵检测系统: 注重的是网络安全状况的监管,通过监视网络或系统资源,寻找 违反安全策略的行为或攻击迹象,并发出报警 ③: 入侵防护系统: 倾向于提供主动防护,注重对入侵行为的控制,设计宗旨: 预先对入侵活动和攻击性网络流量进行拦截 ④: 蜜罐技术: 通过模拟一个或多个易受攻击的主机和服务,给攻击者提供一个容易攻击的目标. 做个比喻: 防火墙相当于小区保安,在门口拦截一切可疑人等,而入侵检测系统相当于小区里的监控,监控小区里面发生的异常. ⑤: 访问控制: 分为自主访问控制和强制访问控制两大类 自主访问控制: 用户有权对自己创建的对象进行访问,并可以将这些对象的访问权限授权于其他用户,或收回权限 强制访问控制: 由系统(通过专门设置的系统安全员)对用户所创建的对象进行统一的强制性控制,按照规定的规则决定哪些用户可以对哪些对象进行什么样的操作,即使是创建者用户,在创建一个对象后,也可能无权访问该对象. 3.43 信息系统规划工具P / O矩阵: 过程/组织矩阵(Progress/organization) C/U矩阵: 创建/用户矩阵(Create/User): 数据类型 和 企业过程 R/D矩阵: 资源/数据矩阵(Resource/Data): 3.44 CCB 变更控制委员会CCB(Change Control Board) 在CMMI(Capability Maturity Model Integration)中，是“变更控制委员会”的含义，同时具有配置控制委员会（Configuration Control Board）的含义。 CCB可以由一个小组担任，也可以由多个不同的组担任，负责做出决定究竟将哪些已建议需求变更或新产品特性付诸应用。典型的变更控制委员会会同样决定在哪一些版本中纠正哪些错误。 CCB的成员应当能代表变更涉及的团体。其可能包括如下方面的代表： 1.产品或计划管理部门 2.项目管理部门 3.开发部门 4.测试或质量保证部门 5.市场部或客户代表 6.制作用户文档的部门 7.技术支持部门 3.44.1 CCB负责组织 对 变更申请进行评估 并确定以下内容:①: 变更对项目的影响 ②: 变更的内容是否必要 ③: 变更的范围是否考虑周全 ④: 变更的实施方案是否可行 ⑤: 变更工作量估计是否合理 CCB决定是否接受变更,并将决定通知相关人员 变更由变更控制委员会CCB审批 3.45 变更请求:由项目经理审查,评价, 由CCB来批准或否决. CCB决定是否变更项目基准. 项目经理负责项目的监控. 注: 项目集指导委员会 是项目的决策机构,负责为项目集的管理方式提供支持. 3.45.1 配置项的三种状态:①: 草稿: 配置项刚建立时 ②: 正式发布: 配置项通过评审后,其状态变为”正式发布” ③: 正在修改: 正式发布后,如果修改必须依照”变更控制规程”执行,其状态变为”正在修改”.当配置项修改完毕并通过评审时,其状态又变为”正式发布”,如此循环. 3.46 两化融合①: 工业化 和 信息化 发展攻略的融合 3.47 大数据 3.48 信息系统安全等级第一级: 用户自主保护——&gt;普通内联网用户 第二级: 系统审计保护——&gt;通过内联网进行商业活动,需要保密的非重要单位. 第三级: 安全标记保护——-&gt;地方各级国家机关,该级别受到破坏后会对社会秩序,和公共利益造成严重损害,或对国家安全造成损害. 第四级: 结构化保护——–&gt;中央级国家机关,国家重点科研单位机构 第五级: 访问验证保护级——-&gt;国防关键部门 口诀: 一主二审三标四化五验证 口诀: 验国防,化中央,标地方 3.49 互联网+ 3.50 项目建议书的内容①: 项目的必要性 ②: 项目的市场预测 ③: 项目建设必须的条件 ④: 产品或服务的市场预测 不包含风险因素和对策 3.51 开发总成本①: 研发成本 ②: 行政管理 ③: 销售与分销 ④: 财务费用和折旧 注: 前三个成本的总和为经营成本 3.52 变更性质①: 重大变更 ②: 重要变更 ③: 一般变更 3.53 组织级项目管理①: 项目组合管理: 通过选择正确的项目集和项目、设定工作的优先级并提供必要的资源的方式来促成组织的战略实现. ②: 项目集管理: 对其所包含的项目子集和项目的依赖关系进行有效的管理,从而实现项目集的特定利益 ③: 项目管理: 通过制定和实施集合来完成特定的工作范围,支持项目集和项目组合目标的实现.最终确保组织战略得以实现. 要求三者战略方向一致 3.54 评审和审计①: 管理评审: 监控进展决定计划和进度的状态,或评价用于达到目标所用管理方法的有效性. ②: 技术评审: 评价软件产品,已确定其对使用意图的适合性. 口诀: 管监控,技意图 评审者按照规范的步骤对软件需求、设计、代码或技术文档进行仔细地检查,以找出和消除其中的缺陷.目的主要在于发现问题和验证符合性. 注: 评价所用管理方法的有效性属于过程管理或过程审计的内容,不属于技术评审. ③: 走查 ④: 审计: 是正式组织的活动,识别违例情况,并要生成审计报告,采取根正性行动. 审计的目的: 提供软件产品对于可应用规则标准指南计划和流程的遵从性的独立评价. 3.55 权力/利益分析法: 属于第二区域的项目干系人: 项目的客户, 项目经理的主管领导—————-权力大,利益高应该重点管理 3.55.1 成员:项目团队成员属于: 供应商属于: 项目经理属于: 3.55.2 管理策略原则:权力高,利益高 的干系人的管理策略是: 重点管理,即使报告 权力高,利益低 的干系人 的管理策略是: 令其满意 权力低,利益高的干系人 的管理策略是: 随时告知 权力低,利益低的干系人 的管理策略是: 花较少的精力监督即可. 口诀: 重点管理双高, 权高利低满意即可 3.56 项目计划①: 一般的项目计划: 主要关注的是 项目活动的计划. ②: 大型及复杂的项目: 制定活动计划 之前必须考虑项目的过程计划,也就是必须考虑用什么方法和过程来完成项目. 过程计划: 制定过程, 执行过程,监督过程,但不包括 裁剪过程. ③: 大型及复杂的项目的控制过程 有3个重要因素: 项目绩效跟踪,外部变更请求,变更控制. 注: 里程碑设置 不管是 小项目还是大项目一般都需要 3.57 网络系统的设计原则①: 可靠性原则 ②: 安全性原则 ③: 高效性原则 ④: 可扩展性原则: 能在规模和性能两个方向上进行扩展 3.58 项目管理办公室①: 建立项目管理的支撑环境 ②: 提供项目管理指导咨询 ③: 多项目的管理和监控 注: 制定项目管理计划 由 各项目团队来做. 3.59 信息物理系统CPS是一个综合计算,网络和物理环境的多维复杂系统,通过3C(Computer,Communication,Control)技术的融合与深度写作实现大型工程系统的实时感知,动态控制和信息服务.CPS实现计算,通信,与物理系统的一体化,可以使物理系统更加可靠,高效,实时协同. 3.60 布线 3.61 对象模型技术OMT把需求分析收集的信息构造在三层模型中,即对象模型,动态模型,功能模型 对象模型: 对谁做 动态模型: 何时做 功能模型: 做什么 3.62 项目配置项详细设计,概要设计,源代码的成果是一定要进入基线配置项的,因为这些是软件开发的产品过程成果,必须纳入基线严格管理. 注: 进度计划一般不会纳入基线来管理 3.63 软件版本号小升级是升级小数点后面的数字, 第一次小升级为V1.1 ,第二次为V1.2 , 所以二次小的升级后版本号是V1.2 注: X.YZ 是表示正在修改的版本 3.64 未来经济发展的重要特征:数据驱动 3.65 网络安全审计从审计级别上分为: ①: 系统级审计 ②: 应用级审计 ③: 用户级审计 四、软件工程相关4.1 数据流图:4.1.1 四个要素:①: 数据流②: 加工③: 数据存储④: 外部实体 : 存在于软件系统之外的人员或组织 4.2 软件维护:交付前和交付后,都要进行,是为需要提供软件支持的全部活动 4.2.1 四种类型:①: 纠正性维护: 改正测试阶段未发现,投入生产运行一段时间后暴露的问题——&gt;就②: 适应性维护: 能适应变化(如迁移数据库,或操作系统),环境变化后能继续使用——-&gt;是③: 预防性维护: 更正潜在错误,为改进软件未来的可维护性,和可靠性,或者给未来的改进提供更好的基础而做出的修改–&gt;鱼④: 完善性维护: 增加功能——&gt;丸 口诀: 就是鱼丸 技巧: 题目中出现预防 / 未来 / 潜在 等字,基本可锁定预防性维护 4.3 开发方法:4.3.1 原型法:需求不清, 快速开发一个原型系统, 通过反复修改来实现最终系统需求 4.3.2瀑布模型:需求明确,变更少 瀑布模型将软件生命周期分为制定计划(问题定义,可行性研究),需求分析,软件设计(概要设计,详细设计),软件实现(编码),软件测试,运行维护等六个阶段. 4.3.3 喷泉模型描述面向对象的软件开发过程 4.3.4 V模型 ①: 开发和测试同等重要,左侧代表开发阶段,右侧代表测试阶段②: 针对每个开发阶段,都有一个测试级别与之对应③: 适用于需求明确和需求变更不频繁的情形 单元测试: 一般由开发人员来执行, 针对编码过程, 检查每个模块内是否正确实现了详细设计说明中的功能性能,接口等集成测试: 针对概要设计,检查模块间的接口关系,和验证已集成的软件是否符合设计要求.系统测试: 针对需求分析, 检查系统作为一个整体是否有效的得到运行,验收测试: 通常由业务专家或用户进行,确认产品功能,性能是否符合用户业务上的需要是否和用户需求一致. 4.3.5 增量迭代模型需求不确定 很多不确定因素且项目参与人员还不能完全理解项目需求,范围 4.4 CMMI 模型:Capability Maturity Model Integration 能力成熟度集成模型,整合了不同的CMM模型 两种表示方法: ①: 阶段式: 组织的成熟度等级针对整个组织进行统一评价成熟度等级 1) 初始级CMM1: 管理无章法，缺乏健全的管理制度 2) 可重复级 CMM2 : 新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件 3) 已定义级 CMM3 : 开发过程，包括技术工作和管理工作,均已实现标准化、文档化。建立了完善的培训制度和专家评审制度 4) 已管理级(定量管理级) CMM4 : 产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的 5) 优化级 CMM5 : 拥有防止出现缺陷、识别薄弱环节以及加以改进的手段 已管理级 有7个过程域: 过程和质量保证 : 使工作人员客观洞察过程和相关工作产品 ②: 连续式: 组织的过程能力等级 针对组织的某些过程度评级(相对单个过程域),即评价组织的某个PA的能力等级为2级或3级. 口诀: 阶段组成熟,连续组过能 4.5 软件质量模型:4.5.1 McCall 质量模型:三种视角来定义和识别软件质量 ①: 产品转移: 可移植,可复用性 ②: 产品修改: 可维护 ③: 产品运行: 正确,可靠,效率,完整性 4. 6 需求分析:4.6.1 作用:描述一个系统必须做什么,或者一个系统是什么(从用户那里了解需求的本质,知道软件需要做什么功能.) 4.6.2 需求分析阶段用到的图形工具:①: 层次方框图: 又称层次模块结构图, 将系统分为若干个子系统,子系统再划分为若干个模块,大模块再分为若干小模块,需求分析阶段可以用此图画出系统的功能蓝图. ②: 用例图: 从用户角度描述系统功能,是用户所能观察到的系统功能模型图,它可以用于需求分析阶段 ③: IPO图: Input Processing Output 输入加工输出, 描述功能需求的输入和输出,它可以用于需求分析阶段 注: N-S图也称盒图,不能用于需求分析阶段, 在流程图中完全去掉流程线,全部算法写在一个矩形阵内,在框内还包含其他框的流程图形式.主要用于程序设计 4.6.3 产生的文档:软件需求规格说明,数据要求说明,初步用户手册 初步用户手册通常是需求人员编写,写完需求文档,就可以写初步用户手册了(肯没有最终的功能界面,但已经可以作为联机帮助手册) 注: 数据库设计是 详细设计的产物, 软件产品规格说明(产品说明书) 是 产品做出来后写的 4.7 软件需求4.7.1 需求的层次:①: 业务需求 企业或客户对系统高层次的目标要求. ②: 用户需求 用户要求系统必须能完成的任务 ③: 系统需求 包括功能需求,非功能需求非功能性需求: 系统必须具备的属性或品质,及设计约束 4.7.2 系统需求分类①: 功能需求: 必须完成的基本动作,用来完成具体的业务 例如: 按照订单及原材料自动安排生产排序定期生成销售分析报表 ②: 性能需求 软件或人与软件交互的静态或者动态数值需求.如响应速度,处理速度 ③: 外部接口需求 用户接口,硬件接口,软件接口,通信接口 ④: 设计约束和质量属性 设计约束: 受硬件限制例如: 系统可实现对多字符集支持,GBK,BIG5,UTF-8等必须运行在UNIX系统下等 属性: 可用性,安全性,可维护性,可转移/转换性,效率例如: 系统同时支持1000个独立站点的并发访问.系统实行同城异地双机备份,保障数据安全 技巧: 看到”必须完成” 基本可以锁定功能需求 看到”速度”基本可以锁定性能需求 看到”安全,并发,字符集”基本可以锁定约束和质量属性 4.7.3 质量功能部署QFD对需求的分类:QFD: Quality Function Deployment : 是一种将用户要求转换为软件需求的技术. 常规需求: 用户认为系统应具备的功能 期望需求: 用户想当然认为系统应具备的功能 意外需求: 用户没有提出的,开发人员自己加的 4.7.4 需求分析的阶段①: 需求提出 ②: 需求描述 ③: 需求评审 4.8 敏捷方法敏捷软件开发宣言:①: 个体和交互胜于过程和工具: 以人为本的思想②: 可以工作的软件胜于面面俱到的文档③: 客户合作优于合同谈判④: 响应变化优于遵循计划 4.9 软件过程改进4.9.1 五条核心原则:①: 注重问题②: 强调知识创新③: 鼓励参与④: 领导层的统一⑤: 计划不断改进 4.10 软件测试4.10.1 从是否关心软件内部结构和具体实现的角度分类: 白盒测试 黑盒测试 灰盒测试: 介于白盒和黑盒之间,多用于集成测试阶段 4.10.2 从是否执行程序的角度分类: 静态测试 和 动态测试 4.10.2.1 静态测试: 不运行被测程序本身,仅通过分析或检查源程序的语法,结构过程,接口等来检查程序的正确性.代码的静态测试 和 文档的静态测试. 对文档的静态测试: 检查单的形式进行 对代码的静态测试: 采用桌前检查, 代码走查, 和代码审查 桌面检查: 对程序执行情况,进行人工模拟,逐步检查源代码中有无逻辑或语法错误的方法来检测故障. 代码走查: 程序员或设计者引导开发组成员通读已经书写的设计文档或编码 代码审计: 由某人、某小组或借助某种工具对代码进行独立的审查,以验证其是否 符合软件设计文件 和程序设计标准. 代码评审: 也称代码复查, 通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动. 口诀: 捉错误, 揍设编, 审标准, 评质量 4.10.2.2 动态测试: 通过运行被测程序,检查运行结果与预测结果的差异,并分析运行效率,正确性和健壮性等性能,该方法由三部分组成: 构造测试用例,执行程序,分析程序的输出结果.白盒测试属于动态测试 注: 黑盒测试 : 属于 功能测试 4.11 设计模式①: 根据 处理范围不同: 分为类模式和对象模式 类模式处理类与子类之间的关系,通过继承建立,在编译期间确定,属于静态关系 对象模式 处理对象之间的关系,在运行时刻变化,更具有动态性. ②: 根据目的与用途分为 : 创建型, 行为型,结构型 4.12 软件测试类型①: 回归测试: 修改了旧代码后,重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误. ②: 冒烟测试: 这一术语源于硬件行业 五、计算机网络 OSI 7层模型: 物理层————巫数据链路层——术网络层————忘传输层————传会话层————会表示层————彪应用层————鹰 口诀: 巫术忘传会彪鹰 5.0 会话层管理主机之间的会话进程,即负责建立,终止进程之间的会话,还利用在数据中插入校验点来实现数据同步. 5.1 传输层:传输层: 实现端用户之间可靠通信 SPX(序列分组交换协议) 5.2 表示层对上层数据或信息进行转换,以保证一个主机应用层信息,能被另一主机的应用程序理解. MPEG协议 数据加密,压缩,格式转换. 5.3 物理层:①: 集线器: 收集多个端口来的数据帧,并广播出去 是共享带宽式的,带宽由端口平均分配 ②: 调制解调器: 模数/数模信号转换③: 中继器: 用于完全相同的两类网络的互连,对数据信号重新发送或转发,来扩大网络传输距离. IEEE802.11: 标准定义了三种物理层通信技术:直接序列扩频调频扩频漫反射红外线 5.4 数据链路层:以太网交换机,根据以太帧中的地址转发数据帧. IEEE802系列规范 5.5 网络层5.5.1 路由器:5.5.2 路由协议分类:内部网关协议IGP: 在一个AS(AutonomousSystem)自制系统(指有权自主决定在本系统应该采用何种路由选择协议的网络)内的路由协议 外部网关协议: AS之间的路由协议 5.6 100BaseFX:F: fiber光纤 是在光纤上实现的100Mbps标准, 运行于光缆上,适合长距离/骨干传输,802.3u标准 5.7 层次化网络设计:5.7.1 三个关键层概念:①: 核心层: Core Layer 目标: 高效速度传输,为网络提供骨干组件 ②: 汇聚层: Distribution Layer 核心层与终端用户接入层的分界面 完成网络访问的策略控制,广播域的定义,过滤寻址等数据处理业务. ③: 接入层: Access Layer 网络分段,广播/多播能力,介质访问的安全性,路由发现,MAC地址的过滤 口诀: 汇策略,核骨干 5.8 关于TCP/UDP:5.8.1 基于TCP协议 :HTTP ,FTP,Telnet, SMTP ,POP3, WWW 注: TFTP,NTP,SNMP是基于UDP 5.9 网络交换5.9.1 4 个发展阶段:①: 电路交换面向连接,在通信前,需要为通信双方分配一条具有固定带宽的通信线路,通信双方在通信过程中将一直占用所分配的资源到通信结束. ②: 报文交换 采用存储转发机制,以报文为传送单元,用于实时性要求低,报文较短的通信业务 ③: 分组交换 面向无连接,采用存储转发方式, 将数据分割为小段并添加头部,作为数据传送的基本单元即分组, 比电路交换的电路利用率高,但时延大,适用于计算机网络,数据传输可靠,线路利用率较高 ④: ATM (Asynch-ronous TransferMode) 异步传输模式,将面向连接机制和分组机制相结合,在通信开始前需要建立连接,但是该连接并不独占物理通道,而是和其他连接统计复用,同时所有的媒体信息,被分割并封装为固定长度的分组在网络中传送和交换. 适合传送高速数据业务,ATM技术复杂性,导致ATM交换机造价及其昂贵 5.10 双绞线屏蔽双绞线(Shielded Twisted Pair): 增加了全屏蔽层,减少了衰减和噪音, 价格贵重量重,不易安装,一般用于涉密信息等要求高的情况下 非屏蔽双绞线(UnShielded Twisted Pair) 5.11 APAP接入点(Access Point) 是用于无线网络的无线HUB,是无线网络的核心. 它是移动计算机用户进入有线以太网骨干的接入点,AP可简单安装在天花板或墙壁,他在开放空间最大覆盖范围300米,无线传输速率11Mbps,理论上可同时接入1024 个移动设备. 5.12 可用于查询IP地址的常见命令:①: nslookup②: tracert③: ping 用法: 命令+ 域名 ,如 nslookup www.baidu.com 注: ipconfig 用于查询本地电脑IP,网关等信息的,命令后面不带网址. 5.13 网络分类5.13.1 按照作用范围分:广域网WAN: (Wide Area Network) 如北京到上海之间的网络按照作用范围分,它属于广域网 城域网MAN 局域网LAN 5.14 IEEE802IEEE802.1: 定义局域网体系结构,寻址,网络互联和网络. IEEE802.3 : 是以太网标准(局域网标准) IEEE802.6: 城域网协议 IEEE802.11 : 是无线局域网WIFI的技术标准 5.15 WLAN无线网络常用的认证与加密方式:5.15.1 WEPWired Equivalent Privacy ,有线等效保密,是对在两台设备间无线传输的数据进行加密的方式,用于防窃听 5.15.2 WPAWPA目前有四种认证方式: WPA: 替代WEP, 加强了生成加密密钥的算法,增加了防数据中途被篡改的功能和认证功能 WPA2: 与WPA相比,增加了AES的加密方式 WPA-PSK WPA2-PSK 5.14 网络设备 5.15 以太网①: 使用CSMA/CD(即载波监听多路访问及冲突检测技术) ②: 支持半双工和全双工 ③: 以太网帧长度不固定,如Ethernet II类型以太网帧最小长度为64字节(6+6+2+46+4),最大长度为1518字节(6+6+2+1500+4) 5.16 WLAN无线网络 六、数据库6.1 六种范式:①: INF②: 2NF③: 3NF④: BCNF⑤: 4NF⑥: 5NF 范式级别越高,数据冗余程度越小,存储同样的数据就需要分解成更多张表,数据库性能(速度)将下降 七、立项管理7.1 立项管理的5个阶段①: 项目建议 ②: 项目可行性分析 ③: 项目审批 ④: 项目招标 ⑤: 项目合同谈判和签订 7.2 系统方法论的基本原则:①: 整体性原则 ②: 相关性原则 ③: 有序性原则 ④: 动态性原则 ⑤: 最优化原则 注: 不包括易用性 八、项目整体管理:8.1 事业环境因素:①: 国家标准或行业标准②: 帮助管理项目的工具(项目管理信息系统)③: 实施单位的企业文化和组织机构④: 市场状况⑤: 行业数据库⑥: 现有设施和固定资产等⑦: 项目干系人对风险的承受力 8.2 组织过程资产①: 变更控制流程 项目团队可以 选择,增补 是 组织过程资产范畴②: 合同 也 属于 组织过程资产③: 产品组件标准 也 属于 组织过程资产④: 以往项目的经验教训 组织内部形成的 而不是全行业 的 统一标准 则不能算组织过程资产. 口诀: 合同教训 是 组织 8.3 五大过程组,47个子过程8.3.1 启动过程组(项目启动)定义并批准项目或项目阶段, 制定项目章程,和识别项目干系人 8.3.2 计划过程组(指定项目计划)①: 建立WBS 和 WBS字典②: 项目风险分析③: 定义和细化目标,规划最佳的行动方案. 活动排序 8.3.3 执行过程组(指导和管理项目执行)项目团队的组建项目质量保证询价卖方选择 8.3.4 监督和控制组8.3.5 项目收尾合同收尾管理收尾 : 也叫行政收尾,覆盖整个项目,阶段完成或项目完成都需要收尾(包括项目评价,总结经验教训,归档项目文件等)指导项目收尾的程序和方法, 包括收尾的所有活动 及角色 职责. 8.4 项目管理计划过程的输入①: 项目章程: 用于确定项目地位,对项目经理授权②: 事业环境因素③: 组织过程资产 8.5 项目初步范围说明书内容:①: 产品范围描述②: 项目需求和可交付成果⑤: 产品或服务的需求和特点⑥: 制约因素⑦: 假设条件⑧: 初始WBS⑨: 成本概算⑩: 验收标准⑩: 进度里程碑⑩: 项目边界⑩: 最初定义的风险 8.6 项目工作说明书SOW内容:SOW：对内部项目而言，由项目发起人提出；对外部项目而言，可以作为投标文档一部分从客户那里得到 ①: 业务需求: 一个组织的业务需求可能是培训,市场需求技术进步,法律需求或政府的标准 ②: 产品范围描述: 记录项目所要创建的产品的需求,以及产品或服务的特性. ③: 项目目标,战略计划: 所有项目都要支持组织的战略目标,执行组织要把战略计划作为项目选择的一个要素来考虑. 口诀: 爷参战。 8.7 项目收尾的输出:①: 合同收尾章程②: 管理收尾章程③: 组织过程资产更新 8.8 合同收尾 的内容项目验收 8.9 项目评估主要由第三方实施, 而不是由建设方,承建方等 主要特征:①: 整体性 : 综合集成经济,环境 ,风险,技术运行②: 目标性③: 相关性: 时间,知识,逻辑④: 动态性: 项目生命周期 依据: ①: 项目建议书 ②: 项目可行性研究报告 ③: 报送单位的申请报告及主管部门的初审意见 ④: 有关资源,配件,燃料,水,电等方面的协议文件 注: 不包括项目变更管理策略 8.10 项目管理计划的内容:①: 范围基准: 范围说明书,WBS,WBS字典 ②: 进度基准 ③: 成本基准 ④: 其他管理计划 注: 项目绩效信息 是在 项目执行中产生的,不包括在项目管理计划中 8.11 项目监控工作成果:变更请求工作绩效报告项目管理计划更新项目文件更新 注: 工作绩效报告 能提供当前项目的状态与预测项目状态的比较. 8.12 项目章程的内容: (很重要)指定项目经理及授权级别概要的里程碑计划干系人的影响职能组织项目目的或论证结果商业需求,产品需求,项目需求,项目概述概要预算假设及约束条件项目的业务方案投资回报率 总结: 各种需求 作用: ①: 确定项目经理,规定项目经理的权利 ②: 正式确认项目的存在,给项目一个合法的地位 ③: 规定项目的总体目标,包括范围,质量,成本,时间等 ④: 通过叙述项目启动的理由,把项目与执行组织的日常经营运作及战略计划联系起来. 8.13 项目文件:①: 质量管理计划 ②: 范围管理计划 ③: 进度管理计划 ④: 成本管理计划 九、项目范围管理:9.1 WBS的3种分解方法:①: 生命周期的各阶段作为分解的第二层,可交付性成果在第三层 ②: 主要可交付性成果在第二层 ③: 子项目安排在第一层,再分解子项目的WBS 9.2 WBS的分解过程注意事项:①: 必须面向交付成果 ②: 只由一个人负责,尽管可能多人参与 ③: 任务分解应该控制在4~6层 ④: 分包出去的工作,和项目管理工作也在WBS中 ⑤: 并非一成不变 ④: 工作单元从属唯一,避免交叉从属 ⑤: 相同层次的工作单元有相同的性质 ⑥:WBS的编制需要所有(主要)项目干系人的参与 注: WBS中必须包含全部工作内容,即100%原则,未包括的则不属于项目范围,如果要增加必须遵循变更流程. 大项目的WBS分解,可按照产品结构,生命周期,3个层次制定分解,不包含风险分解结构. 9.3 WBS过程的功能:①: 责任分工明确②: 定义绩效考核和控制基线③: 提高成本、时间和资源估算的准确度④: 识别可交付成果和工作包 物料清单: 描述一个产品所需要的实际部件,组件和构件的分级表格. 9.4 项目范围基线:①: 批准的项目范围说明书②: WBS③: WBS字典: 提供WBS要素的详细信息. 9.5 工作包①: 工作包是进度安排和成本估算,资源需求及控制的依据,是底层单元 ②: 工作包必须是具体的 注: 子项目一般还是很大,不是工作包,工作包是底层单元. 9.6 需求跟踪矩阵:目的: 追溯需求实现情况,和回溯需求来源,而不是确认需求 可改善产品质量,降低维护成本,容易实现重用 回溯: 又称逆向跟踪, 检查设计文档,代码测试用例等是否能在&lt;&lt;产品需求规格说明书&gt;&gt;中找到出处 9.7 项目范围说明书:包含产品范围 和 项目范围 范围说明书的输入是 : 项目章程 范围说明书的 主要内容: 可交付成果,项目目标 9.7.1 产品范围和 项目范围的区别:产品范围: 产品或 服务所应该包含的功能 项目范围: 为了能交付产品,项目所必须做的工作. 9.8 创建WBS的输入:①: 范围管理计划②: 项目范围说明书③: 需求文件④: 组织过程资产 9.9 范围确认的输入:①: 项目范围说明书②: WBS③: 项目范围管理计划④: 可交付物(可交付成果) 9.9 范围确认和项目收尾区别:范围确认 强调 核实与接受 可交付成果, 以及验收可交付成果 项目收尾 强调 结束项目所要做的流程性工作, 以及验收产品 9.10 WBS字典:包括账户编码,工作描述,执行组织,里程碑列表,资源需求,成本估算,活动列表等是对工作包的细节描述.不包含管理储备 9.11 控制账户:控制账户是一个管理控制点,在该控制点上,把范围预算,实际成本和进度加以整合,并与挣值比较,以测量绩效. 每个工作包分配到一个控制账户,并根据”账户编码”为工作包建立唯一的标识,是创建WBS的最后一步. 每个控制账户可能包括一个或多个工作包,但一个工作包只能属于一个控制账户. 9.12 追溯和回溯区别:追溯: 客户需求向前追溯到需求, 跟踪需求,以免被做漏做偏 回溯: 从需求回溯相应的客户需求, 查清需求源头,了解为什么要做这个需求 需求跟踪: 主要不是 确认需求,而是 追溯需求实现情况 和回溯需求来源. 9.13 需求开发过程:顺序如下: ①: 需求获取 ②: 分析 ③: 定义 ④: 验证 ⑤: 确定需求基线 注: 先分析后定义 注: 需求阶段,应该编制 需求规格说明书, 初步用户手册, 数据要去说明. 需求规格说明书 需要经过阶段评审 和 技术评审后建立基线,它是阶段测试 和后续开发的重要基础.不能只通过同行评审就建立基线 9.14 范围确认和 质量控制:质量控制: 核实工作结果正确与否 范围确认: 有关工作结果是否可接受 质量保证: 建立对未来输出或正在进行的工作在完工时满足特定需求和期望的信心. 简言之: 控制正确性,确认可接受,保证信心. 口诀: 孔雀忍受暴行 例如: ①对详细的范围说明书进行评审,提交客户签字确认②:与客户开展审查,判断工作和交付成果是否符合标准. 9.15 范围控制:作用: 防止范围蔓延(范围蔓延就是范围不受控制)例: 客户提出新的需求时,说服他放弃新需求 9.16 滚动式计划创建工作分解结构时,近期的要分解详细,以便于安排核实,远期的可以放一个规划包,滚动规划和分解. 9.17 项目范围管理的流程:顺序如下:①: 收集需求②: 定义范围③: 创建工作分解结构④: 核实范围⑤: 控制范围 9.18 范围管理和时间管理的顺序:范围规划——&gt;范围定义——-&gt;活动定义——-&gt;活动排序——–&gt;活动历时估算 注: 先规划,后定义 9.19 工具和技术①: 收集需求 的工具: 引导式研讨会,标杆对照 ②: 范围定义 的工具: 引导式研讨会,产品分析 ③: 范围控制的工具: 偏差分析 9.20 配置控制即配置项 和 基线的变更控制,包括下列任务: ①: 标识记录变更申请 ②: 分析评价变更 ③: 批准或否决申请 ④: 实现、验证和发布已经修改的配置项 注: 配置控制其实主要内容就是变更控制 项目经理职责: ①: 确定受变更影响的关联配置项和有关基线 ②: 将变更申请的决议通知受此变更影响的每个干系人 ③: 组织修改配置项,并在相应的文档或程序代码中记录变更信息 配置管理员职责: 将变更后的配置项纳入基线,并将变更内容和结果通知相关人. 简言之:项目经理 负责记录变更,确定基线配置项,通知决议给干系人 9.21 需求的状态值①: 已建议: 该需求被有权提出需求的人建立 ②: 已批准: 该需求已经被分析,估计了对项目余下部分的影响,已用一个确定的版本号,或创建编号分配到相关基线中,软件开发团队已经同意实现该需求. ③: 已实现: 已经实现了代码的设计,编写,单元测试. ④: 已验证: 使用所选择的方法已验证了实现的需求,例如测试和检测 9.22 分解:将整个项目工作分解为工作包需要开展以下活动: ①: 识别和分析可交付成果及相关工作 ②: 确定WBS结构和编排方法 ③: 自上而下逐层细化分解 ④: 为WBS组件制定和分配标识编码 ⑤: 核实可交付成果分解的程度是否恰当. 十、进度管理10.1 进度压缩的原则优先压缩关键路径上的活动和每压缩一天需要增加额外费用最小的活动 十一、成本管理估算————————产物—————————–&gt; 预算—————–产物———————-&gt; 成本基准 11.1 成本类型①: 可变成本: 如普通员工工资,消耗原材料 ②: 固定成本: 如管理者工资,设备折旧费 ③: 直接成本: 直接归属于项目工作的成本,如项目使用的物料及设备使用费,项目团队的工资,奖金等,由项目经理直接控制 ④: 机会成本: 被舍弃的选项中价值最高者 ⑤: 间接成本: 几个项目共同分摊的成本,如保安费,公司福利,财务部门费用等 ⑥: 沉没成本: 过去发生且无法回收 11.2 项目成本(直接成本)需求,设计,开发,实施(部署),上线验收,这些成本一般纳入项目成本. 可行性研究费用, 监理费用都是业主方负责(甲方)的费用,且一般在立项之前,所以不能纳入项目成本 注: 业主方出钱,以及立项之前的成本 都不属于 项目成本 11.3 成本估算11.3.1 成本估算的常用方法①: 专家判断 ②: 类比估算: 以过去类似项目参数值为基础,来估算当前项目同类参数或指标. ③: 参数估算(公式法): 利用历史数据之间的统计关系 注: 类比 和 参数估算易混淆, 所以 只记住 题目中出现 类似 就是类比估算 ④: 自下而上估算 :先对单个的工作包,进行细致的成本估算,然后向上汇总到更高层次. ⑤: 三点估算法: 考虑到估算的不确定性和风险最乐观成本: 最好情况的成本 最可能成本: 比较现实的估算 最悲观成本: 最差情况的成本 公式: 预期成本 = (最乐观+ 4 * 最可能+ 最悲观) / 6 注: 挣值分析 不是 成本估算的方法,而是 成本控制的工具 11.3.2 成本估算的输入①: 项目进度管理计划 ②: 项目管理计划 ③: 风险事件 注: 项目成本绩效报告不属于 成本估算的输入. 成本估算建议在WBS 的最底层进行, WBS 最底层是工作包,是进度安排,成本估计和监控的基础.成本和进度的估算应该在工作包 这一层进行. 11.3.3 成本估算的内容:分析成本构成结果,找出各种可以相互替代的成本,协调各成本之间的关系. 11.3.4 成本估算的步骤:①: 识别并分析项目成本构成科目 ②: 估算每一个成本科目的成本大小 ③: 分析成本估算结果 ,找出各种可以相互替代的成本,协调各成本之间的关系. 11.3.5 成本估算的工具和技术储备分析 11.4 成本预算11.4.1 输入①: 成本管理计划 ②: 范围基准 ③: 活动成本估算 ④: 协议 ⑤: 资源 ⑥: 风险登记册 ⑦: 组织过程资产 ⑧: 项目进度计划 11.4.2 输出:①: 项目资金需求 ②: 项目文件更新 ③: 成本基准 11.4.3 成本预算的内容将项目的成本分配到项目的各项具体工作上属于成本预算 注: 范围基准 是 创建WBS的输出 项目的范围基准是 经过批准的项目范围说明书,WBS 和 WBS词典. 判断项目范围是否完成 需要 范围基准来衡量 判断产品范围是否完成 需要 根据产品是否满足了产品描述(软件需求规格说明书)来判断. 总结: XXX基准一般是对应XXX过程的输出 11.4.4 管理储备:①: 它不是成本基线的一部分,属于成本基准外,但是在项目预算内. ②: 由公司高层管理 ③: 用来处理非预期且不确定事件 ④: 不参加挣值计算 ⑤: 成本预算过程产生,风险控制过程使用 ####11.4.5 产物: 成本基准计划 11.4.6 应急储备:①: 由项目经理管理使用 ②: 成本估算过程中产生,风险控制过程使用 ③: 处理 预期 但 不确定事件 其他与上面相反 注: ①: 总预算 ≠ 完工预算BAC②: 总预算 ＝ 完工预算BAC + 管理储备 11.5 挣值管理EVM是把范围,进度,资源绩效综合起来考虑,以评估项目绩效和进展的方法. 11.5.1 关键指标 即计算公式:PV : 计划值—–&gt;计划完成工作的预算成本 PV: 将资金平摊到每一天, 当到达某一天时, 计划应该花掉多少钱,这个值就是计划值,也就是说PV的值与时间有关,也就是与进度有关. EV: 挣值—–&gt;已完成工作的预算成本 (已完成 工作的 计划价值 之和) EV: 按已经完成的工作量,计划应该花掉多少钱 AC: 实际成本——&gt;已完成工作的实际成本 BAC: 项目的总计划值(完工预算) SV : 进度偏差 SV = EV - PV CV: 成本偏差 CV = EV - AC SV 为负数 表示 进度落后, 正数则相反CV 为负数 表示 成本超支, 正数则相反 SPI : 进度绩效指数 SPI = EV / PV CPI: 成本绩效指数 CPI = EV / AC SPI &lt; 1.0 则表示 进度落后, &gt;1.0 则相反CPI &lt; 1.0 则表示 成本超支, &gt;1.0 则相反 总结 : ①: SV,CV小于0 则 不好, SPI,CPI 小于1 则 不好 ②: SPI,SV 都是 EV 和 PV之间运算, CPI 和 AC 都是 EV 和 AC 之间运算. BAC: 完工预算VAC: 完工偏差ETC : 完工尚需估算(完成剩余部分)EAC : 完工估算(完成所有工作,所需预期总成本) : 按照目前的情况继续发展,ETC = (BAC - EV) / CPI 当预计剩余工作的CPI与当前一致时, 则 EAC = BAC / CPI EAC = AC + ETC = AC + (BAC - EV) / CPI VAC = BAC - EAC 注: ①: 总预算 ≠ 完工预算BAC②: 总预算 ＝ 完工预算BAC + 管理储备③: 成本基线不包括管理储备,管理储备不参与挣值计算④: 成本基准 = 估算 + 应急储备⑤: 项目预算 = 成本基准 + 管理储备 = 估算 + 应急储备 + 管理储备 也就是项目总预算包括管理储备,BAC不包括 管理储备. 完工工期估算=预算工期 / SPI = 关键路径长度 / SPI 例题 例题: 11.6 成本预测11.7 成本控制在项目过程中,对形成成本的要素进行跟踪,分析,监督,控制和调节. 内容: 识别可能引起 项目成本 基准计划 发生变动的因素,对这些因素施加影响,以保证该变化朝着有利方向发展,以工作包为单位监督成本实施情况,查找偏差原因,作好实际成本的分析评估工作,对发生成本偏差工作包实施管理,并采取纠正措施,必要时修改项目成本基准计划,同时确保所有变更都准确记录在 成本基准计划中,将核准的成本变更后的 成本基准计划通知项目相关人员. 11.8 净现值指投资方案所产生的现金净流量以资金成本为贴现率折现之后与原始投资额现值的差额。 例题: ①: 净现值 = 未来报酬的总现值 － 初始投资 ②: 净现值 = 净现金 * 折现系数 折现系数 = 1 / [ ( 1 + 折现率) ^ N ] 公式: NPV=∑(CI-CO)/(1+i)^t NPV：净现值 CI：各年收益 CO：各年支出 CI-CO：净现金流量 t：时间， i：基准收益率（贴现率，基准折现率） 净现值指标是反映项目投资获利能力的指标。 决策标准： 净现值≥0 方案可行； 净现值&lt;0 方案不可行； 净现值均&gt;0 净现值最大的方案为最优方案。 净现值法就是按净现值大小来评价方案优劣的一种方法。净现值大于零则方案可行，且净现值越大，方案越优，投资效益越好。 示例: 设定折现率（基准收益率），即公式中的i 为8% 2009年，净现值=(0-800)/(1+0.08)= -740.74 2010年，净现值=(0-600)/(1+0.08)^2= -514.40 2011年，净现值=(2000-1500)/(1+0.08)^3 = 396.92 2012年，净现值=(1800-1200)/(1+0.08)^4= 441.02 2013年，净现值=(1900-1000)/(1+0.08)^5= 612.52 NPV= -740.74-514.40+396.92+441.02+612.52=195.32 例2: 第0期，净现值=(-630)/(1+10%)^0= -630 第1期，净现值=(330)/(1+10%)^1 = 300 第2期，净现值= (440)/(1+10%)^2 = 363.6 NPV= 300+363.6-630=33.6≈34 例3: 方案A: 第0年(初始投入的成本): (-30000)/(1+10%)^0=-30000 第一年: (14000)/(1+10%)^1=12727 第二年: (19000)/(1+10%)^2=15702 NPV=-30000+12727+15702=-1571 同理计算BCD方案. 11.9 静态投资回收期:不考虑时间价值,计算到什么时候为正值. 11.10 计算题:例1: 按照目前的情况继续发展,ETC = (BAC - EV) / CPIEV : 已完成工作的预算成本CPI = EV / AC 例2: 题目中说: PV: 计划值, 与进度有关(一般与时间或者完成工作量有关).一般指 到了某个工作日,完成当期计划进度的100%后, 此时应该使用了多少 资金.此题而言: PV = 40万 * ( 30 / 40 ) = 30 万, 也就是说,计划40天完成,且预算资金40万的情况下,那么,在第30天的时候且此时已经完成了30天所必须完成的工作量后 总共会用掉30万. AC: 实际成本,与成本有关. 例3: 例4: 例5: AC = 1000 + 2500 + 10000 + 15000 = 28500 EV = 1000*100%+3000*100%+8000*100%+13000*90%=23700 CPI=EV/AC=0.83 11.11 控制成本的输入①: 项目资金需求 11.12 控制成本的输出①: 工作绩效 ②: 成本预测 ③: 变更请求 ④: 项目文件更新 ⑤: 组织过程资产更新 ⑥: 项目管理计划更新 11.13 关键路径法:①: 找工期最长的那条路径 ②: 关键路径上的活动总浮动时间为0, 自由浮动时间为0 ③: 总浮动时间 = 晚完成-早完成 = 晚开始-早开始④: 最早开始 + 工期 = 最早完成 最迟开始 + 工期 = 最迟完成总结: 上下相减是浮动,左右相减是工期口诀: 早开始,迟完成,紧前紧后来分析, 其他皆可推. ⑤: 第一个活动最早开始 = 项目最早开始 最后一个项目最迟完成 = 项目最迟完成 ⑥: 自由浮动时间: 是本活动与紧后活动的关系, 指不延误任何紧后活动的最早开始且不违反进度制约因素的前提下,活动可以从最早开始推迟或拖延的时间量. 自由浮动时间 = 紧后活动最早开始的最小值 - 本活动最早完成 总之: 在关键路径法 的活动结点中的值 需要我们求的 就是 最早开始 和 最迟完成 其他的值可以依据公式推出. 总浮动时间: 不影响工期 自由浮动时间: 不影响紧后活动的最早开始时间 ⑦: 网络图: 单代号网络图: 箭头是关系, 结点是活动双代号网络图: 箭头是活动, 结点是事件.时标网络图 注: 双代号网络图的活动在箭线上,结点耗时为0,即结点的最早开始时间等于最早完成时间,从而合成一个最早开始时间(标注与结点上方) 11.13.1 一个非常重要的地方: 注: 其中活动A和活动B可以同时进行, 但只有活动A 和 活动B 都完成后, 活动C 才能开始. 另外: 当一个活动有多个紧前活动时,要看最后一个完成的活动的最早完成时间. 举个例子: C的紧前活动是A和B, 如果完成A活动需要9天,完成B活动需要10天,那么C活动最早开始时间是 第10天,而不是第九天. 总结: ⑧: 最早开始时间的求法: 要看紧前活动最早什么时候完成 (当一个活动有多个紧前活动时,要看最后一个完成时的时间) ⑨: 最迟完成时间求法: 要看紧后活动最迟什么时候开始(当一个活动有多个紧后活动时,要看最先一个开始的紧后活动的最迟开始时间————==原因: 确保所有的紧后活动不受影响.==) 例题: 解答: E 由于在关键路径上所以总浮动时间和自由浮动时间都为0 G 在非关键路径上: 方法一: 公式法: G的总浮动时间=G最迟开始时间 - G最早开始时间 G最早开始是在第5天(因为只有一个紧前活动F,且F最早在第5天完成) G最迟开始时间=G最迟完成-G的工期=G最迟完成-4 G最迟完成要看G的紧后活动最迟什么时候开始,G只有一个紧后活动E且最迟开始时间为10(因为G在关键路径上,最迟开始=最早开始=10) G最迟开始时间=10-4=6 G的总浮动时间=6-5=1 方法二: 用工期21 减去G所在的最长路径20 得到的就是G 的总浮动时间为1天 G的自由浮动时间 = E的最早开始-G的最早完成 E最早第10天开始,G最早第9天完成 G的自由浮动时间=10-9=1 十二、质量管理12.1 质量控制的输入①: 项目管理计划 ②: 质量测量指标 ③: 工作绩效数据 12.2 质量控制的输出①: 确认的变更 ②: 核实的可交付性成果 12.3 质量管理过程①: 质量规划: 识别和项目有关的标准以及如何满足这些标准,确定需要对哪些过程和工作产品进行质量管理. ②: 质量保证: 建立对未来输出或正在进行的工作在完工时满足特定需求和期望的信心. ③: 质量控制: 采取措施,监督项目的具体实施结果是否符合相关的项目质量标准,并确定消除产品的不良结果的原因. 12.4 软件质量特性 功能性——功能 5可靠性——靠 3可用性——用 3效率———小 2可维护性—护 4可移植性—翼 4 大特性口诀: 功能靠用小护翼 功能性: 是——适合性准——准确性用——互用性一——依从性安——安全性 可靠性: 错——容错性译——易恢复性成——成熟性 易用性: 学——易学性姐——易理解性操——易操作性 效率: 石——时间特性源——资源特性 维护性: 试——可测试性改——可修改性定——稳定性分——易分析性 可移植性: 应——适应性装——易安装性一——一致性T ——可替换性 故事是这样的，某外语课，老师说了一段外语，谐音“是准用一安”（可以理解为：是准备用一安培），某同学错误翻译成“学姐操石源(日本人)”结果老师判定不及格，某同学试着修改定下的分数，别人告诉她，应该装一个套套去… 口诀：是准用一安，错译成，学姐操，石源，试改定分，应装一T（套套一般都用T代替） 12.4 质量管理常用工具：老七种工具：流程图、因果图、直方图、散点图、排列图、控制图、检查表。新七种工具：矩阵图、树状图、相互关系图、亲和图、过程决策方法图、活动网络图、优先矩阵图。 编成一句诗：流因直点列制查，矩树相亲策动优。谐音是：刘英只点劣质茶，钜树相亲策动优。 诗文讲的故事是：有一个叫刘英的人在相亲时只敢点最便宜的劣质茶，为什么？家里穷呀。原来，她是锯了家里的树，卖了钱，来相亲的。可见这次相亲的策划活动有多优秀。 口诀: 刘英只点劣质茶，钜树相亲策动优 控制图: 用来分析过程是否稳定,是否发生异常情况. 12.5 规划质量管理的输入①: 项目管理计划 ②: 干系人登记册 ③: 风险登记册 ④: 需求文件 ⑤: 事业环境因素 ⑥: 组织过程资产 12.6 统计方法:①: 实验设计: 是一种统计方法,通过进行实验找出哪些变量对项目结果的影响最大. 用来识别哪些因素会对正在生产的产品或正在开发的流程的特定变量产生影响 ②: 标杆对照 ③: 过程分析: 主要是分析执行过程中的问题、无价值的活动等.用于识别问题、探究根本原因.并制定预防措施. ④: 质量审计: 对其他质量管理活动的结构性的审查,是决定一个项目质量活动是否符合组织政策,过程,程序的独立的评估. 12.6 规划质量管理的输出①: 质量测量指标: 描述项目或产品属性 以及 用于在质量控制过程如何对属性进行测量质量测量指标的例子: 准时性、故障率、可用性、成本控制、和测试覆盖度等. 提供了应该被测量的属性和允许的偏差. ②: 过程改进计划: 详细说明对项目管理过程和产品开发过程进行分析的各个步骤,以识别增值活动. ③: 质量管理计划: 描述如何实施组织的质量政策,以及如何达到项目的质量要求. ④: 质量核对单: 具体列出各项内容,用来核实所要求的一系列步骤,是否已经得到执行. 12.7 质量管理执行阶段的技术①: 质量审计 ②: 过程分析 ③: 七种基本质量工具(过程决策程序图)、统计抽样、检查、审查已批准的变更请求. 过程决策程序图: 用于理解一个目标与达成此目标的步骤之间的关系.有助于制定应急计划 12.8 质量保证的输入①: 质量测量指标 ②: 质量管理计划 ③: 过程改进计划 ④: 工作绩效信息 ⑤: 变更请求 12.9 质量保证通过用规划过程预防缺陷,或者在执行阶段对正在进行的工作检查出缺陷,来保证质量的确定性, 而不是通过执行产品检查并发现缺陷来实现的. 12.9.1 质量保证的职能:主要职能是: 过程检查,过程改进 12.10 确认过程目的: 确保产品满足其特定的目标 12.11 验证过程目的: 确保活动的输出产品满足活动的规范说明. 12.12 软件包质量要求:①: 产品描述要求 ②: 用户文档要求 ③: 程序和数据要求 12.13 编制质量计划的工具和技术①: 基准分析: 将实际计划中的项目做法同其他类似项目的实际做法进行比较,通过比较来改善和提高目前项目的质量管理,以达到项目预期的质量. 12.14 质量控制①: 主要是对产品或服务成果的控制和检查,不是评估项目绩效 所以 检查关键交付物的质量 就属于 质量控制的职能. 12.15 外部度量①: 易学性度量: 评估软件的帮助文档和文档的有效性. ②: 易操作性度量 ③: 易理解性度量 12.16 故障成本错误的纠正成本为非一致性成本,即故障成本 举例: 某如那件系统测试发现有错误并不能满足质量需求,为了纠正其错误投入了10人天的成本,该成本就属于 故障成本 12.17 控制质量的工具和技术①: 帕累托图: 特殊的垂直条形图,==用于识别造成大多数问题的少数重要原因==,在横轴上显示的原因类别,作为有效的概率分布,涵盖100%的可能观察结果. ②: 因果图: 又称鱼骨图, 发现问题的原因; 通常问题陈述放在鱼骨的头部作起点来追溯问题的来源 ③: 流程图 ④: 直方图: 用于描述集中趋势,分散程度,和统计分布形状, 与控制图不同它不考虑时间对分布内的变化的影响. ⑤: 散点图: 显示两个变量之间是否有关系 ⑥: 控制图: 实时展示项目进展信息的图表, 用于判断某一过程处于控制之中还是处于失控状态. ⑦: 核查表: 用于收集数据的查对清单(如收集缺陷数量和后果的数据) 技术: ⑧: 趋势分析 ⑨: 缺陷修复审查 12.18 工作绩效数据 工作绩效信息 工作绩效报告 区别与联系工作绩效数据: 是执行过程的输出，监控过程的输入。 在执行项目的工作过程中，从每个正在执行的活动中一边执行一边收集起来的，未经任何加工整理的原始观察结果和测量值用于真实，完整地记录工作的执行情况。它是指导与管理项目工作过程的输出。是项目监控时用来与计划要求做比较实际的实际数据。 例如：工作完成百分比，质量和技术绩效测量值，进度活动的开始和结束日期，变更请求的数量，缺陷数量，实际成本和实际持续时间等。 它强调的是原始的，基础的数据，再执行项目管理计划后，出现的能反映项目当前执行情况（主要是范围，进度，成本）的原始的，基础的数据。 工作绩效信息: 是监控过程的输出。 是对工作绩效数据进行加工整理（主要是与基准计划对比）后得到的，是各基层局部监控过程的输出。进行整合分析而得到的绩效数据。 在PMBOK指南中，总共有九个基层局部监控过程，即确认范围，控制范围，控制进度，控制沟通，控制质量，控制成本，控制干系人参与过程, 控制风险，控制采购。 例如：可交付成果物的状况，请求变更的执行状况，预测的完工估算。 它强调的是用工作绩效数据和基准计划的对比结果，也可以理解为偏差结果。 反映项目实际执行和计划要求之间的偏差,对偏差程度和原因的分析,以便决定是否需要变更 提供了沟通和支持项目决策的机制 注意：”可交付成果物的完成状况“属于 工作绩效信息。 工作绩效报告: 对绩效信息进一步加工，整理，汇编而得到的，关于项目绩效的专题和综合报告。他是监控工作过程的输出， 为指定决策，提出问题，采取行动或引起关注，而汇编工作绩效信息，所形成的实物或电子项目文件 是整个项目层次的更深入或更综合的执行与计划的比较。 例如：状况报告，备忘录，论证报告，信息札礼，电子报表，推荐意见或情况更新。 它强调的是可以正式提交给干系人，能全面反映项目情况的正式文件。 12.19 质量成本一致性成本: 预防成本 培训 流程文档化 评价成本 测试 检查 破坏性测试导致的损失 非一致性成本: 内部失败成本 返工 废品 外部失败成本 责任 报修 十三、人力资源管理 13.1 组织分解结构OBS根据现有的部门,单位或团队进行分解.项目的活动和工作包列在负责的部门下面. 13.2 优秀团队的建设阶段:(塔克曼阶梯理论)团队发展阶段: ①: 形成阶段 ②: 震荡阶段: 个体之间争执,互相指责 ③: 规范阶段: 经过一段时间的磨合,相互熟悉了解,矛盾基本解决 ④: 发挥阶段(表现阶段): 成员积极工作,集体荣誉感非常强 ⑤: 解散阶段: 随着项目的结束,团队也被遣散. 注: 如果有新成员加入,团队又会回到形成阶段. 13.3 管理项目团队的工具和技术①: 观察和对话 ②: 项目绩效评估 ③: 冲突管理: ④: 问题日志: 注: 项目绩效,问题日志 属于 管理项目团队过程 而不是 建设项目团队过程 13.4 团队建设的内容①: 培训 ②: 认可和奖励 ③: 同地办公(集中) ④: 基本原则 ⑤: 团队建设活动 ⑥: 一般管理技能 ⑦: 组织娱乐活动让大家认识 注: 评价绩效 属于 管理团队的工具和技术 13.5 项目绩效评审在一个阶段末的项目绩效评审主要目标是本阶段的任务是否已经完成,决定项目是否从当前阶段进入下一阶段. 13.6 激励理论: X理论 ,Y理论,马斯洛理论,赫兹伯格理论,期望理论13.6.1 : X理论消极假设 ①: 人天性好逸恶劳,只要有可能就会逃避工作 ②: 人生来就以自我为中心,漠视组织要求 ③: 人们天生就反对改革 ④: 人缺乏进取心,逃避责任. 优点: 加强管理 缺点: 成员通常比较被动工作 13.6.2 Y理论积极假设 ①: 人天性并不是好逸恶劳,他们热爱工作,从工作中的到满足感和成就感 ②: 适当条件下人们愿意主动承担责任 ③: 大多数人具有一定的创造力和想象力 优点: 激发员工主动性 缺点: 对于员工把握工作而言可能又放任过度. 13.6.3 马斯洛需求是一个5层金字塔结构,当某一级的需求满足后,才会追求更高一级的需求,如此逐级上升,成为他工作的动机. 分五个层次 ①: 生理需求: 对衣食住行的需求等 级别最低位于金字塔最底层.人们在转向较高层次的需求时 总是尽力满足这类需求, 常见的激励措施 : 员工宿舍,奖金,补贴等 ②: 安全需求: 包括对人身安全,生活稳定,不至于失业 常见激励措施: 养老保险,长期劳动合同,意外保险等 ③: 社会交往需求: 友谊,爱情等隶属关系的需求. 常见的激励措施 : 员工活动,聚会,比赛,俱乐部 ④: 受尊重需求: 自尊心,荣誉感 常见的激励措施: 荣誉性的奖励, 形象地位的提升,颁发奖章. ⑤: 自我实现的需求 常见的激励措施: 参与决策,参与公司管理会议. 13.6.4 赫兹伯格理论双因素激励理论: ①: 保健因素: 与工作环境有关,能防止人们产生不满意感, 如工作环境,薪水,个人生活,人际关系,公司政策. ②: 激励因素: 与工作内容有关,能促使人们产生工作满意感, 如 工作成就感,认可和赞赏,成长和发展 类似于马斯洛理论中的 尊重和自我实现. 注: 注意 区别 保健因素 和 激励因素 ,前者的满足 可以 消除不满,后者的满足可以产生满意. 13.6.5 期望理论通过考察人们的努力行为与其获得的最终奖酬之间的因果关系,来说明激励过程,并以选择合适的行为达到最终的奖酬目标的理论 一个目标对人的激励程度有两个因素: ①: 目标效价: 实现目标后 能带来多少价值 ②: 期望值: 实现目标的可能性 激发力量=目标效价 * 期望值 13.7 人力资源管理计划的内容①: 角色和职责: 某人承担的职务,为完成工作成员必须履行的工作和职责. 角色和职责的定义的三种形式: 层级型: 工作分解结构WBS: 显示如何把项目可交付成果分解为工作包 组织分解结构OBS: 在每个部门下列出其所负责的项目或工作包 资源分解结构RBS按照资源类别和类型对资源的层级列表. 矩阵型: 责任分配矩阵RAM 用来显示分配给每个工作包的资源的表格, 即用来显示工作包与团队成员的关系,它能反映与每个人相关的所有活动,以及与每个活动相关的所有人员,它可确保任何一项任务都只有一个人负责.,从而避免职责不清. 文本型: 详细描述团队成员的职责.提供如职责,职权能力,资格等方面的信息. ②: 项目的组织结构图: 以图形方式展示项目团队成员及其报告关系. ③: 人员配备管理计划: 说明何时何种方式获得项目团队成员,以及他们需要在项目中工作多久. 13.8 人员配备管理计划的内容①: 人员招募 ②: 人员遣散计划 ③: 认可与奖励 ④: 资源日历 ⑤: 培训需要 ⑥: 合规性 13.9 组建项目团队的输入①: 角色和责任 ②: 项目的组织结构图 ③: 环境和组织结构图 13.10 组建项目团队的输出①: 资源日历 ②: 团队成员的通讯录 ③: 项目人员分配 13.11 资源日历 ,项目日历, 资源直方图区别①: 资源日历 资源工作时段,如团队成员工作时段,或休息 ②: 项目日历 项目的工作日历, 如 工作日,休息日,特殊项目的休整期(台风期,汛期) ③: 资源直方图 项目对资源的使用需求,如 某高级工程师在项目中的工作时长及负荷. 13.12 项目财务绩效评估:13.12.1 静态分析法不考虑资金的时间价值. 包括: 投资收益率法,投资回收期法 ,最小费用法 13.12.2 动态分析法考虑资金的时间价值,也叫贴现法. 包括: 净现值法,内部收益率法,投资回收期法等. 注意: 投资 回收期 有静态和动态的计算. 口诀: 最小投收是静态 13.13 绩效评估①: 包括定性和定量,主要是定量 ②: 评估人员 : 包括财务,管理,信息技术人员等 ③: 评估过程: 归纳,分析,撰写评估报告 13.14 对项目内部各成员制定绩效任务步骤:①: 对每个岗位工作内容进行分解 ②: 针对每个岗位的工作进度,成本,质量等设定KPI值,KPI 值需要设定 为高中低三种档次,给与不同的奖励 ③: 确定KPI评分标准(各评分标准,指标权重) ④: 确定考核频率 13.15 项目绩效审计①: 经济审计 ②: 效率审计 ③: 效果审计 注: 不包括 风险审计 13.16 项目人力资源管理的过程顺序13.16.1 规划人力资源管理识别和记录项目角色,职责,所需技能,并编制人员配备管理计划 13.16.2 组建项目团队确认人力资源可用情况,并为开展项目活动而组建团队, ①: 项目人员分配 13.16.3 建设项目团队提高工作能力,促进团队成员的互动,改善团队整体氛围,以提高项目绩效. 13.16.4 管理项目团队跟踪团队成员的工作表现,提供反馈,解决问题并管理团队变更,以优化项目绩效. 13.17 建设项目团队的工具和技术①: 培训(如 拓展、组织一些娱乐活动) ②: 集中办公 ③: 认可和奖励 ④: 团队建设活动 ⑤: 基本规则 ⑥: 通用管理技能 13.18 管理项目团队的输入①: 人力资源管理计划 ②: 项目人员分配清单 ③: 团队绩效评价 ④: 问题日志 ⑤: 工作绩效报告 ⑥: 组织过程资产 注: 变更请求是 输出. 口诀: 绩效日志组织入,变更请求是输出 13.19 冲突管理13.19.1 冲突的解决方法:①: 撤退/回避 ②: 妥协/协调: 双方都让步 ③: 缓和/包容 ④: 强迫/命令: 利用权力解决,使一方赢,一方输 ⑤: 合作/解决问题 13.20人际关系技能①: 领导力 ②: 沟通 ③: 激励 ④: 影响力 ⑤: 谈判 ⑥: 冲突管理 ⑦: 团队建设 ⑧: 管理技能 ⑨: 建立信任 13.21 项目经理权力来源①: 职位权力 ②: 奖励权力 ③: 惩罚权力 ④: 专家权力 ⑤: 参照权力 13.22 虚拟团队特点: ①: 将在家办公的员工纳入团队———空间 ②: 在组织内部地处不同地理位置的员工之间组织项目团队——-空间 ③: 将行动不便的或残疾人纳入团队——-人员 ④: 在工作班次,工作小时,或工作日不同的员工之间组件团队———时间 ⑤: 执行那些因为差旅费过高而被否决的项目——–开销 13.23 管理项目团队跟踪团队成员的工作表现,解决问题,管理团队变更,以优化项目绩效. 输入: ①: 人力资源管理计划 ②: 项目人员分派 ③: 团队绩效评价 ④: 问题日志 ⑤: 工作绩效报告 ⑥: 组织过程资产 工具技术: ①: 观察交谈 ②: 项目绩效评估 ③: 冲突管理 ④: 人机关系技能 输出: ①: 变更请求 ②:项目管理计划更新 ③: 项目文件更新 ④: 事业环境因素更新 ⑤: 组织过程资产更新 十四、沟通管理和关系人管理14.1 项目干系人管理的主要目的避免项目干系人 在 项目管理中 的严重 分歧 14.2 沟通管理的过程①: 编制沟通计划 ②: 记录工作日志 ③: 发布项目信息 14.3 沟通升级的原则与对方沟通—–&gt;与对方上级沟通——-&gt;与自己上级沟通——&gt;上级与上级沟通. 14.4 绩效报告的输出绩效报告 和 需求变更 ,因为 绩效报告 一般 是 与同领导或客户汇报,经常都带来或大或小的变更. 14.5 项目沟通计划第一个工具与技术 : 干系人分析 输入: 项目章程 14.6 语义障碍 和 认知障碍语义障碍 主要发生在沟通传送时认知障碍 通常发生在 信息的加工和理解上. 14.7 项目绩效评审 目标评审本阶段的任务是否完成,决定项目是否 从当前阶段进入下一阶段. 14.8 绩效评估实施过程①: 首要任务: 确定绩效评估项 ②: 组织评估团队 ③: 收集审核绩效数据资料 ④: 进行定量 和定性 评价,归纳,分析,撰写评价报告. 14.9 绩效报告的内容①: 项目进展和执行情况 ②: 成本使用情况 ③: 团队成员绩效情况 ④: 项目存在的问题及解决措施 ⑤: 对项目的预测 ⑥: 变更请求 ⑦: 绩效目标及依据 注: 不包括 干系人沟通需求,干系人沟通需求是 在沟通管理计划里面 14.10 计算题 14.11 项目干系人分析 14.12 项目干系人管理输入:①: 干系人管理计划 ②: 沟通管理计划 ③: 变更日志 ④: 组织过程资产 注: 问题日志 是 管理干系人参与的 输出. 14.13 沟通方法有多种方法在干系人间共享信息 ①: 拉式沟通: 用于信息量大,受众很多的情况,要求接收者自行地访问信息内容,例如: 企业内网,电子在线课程,经验教训数据库,知识库②: 推式沟通: 把信息发送给需要接收这些信息的特定接收方,例如: 电子邮件,传真,信件等③: 交互式沟通: 在两方或多方进行多向信息交换,例如: 会议,电话,视频会议等 注: 最有效的沟通并解决干系人之间问题的方法————-面对面会议 14.14 沟通管理计划的工具和技术①: 沟通需求分析 14.15 沟通管理计划的输入①: 组织过程资产 ②: 项目章程 ③: 项目范围说明书 十五、风险管理15.1 风险识别的输入:①: 风险管理计划 ②: 成本 ③: 进度 ④: 质量 ⑤: 人力资源 ⑥: 范围 ⑦: 活动成本估算 ⑧: 活动持续时间估算 ⑨: 干系人登记册 ⑩: 项目文件 ⑩: 采购文件 ⑩: 事业环境因素 ⑩: 组织过程资产 15.2 风险管理计划的内容:①: 风险类别 风险类别: 它提供了一种结构化方法以便使风险识别的过程系统化,全面化,这样就能在统一的框架下进行风险识别,目的是提高风险识别的工作质量和有效性 ②: 风险概率和影响力的定义 ③: 概率及影响矩阵 ④: 预算 ⑤: 方法论 ⑥: 角色与职责 ⑦: 已修订的项目干系人对风险的忍受度 ⑧: 报告的格式 ⑨: 制定的时间表 ⑩: 跟踪 15.3 定性风险分析对风险概率或影响进行评估和汇总,进而对风险进行排序,以便随后进一步分析或行动. 15.4 风险识别的工具①: 德尔菲技术 通过多伦征询获得专家对项目的一致见解, 项目风险专家以匿名方式参与活动,防防止个人对结果产生过大影响 所以只看最后一个回合的值 ②: 头脑风暴 目的是取得一份综合的风险清单,与会人员就项目风险 集思广益 ③: 访谈 ④: 根本原因识别 ⑤: SWOT: 从项目的每个优势,劣势,机会,威胁出发,对项目进行考察,从而更全方面的考虑风险. 15.5 风险分类①: 从性质分: 静态风险: 自然力的不规则作用,人们的错误判断,和错误行为导致的风险. 动态风险: 由于人们欲望的变化,生产方式和生产技术的变化以及企业组织的变化导致的风险. ②: 从结果分: 纯粹风险: 仅仅造成损害 投机风险: 可能产生利润,可能造成损失 ③: 从风险源分: 自然事件 人为事件 软件风险 软件过程风险 项目管理风险 应用风险 用户使用风险 商业风险: 开发的产品不符合市场需求 15.6 项目风险识别的图解技术:①: 因果分析图: 又称 鱼骨图: 用于确定风险的起因 ②: 系统或过程的流程图: 反映某一系统内部各要素之间是如何相互联系的,并反映发生因果关系的机制. ③:影响图: 是一种图解表示问题的方法,反映了变量和结果之间的因果关系的相互作用,事件的时间顺序及其他关系. 15.7 风险应对策略:①: 消极风险应对策略: 改变计划,以排除风险,或保护项目目标不受影响,或对受威胁的一些项目目标放松要求. 15.8 风险识别①: 参与者: 尽可能多,尽可能广泛的人员参与,主要是 项目团队、客户、项目干系人等 ②: 风险识别是一个不断重复的系统活动,而不是一次性的 ③: 识别内部和外部风险 15.9 风险监控的输出①: 建议的纠正措施 ②: 新发现的风险 ③: 新的风险管理知识 ④: 变更申请 但不是批准的变更申请 15.10 风险三要素①: 风险事件 ②: 风险概率 ③: 风险结果 15.11 权变措施①: 对不利风险事件的未经计划的应对 十六、采购管理16.1 采购规划的输出①: 采购工作说明书 16.2 采购规划的输入①: 干系人登记册 ②: 风险登记册 ③: 项目管理计划 16.3 关于合同:在编制项目采购计划时,根据采购类型的不同,需要不同类型的合同来配合. ①: 总价合同: 采用固定总价格,适用于产品范围较明确,买方风险小. ②: 成本补偿合同: 包括支付给卖方的实际成本, 加上一些通常作为卖方利润的费用,适合产品范围不明确,或项目存在较高风险,卖方风险小. ③: 工时和材料合同: 也称单价合同,是综合了固定总价和成本补偿的优点的合同,适用于 数量和时长不确定,工作规模或产品界定不甚明确.如聘请专家等 十七、合同管理17.1 注意事项①: 如果合同中有附件,当附件和主合同产生矛盾时,应该以主合同为准. 17.2 合同描述:①: 合同不是解决两方或多方当事人分歧的 而是双方订立的一种约定 十八、知识产权与标准规范18.1 标准代号①: GSB: 我国国家实物标准代号(国实标) ②: GB / T 推荐性国家标准(国标/推) ③: GA / T 我国公安部制定的推荐性标准 (国安/推) ——&gt; 属于行业标准,不属于国家标准 ④: GB / Z 国家标准指导性技术文件 ⑤: BS 英国国家标准 ⑥: ANSI: 美国国家标准 18.2 &lt;&lt;中华人民共和国政府采购法&gt;&gt;政府采购实行集中采购 和 分散采购 ①: 集中采购: 由省级以上人民政府公布的集中采购目录确定, 属于中央预算的政府采购项目,其集中采购目录 由国务院 确定并公布;属于地方预算的政府采购项目,其集中采购目录 由 省 自治区, 直辖市人民政府,或其授权的机构确定. ②: 分散采购: ③: 采购人,采购代理机构对政府采购项目每项采购活动的采购文件保存期限为 从采购结束之日起 至少保存 15年. ④: 采购文件 中包含采购活动记录,采购预算,招标文件(由招标方准备),投标文件,评标标准,评估报告,合同文件等 ⑤: 竞争性谈判: 主要依据: 条件相当下的报价最低的原则 确定供应商,而不是 根据综合实力 ⑥: 政府采购合同履行中,采购人需要追加与合同标的相同的货物等,在不改变合同其他条款前提下,可以与供应商协商签订 补充合同,但采购金额不得超过原合同采购金额的 10%. ⑦: 采购人采购纳入集中采购目录的政府采购项目,必须委托集中采购机构代理采购;未纳入集中采购目录的政府采购项目,可以自行采购,也可以委托集中采购机构在委托的范围内代理采购. ⑧: 采购人有权自行选择采购代理机构, 任何单位和个人不能以任何方式为采购人指定采购代理机构 18.3 &lt;&lt;中华人民共和国 招标投标法&gt;&gt;①: 招标人设有标底的,标底必须保密. ②: 招标人不得向他人透露 已 获取招标文件的潜在投标人的名称,数量,以及可能影响公平竞争的有关招标投标的其他情况. ③: 中标人按照合同约定 或者经过 招标人同意,可以将 中标项目的部分非主体,非关键性工作分包给他人完成,接受分包的人应当具备相应的条件,并不得再次 分包. ④: 招标人对已发出的招标文件进行必要的澄清 或者修改的,应该在 招标文件要求提交投标文件的截止时间至少 15 日前,以书面形式通知所有招标文件收受者. ⑤: 30日内签订合同 ⑥: 评审委员会人数 必须 5人以上单数 ⑦: 确定中标人 后 要通知所有 投标人 ⑧: 招标人最迟应当在 书面合同签订后5日内向中标人,和未中标的投标人退换投标保证金及银行同期存款利息 ⑨: 评审委员会成员 中 技术,经济等方面专家不得少于成员总数的 2/3. ⑩: 开标由招标人主持,邀请所有投标人参加. ⑩: 招标人可以授权 评标委员会 直接确定中标人. ⑩: 招标人有权自行选择招标代理机构,委托其办理招标事宜. ⑩: 招标人具有编制招标文件和组织评标能力的,可以自行办理招标事宜. ⑩: 招标人收到投标文件后,应当签收保存,不得开启. ⑩: 合同中未说明时,合同生效日期,以邮戳为准 ⑩: 自招标文件开始发出之日起至投标人提交投标文件截止日为止,最短不得少于20日. 注意: 几个数字: 30,20,15,5,2/3 18.4 软件维护指南GB/T 14079-1993属于开发标准, 而不是文档标准. 18.5 软件文档三种类型: 18.5.1 开发文档描述开发过程本身. ①: 可行性研究和项目任务书 ②: 需求规格说明 ③: 功能规格说明 ④: 设计规格说明(包括程序和数据规格说明) ⑤: 开发计划 ⑥: 软件集成和测试计划 ⑦: 质量保证计划,标准,进度. ⑧: 安全和测试信息 18.5.2 产品文档① : 培训手册 ②: 参考手册和用户指南 ③: 产品手册 ④: 软件支持手册 18.5.3 管理文档记录项目管理的信息 ①: 开发过程的每个阶段的进度和 进度变更的记录. ②: 软件变更情况 的记录 ③: 相对于开发的判定记录 ④: 职责定义 口诀: 开计划,产手册,管变更 18.6 软件质量保证计划规范 GB/T12504-1990项目开发组组长或其代表 可作为评审组成员,但是不能 担任 评审组 组长 或副组长 ①: 验证(重点是: 是否达到需求) 确定软件开发周期中的一个给定阶段的额产品是否达到 上一阶段 确立的 需求 的过程 ②: 确认(重点是: 是否 与需求一致) 软件开发过程结束 时 对软件进行评价以确定它是否 和软件需求 相一致的过程. ③: 测试 通过执行程序 来有意识 地发现 程序设计 错误 和编码错误的过程. 18.7 质量管理①: 重要工作: 评价和改进 ②: 重点: 持续改进 18.8 软件保护条例包括 程序 和文档 ,但不包括 开发该软件所用的思想. 18.9 评标委员会 和 评标方法 暂行规定投标文件中 大写金额和 小写金额 不一致 的 ,以 大写金额 为准;总价金额 与 单价金额 不一致的 以单价金额为准.,但单价金额小数点有错误的除外,对不同文本发生异议的,以中文为准. 18.10 文档质量可按照文档形式 和 列出的要求划分为4级 ①: 最低限度文档(1级文档): 开发工作量低于 一个人月的开发者自用程序 ②: 内部文档(2级文档): 没有与其他用户共享资源的专用程序 ③: 工作文档(3级文档): 同一单位若干人联合开发的程序 ④: 正式文档(4级文档): 正式发行供普遍使用的软件产品. 18.11 软件质量属性①: 功能性: ②: 可靠性: 成熟,容错,易恢复 ③: 易用性: 使用的难易程度及规定 ④: 效率: 软件性能水平和所用资源之间的关系 ⑤: 维护性 ⑥: 可移植性 18.12 完整的综合布线系统(6个部分)①: 建筑群子系统: 实现建筑物之间的相互连接,通常介质是光缆. ②: 垂直干线子系统: 负责连接管理间子系统,到设备间子系统,使用光缆或UTP. ③: 水平配线子系统: 实现信息插座和管理子系统的连接. ④: 设备间子系统: 由设备中的电缆,连接器和相关支撑设备组成,与公共系统设备相连. ⑤: 工作区子系统: 终端设备连到信息插座 ⑥: 管理子系统: 是干线子系统和水平子系统的桥梁,同时又可为同层组网提供条件,为连接其他子系统提供连接手段,由配线架,HUB,机柜,电源灯组成. 18.13 &lt;&lt;中华人民共和国著作权法&gt;&gt;①: 改编,翻译,注释,整理已有作品而产生的作品,著作权由 改编,翻译,注释,整理人 享有.. ②: 作者的署名权,修改权,保护作品完整权的 保护期不受限制. ③: 公民的作品,其发表权,使用权和获得报酬权的保护期 为作者终生及其死亡 后 50 年, 截止 于 作者死亡后 第50年的12月31日. ④: 计算机软件和口述作品等受著作权保护 注: ①: 不适用于: 法律,法规,行政,司法性质的文件等 ②: 不适用于时事新闻 ③: 不适用于 历法,通用数表,通用表格和公式. 18.14 软件文档管理指南GB/T16680-1996文档评审:由软件开发小组成员,用户代表,软件开发单位负责人,标准化人员,科技管理人员组成评审小组. 注: 用户代表 必须参加. 18.15 电子计算机机房规范GB50174-1993四种接地方式: ①: 直流工作接地: 接地电阻 应按照计算机系统具体要求, 一般不大于1欧姆 ②: 交流工作接地: 接地电阻 不应大于4欧姆 ③: 安全工作接地: 接地电阻 不应大于4欧姆 ④: 防雷接地: 应该按照现行 国家标准 &lt;&lt;建筑防雷设计规范&gt;&gt;执行,一般不大于10 欧姆 注: 静电接地 可以经过限流电阻 及自己的连接线与接地装置相连,限流电阻的阻值宜为1M欧姆. 口诀: 1直男交4女友被雷劈10 18.16 合同法①: 当事人订立合同,采取方式 有 “要约”,和”承诺”方式. ②: 当事人 采用信件,数据电文等形式订立合同的,可以在合同成立之前要求签订确认书,签订确认书时合同成立. 18.16.1 要约表示自己希望和他人订立合同 例如: 投标人向招标人投递标书 18.16.2 要约邀请表示希望他人向自己 发出要约,例如: 征婚广告,拍卖公告,招标公告,商业广告,寄送的价目表等都是要约邀请. 注: 要约到达受要约人时生效. 18.16.3 承诺表示受要约人同意要约 18.17 格式条款 与 非格式条款18.17.1 格式条款:①: 又称标准条款,指当事人为重复使用而预先拟定的,并在订立合同时未与对方协商的条款,如保险合同,拍卖成交确认书等都是格式合同. ②: 采用订立合同的,提供格式条款的一方应当遵循公平原则确定当事人之间的权利和义务,并采取合理的 方式提请对方注意免除或者限制其责任的条款. ③: 当格式条款与 非格式条款不一致时 应当 采用 非格式 条款. ④: 提供格式条款 一方免除其责任,加重对方责任,排除对方主要权利的该条款无效. 18.17.2 非格式条款18.18 有效性计算有效性 = ( 总运行时间 - 故障恢复时间 ) / 总运行时间 例题: 18.19 政府采购的招标程序①: 采购人 编制计划,报县级以上人民政府的财政部门批准 ②: 采购办与招标代理机构 办理委托手续,确定招标方式 ③: 建设单位委托 相关 的咨询公司进行 市场调查, 与采购人确认采购项目后,编制招标文件. ④: 发布招标公告,或招标邀请函 ⑤: 出售招标文件,对潜在的投标人资格预审 ⑥: 接受投标人标书 ⑦: 在公告或邀请函中规定的时间,地点公开开标 ⑧: 由评标委员对投标文件评标 ⑨: 依据评标原则确定中标人 ⑩: 向中标人发送中标通知书,并通知所有投标人 ⑩: 组织中标人与采购单位签订合同 18.20 软件工程术语GB/T11457-2006对于配置管理有以下三种基线: ①: 功能基线 ②: 分配基线 ③: 产品基线 18.21 机房工程设计原则①: 实用性和先进性: 满足当前业务需求,兼顾未来的业务需求,尽可能采用先进设备,技术. ②: 安全可靠性: 决不能出现单点故障 ③: 灵活可扩展性: 能根据业务不断深入发展的需要,扩大设备容量,提高可容纳用户数,支持多种网络传输,多种物理接口的能力等 ④: 标准化 ⑤: 经济性,投资保护 ⑥: 可管理性 18.22 合同管理的目的①: 审核并记录供应商的绩效以建立必须的纠正措施并作为将来选择供应商的参考 ②: 管理合同相关的变更利于项目客户的合同关系 ③: 十九、干系人管理19.1 干系人登记册为项目的沟通计划提供了干系人的信息,从干系人的登记册中,可知道项目中干系人的信息: 主要沟通对象,关键影响人,次要沟通对象. 19.2 管理干系人的参与 输入:①: 干系人管理计划 ②: 沟通管理计划 ③: 变更日志 ④: 组织过程资产 19.3 管理干系人的参与 输出:①: 问题日志 19.4项目干系人管理:主要内容: ①: 项目干系人分析: 识别干系人,并分析干系人兴趣,影响力理解关键干系人的希望期望需要. ②: 沟通管理: ③: 问题管理: 对沟通过程发现的问题,记录并采取行动解决. 19.5 项目干系人管理 与 人力资源管理 区别干系人管理 与 沟通管理: 如何与形形色色的人打交道 人力资源管理: 如何管人,带团队 二十、速记口诀口诀: 范进整狗子,成人风采. 对应的过程数: 676 3344 464 口诀: 两启两收先来记 口诀: 范进成风无执行 口诀: 人力资源无监控 范围管理口诀: 范围需要先收集，裁剪补充再定义； 拆分工作创WBS，审批输出一基准 控制范围先确认. 进度管理口诀: 进度先要定活动，然后才能排顺序； 资源 时间要估算，这样才能制计划。 风险管理口诀: 风险识别要靠前，定性定量分析全； 已知未知要了解，这样才能来应对。 口诀: 用逻辑进程实现部署, 静态实现构件图 口诀: 部队用包袱制品够累—–静态视图 口诀: 东西装信是交互——动态视图 口诀: 鸟翅组合强关联,相依为命同根生 口诀: 类与用例两不同,包含扩展类中无 四控,三管,一协调.———&gt;镜子投资变更控, 信安合管一协调, 口诀: 划分即实验—–生命周期 口诀: 窃可用,截机密,篡完整,伪合法 口诀: 一主二审三标四化五验证口诀: 验国防,化中央,标地方 口诀: 就是鱼丸—–软件维护四过程 口诀: 阶段组成熟,连续组过能——-CMMI 口诀: 捉错误, 揍设编, 审标准, 评质量 口诀: 巫术忘传会彪鹰—–OSI七层模型 口诀: 汇策略,核骨干——汇聚层 口诀: 叫鸡验指纹—–教训、企业计划、经验、指导方针、文档等。——–组织过程资产 口诀: 孔雀忍受暴行 —————–&gt;质量控制正确性,范围确认可接受,质量保证信心. 大特性口诀: 功能靠用小护翼 小特性口诀：是准用一安，错译成，学姐操石源，试改定分，应装一T 口诀: 绩效日志组织入,变更请求是输出———-&gt;管理项目团队 赫兹伯格保激理论 马斯洛5层需求金字塔 塔克曼阶梯5阶段—&gt;形震规发终解散 项目评估的基本方法： 静态分析法：小偷偷偷2———–最小费用法，投资收益率法，投资回收期法，追加投资回收期法 动态分析法：投资回收期法 和 贱内 ———（净现值法，内部收益率法） 口诀: 最小投收是静态 口诀: 重点管理双高, 权高利低满意即可 口诀: 开计划,产手册,管变更 总结: 上下相减是浮动,左右相减是工期——-关键路径口诀: 早开始,迟完成,紧前紧后来分析, 其他皆可推.——关键路径 项目收尾：包括管理收尾和合同收尾； 合同收尾过程涉及产品验收和管理收尾 口诀: 1直男交4女友被雷劈10———机房中防雷、直流交流电阻相关知识 项目目标特性：口诀: 鲜橙多。优先性，层次性，多目标性； 项目特点：临时性、独特性、渐进性。 软技能：口诀: 勾引领导，激谈解决——有效的沟通，对组织施加影响，领导，激励，谈判与冲突管理，解决问题。 事前检查、事中评审、事后审计 项目阶段末可以进行一次审查，目的是取得对结束当前阶段并启动下一阶段的核准 五大过程组：启动，规划，执行，监控，收尾； PDCA：计划，执行，检查，行动。 可研的内容：基金运气。技术，经济，运行环境，其他方面（法律，社会）可行性分析。 可研的方法：惊世娘子。经济评价法，市场预测法，增量净效益法，投资估算法。 可研的原则：客观公。科学性、客观性和公正性。 可研的风险：急诊室。技术风险，政治风险，市场风险。 可研的步骤：木桶鸡粗腿变焦。1）确定项目规模和目标，2）研究正在运行的系统，3）建立新系统的逻辑模型，4）导出和评价各种方案，5）推荐可行性方案，6）编写可行性方案，7）递交可行性方案。 投资前期四个阶段：机会研究，初步可行性研究，详细可行性研究，评估与决策 项目论证三个阶段：机会研究（寻求投资机会，鉴别投资方向，±30%），初步可行性研究（项目是否有生命力，是否赢利，±20%），详细可行性研究（详细技术经济论证，多方案中选择最优方案，±10%）。 项目论证：分为内部论证和外部论证，可以贯穿于可行性研究的整个阶段，项目论证费用属于立项前费用，不计入项目的总投资之内；项目评估由第三方进行；论证和评估可以同时进行。 项目建议书：包含项目必要性，市场，预测，不包含风险因素。 数据库和数据仓库：动态变化和不变，数据仓库4个特性：面向主题，稳定，集成，反映历史变化。 软件文档：开餐馆。 开，产，管。 程序流程图（设计阶段）、数据流程图DFD（分析阶段）是结构化方法使用的主要工具； 多路复用技术：贫富，薄雾，试题，马戏。频分FDMA，波分WDMA，时分TDMA，码分CDMA。 OLAP的实现方法3种：官多喝。ROLAP（关系数据库）、MOLAP（多维数据存储）、HOLAP（混合）。 CRM要素：1）以客户为中心，2）注重客户满意度，增加企业获利能力，3）针对不同客户采取不同措施。 CRM组成：触发中心，挖掘中心。 对象是一个封装，三要素：对象标识，对象状态，对象行为；对象是类的实例，类是对象的模板。 RUP四个阶段：粗细尖椒。 初始阶段，细化阶段，构建阶段，交付阶段。 软件架构模式：1）管道/过滤器模式，2）面向对象模式，3）事件驱动模式（典型的图形界面工具），4）分层模式，5）知识库模式（知识源，黑板，语音和识别），6）C/S模式（C/S需要客户端，B/S使用浏览器）。 分布式对象中间件：呕血，色，妈的。OMG的CORBA，SUN的EJB，MICROSOFT的DCOM。 数据库访问中间件：WINDOWS平台的ODBC，JAVA平台的JDBC。 面向消息中间件：IBM的MQSERIES。 物联网三层：敢裸泳。感知层 网络层 应用层。 云计算：IAAS（基础设施），SAAS（软件），PAAS（平台）。 IPV6：2的128次方，IPV4：2的32次方。 ERP：管理层面，设计层面用其他方法。 JAVA：单继承语言 WEB SERVICE：翻译，桥梁，异构，单机和局域网不适用，是实现SOA的最主要方法，SOAP（执行服务调用）,UDDI（发布查找服务）,WSDL（描述服务和接口）是基于XML的。SOAP使用XML进行编码，与应用平台完全无关。 J2EE和.NET：跨平台和不跨；J2EE运行环境包括：构件（应用逻辑的代码），容器（构件的运行环境），服务（功能接口）。 .NET开发框架：ADO.NET技术用于访问数据库；基础类库提供接口，基于下一代网络应用；通用语言运行环境处于.NET最底层，是基础。 工作流3个阶段：流程建模、仿真、改进或优化。 信息化知识点：鹰上鸡下人左龟右。应（龙头）资（核心）网，产人（成功之本）政（根本保障）。 电子商务：涉及4种流：戏子伤我（信息流、资金流、商流、物流），戏不可少。信息流是最基本必不可少的。 现代电子商务包括：1）基于因特网，2）多个参与方，3）活动范围扩大。 电子政务建设原则：1）统一规划，加强领导，2）需求主导，突出重点，3）整合资源，拉动产业，4）统一标准，保障安全。 B2B：阿里巴巴，B2C：京东、淘宝、一号店，C2C：淘宝网。 支付技术：电子钱包，电子现金，智能卡，支付形式：支付网关，第三方支付（淘宝），直接支付。协议SSL（传输层），SET（应用层）。 SSL、TLS是传输层安全协议；IPSEC是网络层安全协议；TTPT是链路层安全协议 PPTP和IPSEC协议用于虚拟专用网。 商业智能BI（要有决策有结果），数据挖掘（线性回归，描述，分类，预测），企业应用集成EAI （跟过程有关，核心ESB），CRM客户关系管理（一定要为企业盈利，不对）。 法律法规知识点：5天（退还保证金，资格预审），5个工作日（卖标书），7个工作日（质疑），15天（修改，确定中标人上报），15个工作日（投诉），20天（截止），28天（索赔），30天（签合同，暂停时间），30个工作日（书面通知投诉人），15年（采购文件保存）。 公司倒闭了合同无效。 著作权50年，发明专利权20年，新型、外观设计10年，商标保护10年；地域性无效，50年后失效。 国家标准有效期为5年。 计算机系统集成资质认证工作：根据认证和审批分离原则，先由认证机构认证，再由信息产业主管部门审批。 投标单位主要活动：1）收集招标信息，2）索购并填报资格预审文件，3）购买招标文件，4）提出问题，5）编制投标文件，6）提交投标文件，7）参加开标会议，8）讲解投标文件，9）回应招标方质疑或提交补充材料，10）如果中标，还需要签订书面合同。 监理知识点：1）监理合同是解决争议的依据；2）总监负责制；4）监理大纲是投标阶段方案性文件，监理规划是签合同后纲领性文件，监理实施细则是可操作性业务文件；5）监理不可参与验收方案的制订；6）总监负责人、工期、钱、规划；监理四级：甲乙丙暂定级，总监负责制，旁站隐蔽工程，索赔28天；7）内容：四控三管一协调。只见头变心何安8）分为咨询式、里程碑式和全过程监理。（质量、进度、投资和变更控制，信息、合同和安全管理，协调）； 连接2个以太网的设备是网桥。 网络规划：分界内的自己，分界外的运营商负责。 PING：看网络配置是否正确,127本机网卡是否正确。 UDP：面向无连接、不可靠的传输协议。 机房工程：2-3层，A（需要配备柴油发电机）BC三个等级，机房等电位连接方式，耐火材料不低于2级。 MAC地址：ARP协议转换的，MAC对于一个IP而言可以有多个，使用路由器时。 静电电压：1000V ；1**直交4个女友雷10。** 局域网3个网络协议：1）微软的NETBEUI；2）NOVELL的IPX/SPX；3）TCP/IP。 LAN分为：总线型（逻辑）、星型（物理，分带宽）、环型局域网。 RAID0（n），RAID1（n/2），RAID5（n-1）。 完全备份&gt;差分备份&gt;增量备份&gt;按需备份。 无线网络四类：WLAN，WMAN，WWAN，WPAN（无线个人网）。 无线接入：WIMAX（50千米）使用802.16协议，WI-FI（10-300米）使用802.11协议，Zigbee（10米）使用802.15.4属于WPAS，网络桥接器AP（100-300米），蓝牙10米。 802.11定义了3种物理层通信技术：直接序列扩频，窄带微波，漫反射红外线。 光纤接入方式：FTTR远端接点，FTTB大楼，FTTC路边，FTTZ小区，FTTH户，FTTD桌面。 打印服务器：采用TCP/IP协议。 信息插座到网卡之间使用无屏蔽双绞线，布线距离最大10米。 FTP基于TCP20和TCP21完成面向连接、可靠的数据传输；TFTP基于UDP69端口号；HTTP基于TCP80端口号；Serv-U是一种广泛运用的FTP服务器端软件。 交叉线：同种设备之间、ADSL MODEM和集线器HUB连接时；其余用直连线。 三层交换机：即核心交换机，具有组播功能。 3G标准4种：WCDMA\CDMA2000\TD-CDMA\WIMAX。 LTE比3G更好：高数据速率，分组传送，延迟降低，广域覆盖，向下兼容。 病毒是一些可以自我复制到可执行文件中的代码段； 蠕虫是一种可以自我复制传播且不需要宿主的完整的程序（熊猫烧香）； 木马是一种程序，可以隐藏在正常程序中执行破坏功能（灰鸽子）； DOS攻击破坏可用性。 战略管理： 战略管理的主要活动：战略制定，战略执行，战略评估。 战略五个步骤：分离择姑配。战略分析，战略梳理，战略选择，战略评估，战略匹配。 PEST宏观环境分析：震惊社稷。政治，经济，社会和文化，技术。 战略层次：公司战略，业务战略，职能战略。 战略组织类型：防御型（采用竞争性定价或高质量产品组织竞争对手进入），开拓型（寻找和开发新的产品和市场，声誉比利润更重要），分析型（介于前两者之间），被动反应型（消极无效的组织形态，总是不稳定）。 知识管理： 隐性知识的共享方法：编码化，面对面交流，人员轮换，网络；隐性知识是“惯例”。 配置管理： 配置管理：第一个过程是建方针。 配置项：1）属于产品组成部分的工作成果，2）属于项目管理和机构支撑过程域产生的文档。 测试报告、会议记要、工作记录不能作为配置项，因为不能修改。 配置管理有3种基线：功能、分配和产品基线。 产品的测试版本也可以看作基线。 3E审计：妓女笑。经济、效率和效果审计。 项目配置管理的任务：技师变态神经1）制定项目配置管理计划，2）确定配置标识规则，3）实施变更措施，4）报告配置状态，5）进行配置审核，6）进行版本管理和发行管理。。 配置管理活动：是童颜。1）配置识别（为产品配置的定义和验证、产品的标识和归档；变更的管理及其责任提供了基础），2）配置状况统计（收集、存储和访问配置信息，以维护产品的有效性），3）配置验证和审核（如相关的功能需求已经被设计文档实现，而且设计文档已纳入配置管理系统）。 配置管理员CMO才可以删除，CCB、PM、DEV（开发人员）不能删除。 配置库的主要作用：极品区。1）记录与配置相关的所有信息，其中存放受控的软件配置项是很重要的内容，2）利用库中的信息可评价变更的后果，这对变更控制有着重要的意义，3）从库中可提取各种配置管理过程的管理信息，可利用库中的信息查询回答许多配置管理的问题。 配置库三类：开泰。1）开发库（动态库，较为频繁的修改），2）守住系统。3）产品库（静态库，最终产品存入库内）。受控库（主库或系统库，管理基线和变更，二次开发），长今。 外包管理： 外包是为了达到降低成本，提高效率，充分发挥自身核心竞争力，增强自身应变能力。 越来越多的企业回归核心业务。 如何以合适的方式监督供方是项目外包管理的一个重点，监控方式正确的是与供应商先确定评价的频次和方法，列出日程表，按照计划进行评价。 鞭子效应：是将单一的决策问题多阶段化以回避风险，提高决策效率，类似于分散投资。 需求管理： 需求工程：包括需求开发和需求管理，前者是主线、目标，后者是支持、保障。 需求开发四过程：需求捕获（用户访谈，用户调查，现场观摩，文档考古，联合讨论会）—《用户需求说明书》，分析，定义（《需求规格说明书》更详细），验证。 需求规格说明书SRS：精确地阐述了一个软件系统必须提供的功能和性能，以及它所考虑的限制条件。 需求跟踪性矩阵保存了需求与后续工作成果的对应关系。 需求验证后形成需求基线。 需求开发的目的是通过调查与分析，获取用户需求并定义产品需求；需求管理的目的：1）确保各方对需求的一致理解，2）管理和控制需求的变更，3）从需求到最终产品的双向跟踪；范围管理的目的确定项目包含且仅仅只包含项目所必须完成的工作。 需求管理包括：定义需求基线，处理需求变更，需求跟踪等。 范围管理： 规定贱人制，（范围规划，范围定义，创建WBS分解结构，范围确认，范围控制） 标杆分检查。（模板表格和标准，产品和干系人分析，分解，检查，变更控制系统和偏差分析）。项目范围和产品范围：项目范围强调过程，产品范围强调结果。项目范围是否完成以项目管理计划、项目范围说明书、WBS、WBS字典作为衡量标准，产品范围是否完成以产品需求说明书作为衡量标准。 范围管理计划内容：1）如何基于初步的项目范围说明书准备一个详细的项目范围说明书，2）如何从详细的项目范围说明书创建WBS， 3）如何对已完成项目的可交付物进行正式的确认和接受的，4）如何对详细的项目范围说明书申请变更，这个过程直接与整体变更控制过程相关联。 详细的范围说明书包括：标书求姐夫，厂家约疯子，北京惩治囚犯。1）项目目标，2）产品范围描述，3）项目需求，4）项目边界，5）项目的可交付物，6）产品可接受的标准，7）项目的假设条件，8）项目的约束条件，9）初始风险，10）初始的项目组织，11）进度里程碑，12）资金限制，13）成本估算，14）项目配置管理需求，15）已批准的需求，16）项目规范。 分级树型：直观而不容易修改，适合小中项目；表格形式：不直观而方便，适合大项目。 WBS三个方法：吃饺子。1）把主要的项目可交付物和子项目作为第一层，2）子项目作为第一层，3）把项目的生命期作为第一层，项目交付物作为第二层。WBS一般3到5层，它是组织的核心。 WBS八个原则：1）在各层次上保持项目的完整性，避免遗漏必要的组成部分，2）一个工作单元只能从属于某个上层单元，避免交叉从属，3）相同层次的工作单元应用相同性质，4）工作单元应能分开不同的责任者和不同工作内容，5）便于项目管理计划、控制的管理需要，6）最底层工作应该具有可比性，是可管理的，可定量检查的，7）应包括项目管理工作，包括分包出去的工作。 WBS主要步骤：1）识别项目交付物和相关项目工作，2）对WBS的结构进行组织，3）对WBS进行分解，4）对WBS中各级工作单元分配标识符或编号，5）对当前的分解级别进行检验，以确保它们是必须的，而且是足够详细的。 WBS\OBS\RBS：工作分解结构WBS根据可交付物进行分解，组织分解结构OBS根据组织的部门、单位或团队进行分解，资源分解结构RBS根据资源进行分解，风险分解结构RBS根据已识别的风险进行分解。 范围基线包括：已批准的项目范围说明书（详细）、WBS、WBS字典。它是创建WBS的输出。 范围确认和质量控制：范围确认是有关工作结果的可接受问题，而质量控制是有关工作结果是否满足质量需求的问题。质量控制通常在范围确认之前进行，也可以并行。 范围确认应该是贯穿项目的始终，采用检查，范围确认完成时，同时应当对确认中的WBS和WBS字典进行更新。 范围蔓延原因：三无。1）无基线2）需求挖掘不够3）无变更控制程序。 变更原因：1）项目外部环境发生变化，2）项目范围的计划编制不周密详细，有一定的错误或遗漏，3）世界上出现了或是设计人员提出了新技术、手段或方案，4）项目实施组织本身发生了变化，5）客户对项目、项目产品或服务的要求发生变化。 变更控制的焦点问题：1）对造成范围变更的因素施加影响，以确保这些变更得到更一致的认可，2）确定范围变更已经发生，3）当范围变更发生时，对实际的变更进行管理。 范围变更后，要更新基准、预算、项目管理计划。 范围管理中常见问题和建议：1）不完整的需求：得到完整的需求，2）缺乏用户参与：联系所有项目干系人，3）不现实的期望：加强沟通，4）需求改变：进行范围控制，5）缺乏计划：增强项目计划，6）在压力下放弃计划：增强项目计划，7）遗漏必要的任务：加强范围确认，8）开发人员的镀金：界定项目边界，9）功能蔓延：进行范围控制。 范围问题应想到建立变更控制管理流程，质量问题应想到建立质量管理体系，建立标准，基线，重新制定完善管理计划，对流程进行优化。 进度管理： 腚需圆，利画质。（活动定义，活动排序，活动资源估算，活动历时估算，制订进度计划，进度控制） 腚需圆（专替姑管下：专家判断法，替换方案确定，公开估算数据，项目管理软件，自下而上的估算），利（专流沧桑泪：专家判断，预留时间，参数式估算，历时的三点估算，类比估算法）画质 项目计划（进度）网络图：是活动排序的输出，进度计划编制的输入。 资源估算：输入（企业环境因素，组织过程资产，活动清单，活动属性，资源可用性，项目管理计划），工具（专家判断法，替换方案确定，公开估算数据，项目管理软件，自下而上的估算），输出（活动资源需求，更新的活动属性，资源分解结构RBS，更新的资源日历，变更请求），它不包括后备分析。 历时估算：输入（企业环境因素，组织过程资产，项目范围说明书，活动清单，活动清单属性，活动资源需求，资源日历，项目管理计划），工具（专家判断，预留时间，类比估算法，参数式估算，历时的三点估算），输出（活动历时估算结果，更新的活动清单属性）。 关键链：缓冲段防范风险。 进度估算工期方法：1）明确定义项目的WBS；2）根据以往经验，采用类比估算法；3）联系业界专家，采用德尔菲法；4）依据数据采用参数估算法和三点估算法。 加快进度的措施：新加支筷子。新技术，加班，增加资源，快速跟进，资源平衡。 进度压缩工期方法：1）缩小范围，2）外包，3）并行工作，4）明确奖惩机制，提高员工工作绩效，5）赶工，6）加强阶段性检查和控制，避免后期返工，7）加强沟通，争取客户能够对项目范围，以及需求、设计和验收标准进行确认，避免后期频繁出现变更。 进度跟踪方法：1）制定活动网络图和项目工作计划，2）建立监督和测量机制，3）建立评审机制，4）及时纠正和预防问题，进行有效的变更管理，5）使用有效的项目管理工具，提高工作效率。 整体管理： 章书记指空整薇，（制定项目章程，制定初步的项目范围说明书，制定项目计划，指导和管理项目执行，监控项目执行，整体变更控制，项目收尾。） 项目章程：正式批准一个项目或者批准项目是否进入下一阶段的文档，并对项目经理授权。由组织外的发起人或资助人发布。 项目章程内容：嘘嘘的人干杯，只假约翻盖。1）项目需求，反映干系人的要求和期望，2）项目必须实现的商业需求，项目概述或产品需求，3）项目的目的或论证结果，4）任命项目经理并授权级别，5）干系人的影响，6）里程碑进度计划，7）职能组织，8）组织的、环境的和外部的假设，9）组织的、环境的和外部的约束，10）论证项目的业务方案，包括投资回报率，11）概要预算。 工作说明书SOW：对内部项目而言，由项目发起人提出；对外部项目而言，可以作为投标文档一部分从客户那里得到。包括：爷参战。业务需求，产品范围描述，战略计划。 组织过程资产：叫鸡验指纹。教训、企业计划、经验、指导方针、文档等。 项目管理计划内容：过失工期管制，控制机构责问。1）所使用的项目管理过程，2）每个特定项目管理过程的实施程度，3）完成这些过程的工具和技术的描述，4）选择的项目的生命周期和相关的项目阶段，5）如何用选定的过程来管理具体的项目。包括过程之间的依赖与交互关系和基本的输入输出等，6）如何执行工作来完成项目目标，7）如何监督和控制变更，8）如何实施配置管理，9）如何维护项目绩效基线的完整性，10）与项目干系人进行沟通的要求和技术，11）为项目选择的生命周期模型。对于多阶段项目，要包括所定义阶段是如何划分的，12）为了解决某些遗留问题和未定的决策，对于其内容，严重程度和紧迫程度进行的关键管理评审。 工作绩效信息包括：进度进展，已（未）完成哪些交付物，已开始（完成）哪些活动，满足质量标准的程度，批准的预算与发生的成本，已开始活动的预计完成日期，当前项目活动所完成的百分比，已记录下的经验教训，资源使用情况。 变更：分别内部和外部变更。流程：生平绝食盐蛋。CCB一定要有，CCB不能提出变更申请，PM不担任CCB主席，主席一票否决权，在基准内不用走变更流程，是决策机构不是作业机构，不必是常设机构，可以一个人或者多人，甚至兼职人员，人员组成：高项配车子。CCB的职责之一。（高层经理、项目经理、配置管理负责人、测试负责人、质量保证负责人等），变更控制流程的作用不包括确定要批准还是否决变更请求，它是（变更申请，评估，决策，实施，验证，沟通存档）， 监理在变更中的工作：1）接受变更申请，2）评估变更，3）参与CCB评审，4）下达变更通知书，与PM共同发布变更，5）监控变更实施，6）对变更结果进行验证。 变更批准后项目经理工作：1）更新项目管理计划或其他管理计划文件，2）安排相应人员负责新的项目活动，3）更新WBS和WBS字典，4）编制新的或修订成本估算、活动排序、进度日期、资源需求和风险应对方案等。 项目收尾：包括管理收尾和合同收尾；合同收尾过程涉及产品验收和管理收尾。 沟通管理： 勾媳暴干。(沟通计划编制，信息分发，绩效报告，项目干系人管理) 高效会议：定期揭发，发誓归总记账。1）事先制定一个例会制度，2）放弃可开可不开的会议，3）明确会议的目的和期望结果，4）发布会议通知，5）在会议前将会议资料发给参会人员，6）可以借助视频设备，7）明确会议规则，8）会议后要总结，提炼结论，9）会议要有纪要，10）做好会议的后勤保障。 认知障碍：从源头；语义障碍：传递过程中。 沟通五个原则：早接住别生。1）尽早沟通，2）采用对方能接受的沟通风格，3）主动沟通， 4）内外有别， 5）沟通的升级原则。 绩效报告：1）进度和状态报告（进展报告需要分析原因，突出建议和决策），2）预测。 项目干系人管理的目的：避免他们在项目进行期间分崩离析，它贯穿始终。 质量管理： 鞭暴之，（质量计划编制，执行质量保证，执行质量控制） 鞭（小鸡公爵六十只/效益分析，基准分析，功能展开，过程决策，流程图，实验设计，质量成本）：成本 暴（济公审过鸡：质量计划工具和技术，质量控制工具和技术，质量审计，过程分析，基准分析） 之（老七：贱人只留三排孔6西格玛；新七：相亲数据有火锅：相互关系图、亲和图、树状图、矩形图、优先矩形图、活动网络图、过程决策图）：检查表、因果图、直方图、流程图、散点图、排列图、控制图；侧面桶抽六个马：测试、统计、抽样、 质量成本：分为一致成本（预防成本、评估成本）和不一致成本（故障成本）。 质量保证QA：项目经理不能担任QA，针对过程，质量控制QC针对结果。 QA职责：包括过程指导、过程评审、产品审计、过程改进和过程度量等（前期当导师，辅助PM制定项目计划、项目估算、设定质量目标、培训指导人员等；实施中当警察，选择性地参加项目技术评审，定期对产品和过程进行审计和评审；实施中还当医生，承担收集、统计和分析度量数据的工作，用于支持管理决策。） 全面质量管理TQM：四全：元芳过节（全员、全过程、全面方法、全面结果）；朱兰：娘子高（“质量规划、控制、提高”三部曲）；克鲁斯比（零缺陷源于预防）。 质量审计：是QA工具，可以是有计划的或者随机的，分为内审和外审。 预防（把错误排除在过程之外）和检查（把错误排除在到达客户之前）；特殊抽样（结果符合或不符合）和变量抽样（结果是在测量符合程度的连续坐标系表示）；特殊原因（异常事件）和随机原因（正常过程偏差）；许可的误差（如果在许可的误差规定范围内，结果是可以被接受的）和控制限度（如果结果是在控制限度内，表明过程是在控制之中）。 趋势分析图：继续测试，平稳后不用测试。 CMM5级：质量要保证，除虫定管用。初始级，可重复，已定义，已管理，优化级。 CMMI过程改进目标：保证产品及服务质量，项目时间控制，最低的成本。 CMMI评估：A类（全面综合的评估法），B类（较少综合，花费也少），C类（快速评估法）。 OPM3由过程组，知识领域和过程改进组成，其中过程改进四个阶段是标准化，可测量，可控制，持续改进。 6个质量特性和21个子特性：功能靠用小护翼（是准用一安，错译成，学姐操，石源，试改定分，应装一T）。 质量管理重点工作：1）制定切实可行的质量管理计划，2）应安排独立于项目组的QA人员负责质量保证工作，3）实施质量审计，4）注重技术评审工作，5）注重测试工作，6）对发现的缺陷进行统计分析，确保质量，7）为项目组成员提供质量管理要求方面的培训。 质量管理计划内容：1）描述组织的项目质量管理体系，2）质量控制的方法，工具与重点，3）设计、生产过程、安装、服务、检查和测试程序及文档，4）识别出的测量要求，5）特定阶段的审核要求，6）质量标准或验收标准。 软件需求：功能，非功能，设计约束。 软件质量评价：验证和确认，验证满足前面要求，确认是看结果是否正确。 软件配置：物理性，功能性。 评审与审计：评审是质量控制的，正式的，评审可以自己评审，内审和外审。审计或评估是第三方，QC和QA不能同时担任，项目经理不能担任QA。 评审过程包括：管理评审（监控进展）、技术评审（评价软件）、检查（检测异常）和走查（不正式）。 质量问题三无：无标准、无基线、无质量控制流程。 成本管理： 顾欲空，（成本估算，成本预算，成本控制） 顾（下官擂肥卖金子：自下而上的成本估算，项目管理软件，类别估算法，确定资源费率，卖方投标分析，准备金分析，质量成本） 欲（城管掺和：成本总计，管理储备，参数模型，支出的合理化原则） 空（成绩预计偏软：成本更变控制系统，绩效测量，预测技术，项目绩效评估，偏差管理，项目管理软件） 应急储备：已知的未知事件，用来处理预期但不确定的事件，项目经理可自由使用，是项目范围和成本基准的一部分。 管理储备：未计划但可能需要的范围和成本的潜在变化而预留的预算，项目经理使用前要得到批准，不是项目成本基线的一部分，但包含在项目预算中，不是挣值的一部分。 成本：直接（直接消耗的，涉密安防系统），间接（共同分担），可变，机会，沉没。 成本基准通常以S曲线形式显示。许多项目，特别是大项目，可能有多个成本基准。 成本失控的原因：1）对工程项目认识不足，2）组织制度不健全，3）方法问题，4）技术制约。 人力资源管理： ² 记住射里，（人力资源计划编制，组建项目团队，项目团队建设，管理项目团队） ² 记（组人组人：组织结构图和职位描述，人力资源模板，组织理论，人际网络） ² 住（仙谈虚构：事先分派，谈判，虚拟团队，采购） ² 射（公认你赔活鸡：同地办公，认可奖励，一般管理技能，培训，团队建设活动，基本原则） ² 里（关机图纹：观察与对话，项目绩效评估，冲突管理，问题日志） 责任分配矩阵RAM：工作和人员一一对应的关系，是WBS和OBS结合。 成功团队特征：标致公平女性。1）目标明确，2）组织结构清晰，岗位明确3）规范的工作流程和方法，4）有明确的考核和评价标准，5）组织纪律性强，6）相互信任，善于总结和学习。 绩效评估范围：包括进度控制，成本控制，质量控制，范围验证和过程审计的结果。 冲突的产生和类型：1）项目的高压环境，2）责任模糊，3）多个上级的存在，4）新科技的流行。 马斯洛需求层次五层：李安会重现。 生理，安全，社会，受尊重，自我实现。 双因素理论：一是保健卫生（无激励作用），二是激励需求（有激励作用）。 ² 风险管理： ² 即时性，亮鞭奸。（风险管理计划编制，风险识别，定性风险分析,定量风险分析，风险应对计划编制，风险监控） ² 风险识别工具：文档评审，信息收集技术（脑儿烦死。 SWOT优劣机危分析），检查表，假设分析，图解技术（因果分析图，系统或过程流程图，影响图）。头脑风暴法，德尔菲法，访谈法， ² 风险属性：随机性、相对性、可变性。 ² 定性风险分析工具：故居娘憧憬。风险概率及影响评估，概率及影响矩阵，风险数据质量评估，风险种类，风险紧急度评估。 ² 定量风险分析工具：数据收集和表示技术（谈改嫁。EMV，决策树分析，建模和仿真）。访谈，概率分布，专家判断），定量风险分析和建模技术（灵气车模。灵敏度分析，期望货币价值分析 ² 负面风险应对策略：避免（项目早期），转移（外包等），减轻（冗余等）。 ² 采购管理： ² 鞭同膘，折管收。（采购计划编制，编制合同，招标，供方选择，合同管理，合同收尾） ² 自制/外购分析：技术达不到（外购），组织内长期使用或涉密（自制）。 ² 采购工作说明书SOW输入：范围说明书，WBS，WBS字典。 ² 投标人会议：是指在准备建议书之前与潜在供应商的碰头会。 ² 建议书：是卖方准备的文件，用来说明卖方提供所需产品或服务的能力和意愿。 ² 采购文件：用于向潜在的供应商征集建议书，由建设方准备。 ² 采购审计的目标是找出采购过程中的成功和失败之处 20.1 输入+输出+工具和技术20.1.1范围管理:①: 章==计==业组==初范书==,专家==模表==范==需==划——&gt;规划范围管理(范围计划的编制)—-(计: 指的是项目管理计划,需: 指的是需求管理计划) 首尾相接②: 范需人划章程==册==,访问观察原标杆,交互引导群决策,需求文件==矩阵==出——&gt;收集需求——(交互: 系统交互图, 矩阵: 需求跟踪矩阵, 册: 干系人登记册) ③: 章程范划组==变更==,==产分==专家==引== 备案==,== 项划==更新出==详书==.——&gt; 定义范围——-(备案: 备选方案生成) XX范划开头, 首尾相接④: 详书范划需业组, ==工分模板====分解==术, 范划更新==WBS字典==出基准——-&gt;创建WBS—–(基准: 范围基准) ⑤: 范书 范划==交==字典,==检查== ==决策==工具术, 变更绩效==验可交==——&gt;确认范围——(交: 可交付物, 检查: 审查,产品评审,审计,走查,巡检,字典: WBS字典 验可交: 验收的可交付性成果) ⑦: 变更 范划 ==效==字典,==偏差分析==变更控, 计组字典齐更新,变更请求来输出———&gt;控制范围 注: ①: 范围基准需要 评审和审批; ②: 范围说明书不能有项目 经理一人编写; ③: WBS和范围基准应该由项目团队和所有关键干系人一起创建不应该由项目经理一人创建,导致工作遗漏 ④: 要做好整体变更控制,防止范围蔓延,范围变更应该和整体变更相结合,综合评估. ⑤: 范围变更要有规范的变更控制流程 ⑥: 变更结果一定要得到用户的确认和接受 20.1.2 进度管理①: 章程计划找业组,==分== ==家== ==会==上==进管子==——-&gt;规划进度管理—-(分: 分析技术; 家: 专家判断; 会: 会议; 进管子: 进度管理计划) ②: 业组进管炒 ==基范==, 分 家==滚==出 ==清== ==属== ==里==——–&gt;定义活动—-(基范: 范围基准; 滚: 滚动式规则; 清: 活动清单; 属: 活动属性; 里: 里程碑清单) ③: 范书进计清属里, 前后紧赖网新文——&gt;排列活动顺序——(==前== 紧前关系绘图法; 后: 提前与滞后; 赖: 确定依赖关系) ④: 业组进管估成本,==清== ==属== ==资历== 有风册, 自选 ==软件== ==算== 专家, 活资 ==分解== ==新文件==——&gt;估算活动资源—(资历: 资源日历; 风册: 风险登记册; 软件: 项目管理软件; 算: 自下而上估算; 选: 自选方案分析; 分解: 资源分解结构; 新文件: 项目文件更新 ) ⑤: 业组资需分日进,清属范书有风险,==三== ==类== 专家数 策备, ==时间== 估算新文件.——&gt;估算活动持续时间—(三: 三点估算; 类 : 类比估算活动持续时间估算) ⑥: 业组资需分日进,清属范书有风险, 人员进, 压缩==网== ==路== 前后链, 优化建模靠工具, 进划基数日,新文划—–&gt;制定进度计划—(网: 进度网络分析; 路: 关键路径法; 链:关键链法; ) ⑦: 两数两划组日历, 优化建模需审查,前后压缩需软件, 进度预测 ==5大件==——&gt; 控制进度—(5大件: 项目管理计划更新,组织过程更新,项目文件更新,变更请求,工作绩效信息;,,) 20.1.3 整体管理①: 工商议事有组织,专家引导出章程——-&gt;制定项目章程—-(工: 项目工作说明书, 专家: 专家判断, 引导: 引导技术) 首尾相接②: 章程输出靠业组, 专家引导出计划——-&gt;制定项目管理计划—(输出: 其他过程的输出) 首字同绩效③: ==计== 变业组会专==项==, ==效== ==果== 变更 新文划——&gt;指导和管理项目的执行—–(变: 批准的变更请求, 项: 项目管理信息系统, 果: 可交付成果 ,效: 工作绩效数据; 变更: 变更请求) 首字同精确④: ==进== ==程== 预测计划后,==确认变更== ==效==业组(都是输入),会议分析项专家,计文更新==效报告==——-&gt;监控项目工作–(效: 工作绩效信息; 效报告: 项目绩效报告) 收尾相接⑤: 业组==计划==效变更,批准==日志==新文划——–&gt;实施整体变更控制—(批准: 批准的变更请求) 首字同宴会⑥: 验交 ==计划== 无事业,会议分析有专家,组织更新出产品——–&gt;结束项目或阶段—–(验收: 验收的可交付成果) 20.1.4 沟通管理①: 章程计划组范书,==沟技== ==沟需== ==人==分析, 最终输出沟计划——&gt;规划沟通管理(沟通计划的编制) 首尾相接②: 沟管计划==效==业组, 组==计== ==文件==齐更新——-&gt;管理沟通(信息分发,绩效报告,干系人管理) ③: ==问题日志==效计组,专家会议==信管==术,计组 ==文件==齐更新,==变更== ==绩效== 同输出.——&gt;控制沟通 20.1.5 质量管理①: 计干人册风险册,章程范书假日志,需求文件业组入, ==成收== 质成 ==标== ==实设==, ==质划== ==质测== ==质核== ==过改划==——&gt;规划质量管理(质量计划编制)—-(标: 基准分析) 规划质量管理: 是识别项目及其可交付成果的质量要求和标准,并准备对策来确保符合质量要求 的过程.作用: 为整个项目中如何管理和确认质量提供了指南和方向. 首尾相接②: 质划 质测 质控 过改划, ==质审== ==过分== ==统抽== ==七工具== , 计组 ==文件== 齐更新,变更请求来输出 ——&gt;实施质量保证——-(质审: 质量审计, 过分: 过程分析,七工具: 因果图流程图,帕累托图,核查图,直方图,控制图,散点图; 文件: 项目文件) ③: 质测 质核, 效计组, ==批变请== ==交== ==项文件== , ==确变== ==核交== 绩效出, 计组项文齐更新,还有变更请求来输出——–&gt;控制质量——–(批变请: 批准的变更请求, 交: 可交付成果, 项文件: 项目文件) 20.1.6 成本管理 20.1.7 人力资源管理①: ==活资需求== 计业组, ==人模== ==人网==组理论, 人资管划一输出. ———-规划人力资源管理(人力资源计划的编制)(人模: 人力资源模板,人网: 人迹网络,组理论: 组织理论.) 首尾相接②: ==人资管划==业组入,谈判预派虚团队,招募多标决策术, 人员分派计更新,资源日历来输出—组建项目团队 ③: 计 ==资日历==人分派, 培训团建集办公,认可奖励==人== ==人测评==,团绩评价事业输出——&gt;建设项目团队—(人: 人际关系技能, 人测评: 人事测评工具 ) ④: 人资计划 ==人分派==,问题日志 ==绩报告==,组织过程 ==团绩评==, 观 ==谈== 绩评==冲== 人技. 文计业组齐更新,还有变更请求来输出——管理项目团队.—-(冲: 冲突管理 ) 20.1.8 项目干系人管理:①: 采购文件章业组, 干人分析专会议, 管理沟通人技能,干人登册独输出.———-&gt;识别干系人 首尾相接②: ==干人登册== 计业组, 干人管划来输出———–&gt;规划干系人管理 ③: ==干人计划== 沟计划,变更日志 组织入, 变更请求 ==问日志==,计组 ==文件==齐更新——-管理干系人 ④: 计 ==问日志== 绩 ==文件==,文组更新绩变更——-控制干系人参与 注: ①: 充分分析干系人的期望和要求 20.1.9风险管理:期望货币值–定量风险分析的技术 20.1.10 采购管理 20.2 总结:20.2.1 文件:项目工作说明书 项目章程 项目管理计划 需求管理计划 工作绩效报告 工作绩效数据 工作绩效信息 需求文件 项目文件 干系人管理计划 干系人登记册 范围管理计划 项目范围说明书 进度管理计划 风险登记册 资源日历 问题日志 变更日志 活动清单 活动属性 成本管理计划 人力资源管理计划 质量管理计划 过程改进计划 质量测量指标 批准的变更请求 团队绩效评价 事业环境因素 组织过程资产 采购管理计划 采购文件 采购工作说明书 变更请求 20.2.2 工具和技术 范: 专家判断——-会议——–引导技术——-分析技术——项目管理信息系统—–变更控制工具 访谈——问卷调查——观察——原型——标杆对照—–系统交互图——引导式研讨会——-群体决策技术=====================&gt;收集需求 产品分析——-备选方案生成==============================================&gt;定义范围 分解==============================================&gt;创建WBS 检查——-群体决策技术==============================================&gt; 确认范围 偏差分析==============================================&gt;控制范围 进: 滚动式规则——分解 ==============================================&gt; 定义活动 紧前关系绘图法PDM——-确定依赖关系提前量与滞后量============================================&gt;排列活动顺序 自下而上估算—–备选方案分析——项目管理软件============================================&gt;估算活动资源 类比估算———三点估算——-储备分析—–参数估算——-群体决策============================================&gt;估算活动持续时间 进度网络分析–关键路径法—-关键链法—-资源优化技术—建模技术–进度压缩—进度计划编制工具==========================&gt;制定进度计划 绩效审查==========================================&gt;控制进度 整: 专家判断——-会议——–引导技术——-分析技术——项目管理信息系统—–变更控制工具 沟: 沟通需求分析—-沟通技术—-沟通模型====================================&gt;规划沟通管理 报告绩效—–信息管理系统—-沟通方法—-沟通技术—-沟通模型==================================&gt;管理沟通 质: 成本效益分析法—-质量成本法—-实验设计–标杆对照—-七种基本质量工具—其他质量规划工具======================================&gt;规划质量管理 质量管理和控制工具—过程分析—-质量审计====================================&gt;实施质量保证 成: 类比估算—-质量成本—–三点估算—卖方投标分析—-储备分析—–参数估算——-群体决策—-自下而上估算============================================&gt;估算成本 成本汇总—-资源限制平衡—-储备分析—-历史关系==========================================&gt;制定预算 挣值管理—–完工尚需绩效指数—-绩效审查—–项目管理软件—储备分析==========================================&gt;控制成本 人: 组织图和职位描述—-人际交往—–组织理论—–专家判断—-会议========================================&gt;规划人力资源 预分派—谈判—招募—-虚拟团队—多标准决策分析======================================&gt; 组建项目团队 培训——团队建设活动—–基本规则——–集中办公——认可与奖励——-人事评测工具====================================&gt; 建设项目团队 观察和交谈——项目绩效评估—-冲突管理—-人机关系技能==================================&gt;管理项目团队 人: 干系人分析================================&gt; 识别干系人 沟通方法——人际关系技能—–管理技能================================&gt;管理干系人参与 风: 文档审查——-信息收集技术——–假设分析———图解技术———SWOT分析==============================&gt;识别风险 风险概率和影响评估—概率和影响矩阵—风险数据质量评估—风险分类—风险紧迫性评估============================&gt;实施定性风险分析 数据收集和展示—–定量风险分析和建模==========================&gt;实施定量风险分析==========================&gt; 实施定量风险分析 消极风险的应对策略—–积极风险的应对策略—-应急应对策略========================&gt; 规划风险应对 风险再评估—-风险审计—-偏差与趋势分析—-技术绩效测量======================&gt;控制风险 采: 自制和外购分析—-市场调研========================================&gt;规划采购管理 投标人会议—-建议书评价技术——-建立估算—–广告—-分析技术—-采购谈判========================================&gt;实施采购 合同变更控制系统—采购绩效审查—检查与审计—-报告绩效—-支付系统—索赔管理—记录管理系统========================================&gt;控制采购 采购审计—-采购谈判—-记录管理系统======================================&gt;结束采购 二十一、英语阅读题:词汇: Composition: 组成Decomposition: 分解 precedence : 优先权precedence diagramming method 前导图法]]></content>
      <categories>
        <category>考证</category>
      </categories>
      <tags>
        <tag>信息系统项目管理师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络编程之TCP-UDP]]></title>
    <url>%2Fjava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP%2Fjava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP.html</url>
    <content type="text"><![CDATA[一、网络编程基础1.1 网络编程有两个主要的问题:①: 如何准确定位网络上的一台或多台主机②: 定位后如何可靠高效的传输数据 在TCP/IP中,IP层主要负责网络主机的定位,数据传输的路由,由IP地址可以唯一的确定网络上的一台主机.而TCP层提供面向应用的数据传输机制,这是网络编程的主要对象. 1.2 基本概念:端口号: 网络通信时同一机器上的不同进程的标识（其中0~1023为系统保留的端口号）,端口范围: 0~65535套接字: IP : 端口号资源名: 是资源的完整地址,包括主机名,端口号,文件名,如http://www.sun.com （协议名://主机名）http://home.netscape.com/home/welcome.html（协议名：//机器名+文件名）协议名：指明获取资源时所使用的传输协议。 如http，ftp,gopher,file 1.3 关于UDP:UDP: 无连接的协议,每个数据报都是一个独立的信息,包括完整的源地址或目的地址,它在网络上任何可能路径传往目的地,不可靠性(发送方发送的数据报不一定以相同次序到达接收方),传输效率高,有大小限制(每个数据报大小不超过64KB),. 1.4 获取网络信息和资源:1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)java.net中很多类使用到了它,如ServerSocket, Socket , DatagramSocket等 1.4.2 常用方法:获取本机主机名: InetAddress.getLocalHost().getHostName()获取本机IP: InetAddress.getLocalHost().getHostAddress()获取本机端口: serverSocket = new ServerSocket(6666); serverSocket.getLocalPort(); 服务器端获取客户端IP: Socket socket = serverSocket.accept(); socket.getInetAddress().getHostAddress();服务器获取客户端端口: String.valueOf(socket.getPort()) 二、基于TCP的网络通信:2.1 通过套接字建立连接的过程: 2.2 实例:客户端: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267package com.zwq;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.*;import java.net.Socket;/** * Created by IntelliJ IDEA * @Author: zwq *///客户端public class Client extends JFrame implements ActionListener&#123; //程序入口 public static void main(String[] args) &#123; new Client(); &#125; Socket sock; //界面上显示的组件 JTextField txtMsgServerIP = new JTextField(20); JTextField txtMsgServerPort = new JTextField(5); JButton btnConnect = new JButton("连接服务器"); JButton btnDisConnect = new JButton("断开连接"); JTextArea txtMsgArea = new JTextArea(); JTextField txtMsgSend = new JTextField(20); JButton btnSend = new JButton("发送"); //数据输入输出流 DataOutputStream out; DataInputStream in; boolean canWaite = true; CWaiter waiter; /** * 构造器中完成初始化 */ public Client() &#123; //容器 Container container = this.getContentPane(); //初始状态时"连接服务器"按钮可点击 btnConnect.setEnabled(true); //初始状态时"断开连接"按钮不可点击 btnDisConnect.setEnabled(false); //初始状态时文本域不可编辑,只能用于显示通话信息 txtMsgArea.setEditable(false); //初始状态时发送消息的编辑框不可输入 txtMsgSend.setEditable(false); //初始状态时发送按钮不可点 btnSend.setEnabled(false); //创建面板 JPanel jp = new JPanel(new GridLayout(2,1)); JPanel jp_f1 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JPanel jp_f2 = new JPanel(new FlowLayout(FlowLayout.CENTER)); jp_f1.add(new JLabel("服务器IP")); jp_f1.add(txtMsgServerIP); jp_f1.add(new JLabel("服务器端口号")); jp_f1.add(txtMsgServerPort); jp_f2.add(btnConnect); jp_f2.add(btnDisConnect); jp.add(jp_f1); jp.add(jp_f2); //创建面板,并把组件添加到面板 JScrollPane jsp = new JScrollPane(txtMsgArea); JPanel jp2 = new JPanel(); //组件添加到面板 jp2.add(txtMsgSend); jp2.add(btnSend); //面板添加到容器 container.add(jp,"North"); container.add(jsp,"Center"); container.add(jp2,"South"); //窗口标题 setTitle("客户端"); //窗口大小 setSize(500,500); //是否可见 setVisible(true); //给组件添加监听器 txtMsgSend.addActionListener(this); btnSend.addActionListener(this); btnConnect.addActionListener(this); btnDisConnect.addActionListener(this); //添加窗口监听器 addWindowListener(new WindowAdapter() &#123; //窗口关闭事件 @Override public void windowClosing(WindowEvent e) &#123; try &#123; disconnect(); &#125; catch (Exception ee) &#123; dispose(); System.exit(0); &#125; &#125; &#125;); &#125; /** * 连接服务器 * @throws IOException */ private void connect(String ServerIP,Integer ServerPort) &#123; try &#123; //创建套接字,用于连接服务器 sock = new Socket(ServerIP,ServerPort); //由套接字获取输入输出流 InputStream is = sock.getInputStream(); OutputStream os = sock.getOutputStream(); //由输入输出流获取数据输入输出流 in = new DataInputStream(is); out = new DataOutputStream(os); //向输出流(向服务器端)写数据 out.writeUTF("客户进来"); //客户端的文本域中显示连接信息 txtMsgArea.append("连接成功\n"); //连接服务器按钮 设置为不可点击(因为现在已经连接了服务器,避免重复连接,所以按钮设置为不可点击) btnConnect.setEnabled(false); //断开连接按钮 设置为 可点击 btnDisConnect.setEnabled(true); //发送信息按钮 设置为 可点击 btnSend.setEnabled(true); //发送信息的编辑框 设置为可输入 txtMsgSend.setEditable(true); //启动线程 waiter = new CWaiter(); waiter.start(); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(null,"连接服务器失败!"); &#125; &#125; /** * 客户端发送消息到服务器 */ private void sendMsg() &#123; //发送的消息不为空 if(!txtMsgSend.getText().equals(""))&#123; try &#123; //通过输出流向服务器发消息 out.writeUTF(txtMsgSend.getText()); &#125; catch (IOException e) &#123; JOptionPane.showMessageDialog(null,"发送消息失败!"); &#125; &#125; else&#123; JOptionPane.showMessageDialog(null,"不能发送空消息!"); &#125; &#125; /** * 断开连接 */ private void disconnect()&#123; //设置组件权限 btnConnect.setEnabled(true); btnDisConnect.setEnabled(false); btnSend.setEnabled(false); txtMsgSend.setEditable(false); try &#123; //向服务器发消息,内容为disconnect,表示要断开连接 out.writeUTF("disconnect"); &#125; catch (Exception e) &#123; &#125; finally &#123; canWaite = false; try &#123; //关闭输入输出流 in.close(); out.close(); &#125; catch (Exception e)&#123; try &#123; //关闭套接字 sock.close(); &#125; catch (IOException e1) &#123; &#125; &#125; &#125; &#125; /** * 处理事件 * @param e */ @Override public void actionPerformed(ActionEvent e) &#123; //如果点击了发送按钮,就调用sendMsg函数,发送消息到服务器 if(e.getSource() == btnSend || e.getSource() == txtMsgSend)&#123; sendMsg(); txtMsgSend.setText(""); txtMsgSend.requestFocus(); &#125; else if(e.getSource() == btnConnect)&#123; //如果点击了连接按钮,就调用connect函数 //都不为空 if(!(txtMsgServerIP.getText().equals("") || txtMsgServerPort.getText().equals("")))&#123; canWaite = true; int ServerPort = Integer.parseInt(txtMsgServerPort.getText()); if(!(ServerPort &gt; 0 &amp;&amp; ServerPort &lt; 65535)) &#123; JOptionPane.showMessageDialog(null,"端口值必须在0~65535之间!"); &#125; connect(txtMsgServerIP.getText(),Integer.parseInt(txtMsgServerPort.getText())); &#125; else &#123;//不都为空 JOptionPane.showMessageDialog(null,"服务器IP或端口号不能为空!"); &#125; &#125; else if(e.getSource() == btnDisConnect)&#123; disconnect(); &#125; &#125; /** * 用于接收信息的线程 */ private class CWaiter extends Thread&#123; @Override public void run() &#123; String msg; while(canWaite) &#123; try&#123; //从输入流中读取服务器返回的数据 msg = in.readUTF(); if(msg.equals("serverStop"))&#123; txtMsgArea.append("服务器停止!\n"); break; &#125; txtMsgArea.append("服务器说: "+ msg + "\n"); &#125; catch (IOException e) &#123; break; &#125; &#125; txtMsgArea.append("客户离开\n"); disconnect(); &#125; &#125;&#125; 运行图: 服务器端: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316package com.zwq;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * Created by IntelliJ IDEA * @Author: zwq *///服务器端public class Server extends JFrame implements ActionListener &#123; //程序入口 public static void main(String[] args) &#123; new Server(); &#125; //定义界面组件 JTextField txtServerPort = new JTextField(5); JTextArea txtMsgArea = new JTextArea(); JTextField txtMsgSend = new JTextField(20); JButton btnSend = new JButton("发送"); JButton btnStart = new JButton("启动服务器"); JButton btnStop = new JButton("停止服务器"); //服务器端套接字 ServerSocket serverSocket; Socket socket; //数据流 DataOutputStream out; DataInputStream in; //控制线程的逻辑变量 boolean canWaiter = true; boolean canAccepter = true; Accepter accepter; SWaiter waiter; /** * 构造器中完成界面初始化 */ public Server() &#123; Container container = this.getContentPane(); txtMsgArea.setEditable(false); btnStart.setEnabled(true); btnStop.setEnabled(false); btnSend.setEnabled(false); txtMsgSend.setEditable(false); //网格布局 JPanel jp = new JPanel(new GridLayout(2,1)); //流式布局 JPanel jp_f1 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JPanel jp_f2 = new JPanel(new FlowLayout(FlowLayout.CENTER)); jp_f1.add(new JLabel("服务器端口号")); jp_f1.add(txtServerPort); jp_f2.add(btnStart); jp_f2.add(btnStop); jp.add(jp_f1); jp.add(jp_f2); JScrollPane jsp = new JScrollPane(txtMsgArea); JPanel jp2 = new JPanel(); jp2.add(txtMsgSend); jp2.add(btnSend); container.add(jp, "North"); container.add(jsp, "Center"); container.add(jp2, "South"); setTitle("服务器"); setSize(500, 500); setVisible(true); btnStart.addActionListener(this); btnStop.addActionListener(this); btnSend.addActionListener(this); txtMsgSend.addActionListener(this); addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; stopServer(); dispose(); System.exit(0); &#125; &#125;); &#125; /** * 启动服务器 */ private void startServer(Integer txtServerPort) &#123; try &#123; serverSocket = new ServerSocket(txtServerPort); btnStart.setEnabled(false); btnStop.setEnabled(true); accepter = new Accepter(); accepter.start(); //System.out.println(InetAddress.getLocalHost().getHostName()); //System.out.println(InetAddress.getLocalHost().getHostAddress()); txtMsgArea.append("服务器已成功启动...\n"); txtMsgArea.append("服务器主机名为: " + InetAddress.getLocalHost().getHostName()+"\n"); txtMsgArea.append("服务器IP地址为: " + InetAddress.getLocalHost().getHostAddress()+"\n"); txtMsgArea.append("服务器端口号为: " + serverSocket.getLocalPort()+"\n"); txtMsgArea.append("==============================================\n"); &#125; catch (IOException e) &#123; JOptionPane.showMessageDialog(null, "启动服务器失败"); &#125; &#125; /** * 发送消息到客户端 */ private void sendMsg() &#123; if (!txtMsgSend.getText().equals("")) &#123; try &#123; //向客户端写数据 out.writeUTF(txtMsgSend.getText()); txtMsgArea.append("服务器说: " + txtMsgSend.getText() + "\n"); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(null, "发送消息失败!"); &#125; &#125; else &#123; JOptionPane.showMessageDialog(null, "不能发送消息!"); &#125; &#125; /** * 停止服务器 */ private void stopServer() &#123; //设置组件的权限 btnStop.setEnabled(false); btnStart.setEnabled(true); //停止等待客户端请求的线程 canAccepter = false; try &#123; //向输出流写数据,通知客户端服务器已停止. out.writeUTF("serverStop"); &#125; catch (Exception e) &#123; &#125; finally &#123; try &#123; //关闭服务器端套接字 serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //断开连接 disconnect(); &#125; &#125; &#125; /** * 断开连接 */ private void disconnect() &#123; btnSend.setEnabled(false); txtMsgSend.setEditable(false); try &#123; //向输出流写数据,通知客户端服务器已停止. out.writeUTF("serverStop"); &#125; catch (Exception e) &#123; &#125; finally &#123; //停止接收信息的线程 canWaiter = false; try &#123; //关闭流 in.close(); out.close(); &#125; catch (IOException e) &#123; &#125; finally &#123; try &#123; //关闭套接字 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 接收连接 */ private void acceptConnect() &#123; try &#123; //根据套接字获得输入输出流 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); //由输入输出流 建立数据输入输出流 in = new DataInputStream(is); out = new DataOutputStream(os); //从输入流读取客户端写入的数据,并显示 String msg = in.readUTF(); txtMsgArea.append(msg + "\n"); //设置组件的权限 btnSend.setEnabled(true); txtMsgSend.setEditable(true); canWaiter = true; //建立 和 启动线程 waiter = new SWaiter(); waiter.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 处理事件(如按钮被点击) * @param e */ @Override public void actionPerformed(ActionEvent e) &#123; if (e.getSource() == btnSend || e.getSource() == txtMsgSend) &#123; sendMsg(); //发送完消息后清空输入框,以便下一次输入 txtMsgSend.setText(""); //定位焦点到输入框,以便下一次输入 txtMsgSend.requestFocus(); &#125; else if (e.getSource() == btnStart) &#123; if(!(txtServerPort.getText().equals("")))&#123; int ServerPort = Integer.parseInt(txtServerPort.getText()); if(!(ServerPort &gt; 0 &amp;&amp; ServerPort &lt; 65535)) &#123; JOptionPane.showMessageDialog(null,"端口值必须在0~65535之间!"); &#125; canAccepter = true; canWaiter = true; startServer(ServerPort); &#125; &#125; else if (e.getSource() == btnStop) &#123; stopServer(); &#125; &#125; /** * 接收客户端请求的线程 */ private class Accepter extends Thread &#123; @Override public void run() &#123; while (canAccepter) &#123; try &#123; socket = serverSocket.accept(); acceptConnect(); //在服务器端窗口显示客户端的IP地址和端口格式为 "/192.168.56.1:9606" //txtMsgArea.append(socket.getRemoteSocketAddress().toString()+"\n"); //在服务器端窗口显示客户端的IP地址 txtMsgArea.append("客户端IP地址: "+socket.getInetAddress().getHostAddress()+"\n"); //服务器端窗口显示客户端端口 txtMsgArea.append("客户端端口号: "+ String.valueOf(socket.getPort())+"\n"); txtMsgArea.append("==============================================\n"); &#125; catch (IOException e) &#123; break; &#125; &#125; try &#123; //关闭服务器套接字 serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 等待消息的线程 */ private class SWaiter extends Thread &#123; @Override public void run() &#123; String msg = null; while (canWaiter) &#123; try &#123; msg = in.readUTF(); if (msg.equals("disconnect")) &#123; txtMsgArea.append("客户离开!\n"); break; &#125; txtMsgArea.append("客户说: " + msg + "\n"); &#125; catch (IOException e) &#123; break; &#125; &#125; txtMsgArea.append("断开连接\n"); txtMsgArea.append("==============================================\n"); disconnect(); &#125; &#125;&#125; 运行图: 客户端与服务器通信: 三、基于UDP的网络通信:3.1 实例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215package com.zwq;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.IOException;import java.net.*;/** * Created by IntelliJ IDEA * @Author: zwq */public class HostComputer extends JFrame implements ActionListener&#123; //程序入口 public static void main(String[] args) &#123; new HostComputer(); &#125; //文本域 JTextArea txtMsgArea = new JTextArea(); //输入框 JTextField txtMsgSend = new JTextField(20); //对方地址 JTextField txtToAddress = new JTextField(15); //对方端口 JTextField txtToPort = new JTextField(5); //本地端口 JTextField txtLocalPort = new JTextField(5); //按钮 JButton btnSend = new JButton("发送"); JButton btnStart = new JButton("开始"); //缓冲区大小 byte[]buf = new byte[1024]; //服务器地址 InetAddress toAddress; //服务器端口 int toPort; //本地端口 int localPort; //数据报套接字 DatagramSocket socket; //控制线程的逻辑变量 boolean canWaiter; /** * 构造器 */ public HostComputer() &#123; //设置组件权限 txtMsgArea.setEditable(false); txtMsgSend.setEditable(false); btnSend.setEnabled(false); Container container = this.getContentPane(); JPanel jp_G = new JPanel(new GridLayout(2,1)); JPanel jp_f1 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JPanel jp_f2 = new JPanel(new FlowLayout(FlowLayout.LEFT)); JScrollPane jsp = new JScrollPane(txtMsgArea); JPanel jp = new JPanel(); jp_f1.add(new JLabel("对方地址")); jp_f1.add(txtToAddress); jp_f1.add(new JLabel("对方端口")); jp_f1.add(txtToPort); jp_f2.add(new JLabel("本地端口")); jp_f2.add(txtLocalPort); jp_f2.add(btnStart); jp_G.add(jp_f1); jp_G.add(jp_f2); jp.add(txtMsgSend); jp.add(btnSend); txtMsgSend.addActionListener(this); btnSend.addActionListener(this); btnStart.addActionListener(this); container.add(jp_G,"North"); container.add(jsp,"Center"); container.add(jp,"South"); setTitle("基于数据报的UDP通信"); setSize(500,300); setVisible(true); addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; try &#123; stop(); &#125; catch (Exception e1)&#123; &#125; dispose(); System.exit(0); &#125; &#125;); &#125; /** * */ private void start()&#123; try &#123; toAddress = InetAddress.getByName(txtToAddress.getText()); toPort = Integer.parseInt(txtToPort.getText()); localPort = Integer.parseInt(txtLocalPort.getText()); socket = new DatagramSocket(localPort); canWaiter = true; (new Waiter()).start(); //设置组件权限 txtToAddress.setEditable(false); txtToPort.setEditable(false); txtLocalPort.setEditable(false); txtMsgSend.setEditable(true); btnSend.setEnabled(true); btnStart.setText("停止"); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(null,"启动失败!"); &#125; &#125; /** * */ private void stop()&#123; //设置按钮权限 txtMsgSend.setEditable(false); txtLocalPort.setEditable(true); txtToPort.setEditable(true); txtToAddress.setEditable(true); //txtMsgArea.setEditable(false); btnSend.setEnabled(false); canWaiter = false; toAddress = null; socket.close(); btnStart.setText("开始"); &#125; private void send()&#123; if(!txtMsgSend.getText().equals("")) &#123; byte[] b = txtMsgSend.getText().getBytes(); DatagramPacket packet = new DatagramPacket(b,b.length,toAddress,toPort); try &#123; socket.send(packet); txtMsgArea.append("发送的数据: "+txtMsgSend.getText()+"\n"); txtMsgArea.append("发送到"+toAddress+"\n"); txtMsgArea.append("数据长度为: "+packet.getLength()+"\n"); txtMsgSend.setText(""); txtMsgSend.requestFocus(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; JOptionPane.showMessageDialog(null,"不能发送空消息!"); &#125; &#125;class Waiter extends Thread&#123; @Override public void run() &#123; while(canWaiter)&#123; DatagramPacket packet = new DatagramPacket(buf,buf.length); try &#123; socket.receive(packet); String received = new String(packet.getData(),0,packet.getLength()); txtMsgArea.append("收到的数据: "+received+"\n"); txtMsgArea.append("数据来自于: "+packet.getAddress()+"\n"); txtMsgArea.append("数据长度为: "+packet.getLength()+"\n"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; /** * * @param e */ @Override public void actionPerformed(ActionEvent e) &#123; if(e.getSource() == txtMsgSend || e.getSource() == btnSend)&#123; send(); &#125; else if(e.getActionCommand().equals("开始"))&#123; start(); txtMsgSend.requestFocus(); &#125; else if(e.getActionCommand().equals("停止"))&#123; stop(); &#125; &#125;&#125; 运行两次,出现两个窗口,在这两个窗口进行通信** 运行图:]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之UI]]></title>
    <url>%2FAndroid%E4%B9%8BUI.html</url>
    <content type="text"><![CDATA[一、如何编写程序界面:Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局. 二、常见控件的使用方法2.1 TextView主要用于在界面上显示一段文本信息,设置颜色,文本居中 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ....&gt; &lt;TextView //给当前控件定义了一个唯一标识符 android:id="@+id/text_view" //所有的控件都具有这两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content android:layout_width="match_parent" android:layout_height="wrap_content" //文本居中对齐 android:gravity="center" //设置字体大小 android:textSize="24sp" //设置字体颜色 android:textColor="#00ff00" android:text="This is TextView" /&gt;&lt;/LinearLayout&gt;//match_parent 由父布局来决定当前控件的大小//wrap_content 由控件内容决定当前控件的大小 2.2 Button:activity_main.xml 中添加代码: 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ....&gt; .... &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt; 在 MainActivity 中为 Button 的点击事件注册一个监听器 1234567891011121314public class MainActivity extends Activity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... button = (Button) findViewById(R.id.button); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 在此处添加逻辑 &#125; &#125;); &#125;&#125; 2.3 EditText它允许用户在控件里输入和编辑内容 修改 布局文件activity_main.xml 中的代码: 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" ...&gt; .... &lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" //输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失 android:hint="Type something here" //通过 android:maxLines 指定了 EditText 的最大行数为两行，这样当输入的内容超过两行时，文本就会向 //上滚动，而 EditText则不会再继续拉伸 android:maxLines="2" /&gt;&lt;/LinearLayout&gt; 通过点击按钮来获取EditText 中输入的内容。修改 MainActivity 中的代码 123456789101112131415161718192021222324public class MainActivity extends Activity implements OnClickListener &#123; private Button button; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: String inputText = editText.getText().toString(); Toast.makeText(MainActivity.this, inputText, Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125; 2.4 ImageView修改 activity_main.xml 123456789101112&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt;.... &lt;ImageView android:id="@+id/image_view" //将 ImageView 的宽和高都设定为wrap_content，这样保证不管图片的尺寸是多少都可以完整地展示出来 android:layout_width="wrap_content" android:layout_height="wrap_content" //使用 android:src 属性给 ImageView指定了一张图片 android:src="@drawable/ic_launcher" /&gt;&lt;/LinearLayout&gt; 通过代码动态地更改 ImageView 中的图片。这里我准备了另外一张图片，jelly_bean.png，将它复制到 res/drawable-hdpi 目录下，然后修改 MainActivity 的代码，如下所示： 123456789101112131415161718192021222324252627public class MainActivity extends Activity implements OnClickListener &#123; private Button button; private EditText editText; // private ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); // imageView = (ImageView) findViewById(R.id.image_view); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: //调用 ImageView 的 setImageResource()方法将显示的图片改成 jelly_bean imageView.setImageResource(R.drawable.jelly_bean); break; default: break; &#125; &#125;&#125; 2.5 ProgressBar用于在界面上显示一个进度条 修改 activity_main.xml 中的代码: 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"... &gt;... &lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:layout_height="wrap_content" //指定成水平进度条 style="?android:attr/progressBarStyleHorizontal" //给进度条设置一个最大值,然后在MainActivity类中动态地更改进度条的进度 android:max="100" /&gt;&lt;/LinearLayout&gt; Android控件的可见属性。可以通过android:visibility进行指定，可选值有三种，visible、invisible 和 gone。visible 表示控件是可见的，这个值是默认值invisible 表示控件不可见，但是它仍然占据着原来的位置和大小gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 三种值。 点击一下按钮让进度条消失，再点击一下按钮让进度条出现的这种效果。修改 MainActivity 中的代码 123456789101112131415161718192021222324public class MainActivity extends Activity implements OnClickListener &#123; .... private ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... progressBar = (ProgressBar) findViewById(R.id.progress_bar); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: if (progressBar.getVisibility() == View.GONE) &#123; progressBar.setVisibility(View.VISIBLE); &#125; else &#123; progressBar.setVisibility(View.GONE); &#125; break; default: break; &#125; &#125;&#125; 12345678910111213141516//通过 activity_main.xml 中添加 android:max 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度public class MainActivity extends Activity implements OnClickListener &#123; ..... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: int progress = progressBar.getProgress(); progress = progress + 10; progressBar.setProgress(progress); break; default: break; &#125; &#125;&#125; 2.6 AlertDialog在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上,用于提示一些非常重要的内容或者警告信息 修改 MainActivity 中的代码 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity implements OnClickListener &#123; .... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: //通过 AlertDialog.Builder 创建出一个 AlertDialog 的实例 AlertDialog.Builder dialog = new AlertDialog.Builder (MainActivity.this); dialog.setTitle("This is Dialog"); dialog.setMessage("Something important."); dialog.setCancelable(false); //调用 setPositiveButton()方法为对话框设置确定按钮的点击事件 dialog.setPositiveButton("OK", new DialogInterface. OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); //调用 setNegativeButton()方法设置取消按钮的点击事件 dialog.setNegativeButton("Cancel", new DialogInterface. OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); //调用 show()方法将对话框显示出来 dialog.show(); break; default: break; &#125; &#125;&#125; 2.7 ProgressDialog在对话框中显示一个进度条,表示当前操作比较耗时，让用户耐心地等待 修改 MainActivity 中的代码: 12345678910111213141516171819public class MainActivity extends Activity implements OnClickListener &#123; …… @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle("This is ProgressDialog"); progressDialog.setMessage("Loading..."); /*注意如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取 消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的 dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。 */ progressDialog.setCancelable(true); progressDialog.show(); break; default: break; &#125; &#125;&#125; 三、详解四种基本布局布局是一种可用于放置很多控件的容器,布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套 新建一个UILayoutTest项目，并让 ADT 自动帮我们创建好活动，活动名和布局名都使用默认值 3.1 LinearLayout:称作线性布局，是一种非常常用的布局,它所包含的控件在线性方向上依次排列 3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐修改activity_main.xml 中的代码: 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" //指定了排列方向是 vertical(垂直方向), orientation(方向；定向；适应；情况介绍) android:orientation="vertical" &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button 1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button 2" /&gt; &lt;/LinearLayout&gt; 垂直对齐: android:gravity 是用于指定文字在控件中的对齐方式 android:layout_gravity 是用于指定控件在布局中的对齐方式 需要注意，当LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式,同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效. 修改 activity_main.xml 中的代码: 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... /*LinearLayout 的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向(即只能指定上,中,下,而不能指定左右)，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_vertical*/ android:orientation="horizontal" &gt; &lt;Button .... android:layout_gravity="top" android:text="Button 1" /&gt; &lt;Button .... android:layout_gravity="center_vertical" android:text="Button 2" /&gt; &lt;/LinearLayout&gt; 3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小编写一个消息发送界面，需要一个文本编辑框和一个发送按钮 修改activity_main.xml 中的代码 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/input_message" /*这里竟然将 EditText 和 Button 的宽度都指定成了 0，这样文本编辑框和按钮还能显示出来吗？不用担 心，由于我们使用了 android:layout_weight 属性，此时控件的宽度,就不应该再android:layout_width 来决定，这里指定成 0 是一种比较规范的写法 */ android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type something" /&gt; &lt;Button android:id="@+id/send" android:layout_width="0dp" android:layout_height="wrap_content" /* EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示EditText 和 Button 将在水平方向平分宽度*/ android:layout_weight="1" android:text="Send" /&gt;&lt;/LinearLayout&gt;/*为什么将 android:layout_weight 属性的值同时指定为 1 就会平分屏幕宽度呢？系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。*/ 修改activity_main.xml 中的代码 1234567891011121314151617181920/*仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服*/&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" .... android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/input_message" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" ... /&gt; &lt;Button android:id="@+id/send" android:layout_width="wrap_content" .... /&gt;&lt;/LinearLayout&gt; 3.2 RelativeLayout通过相对定位的方式让控件出现在布局的任何位置 3.2.1 每个控件相对于父布局进行定位修改 activity_main.xml 中的代码: 1234567891011121314151617181920212223242526272829303132333435&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" .... &gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" //Button 1和父布局的左上角对齐 android:layout_alignParentLeft="true" android:layout_alignParentTop="true" .../&gt; &lt;Button android:id="@+id/button2" .... android:layout_alignParentRight="true" android:layout_alignParentTop="true" ... /&gt; &lt;Button android:id="@+id/button3" .... android:layout_centerInParent="true" .... /&gt; &lt;Button android:id="@+id/button4" .... android:layout_alignParentBottom="true" android:layout_alignParentLeft="true" .... /&gt; &lt;Button android:id="@+id/button5" .... //Button 5 和父布局的右下角对齐 android:layout_alignParentBottom="true" android:layout_alignParentRight="true" .... /&gt;&lt;/RelativeLayout&gt; 3.2.2 控件相对于控件进行定位修改 activity_main.xml 中的代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt; &lt;Button android:id="@+id/button3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 1" /&gt; &lt;Button android:id="@+id/button1" .... //android:layout_above属性让一个控件位于另一个控件的上方 //@id/button3，表示让该控件位于 Button 3 的上方 android:layout_above="@id/button3" android:layout_toLeftOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button2" .... android:layout_above="@id/button3" android:layout_toRightOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button4" .... android:layout_below="@id/button3" android:layout_toLeftOf="@id/button3" .... /&gt; &lt;Button android:id="@+id/button5" .... android:layout_below="@id/button3" android:layout_toRightOf="@id/button3" .... /&gt;&lt;/RelativeLayout&gt;/*另外一组相对于控件进行定位的属性 如android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐 */ 3.3 FrameLayout没有任何的定位方式，所有的控件都会摆放在布局的左上角,它的应用场景并不多 修改 activity_main.xml 中的代码 1234567891011121314&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"....&gt; //按钮 &lt;Button android:id="@+id/button" .... /&gt; //图片 &lt;ImageView android:id="@+id/image_view" .... android:src="@drawable/ic_launcher" /&gt;&lt;/FrameLayout&gt; 3.4 TableLayout使用表格的方式来排列控件 设计一个登录界面，用户输入账号密码后登录 activity_main.xml 中的代码 123456789101112131415161718192021222324252627282930313233&lt;TableLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; // TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行 &lt;TableRow&gt; //在 TableRow中每加入一个控件，就表示在该行中加入了一列 //TableRow 中的控件是不能指定宽度的 &lt;TextView android:layout_height="wrap_content" android:text="Account:" /&gt; &lt;EditText android:id="@+id/account" android:layout_height="wrap_content" android:hint="Input your account" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;TextView android:layout_height="wrap_content" android:text="Password:" /&gt; &lt;EditText android:id="@+id/password" android:layout_height="wrap_content" android:inputType="textPassword" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;Button android:id="@+id/login" android:layout_height="wrap_content" //对单元格进行合并 android:layout_span="2" android:text="Login" /&gt; &lt;/TableRow&gt;&lt;/TableLayout&gt; android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列进行拉伸，以达到自动适应屏幕宽度的作用 修改 activity_main.xml 中的代码 123456789&lt;TableLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" // android:stretchColumns 的值指定为 1，表示如果表格不能完全占满屏幕宽度，就将第二列进行拉伸 //指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列 android:stretchColumns="1" &gt; ....&lt;/TableLayout&gt; 四、创建自定义控件 所有控件都是直接或间接继承自 View,所有布局都是直接或间接继承自 ViewGroup 创建一个 UICustomViews 项目: 4.1 引入布局1//android:background 用于为布局或控件指定一个背景 修改activity_main.xml 中的代码: 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; //引入标题栏布局 &lt;include layout="@layout/title" /&gt;&lt;/LinearLayout&gt; 别忘了在 MainActivity 中将系统自带的标题栏隐藏掉 修改MainActivity类: 12345678public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... requestWindowFeature(Window.FEATURE_NO_TITLE); .... &#125;&#125; 4.2 创建自定义控件引入布局确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码,这种情况最好是使用自定义控件的方式来解决 新建 TitleLayout类 继承自 LinearLayout，让它成为我们自定义的标题栏控件 123456789101112/*在布局中引入 TitleLayout控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借助 LayoutInflater 来实现了,LayoutInflater 的 from()方法可以构建出一个 LayoutInflater对象，然后调用 inflate()方法就可以动态加载一个布局文件*/public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); //第一个参数是要加载的布局文件的 id,第二个参数是给加载好的布局再添加一个父布局,这里我们想要指定为 TitleLayout，于是直接传入 this LayoutInflater.from(context).inflate(R.layout.title, this); &#125;&#125; 现在自定义控件已经创建好了，然后在布局文件中添加这个自定义控件 修改activity_main.xml 中的代码 123456789//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候我们需要指明控件的完整类名，包名在这里是不可以省略的&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.example.uicustomviews.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/com.example.uicustomviews.TitleLayout&gt;&lt;/LinearLayout&gt; 为标题栏中的按钮注册点击事件 修改 TitleLayout中的代码 123456789101112131415161718192021222324public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); // findViewById()方法得到按钮的实例 Button titleBack = (Button) findViewById(R.id.title_back); Button titleEdit = (Button) findViewById(R.id.title_edit); //分别调用 setOnClickListener()方法给两个按钮注册了点击事件 titleBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; ((Activity) getContext()).finish(); &#125; &#125;); titleEdit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getContext(), "You clicked Edit button", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 五、最常用最难用控件ListViewListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕 5.1 ListView 的简单用法首先新建一个 ListViewTest 项目,都默认 修改activity_main.xml 中的代码 123456789&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 修改 MainActivity 中的代码 12345678910111213141516public class MainActivity extends Activity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry","Cherry", "Mango" &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成 //android.R.layout.simple_list_item_1 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1,data); ListView listView = (ListView) findViewById(R.id.list_view); // setAdapter()方法，将构建好的适配器对象传递进去,这样 ListView和数据之间的关联就建立完成了 listView.setAdapter(adapter); &#125;&#125; 5.2 定制 ListView 的界面新建类 Fruit 1234567891011121314public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; layout 目录下新建fruit_item.xml 12345678910111213141516&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; // ImageView 用于显示水果的图片 &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; //TextView用于显示水果的名称 &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" /&gt;&lt;/LinearLayout&gt; 新建类 FruitAdapter 12345678910111213141516171819202122public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; // getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // getItem()方法得到当前项的 Fruit 实例 Fruit fruit = getItem(position); // 获取当前项的Fruit实例 //LayoutInflater 来为这个子项加载我们传入的布局， View view = LayoutInflater.from(getContext()).inflate(resourceId, null); // findViewById()方法分别获取到 ImageView 和 TextView 的实例 ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); // setImageResource()和 setText()方法来设置显示的图片和文字 fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125; &#125; 修改 MainActivity 中的代码 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends Activity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango" &#125;; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits() &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; ....&#125; 5.3 提升 ListView 的运行效率修改 FruitAdapter中的代码 12345678910111213141516171819202122232425/*getView()方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用*/public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; .... @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; //如果 convertView 为空，则使用LayoutInflater 去加载布局，如果不为空则直接对 convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候也可以表现出更好的性能。 if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); &#125; else &#123; view = convertView; &#125; ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125;&#125;/*虽然现在已经不会再重复去加载布局，但是每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个 ViewHolder来对这部分性能进行优化*/ 可以继续优化 修改 FruitAdapter 中的代码: 1234567891011121314151617181920212223242526272829303132333435public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; ... @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder 存储在View 中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; //ViewHolder，用于对控件的实例进行缓存 class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125;&#125;/*当 convertView为空的时候:创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View的 setTag()方法，将 ViewHolder 对象存储在 View 中。当 convertView 不为空的时候:则调用View的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了*/ 5.4 ListView 的点击事件修改 MainActivity 中的代码 123456789101112131415161718public class MainActivity extends Activity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; .... //通过 position 参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来 listView.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; ……&#125; 六、单位和尺寸布局文件中指定宽高的固定大小有以下常用单位可供选择：px、pt、dp 和 sp px 是像素的意思，即屏幕中可以显示的最小元素单元 pt 是磅数的意思，1 磅等于 1/72 英寸，一般 pt 都会作为字体的单位来使用 新建好一个 UISizeTest 项目 修改 activity_main.xml 中的代码 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" // android:layout_width 属性将按钮的宽指定为 200px android:layout_width="200px" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt; 接着创建一个 240*320 像素的低分辨率模拟器，在这个模拟器上重新运行程序 dp 是密度无关像素的意思，也被称作 dip，和 px 相比，它在不同密度的屏幕中的显示比例将保持一致。 sp 是可伸缩像素的意思，它采用了和 dp 同样的设计理念，解决了文字大小的适配问题 什么叫密度？Android 中的密度就是屏幕每英寸所包含的像素数，通常以 dpi为单位 比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果它的分辨率是 320480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640960，那这个屏幕的密度就是 320dpi 如何得知当前屏幕的密度值? 修改 MainActivity 中的代码 1234567891011public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); float xdpi = getResources().getDisplayMetrics().xdpi; float ydpi = getResources().getDisplayMetrics().ydpi; Log.d("MainActivity", "xdpi is " + xdpi); Log.d("MainActivity", "ydpi is " + ydpi); &#125;&#125; 根据 Android 的规定，在 160dpi 的屏幕上，1dp 等于 1px，而在 320dpi 的屏幕上，1dp就等于 2px。因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的显示比例保持一致 修改 activity_main.xml 中的代码 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" android:layout_width="200dp" android:layout_height="wrap_content" android:text="Button" /&gt;&lt;/LinearLayout&gt;/*尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。*/ 七、编写界面的最佳实践:创建一个 UIBestPractice 项目 7.1 制作 Nine-Patch 图片Nine-Patch 图片,它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸而哪些区域不可以。 准备一张普通的气泡样式的png图片 message_left.png (google上直接搜索message_left.png就可找到) 将这张图片设置为一个 LinearLayout 的背景图片,修改 activity_main.xml 123456789&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/message_left" &gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差. 这时我们就可以使用 Nine-Patch 图片来进行改善 在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。绘制完成后效果如图: 注意：制作完成后，应该将原始文件删除，否则AS会分不清楚而报错。 重新运行程序 这样当图片需要拉伸的时候，就可以只拉伸指定的区域，程序在外观上也是有了很大的改进 7.2 编写精美的聊天界面再制作一张message_right.9.png作为发出消息的背景图 修改 activity_main.xml 1234567891011121314151617181920212223242526272829303132333435&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#d8e0e8" android:orientation="vertical" &gt;// ListView 用于显示聊天的消息内容 &lt;ListView android:id="@+id/msg_list_view" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"// android:divider属性，它可以指定 ListView分隔线的颜色，这里#0000 表示将分隔线设为透明色 android:divider="#0000" &gt; &lt;/ListView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt;//EditText用于输入消息 &lt;EditText android:id="@+id/input_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type somthing here" android:maxLines="2" /&gt;// Button 用于发送消息 &lt;Button android:id="@+id/send" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Send" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 定义消息的实体类，新建 Msg 1234567891011121314151617181920212223public class Msg &#123; //TYPE_RECEIVED 表示这是一条收到的消息 public static final int TYPE_RECEIVED = 0; //TYPE_SENT 表示这是一条发出的消息 public static final int TYPE_SENT = 1; //content 表示消息的内容 private String content; //type 表示消息的类型 private int type; public Msg(String content, int type) &#123; this.content = content; this.type = type; &#125; public String getContent() &#123; return content; &#125; public int getType() &#123; return type; &#125;&#125; 编写 ListView子项的布局，新建 msg_item.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="10dp" &gt;//让收到的消息居左对齐 &lt;LinearLayout android:id="@+id/left_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:background="@drawable/message_left" &gt; &lt;TextView android:id="@+id/left_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" android:textColor="#fff" /&gt; &lt;/LinearLayout&gt;//发出的消息居右对齐 &lt;LinearLayout android:id="@+id/right_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:background="@drawable/message_right" &gt; &lt;TextView android:id="@+id/right_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 创建 ListView 的适配器类，让它继承自 ArrayAdapter，并将泛型指定为 Msg类。新建类 MsgAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MsgAdapter extends ArrayAdapter&lt;Msg&gt; &#123; private int resourceId; public MsgAdapter(Context context, int textViewResourceId, List&lt;Msg&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Msg msg = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); viewHolder.rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); viewHolder.leftMsg = (TextView) view.findViewById(R.id.left_msg); viewHolder.rightMsg = (TextView) view.findViewById(R.id.right_msg); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; if (msg.getType() == Msg.TYPE_RECEIVED) &#123; // 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏 viewHolder.leftLayout.setVisibility(View.VISIBLE); viewHolder.rightLayout.setVisibility(View.GONE); viewHolder.leftMsg.setText(msg.getContent()); &#125; else if (msg.getType() == Msg.TYPE_SENT) &#123; // 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏 viewHolder.rightLayout.setVisibility(View.VISIBLE); viewHolder.leftLayout.setVisibility(View.GONE); viewHolder.rightMsg.setText(msg.getContent()); &#125; return view; &#125; class ViewHolder &#123; LinearLayout leftLayout; LinearLayout rightLayout; TextView leftMsg; TextView rightMsg; &#125;&#125; 修改 MainActivity 中的代码，来为 ListView初始化一些数据，并给发送按钮加入事件响应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends Activity &#123; private ListView msgListView; private EditText inputText; private Button send; private MsgAdapter adapter; private List&lt;Msg&gt; msgList = new ArrayList&lt;Msg&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); initMsgs(); // 初始化消息数据 adapter = new MsgAdapter(MainActivity.this, R.layout.msg_item, msgList); inputText = (EditText) findViewById(R.id.input_text); send = (Button) findViewById(R.id.send); msgListView = (ListView) findViewById(R.id.msg_list_view); msgListView.setAdapter(adapter); send.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取 EditText 中的内容 String content = inputText.getText().toString(); //如果内容不为空则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去 if (!"".equals(content)) &#123; Msg msg = new Msg(content, Msg.TYPE_SENT); msgList.add(msg); //调用了适配器的 notifyDataSetChanged()方法，用于通知列表的数据发生了变化 adapter.notifyDataSetChanged(); // 当有新消息时，刷新ListView中的显示 // 将ListView定位到最后一行,以保证一定可以看得到最后发出的一条消息 msgListView.setSelection(msgList.size()); inputText.setText(""); // 清空输入框中的内容 &#125; &#125; &#125;); &#125; private void initMsgs() &#123; //初始化几条数据用于在 ListView 中显示 Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED); msgList.add(msg1); Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SENT); msgList.add(msg2); Msg msg3 = new Msg("This is Tom. Nice talking to you. ", Msg.TYPE_RECEIVED); msgList.add(msg3); &#125; ......&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android之UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串]]></title>
    <url>%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[一、字符串的特性:String 被声明为 final，因此它不可被继承。 二、不同JDK版本中String的区别:①: 在 Java 8 中，String 内部使用 char 数组存储数据。 ②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 三、String 与StringBuffer,StringBuilder的区别：3.1 可变性:String的长度是不可变的，而StringBuffer和StringBuilder长度是可变的. 也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中. 3.2 线程安全:String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StringBuffer的常用方法: String常用方法: StringBuffer和StringBuilder和String的效率比较: 1234567891011121314151617181920212223242526272829@Testpublic void test2() &#123; long startTime = 0L; long endTime = 0L; String text = ""; StringBuffer buffer = new StringBuffer(""); StringBuilder builder = new StringBuilder(""); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuffer的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuilder的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println("String的执行时间：" + (endTime - startTime));&#125; 四、字符串与其他数据类型的转换: 4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)A ———&gt; B: 调用B的方法:①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法 4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)字符串———&gt;数组 调用字符串的方法数组————&gt;字符串 调用字符串的构造器 ③: 字符串——-&gt;字节数组 调用字符串的getBytes()④: 字符串——-&gt;字符数组 调用字符串的toCharArray() ⑤: 字节数组——&gt;字符串 调用字符串的构造器⑥: 字符数组——&gt;字符串 调用字符串的构造器 五、字符串常量池（String Pool）:①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 ②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 ③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 六、字符串字面量 和字符串对象:字面量指的是能够使用简单结构和符号创建对象的表达式。如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。 七、new String(“abc”)创建了几个对象?使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 八、关于”==” 和”equals”和String的intern()方法:①: “==”比较的是地址②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.③: String类重写了equals方法④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用； 关于intern(): 1234567891011121314151617String s0= “kvill”; String s1=new String(”kvill”); String s2=new String(“kvill”); System.out.println( s0==s1 ); System.out.println( “**********” ); s1.intern(); s2=s2.intern(); //把常量池中“kvill”的引用赋给s2 System.out.println( s0==s1); System.out.println( s0==s1.intern() ); System.out.println( s0==s2 );结果为： false ********** false //虽然执行了s1.intern(),但它的返回值没有赋给s1 true //说明s1.intern()返回的是常量池中”kvill”的引用 true 几个结论: 直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。 new出来的字符串是存放在堆里面。 对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况： 表达式右边是纯字符串常量，那么存放在常量池里面。 表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面 12345678910111213String str1 = "aaa"; //str1存放的值是字符串常量池中字符串aaa对象的地址.String str2 = "bbb";String str3 = "aaabbb";String str4 = str1 + str2; //str4存放的是堆中字符串aaabbb对象的地址String str5 = "aaa" + "bbb";System.out.println(str3 == str4); // falseSystem.out.println(str3 == str4.intern()); // trueSystem.out.println(str3 == str5);// true//分析:结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。其实Integer这种包装类型的-128 ~ +127也是存放在常量池里面，比如Integer i1 = 10;Integer i2 = 10; i1 == i2结果是true，估计也是为了性能优化。 九、五个关于字符串的算法题:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 * 1. 模拟一个trim方法，去除字符串两端的空格 。 * 2. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 * 3. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。 * 4. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = "abcwercvhelloobnm"。 * 5.对字符串中字符进行自然排序 // 1. 模拟trim方法，去除字符串两端的空格 public static String myTrim(String str) &#123; int start = 0; int end = str.length() - 1; // 判断字符串str前面是否有空格 while (start &lt;= end &amp;&amp; str.charAt(start) == ' ') &#123; start++; &#125; System.out.println(start); // 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常 while (start &lt;= end &amp;&amp; str.charAt(end) == ' ') &#123; end--; &#125; System.out.println(end); // 方法一： char[]a = new char[end-start+1]; int j = 0; for (int i = start; i &lt;= end; i++,j++) &#123; System.out.print(i+" "); a[j] = str.charAt(i); &#125; System.out.println(); //将字符数组转换为字符串 String str1 = new String(a); return str1; // // 方法二：// return str.substring(start, end + 1); &#125; // 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一) public static String myReverseString(String str, int start, int end) &#123; //字符串转换为字符数组 char[] c = str.toCharArray(); return myreverseArray(c, start, end); &#125; public static String myreverseArray(char[] c, int start, int end)&#123; for (int i = start,j = end; i &lt; j; i++,j--) &#123; char temp = c[i]; c[i] = c[j]; c[j] = temp; &#125; //字符数组转换为字符串 return new String(c); &#125;&#125; // 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二） public static String reverseString2(String str, int start, int end) &#123; String str1 = str.substring(0,start); for (int i = end; i &gt;= start; i--) &#123; char c = str.charAt(i); str1 += c; &#125; str1 += str.substring(end + 1); return str1; &#125; // 3. 获取一个字符串在另一个字符串中出现的次数. // 判断str2 在 str1 中出现的次数 // 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取 public static int getTime(String str1, String str2) &#123; int count = 0; int length; while ((length = str1.indexOf(str2)) != -1) &#123; count++; str1 = str1.substring(length + str2.length()); &#125; return count; &#125; // 4. 获取两个字符串中最大相同字串。 public static List&lt;String&gt; getMaxSubString(String str1, String str2) &#123; String maxStr = (str1.length() &gt; str2.length())? str1:str2; String minStr = (str1.length() &lt; str2.length())? str1:str2; int length = minStr.length(); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; length; i++) &#123; for (int x = 0,y = length - i; y &lt;= length; x++,y++) &#123; String str = minStr.substring(x,y); if (maxStr.contains(str)) &#123; list.add(str); &#125; &#125; if (list.size() != 0) &#123; return list; &#125; &#125; return null; &#125; //5.对字符串中字符进行自然排序 public static String mySort(String str) &#123; char[]c = str.toCharArray(); Arrays.sort(c); return new String(c); &#125; public class StringDemo &#123; public static void main(String[] args) &#123; // @Test-myTrim String testString1 = " abc d "; // 特殊情况 String testString2 = " "; String str1 = StringDemo.myTrim(testString1); String str2 = StringDemo.myTrim(testString2); System.out.println("----" + str1 + "----"); System.out.println("----" + str2 + "----"); // 验证 String str3 = str1.trim(); String str4 = str2.trim(); System.out.println("----" + str3 + "----"); System.out.println("----" + str4 + "----"); // @Test-myReverseString and myReverseArray String str5 = "abcdefg"; String str6 = myReverseString(str5, 2, 5); System.out.println("原字符串：" + str5); System.out.println("指定部分反转-法一：" + str6); String str7 = "abcdefg"; String str8 = reverseString2(str7, 2, 5); System.out.println("指定部分反转-法二：" + str8); int count = getTime("abkkcadkabkebfkabkskab", "abk"); System.out.println("出现次数为：" + count); List&lt;String&gt; str9 = getMaxSubString("abcwerathelloyuiodef", "abcwercvhellobnm"); System.out.println(str9); String str10 = "aediewfn"; String str11 = mySort(str10); System.out.println(str11); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、数据链路层设备:①: 网桥或桥接器:②: 交换机: 实质: 是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器 特点: 全双工: 并行性: 即能同时连通多对接口，使多对主机能同时通信 自学习: 即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 优点: 对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s. ③: 网络适配器又称网络接口卡，网卡 网络适配器是什么? 网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。 网络适配器的主要作用： 它是主机与介质的桥梁设备 实现主机与介质之间的电信号匹配 提供数据缓冲能力 控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。) 网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。 二、数据链路层协议:2.1 PPP协议: Point-to-Point Protocal; （点到点）互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 2.1.1 特点:①: 简单②: 只检错,不纠错③: 不使用序号,不进行流量控制 2.1.2 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 2.2 PPPoE协议:是为宽带上网的主机使用的链路层协议 2.3 CSMA/CD协议:CSMA/CD 表示载波监听多点接入 / 碰撞检测。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 2.4 IEEE 802.3/.2协议2.5 ATM协议2.6 HDLC协议三、数据链路层基本单元:帧 四、数据链路层三个基本问题:4.1 封装成帧:将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 4.2 透明传输:透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 4.3 差错检测:循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算 五、数据链路层使用的信道:5.1 点对点信道:一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 5.2 广播信道:①: 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。③: 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用CSMA/CD 协议。 六、数据链路层功能：①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输②: 组帧（Framing）③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端④: 流量控制（Flow control）:避免淹没接收端⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权 七、数据链路层任务: 八、MAC 地址:MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 九、以太网:9.1 以太网是一种星型拓扑结构局域网。早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 9.2 特点:采用的协议: CSMA/CD采用无连接,半双工通信对数据帧不进行编号尽最大努力交付(不可靠)不要求对方确认发送的数据都以曼彻斯特编码收到错帧就丢弃 9.3 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 十、局域网:局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 十一、10BASE-T:10 代表 10Mbit/sBASE : 连接线上的信号为基带信号T: 双绞线 十二、数据链路层功能:将网络层接收到的数据分割成特定的可被物理层传输的帧]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown用法]]></title>
    <url>%2FMarkdown%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、常用操作:1.1 代码块:①: 添加代码块 :一行代码时: (也称行内代码) 使用一对单引号(ESC键下面的单引号键),代码放在这对单引号之间 效果图: 多行代码: 连按三个单引号(ESC键下面的单引号键) ,然后回车. 效果图: ②: 代码快速排版: 先把光标定位到代码块中，此时右下角会让你输入代码格式（如Java，C，C#等）,比选择Java， 然后Ctrl+ A选中所有代码, 最后 Shift + tab 拍版前: 排版后: 1.2 插入图片插入互联网上图片: ![这里写图片描述](这里写地址) ![这里写图片描述](http://img3.douban.com/mpic/s1108264.jpg) 1.3 超链接链接文字都是用 [方括号] 来标记,在方块括号后面紧接着圆括号并插入网址链接即可 [This link](http://example.net/) 1.4 分割线：在一行中输入三个连续的减号: 效果图: 1.5 换行方法1: 连续两个以上空格, 然后 回车 方法2：使用html语言换行标签：&lt;br&gt; 1.6 首行缩进：首行缩进两个字符：(每个表示一个空格，连续使用两个即可） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 1.7 字体,字体颜色,字体大小使用内嵌HTML的方法 123456&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;我是浅蓝色,黑体,7号字&lt;/font&gt;&lt;font color=red size=72&gt;我是红色&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 1.8 背景色Markdown本身不支持背景色设置，需要采用内置html的方式实现 借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下： 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=green&gt;背景色是：green&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果图: 背景色是：green]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown用法指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Android]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Android.html</url>
    <content type="text"><![CDATA[一、Android系统四大组件:1.1 活动（Activity）:凡是在应用中你看得到的东西，都是放在活动中的。 1.2 服务（Service）:你无法看到它，但它会一直在后台默默地运行 1.3 广播接收器（Broadcast Receiver）:接收来自各处的广播消息，比如电话、短信等 1.4 内容提供器（ContentProvider）:为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现 二、创建并运行HelloWorld程序:2.1 创建程序 Application Name 代表应用名称，此应用安装到手机之后会在手机上显示该名称:Project Name 代表项目名称，在项目创建完成后该名称会显示在 Eclipse 中Minimum Required SDK 是指程序最低兼容的版本Target SDK 是指你在该目标版本上已经做过了充分的测试，系统不会再帮你在这个版本上做向前兼容的操作了Compile With是指程序将使用哪个版本的 SDK 进行编译最后一个 Theme是指程序 UI 所使用的主题，我个人比较喜欢选择 None 2.1.1 创建活动:选择一个你想创建的活动类型，这里我们就选择 Blank Activity 了 2.2 启动模拟器:点击 Eclipse 导航栏中的 Window→Open Perspective→DDMS如果你的 Devices 窗口中有一个设备显示是 Online 的，那就说明目前一切正常，你的模拟器是在线的 2.3 执行程序代码:右击 HelloWorld 项目→Run As→Android Application 三、程序的目录结构:3.1 gen自动生成的，主要有一个 R.java 文件,你在项目中添加的任何资源都会在其中生成一个相应的资源 id,永远不要手动去修改它。 3.2 bin存放编译时自动产生的文件, 目录下有HelloWorld.apk，把这个文件拷到手机上就可以直接安装了 3.3 libs存放第三方 Jar包, 会被自动添加到构建路径里去 3.4 assets存放一些随程序打包的文件,所有网页相关的文件也都存放在这个目录下 3.5 res: (resources即资源目录)图片、布局、字符串等资源都要存放在这个目录下图片放在 drawable 目录下布局放在 layout 目录下字符串放在 values 目录下 3.6 AndroidManifest.xml整个 Android 项目的配置文件，四大组件都需要在这个文件里注册,还可以添加权限声明,版本兼容修改 3.7 project.properties指定编译程序时所使用的 SDK 版本 四、程序的运行流程分析:4.1 AndroidManifest.xml 文件:1234567891011//对 HelloWorldActivity 这个活动进行注册,没有在 AndroidManifest.xml 里面注册的活动是不能使用的。&lt;activity android:name="com.test.helloworld.HelloWorldActivity" android:label="@string/app_name" &gt; //主活动，在手机上点击应用图标，首先启动的就是这个活动。 &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 4.2 再来看src/HelloWorldActivity.java文件1234567public class HelloWorldActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 调用了setContentView()方法，给当前的活动引入了一个 hello_world_layout 布局 setContentView(R.layout.hello_world_layout); &#125; Activity 是 Android 系统提供的一个活动基类，项目中所有的活动都必须要继承它才能拥有活动的特性 onCreate()方法是一个活动被创建时必定要执行的方法 Android程序的设计讲究逻辑和视图分离,在布局文件中编写界面，然后在活动中引入进来。 4.3 看 res/layout/hello_world_layout.xml 布局文件:12345678&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"....... &lt;TextView android:layout_width="wrap_content" ...... android:text="@string/hello_world" /&gt;&lt;/RelativeLayout&gt; TextView，这是 Android 系统提供的一个控件，用于在布局中显示文字的hello_world_layout.xml布局文件中就是通过引用了 hello_world这个键，才找到了相应的值 4.4 查看res/values/strings.xml 文件:12345&lt;resources&gt; &lt;string name="app_name"&gt;Hello World&lt;/string&gt; .... &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;&lt;/resources&gt; 一 般 是 把 字 符 串 定 义 在res/values/strings.xml 里，然后可以在布局文件或代码中引用Hello world!字符串就是定义在这个文件里的可以在这里通过修改 app_name 对应的值，来改变此应用程序的名称,在哪儿引用了app_name 这个键呢？在AndroidManifest.xml查找. 五、关于资源目录res:drawable开头的文件夹都是用来放图片的values开头的文件夹都是用来放字符串layout 文件夹是用来放布局文件menu 文件夹是用来放菜单文件 之所以有这么多 drawable开头的文件夹，是为了让程序能够兼容更多的设备, 最好能够给同一张图片提供几个不同分辨率的副本只有一份图片时,所有图片都放在 drawable-hdpi下即可 六、如何引用资源? strings.xml 中的 Hello world!字符串，有两种方式引用它： ①: 代码中通过 R.string.hello_world 可以获得该字符串的引用；②: 在 XML 中通过@string/hello_world可以获得该字符串的引用。 string 部分是可以替换的,如果是引用的图片资源就可以替换成 drawable,如果是引用的布局文件就可以替换成 layout,以此类推 七、日志:7.1 打印日志:打开 HelloWorldActivity，在 onCreate()方法中添加一行打印日志的语句， 1234protected void onCreate(Bundle savedInstanceState) &#123; .... Log.d("HelloWorldActivity", "onCreate execute");&#125; Log.d 第一个参数是 tag，一般传入当前的类名，主要用于对打印信息进行过滤。第二个参数是 msg，即想要打印的具体的内容。 7.2 日志过滤器: 给过滤器起名叫 data，并且让它对名为 data 的 Tag进行过滤 在 onCreate()方法中把打印日志的语句改成 Log.d(“data”,”onCreate execute”)，然后再次运行程序，你就会在 data 过滤器下看到这行日志了。 7.3 日志级别:选中debug级别，这时只有使用 debug 及以上级别方法打印的日志才会显示出来如果你把LogCat 中的级别选中为 info、warn 或者 error 时，我们在 onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是 Log.d()方法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>初识Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PV操作]]></title>
    <url>%2FPV%E6%93%8D%E4%BD%9C%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[一、什么是PV操作?PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：P（S）：①将信号量S的值减1，即S=S-1；②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 V（S）：①将信号量S的值加1，即S=S+1； 二、PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。 三、什么是信号量？信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关: ①: 当信号量的值大于0时，表示当前可用资源的数量②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数注意，信号量的值仅能由PV操作来改变。 四、使用PV操作注意事项：①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。③: 互斥信号量的初值一般为1。 五、PV操作实例:5.1 例题1: 吃苹果问题: 解题过程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344 semaphore empty=2； //定义empty对应盘子的剩余放水果的位置个数初值为2( 空缓冲区个数 ) semaphore apple=0； //定义信号量apple对应盘子里的苹果数量初值为0 semaphore orange=0； //定义信号量orange对于盘子里的橘子数量初值为0 semaphore mutex=1： //定义信号量mutex来保护盘子被互斥地访问 father()&#123; //爸爸进程 while(1)&#123; P(empty)； //盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放苹果 P(mutex)； 在盘子里放一个苹果 V(mutex)； V(apple)；//盘中苹果数加一 &#125;&#125;mother()&#123; //妈妈进程 while(1) &#123; P(empty)； //盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放橘子 P(mutex)； //互斥变量减一，如果&lt;0，则说明有进程在临界区。则当前进程必须等待。 在盘子里放一个橘子 V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。 V(orange)； //盘中橘子数加一 &#125; &#125; son()&#123; //用这段程序产生两个儿子进程 while(1) &#123; P(orange)； //盘中橘子个数减一，如果结果&gt;=0时,说明盘中有橘子，可以取 P(mutex)； 从盘子里拿一个橘子 V(mutex)； V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一 &#125;&#125;daughter()&#123; //用这段程序产生两个女儿进程 while(1 ) &#123; P(apple)； //盘中苹果个数减一，如果结果&gt;=0时,说明盘中有苹果，可以取 P(mutex)； 从盘子里拿出一个苹果 V(mutex)； V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一 &#125; &#125; 5.2 : 和尚打水: 分析: 解题过程: 12345678910111213141516171819202122232425262728293031323334353637Semaphore mutexA = 1; //保护井被互斥地访问 Semaphore mutexB = 1; //保护缸被互斥地访问 Semaphore Count = 3； //桶总数为3Semaphore full = 0; //控制出水，刚开始，缸是空的，能取出0桶水Semaphore empty = 10 ; //控制入水，刚开始，缸是空的，能倒入10桶水//小和尚打水：Progress（小和尚）&#123; while（1）&#123; P（empty） //判断缸是否满了（结果如果&gt;=0,未满），决定是否需要打水 P（count） //拿桶（判断是否有空闲的桶，结果如果&gt;=0,有桶） P（mutexA）&#123; //对井互斥访问 从井中打水； V（mutexA） //互斥 &#125; P（mutexB）&#123; //对缸互斥访问 向缸中倒水； V（mutexB） //互斥 &#125; V（count）//还桶，空闲桶的数量加一 V（full） //缸中水的数量加一，（通知老和尚取水） &#125;&#125;//老和尚取水：progress（老和尚）&#123; while（1）&#123; P（full） //判断缸中是否有水，（结果如果&gt;=0,说明缸中有水，可取水） P（count）//拿桶 P（mutexB) //互斥 从缸中取水； V（mutexB）//互斥 V(count) //还桶 V（empty）//缸中还能容纳的水数量加一，（通知小和尚打水） &#125;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>PV操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F%E6%AD%BB%E9%94%81.html</url>
    <content type="text"><![CDATA[一、什么是死锁:是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去. 二、产生死锁的原因: ①: 因为系统资源不足②: 进程运行推进顺序不合适③: 资源分配不当等 三、产生死锁的必要条件:①: 互斥：一个资源每次只能被一个进程使用②: 占有和等待(请求与保持)：一个进程因请求资源而阻塞时，对已获得的资源保持不放。③: 不剥夺: 进程已获得的资源，在使用完之前，不能强行被抢占,它只能被占有它的进程显式地释放。④: 环路等待: 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 注: 只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 四、处理死锁的方法:主要有以下四种方法： 4.1 鸵鸟策略4.1.1 原理: 把头埋在沙子里，假装根本没发生问题, 也就是忽略死锁4.1.2 什么时候用?当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 4.2 死锁检测与死锁恢复4.2.1 原理: 不试图阻止死锁，而是当检测到死锁发生时，再采取措施进行恢复。4.2.2 死锁检测:4.2.2.1 每种类型一个资源的死锁检测:通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 4.2.2.2 每种类型多个资源的死锁检测:每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。①: 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。②: 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。③: 如果没有这样一个进程，算法终止。 4.2.3 死锁恢复:①: 利用抢占恢复②: 利用回滚恢复③: 通过杀死进程恢复 4.3 死锁预防4.3.1 原理:在程序运行之前预防发生死锁 4.3.2 采取方法:破坏死锁的四个必要条件①: 破坏互斥：②: 破坏占有和等待(请求与保持):一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 ③: 破坏不剥夺:④: 破坏环路等待:给资源统一编号，进程只能按编号顺序来请求资源。 4.4 死锁避免在程序运行时避免发生死锁 五、银行家算法:例题:]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之活动]]></title>
    <url>%2FAndroid%E4%B9%8B%E6%B4%BB%E5%8A%A8.html</url>
    <content type="text"><![CDATA[一、活动的基本用法:项目名可以叫做 ActivityTest ,为了手动创建活动 不再勾选 Create Activity 1.1 手动创建活动:src 目录下先添加一个包,使用的默认包名com.example.activitytest新建FirstActivity 类继承自 Activity任何活动都应该重写 Activity 的 onCreate()方法 1.2 创建布局每一个活动对应一个布局，布局就是用来显示界面内容在res/layout 目录下新建 名为first_layout.xml的文件(菜单中点击Android XMLFile),根元素就默认选择为 LinearLayout 添加一个按钮: 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"&gt;... &lt;Button android:id="@+id/button_1" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; XML 中引用一个 id，就使用@id/id_name 这种语法XML 中定义一个 id，则要使用@+id/id_name 这种语法android:layout_width 指定了当前元素的宽度，match_parent表示让当前元素和父元素一样宽。android:layout_height 指定了高度， wrap_content，表示当前元素的高度只要能刚好包含里面的内容就行。android:text 指定了元素中显示的文字内容 1.3 在活动中加载这个布局:FirstActivity类的 onCreate()方法中加入如下代码： 1234567public class FirstActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... setContentView(R.layout.first_layout); &#125;&#125; 项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id，因此我们刚才创建的 first_layout.xml 布局的 id 现在应该是已经添加到 R 文件中了。在代码中引用布局文件: R.layout.first_layout 注意: 这里我们使用的 R，是com.example.activitytest 包下的 R 文件Android SDK 还会自动提供一个 android 包下的 R 文件，千万别使用错了。 1.4 在 AndroidManifest 文件中注册:所有的活动都要在 AndroidManifest.xml 中进行注册才能生效 在AndroidManifest.xml 来给 FirstActivity 注册: 12345678910111213141516171819202122232425262728&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.activitytest" &gt; .... &lt;/application&gt; .... &lt;activity /*.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity 的 缩写由于最外层的&lt;manifest&gt;标签中已经通过 package 属性指定了程序的包名是 com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity */ android:name=".FirstActivity" android:label="This is FirstActivity" &gt; /* 如果你想让 FirstActivity 作为我们这个程序的主活动，即点击桌面应用程序图标时首先打开的就是这 个活动，那就一定要加入下面这两句声明。 */ &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;/*如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他的应用在内部进行调用的，如支付宝快捷支付服务。*/ 活动的注册声明要放在&lt;application&gt;标签内, 通过&lt;activity&gt;标签来对活动进行注册的android:name 来指定具体注册哪一个活动android:label指定活动中标题栏的内容 1.5 隐藏标题栏FirstActivity类的 onCreate()方法中加入如下代码： 123456protected void onCreate(Bundle savedInstanceState) &#123; ... //注意这句代码一定要在 setContentView()之前执行，不然会报错 requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.first_layout);&#125; 1.6 在活动中使用 Toast:toast是什么?界面弹出短小的信息通知给用户，这些信息会在一段时间后自动消失 首先需要定义一个弹出 Toast 的触发点, 如点击按钮的时候弹出一个 Toast FirstActivity类的 onCreate()方法中加入如下代码： 123456789101112131415161718protected void onCreate(Bundle savedInstanceState) &#123; .... // findViewById()方法获取在布局文件中定义的元素，传入 R.id.button_1，来得到按钮的实例 Button button1 = (Button) findViewById(R.id.button_1);//findViewById返回的是一个 View 对象 //注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法 button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; /* makeText()创建出一个 Toast对象, show()是将 Toast 显示出来 第一个参数是 Context，也就是 Toast 要求的上下文，活动本身就是一个 Context 对象 第二个参数是Toast显示的文本内容 第三个参数是Toast显示的时长 */ Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 1.7 在活动中使用 Menu在 res 目录下新建一个 menu 文件夹新建一个 main.xml 文件(点击Android XML File) 12345678&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt; //&lt;item&gt;标签就是用来创建具体的某一个菜单项 &lt;item //给这个菜单项指定一个唯一标识符， android:id="@+id/add_item" //给这个菜单项指定一个名称 android:title="Add"/&gt;&lt;/menu&gt; 然后打开 FirstActivity类，重写 onCreateOptionsMenu()方法 12345678910public boolean onCreateOptionsMenu(Menu menu) &#123; /* inflate()方法就可以给当前活动创建菜单 第一个参数:通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main 第二个参数:用于指定我们的菜单项将添加到哪一个 Menu对象当中，这里直接使用 onCreateOptionsMenu()方法中传 入的 menu参数 */ getMenuInflater().inflate(R.menu.main, menu); //返回 true，表示允许创建的菜单显示出来 return true;&#125; 定义菜单响应事件: FirstActivity 中重写 onOptionsItemSelected() 12345678910111213public boolean onOptionsItemSelected(MenuItem item) &#123; // item.getItemId()来判断我们点击的是哪一个菜单项 switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125; 1.8 销毁一个活动:Activity 类提供了一个 finish()方法: 打开 FirstActivity类,onCreate方法中, 修改按钮监听器中的代码: 1234567button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125;&#125;);//重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一样的。 二、使用 Intent 在活动之间穿梭:2.1 使用显式 Intent:Intent的“意图”非常明显，因此我们称之为显式 Intent 在 ActivityTest 项目中再创建一个活动。新建一个 second_layout.xml 布局文件 12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" &gt; ... //定义了一个按钮，按钮上显示 Button 2 &lt;Button android:id="@+id/button_2" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 2" /&gt;&lt;/LinearLayout&gt; 新建活动 SecondActivity 继承自Activity 12345678public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); &#125;&#125; 最后在 AndroidManifest.xml 中为 SecondActivity 进行注册。 1234567891011121314&lt;application ...&gt; &lt;activity android:name=".FirstActivity" android:label="This is FirstActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; // SecondActivity 不是主活动，因此不需要配置&lt;intent-filter&gt;标签里的内容 &lt;activity android:name=".SecondActivity" &gt; &lt;/activity&gt;&lt;/application&gt; Intent 一般可被用于启动活动、启动服务、以及发送广播等场景Intent 是 各组件之间进行交互的一种重要方式，它可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据 Intent(Context packageContext, Class&lt;?&gt; cls):这个构造函数接收两个参数，第一个参数: 启动活动的上下文，第二个参数 指定想要启动的目标活动 Activity 类中 startActivity()方法，用于启动活动的，它接收一个Intent参数 修改 FirstActivity 中按钮的点击事件: 12345678button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //在FirstActivity活动的基础上打开 SecondActivity活动,startActivity()方法来执行这个Intent Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125;&#125;); 2.2 使用隐式 Intent:不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 action和 category等信息,由系统去分析Intent，并找出合适的活动(响应隐式 Intent的活动)去启动 AndroidManifest.xml添加如下代码: 123456789&lt;activity android:name=".SecondActivity" &gt; &lt;intent-filter&gt; //指明当前活动可以响应 ACTION_START这个 action &lt;action android:name="com.example.activitytest.ACTION_START" /&gt; // 精确地指明当前的活动能够响应的 Intent 中还可能带有的 category &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;//只有&lt;action&gt;和&lt;category&gt;中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。 修改 FirstActivity 中按钮的点击事件，代码如下所示： 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //使用了Intent 的另一个构造函数,传入action的字符串,表明要启动能够响应ACTION_START这个action的活动 Intent intent = new Intent("com.example.activitytest.ACTION_START"); startActivity(intent); &#125;&#125;);//注: &lt;action&gt;和&lt;category&gt;同时匹配上才能响应,而这里没有指定category,这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中 每个 Intent 中只能指定一个 action，但却能指定多个 category 修改 FirstActivity 中按钮的点击事件,增加一个category 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.activitytest.ACTION_START"); // addCategory()方法来添加一个 category intent.addCategory("com.example.activitytest.MY_CATEGORY"); startActivity(intent); &#125;&#125;); 在AndroidManifest.xml中 SecondActivity的&lt;intent-filter&gt;中再添加一个 category 的声明: 123456&lt;activity android:name=".SecondActivity" &gt; &lt;intent-filter&gt; .... &lt;category android:name="com.example.activitytest.MY_CATEGORY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.3 更多隐式 Intent 的用法修改 FirstActivity 中按钮点击事件的代码，如下所示： 1234567891011//应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器来打开这个网页就行了button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // Intent.ACTION_VIEW，这是一个 Android 系统内置的动作 Intent intent = new Intent(Intent.ACTION_VIEW); // Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象 intent.setData(Uri.parse("http://www.baidu.com")); startActivity(intent); &#125;&#125;); 还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地指定当前活动能够响应什么类型的数据。&lt;data&gt;标签中主要可以配置以下内容: android:scheme用于指定数据的协议部分，如上例中的 http 部分 只有&lt;data&gt;标签中指定的内容和 Intent 中携带的 Data完全一致时，当前活动才能够响应该 Intent。如上面浏览器示例中，其实只需要指定 android:scheme 为 http，就可以响应所有的 http 协议的 Intent 了。 2.4 自己建立一个活动，让它也能响应打开网页的Intent新建 third_layout.xml 布局文件: 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;Button android:id="@+id/button_3" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button 3" /&gt;&lt;/LinearLayout&gt; 新建活动 ThirdActivity 类继承自 Activity将布局添加到活动中 12345678public class ThirdActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.third_layout); &#125;&#125; 最后在 AndroidManifest.xml 中为 ThirdActivity 进行注册 12345678&lt;activity android:name=".ThirdActivity" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; //数据的协议必须是 http协议 &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 调用系统拨号界面 除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示拨打电话 123456789button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_DIAL); // data部分指定了协议是 tel，号码是 10086 intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;&#125;); 2.5 向下一个活动传递数据: Intent 还可以在启动活动的时候传递数据, putExtra()的重载，可把想要传递的数据暂存在 Intent 中，启动另一个活动后，只需把这些数据从Intent 中取出就可 SecondActivity 类中,修改代码: 1234567891011// FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity中button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String data = "Hello SecondActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //第一个参数是键,用于后面从 Intent中取值，第二个参数才是真正要传递的数据。 intent.putExtra("extra_data", data); startActivity(intent); &#125;&#125;); 123456789101112public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; .... // getIntent()方法获取到用于启动 SecondActivity 的 Intent Intent intent = getIntent(); //如果传递的是布尔型数据，则使用 getBooleanExtra()方法 //getStringExtra()方法，传入相应的键值，就可以得到传递的数据了 String data = intent.getStringExtra("extra_data"); Log.d("SecondActivity", data); &#125;&#125; 2.6 返回数据给上一个活动:Activity 中 startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 修改 FirstActivity 中按钮的点击事件 12345678button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //第一个参数还是 Intent,第二个参数是请求码，用于在之后的回调中判断数据的来源,请求码只要是一个唯一值就可以了 startActivityForResult(intent, 1); &#125;&#125;); SecondActivity 中给按钮注册点击事件并在点击事件中添加返回数据的逻辑: 123456789101112131415161718192021public class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.second_layout); Button button2 = (Button) findViewById(R.id.button_2); button2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); //setResult()专门用于向上一个活动返回数据的 //第一个参数用于向上一个活动返回处理结果,第二个参数则是把带有数据的 Intent 传递回去 setResult(RESULT_OK, intent); //销毁当前活动 finish(); &#125; &#125;); &#125;&#125; 由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据， 123456789101112131415//第一个参数 requestCode，启动活动时传入的请求码,//第二个参数 resultCode，返回数据时传入的处理结果//第三个参数 data，即携带着返回数据的 Intent@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode == RESULT_OK) &#123; String returnedData = data.getStringExtra("data_return"); Log.d("FirstActivity", returnedData); &#125; break; default: &#125;&#125; 由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到 onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作 如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下Back 键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通过重写 onBackPressed()方法来解决这个问题，代码如下所示： SecondActivity 类中修改代码: 12345678//这样的话，当用户按下 Back 键，就会去执行 onBackPressed()方法中的代码，我们在这里添加返回数据的逻辑就行了@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra("data_return", "Hello FirstActivity"); setResult(RESULT_OK, intent); finish();&#125; 2.7 活动的生命周期:返回栈Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack） 活动状态每个活动在其生命周期中最多可能会有四种状态。运行状态:位于返回栈的栈顶时暂停状态:不再处于栈顶位置，但仍然可见停止状态:不再处于栈顶位置，并且完全不可见销毁状态:从返回栈中移除后就变成了销毁状态 活动的生存期Activity 类中定义了七个回调方法: onCreate():每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。 onStart():在活动由不可见变为可见的时候调用 onResume():在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。 onPause():准备去启动或者恢复另一个活动的时候调用 onStop():在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。 onDestroy():活动被销毁之前调用 onRestart():活动由停止状态变为运行状态之前调用 2.6 活动被回收了怎么办Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。 onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，第二个参数是真正要保存的内容。在 MainActivity 中添加如下代码就可以将临时数据进行保存： 123456@Overrideprotected void onSaveInstanceState(Bundle outState) &#123;super.onSaveInstanceState(outState);String tempData = "Something you just typed";outState.putString("data_key", tempData);&#125; 数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一直使用的 onCreate()方法其实也有一个 Bundle类型的参数。这个参数在一般情况下都是null，但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。修改 MainActivity 的 onCreate()方法，如下所示： 123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... if (savedInstanceState != null) &#123; String tempData = savedInstanceState.getString("data_key"); Log.d(TAG, tempData); &#125; ……&#125; 2.7 活动的启动模式启动模式一共有四种，分别是 standard、singleTop、singleTask 和 singleInstance​ AndroidManifest.xml 中通 过给&lt;activity&gt; 标签 指定android:launchMode属性来选择启动模式 standard 活动默认的启动模式,系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。 singleTop 在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。 修改 AndroidManifest.xml 中 FirstActivity 的启动模式，如下所示： 123456&lt;activity android:name=".FirstActivity" android:launchMode="singleTop" ... ...&lt;/activity&gt; singleTask 很好地解决重复创建栈顶活动的问题 singleInstance 在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android之活动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是适配器模式?适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 二、 分类:2.1 类的适配器模式:使用步骤:步骤1： 创建Target接口步骤2： 创建源类（Adaptee）步骤3： 创建适配器类Adapter (适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。)步骤4： 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 2.2 对象的适配器模式:原理:与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。步骤:①: 创建Target接口②: 创建源类（Adaptee）③: 创建适配器类（Adapter）（不适用继承而是委派）④: 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 2.3 对象的适配器模式与类的适配器模式比较:与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 2.4 什么时候用类的适配器模式? ①: 仅仅希望使用方便时对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。对于对象适配器，需要额外的引用来间接得到Adaptee。②: 需要重新定义Adaptee的部分行为对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 2.5 什么时候用对象的适配器模式?①: 灵活使用时类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。②: 需要同时配源类和其子类对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了； 2.6 总结:建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。 三、主要作用:把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。 三、优点:①: 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。②: 解耦性: 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码③: 符合开放-关闭原则: 同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类④: 更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。⑤: 透明、简单: 客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接, 过多的使用适配器，会让系统非常零乱，不易整体进行把握 四、应用场景:系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 五、实例:背景：小成买了一个进口的电视机冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容解决方案：设置一个适配器将插头输出的220V转变成110V 使用类的适配器模式解题: 12345//步骤1： 创建Target接口；public interface Target &#123; //将220V转换输出110V（原有插头（Adaptee）没有的） void Convert_110V();&#125; 123456//步骤2： 创建源类（Adaptee）public class PowerPort220V &#123; //原有的插口只能输出220V void OutPut_220V()&#123; &#125;&#125; 12345678910111213//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter220V extends PowerPort220V implements Target &#123; //期待的插头要求调用Convert_110v()，但原有插头没有 //因此适配器补充上这个方法名 //但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容 //所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已 @Override public void Convert_110V() &#123; this.OutPut_220V(); &#125;&#125; 1234567891011121314151617181920//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标//通过Adapter类从而调用所需要的方法public class AdapterPattern &#123; public static void main(String[] args) &#123; //用户拿着进口机器插上适配器（调用Convert_110v()方法） //再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V） //适配器只是个外壳，对外提供110V，但本质还是220V进行供电 Target target = new Adapter220V(); target.Convert_110V(); ImportMachine importMachine = new ImportMachine(); importMachine.work(); &#125;&#125;//进口机器类class ImportMachine &#123; void work()&#123; System.out.println("进口机器正常工作!"); &#125;&#125; 类的适配器模式: 12345//步骤1： 创建Target接口；public interface Target &#123; //源类Adapteree没有的方法 void Request();&#125; 12345//步骤2： 创建源类（Adaptee） ；public class Adapteree &#123; public void specificRequest() &#123; &#125;&#125; 12345678910111213//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）//适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。public class Adapter extends Adapteree implements Target &#123; //目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request() //因此适配器补充上这个方法名 //但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容 //所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已 @Override public void Request() &#123; this.specificRequest(); &#125;&#125; 12345678//Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标public class AdapterPattern &#123; public static void main(String[] args) &#123; Target adapter = new Adapter(); adapter.Request(); &#125;&#125; 对象的适配器模式: 1234public interface Target &#123; //这是源类Adapteee没有的方法 void request();&#125; 1234public class Adapteree &#123; void specificRequest()&#123; &#125;&#125; 123456789101112131415public class Adapter implements Target&#123; private Adapteree adapteree; //直接关联被适配类Adapteree // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter(Adapteree adapteree)&#123; this.adapteree = adapteree; &#125; @Override public void request() &#123; //这里是使用委托的方式完成特殊功能 this.adapteree.specificRequest(); &#125;&#125; 123456public class AdapterPattern &#123; public static void main(String[] args) &#123; Target target = new Adapter(new Adapteree()); target.request(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层]]></title>
    <url>%2F%E5%BA%94%E7%94%A8%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、应用层协议:应用层的许多协议是基于客户服务器方式的 1.1 DNS:1.1.1 是什么? DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 1.1.2 作用:用于域名解析服务,将域名(机器名) 转换为 IP地址1.1.3 原理: 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。1.1.4 特点:基于UDP服务，该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。端口号53DNS 可以使用 UDP 或者 TCP 进行传输，大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性1.1.5 在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 1.2 : HTTP:1.2.1 是什么? 这是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页1.2.2 特点: 本身是无连接，无状态的,使用TCP连接进行可靠的传送 1.3 : FTP:1.3.1 是什么? 文件传输协议1.3.2 特点: 提供交互式的访问 ,基于客户服务器模式，面向连接 ,使用TCP可靠的运输服务 ,使用21端口1.3.3 主要功能:减少/消除不同操作系统下文件的不兼容性 1.3.4 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。端口号20 1.3.5 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 1.4 : 简单文件传送协议TFTP:1.4.1 特点: 客户服务器模式 ,使用UDP数据报 ,只支持文件传输，不支持交互 ,TFTP代码占内存小 1.5 : TELNET:1.5.1 作用:用于远程登陆1.5.2 特点:客户服务器模式 使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务,TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 1.6 : 简单网络管理协议（SNMP）:1.6.1 SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议1.6.2 SNMP代理：运行SNMP管理进程的被管理结点对象：描述设备的变量管理信息库（MIB）：保存所有对象的数据结构 1.7 : DHCP:1.7.1 什么是DHCP? 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。1.7.2 DHCP 工作过程如下： ①: 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。②: DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。③: 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。④: DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 1.8 :电子邮件协议:一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1.8.1 : SMTP:1.8.1.1 是什么? 简单邮件传输协议1.8.1.2 作用: 用于发送邮件。1.8.1.3 特点: Client/Server模式，面向连接 ,服务器开放的是25号端口。SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。1.8.1.4 基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件 1.8.2 : POP3:1.8.2.1 是什么? 它是和SMTP对应1.8.2.2 作用: 用于接收邮件1.8.2.3 特点: ①: 只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。②：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”。POP3协议所用的是110端口。 1.8.3 : IMAP:1.8.3.1 作用: 读取邮件1.8.3.2 特点: IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信。 二、关于域名:2.1 域名规范:DNS规定:①: 域名中标号必须是英文或数字②: 不区分大小写③: 除连字符外不能用其他标点④: 级别最低的域名写在最左边⑤: 域名总长度不超过255个字符. 2.2 域名分类:顶级域名(TLD: TOP Level Domain):①: 国家顶级域名: cn代表中国 ,US代表美国②:通用顶级域名: com(公司,企业) net(网络服务机构) edu(教育机构) mail.cctv.com: 其中com为一级域名(即顶级域名), cctv是二级域名,mail是三级域名.域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 2.3 域名管理:①: 在国家顶级域名下注册的二级域名均由该国家自由确定.②: 各级域名由其上一级域名管理机构管理③: 最高的顶级域名由ICANN管理注: 域名中的点与点分十进制IP地址中的点无一一对应的关系 2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?原因: IP地址长度固定(32位)而域名长度不固定,机器处理起来困难. 三、关于域名服务器:一个域名服务器所负责管理的范围叫做区,每个区 设置相应的权限域名服务器为了减轻根域名服务器的压力,域名服务器中广泛使用高速缓存. 3.1 域名服务器分类:①: 根域名服务器: 所有根域名服务器都知道所有顶级域名服务器的域名和IP地址②: 顶级域名服务器: 管理在该顶级域名服务器下注册的所有二级域名,当收到查询请求,就给出查询结果,或者下一步应当找的域名服务器地址③: 权限域名服务器: 负责一个区的域名服务器,当它不能给出最后的查询结果时,就告诉客户下一步应当查找哪个权限域名服务器④: 本地域名服务器: 离用户较近,一般不超过几个路由器的距离 迭代查询: 递归查询: 四、常用端口: 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP HTTPS 443 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP 五、Web 页面请求过程:5.1 DHCP 配置主机信息:假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。①: 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。②: 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。③: 该数据报则被放置在MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。④: 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。⑤: 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。⑥: 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 5.2 ARP 解析 MAC 地址①: 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。②: 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。③: 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中④: 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。⑤: DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。⑥: 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。⑦: 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 5.3 DNS 解析域名:①: 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。②: 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。③: 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。④: 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。⑤: 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 5.4 HTTP 请求页面:①: 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。②: 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。③: HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。④: 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。⑤: HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。⑥: 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 六、应用层功能:负责对软件提供接口以使程序能使用网络服务]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层]]></title>
    <url>%2F%E4%BC%A0%E8%BE%93%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、传输层协议:TCP协议,UDP协议,SPX协议 10.1 关于TCP协议:特点:①: 面向连接②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点 使用场合: 一般用于传输数据量少,且对可靠性要求高的场合. 注: 这2个端点并不是主机,也不是主机的IP地址,不是应用进程,也不是运输层协议端口, 而是指 套接字 ③: 提供可靠交付服务: 无差错 , 不丢失 , 不重复 , 按序到达④: 全双工⑤: 拥塞控制,流量控制⑥: 检错, 分用复用⑦: 面向字节流: (把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)套接字socket = IP地址 ：端口号 10.2 使用TCP协议的各种应用层协议：SMTP: 简单邮件传送协议TELNET: 远程终端协议HTTP: 超文本传输协议FTP: 文件传送协议 10.3 TCP首部格式: 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 10.4 关于UDP协议:特点: ①: 无连接: 发数据前不需要建立连接(即不需要使用套接字(即 IP: 端口号)来建立连接)②: 交互通信: 一对多,一对一,多对一,多对多等③: 尽最大努力交付(不可靠)④: 首部开销小,8字节 而TCP是20字节⑤: 无拥塞控制⑥: 检错, 分用复用⑦: 面向报文: UDP一次交付一个完整报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部) 10.5 UDP首部格式: 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 使用场合: 一般用于传输数据量大,且对可靠性要求不是很高,但要求速度快的场合. 二、传输层数据单元:数据段 三、关于端口:运输层用16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口 四、传输层功能:①: 负责源-目的（端-端）（进程间）完整报文传输②: 分段与重组③: SAP寻址: 确保将完整报文提交给正确进程，如端口号④: 连接控制⑤: 流量控制⑥: 差错控制⑦: 确保数据可靠,顺序,无错地从A点传输到B点 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 五、TCP 可靠传输:TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。 六、TCP 滑动窗口:窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 七、TCP 流量控制:流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 八、TCP 拥塞控制:如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。拥塞窗口的大小取决于网络的拥塞程度判断网络拥塞的依据是出现了超时.发送方的发送窗口 = 拥塞窗口. TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 8.1 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 8.2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 拥塞控制的具体流程: ①: 初始拥塞窗口 cwnd = 1 ②: 发送方每收到一个确认就使cwnd = cwnd + 1;如果按照传输轮次考虑就是指数增长: 第一轮: cwnd = 1, 第二轮: cwnd = 2, 第三轮: cwnd = 4, …….第N轮: cwnd = 2^N cwnd &lt; ssthresh 时,使用慢开始 cwnd = ssthresh 时,既可以使用慢开始,也可以使用拥塞避免算法 cwnd &gt;= ssthresh 时,使用拥塞避免算法 ③: 网络超时时: 使ssthresh = cwnd / 2然后令 cwnd = 1 然后进入慢开始阶段,步骤同上④: 直到连续接收到三个重复确认,启动快重传(立即重传) ⑤: 启动快恢复算法 ssthresh = cwnd / 2 和cwnd=ssthresh 拥塞避免: 拥塞窗口控制为按照线性增长(每个传输轮次结束时,cwnd就增加1) 快重传优点: 可以使整个网络的吞吐量提高20%尽早让发送方知道发生了个别报文段的丢失 规定: 发送方只要一连收到3个重复确认,就知道接收方确实未收到某个报文,应当立即重传(即快重传),这样就不会出现超时,发送方也就不会误认为出现了网络拥塞. 快恢复: 调整ssthresh = cwnd / 2同时设置cwnd = ssthresh;然后执行拥塞避免.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换机的基本配置]]></title>
    <url>%2F%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[一、交换机的基本配置与管理：10.1 交换机的管理方式：基本分为两种: 带内管理和带外管理。带外管理: 通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置带内管理: 通过远程Telnet，拨号等方式属于带内管理 二、交换机的命令行操作模式分类：①: 用户模式: Switch&gt;②: 特权模式: Switch#③: 全局配置模式: Switch(config)#④: 端口模式: Switch(config-if)# 三、交换机命令行:进入特权模式: en命令自动补齐: Tab进入全局配置模式: configure terminal命令简写：conf t进入交换机端口视图模式: int f 0/1返回上一级操作模式: exit从全局以下级别直接返回到特权模式: end帮助信息: ？，co? ,copy ?修改交换机名称: hostname X配置交换机端口参数: speed，duplex查看交换机版本信息: show version查看当前生效的配置信息: show run 四、换机的Telnet远程登录配置: 新建packet tracer 拓扑图 配置交换机管理IP地址 switch&gt; enable 回车 switch#configuration terminal 回车 switch（config）#interface vlan 1 回车 默认情况下交换机所有端口都处于VLAN1中 switch(config-if) ip address xxxx.xxxx.xxxx.xxxx 回车 switch(config-if) no shutdown 回车 开启interface vlan 1的工作状态 switch(config-if)# exit 返回上一级 配置用户登录密码 Switch(config)# enable password xxxx 设置进入特权模式的密码 Switch(config)# line vty 0 4 Switch(config-line)# password xxxxxxx 设置远程登录密码 Switch(config-line)# end Switch# show run]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>交换机的配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、网络层协议:1.1 什么是协议（protocol）?通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”. 1.2 什么是实体（entity）?表示任何可发送或接收消息的硬件或软件进程 1.3 通信协议的三要素：语法,语义,时序语义 :语义是指对协议中各协议元素的含义的解释，例如：在HDLC协议中，标志Flag(7EH)表示报文的开始和结束；在BSC协议中，SOH(01H)表示报文的开始，STX(02H)表示报文正文的开始，ETX(03H)表示报文正文的结束。语法 :语法是指协议元素与数据的组合格式，也就是 报文格式，如下图所示：时序 :时序是指在通信过程中，通信双方操作的执行顺序与规则，如本节开头的图示。总的来说，语法是语义的载体，而时序又是对语义的有序组织。正是基于这种关系，计算机在通信时才得以保持高度默契。 1.4 通信模型: 我们在网络中的任何一个系统都是按照上图中的层次结构模型来组织的，该模型具有以下特点：①: 同一网络中，任意两个端系统必须具有相同的层次；②: 每层使用其下层提供的服务，并向其上层提供服务；③: 通信只在对等层间进行，当然这里所指的通信是间接的、逻辑的、虚拟的，非对等层之间不能互相“通信”；④: 实际的物理通信只在最底层完成；⑤: Pn代表第n层的协议，即第n层对等实体间通信时必须遵循的规则或约定。 1.5 网络层有哪些协议?①: IP协议: 这种不可靠的、无连接的传送机制称为Internet协议(网际协议)与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protcol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP协议三个定义： IP定义了在TCP/IP互联网上数据传送的基本单元和数据格式。IP软件完成路由选择功能，选择数据传送的路径。IP包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。 ②: ICMP协议: 网际控制报文协议作用：用于在IP主机、路由器之间传递控制消息,更有效的转发IP数据报和提高交付成功的机会,应用: ICMP的一个重要应用就是分组网间探测PING（Package Internet Grouper）用来测试两台主机的连通性,,Ping是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP详解见下文 ③: IGMP:网际组管理协议 ④: ARP协议:地址解析协议自动把IP地址解析为数据链路层所需要的硬件地址(MAC地址)IP —–&gt;MAC 地址工作原理: 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据,如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 ⑤: RARP协议:逆地址解析协议, 与ARP相反:MAC地址——&gt;IP地址作用: 是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP 地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 ⑥: RIP协议:内部网关协议基于距离向量的路由选择协议, 距离是指跳数，直接相连的路由器跳数为 1,跳数最多为 15(即允许一条路径最多包含15个路由器)，超过 15 表示不可达。可见RIP只适用于小型互联网 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 优点:实现简单，开销小。缺点:①: RIP 能使用的最大距离为 15，限制了网络的规模。②: 并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。③: 路由器间交换的信息是完整的路由表,随着网络规模的增大,开销也增大. ⑦: OSPF协议: 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示, 而RIP只包含距离,和下一跳路由器地址. 只有当链路状态发生变化时，路由器才会发送信息, 而 RIP不管有无变化,总是定期更新. 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 ⑧: BGP：外部网关协议: BGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息 1.6 网络层特点:向上只提供 :①: 无连接的②: 尽最大努力交付③: 不提供服务质量的保证(不保证分组交付的时限,所传送的分组有可能出错丢失,重复失序)⑤: 进程间通信可靠性由传输层负责 二、网络层设备:①: 路由器 三、网络层基本单元:3.1 什么是协议数据单元?协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。 3.2 每一层协议数据单元分别是什么?从下层到上层:物理层的 PDU是数据位,又称比特（bit），数据链路层的 PDU是数据帧,又称帧（frame），网络层的PDU是数据包又称IP数据报（packet/datagram），传输层的 PDU是数据段（segment），在报文中加一个运输层的头其他更高层次(即会话层,表现层,应用层)的PDU是报文（message）。 从下层往上层是拆封. 四、网络层功能:①: 负责源主机到目的主机数据分组（Packet）交付(可能穿越多个网络)逻辑寻址（Logical addressing ）②: 全局唯一的逻辑地址，确保数据分组被送到目的主机，如IP地址③: 路由（Routing）:路由器（或网关）互连网络，并路由分组至最终目的主机路径选择④: 分组转发⑤: 网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 ⑥: 将网络地址(例如IP地址)翻译为对应的物理地址(例如,网卡地址),并决定如何将数据从发送方路由到接收方 4.1 核心功能:分组转发 与 路由选择（forwarding) 4.1 什么是转发?将分组从路由器的输入端口转移到合适的输出端口转发表确定在本路由器如何转发分组 4.2 转发表是怎么得到的呢？路由算法（协议）确定通过网络的端到端路径 4.3 什么叫路由呢？路由（routing）：确定分组从源到目的经过的路径 五、网络层任务: 六、为什么需要数据封装?增加控制信息—构造协议数据单元（PDU—protocol Data Unit）控制信息主要包括：地址：标志发送端/接收端差错检测编码（error-detecting code）：用于差错检测或纠正协议控制（Protocol control）：实现协议功能的附加信息，如优先级（priority），服务质量（QoS）和安全控制等 七、IP 数据报格式: 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 八、地址解析协议 ARP:ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 九、网际控制报文协议 ICMP:ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 9.1 ICMP协议的应用:PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理: 是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute:用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。Traceroute的工作原理: 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 十、IP 地址编址方式:10.1 IP 地址的编址方式经历了三个历史阶段：①: 分类②: 子网划分③: 无分类 分类: 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 网络号:用于识别主机所在的网络；主机号: 用于识别该网络中的主机IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} IP地址分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。 IP地址类别: 高八位 占总IP地址数的比例: A类：前一位固定为0 第一个八位的范围是0-127目的: 保证了最小为0,最大为127 即255(全一)-128(最高位为1,其他为0)=127 (127-0+1）/ 256=50% B类：前两位固定为10 第一个八位的范围是：128-191前两位固定为10的目的是：为了让前八位表示的数最小为128 (191-128+1) / 256=25% C类：前三位固定为110 第一个八位的范围是：192-223前两位固定为110的目的是：保证最小192 (223-192+1) / 256=12.5% D类：前四位固定为1110 不分网络地址和主机地址 第一个八位的范围是：224-239 (239-224+1) / 256=6.25% E类：前四位固定为1111 不区分网络地址和主机地址 第一个八位的范围是：240-255 (255-240+1) / 256=6.25% A类地址:1）A类地址第1字节为网络地址，其它3个字节为主机地址。它的第1个字节的第一位固定为0，因此只有7位可供使用.可指派的网络号为126个（即2^7-2=126），减2 的原因：第一： IP地址中的全0表示“这个（或者本）”，全1表示所有的。 网络号字段全0 的IP地址是个保留地址， 意思是本网络第二： 网络号为127（即01111111）保留作为本地软件环回测试（loop back test）本主机的进程之间的通信之用。2）A类地址可指派网络号范围：1—1263）A类地址中的私有地址和保留地址：① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址),且范围是（10.0.0.0—10.255.255.255）② 127.X.X.X是保留地址，用做循环测试用的。A类地址主机号占三个字节，因此每个A类网络中最大主机数： 2^24-2=16777214这里减2 的原因： 全0的主机号字段， 表示该IP地址 是”本主机“所连结到的单个网络地址，（例如： 一主机的IP地址为5.6.7.8 ，则该主机所在的网络地址就是5.0.0.0）， 而全1表示”所有的“ ，因此主机号全1表示该网络上的所有主机，4）IP地址空间共2^32 个地址，整个A类地址2^31,占整个IP地址空间的50%. 关于全0全1 还可以再举两个例子：例如： B类地址： 128.7.255.255 表示在网络128.7.0.0 上的所有主机， 而A类地址0.0.0.35 则表示 在这个网络上主机号为35 的主机； B类地址: B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。它的第1个字节的前两位固定为10，只剩下16-2=14位可以分配， 因为网络号字段后面的14位无论取什么值， 也不可能出现使整个2字节的网络号字段成为全0或全1， 所以这里就不存在网络总数减2的问题。 但是实际上B类网络地址的128.0.0.0 是不指派的，而可以指派的B类最小网络地址是128.1.0.0 ， 因此B类地址可指派的网络数为 2^14-1=16383. B 类地址的每个网络上的最大主机数2^16-2=65534这里减2 的原因： 要扣除主机号全0全1的。 （全0表示该IP地址 是”本主机“所连结到的单个网络地址，全1 作为广播地址）整个B类地址空间2^30, 占整个IP地址空间的25%. 2） B类地址可指派网络号范围：128.1—191.255。 3） B类地址的私有地址和保留地址 ① 172.16.0.0—172.31.255.255是私有地址 ② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。 191.255.255.255是广播地址，不能分配。 C类地址 1）C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110, 还有21位可以分配，C类网络地址192.0.0.0也是不分配的， 可以指派的C类最小网络地址192.0.1.0，因此C类 地址可指派的网络总数 ， 2^21-1=2097151 , 每一个C类网络地址的最大主机数2^8-2=254, 整个C类地址空间2^29 个地址，占整个IP地址空间的12.5%。 2）C类地址网络号范围：192.0.1—223.255.255。 3） C类地址中的私有地址： 192.168.X.X是私有地址。（192.168.0.0—192.168.255.255) 10.2 特殊IP地址： 10.3 私有（Private）IP地址:实体IP:在网络的世界里，为了要辨识每一部计算机的位置，因此有了计算机 IP 位址的定义。一个 IP 就好似一个门牌！例如，你要去微软的网站的话，就要去『 64.4.11.42 』这个 IP 位置！这些可以直接在网际网络上沟通的 IP 就被称为『实体 IP 』了。 虚拟IP:不过，众所皆知的，IP 位址仅为 xxx.xxx.xxx.xxx 的资料型态，其中， xxx 为 1-255 间的整数，由于计算机的成长速度太快，实体的 IP 已经有点不足了，好在早在规划 IP 时就已经预留了三个网段的 IP 做为内部网域的虚拟 IP 之用。这三个预留的 IP 分别为：除去主机段全零/全一: 由于是虚拟 IP ，所以当您使用这些地址的时候﹐当然是有所限制的，限制如下：私有位址的路由信息不能对外散播使用私有位址作为来源或目的地址的封包﹐不能透过Internet来转送关于私有位址的参考纪录（如DNS）﹐只能限于内部网络使用 由于虚拟 IP 的计算机并不能直接连上 Internet ，因此需要特别的功能才能上网。不过，这给我们架设IP网络提供了很大的方便﹐比如﹕您的公司还没有连上Internet﹐但这不保证将来不会。使用公共IP的话﹐如果没经过注册﹐在以后真正连上网络的时候﹐就很可能和别人冲突了。也正如前面所分析的﹐到时候再重新规划IP的话﹐将是件非常头痛的问题。这时候﹐我们可以先利用私有位址来架设网络﹐等到真要连上internet的时候﹐我们可以使用IP转换协定﹐如 NAT (Network Addresss Translation)等技术﹐配合新注册的IP就可以了。 10.4 组播地址注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机， 224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP（Internet路由发现协议，使用组播功能）功能，那么你的主机路由表中应该有这样一条路由: 169.254.x.x 如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Windows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。 10.5 受限广播地址广播通信是一个主机对所有主机的通信方式。若一个IP地址的2进制数全为1，也就是255.255.255.255，则这个地址用于定义整个互联网。如果设备想使IP数据报被整个Internet所接收，就发送这个目的地址全为1的广播包，但这样会给整个互联网带来灾难性的负担。因此网络上的所有路由器都阻止具有这种类型的分组被转发出去，使这样的广播仅限于本地网段。 10.6 直接广播地址一个网络中的最后一个地址为直接广播地址，也就是HostID全为1的地址。主机使用这种地址把一个IP数据报发送到本地网段的所有设备上，路由器会转发这种数据报到特定网络上的所有主机。注意：这个地址在IP数据报中只能作为目的地址。另外，直接广播地址使一个网段中可分配给设备的地址数减少了1个。 10.7 源IP地址:若IP地址全为0，也就是0.0.0.0，则这个IP地址在IP数据报中只能用作源IP地址，这发生在当设备启动时但又不知道自己的IP地址情况下。在使用DHCP分配IP地址的网络环境中，这样的地址是很常见的。用户主机为了获得一个可用的IP地址，就给DHCP服务器发送IP分组，并用这样的地址作为源地址，目的地址为255.255.255.255（因为主机这时还不知道DHCP服务器的IP地址）。 10.8 环回地址:127网段的所有地址都称为环回地址，主要用来测试网络协议是否工作正常的作用。比如使用ping.127.0.0.1就可以测试本地TCP/IP协议是否已正确安装。另外一个用途是当客户进程用环回地址发送报文给位于同一台机器上的服务器进程，比如在浏览器里输入127.1.2.3，这样可以在排除网络路由的情况下用来测试IIS是否正常启动。 10.9 NetID为0的地址:当某个主机向同一网段上的其他主机发送报文时就可以使用这样的地址，分组也不会被路由器转发。比如12.12.12.0/24这个网络中的一台主机12.12.12.2/24在与同一网络中的另一台主机12.12.12.8/24通信时，目的地址可以是0.0.0.8。 10.10: 关于子网掩码:为了标识IP地址的网络部分和主机部分，要和地址掩码（Address Mask）结合，掩码跟IP地址一样也是32 bits，用点分十进制表示。IP地址网络部分对应的掩码部分全为“1”，主机部分对应的掩码全为“0”。 缺省状态下，如果没有进行子网划分，A类网络的子网掩码为255.0.0.0，B类网络的子网掩码为255.255.0.0，C类网络的子网掩码为255.255.255.0。利用子网，网络地址的使用会更加有效。 有了子网掩码后，IP地址的标识方法如下：例：192.168.1.1 255.255.255.0或者标识成192.168.1.1/24（掩码中“1”的个数） 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 无分类 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 十一、虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 共有2的24次方个地址 172.16.0.0 ~ 172.31.255.255 共有2的20次方个地址 192.168.0.0 ~ 192.168.255.255 共有2的16次方个地址 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 十二、网络地址转换 NAT:专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 十三、路由器的结构:13.1 路由器的功能：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 13.2 路由器分组转发流程: 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 13.3 路由选择协议:路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、关于进程:1.1 什么是进程?进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。有挂起状态 1.2 进程的组成部分: 进程由四个部分组成: ①: 程序块②: 数据块: 程序和数据刻画的是静态特征③: 进程控制块 (Process Control Block, PCB) : 每个进程只有一个进程控制块Process Control Block (进程描述符), 包含管理进程所需的全部信息.④: 核心栈: 进程运行过程中产生中断或者执行系统调用时又要运行操作系统内核函数 , 核心栈就是存放内核函数在工作时产生的信息 PCB包含三类信息: ①: 标识信息: 数值型进程号0~32767 是进程存在的唯一标识②: 现场信息: 包括通用寄存器, 控制寄存器, 栈指针, 程序状态字 进程让出处理器时,必须将此时的现场信息保存到PCB③: 控制信息: 用于管理和调度进程 1.3 进程状态的切换:进程的三种基本状态: 运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着 阻塞状态：等待资源; 由于进程等待某种条件（如等待I/O操作的完成，或等待另一个进程发来消息(即进程同步)），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行 就绪状态：等待被调度 ; 进程已获得除CPU外的所需资源，由于其他进程占用CPU而暂时无法运行的一种状态 注意: ①: 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的CPU 时间片用完之后就会转为就绪状态，等待下一次调度。②: 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 1.4 进程的特点:动态性: 程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。共享性: 多个不同的进程,可以执行相同的程序, 进程和程序不是一 一对应的异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进独立性: 每个进程是操作系统中的一个独立的实体, 有独立的虚存空间,程序计数器,内部状态并发性: 在单处理器系统中可并发执行, 多处理器环境中并行执行. 1.5 进程的挂起:目的: 平滑系统负荷什么时候挂起? 当系统资源尤其是内存资源已经不能满足进程运行的要求时,必须把某些进程挂起.特点: 将不参与低级调度, 直到它们被对换到内存, 该进程不能立即执行如何结束挂起状态? 只能由操作系统或者父进程发出 1.6 进程挂起和激活:挂 起 原 语 既 可 以 由 进 程 自 己 也 可 以 由 其 他 进 程 调 用, 激 活 原 语 只 能 由 其 他 进 程 调 用 1.7 进程阻塞和唤醒:阻塞: 进程让出处理器,转而等待一个事件,如等待资源,等待IO操作完成, 等待事件发生.进程通常调用阻塞原语来阻塞自己, 因此阻塞是自主行为唤醒: 等待事件完成时会产生中断,激活操作系统,在操作系统控制下,与其相关的另一个进程调用唤醒原语将阻塞进程唤醒. 二、关于线程:1.1 什么是线程?是进程中能并发执行的实体, 是进程的组成部分,有时被称为轻量级进程(Lightweight Process，LWP）, 是处理器调度和分派的基本单位, 是一条执行路径,有独立的程序计数器 无挂起状态 1.2 线程的重要特征:①: 一个进程中可以有多个线程，它们共享进程资源。②: 线程是轻量级的进程③: 线程是由进程创建的(寄生在进程)④: 线程没有独立的地址空间(内存空间)⑤: 线程是系统独立调度和分配的基本单位⑥: 可并发执行⑦: 线程是一种轻型实体线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息： 线程状态 存放每个线程的局部变量主存区 访问同一个进程中的主存和其它资源 当线程不运行时，被保存的现场资源 1.3 创建线程的不同方式:有4种方式可以用来创建线程：①继承Thread类②实现Runnable接口③应用程序可以使用Executor框架来创建线程池实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。④还有一种方式是实现Callable接口 1.4 进程状态的切换: 新建( new )：新创建了一个线程对象。 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。 阻塞的情况分三种： (一). 等待阻塞： 运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。 (二). 同步阻塞： 运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。 (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 1.4 优点:快速切换 : 同一个进程中的多线程只需要改变堆栈和寄存器, 地址空间不变通信容易: 不必经过内核, 可自由访问全局数据,自动共享进程的内存和文件减少管理开销: 线程的创建和撤销工作比进程少很多,并且无需再分配存储空间,和各种资源并发程度提高: 三、进程与线程的区别:3.1 就资源而言:进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 3.2 就调度而言:线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 3.3 就系统开销而言:由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 3.4 就通信而言:线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。但是进程通信需要借助 IPC。 3.5 就组成而言:进程可分为两部分: 资源集合 和 线程集合进程封装管理信息,线程封装执行信息 四、进程的调度算法:不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 4.1 批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 ①: 先来先服务 first-come first-serverd（FCFS）按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 ②: 短作业优先 shortest job first（SJF）按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 ③: 最短剩余时间优先 shortest remaining time next（SRTN）按估计剩余时间最短的顺序进行调度。 4.2 交互式系统:交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。④: 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 ⑤: 优先级调度 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 ⑥: 多级反馈队列 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 4.3 实时系统实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 五、进程同步:临界区:对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步与互斥:同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量:信号量（Semaphore）是一个整型变量，可以对其执行 P 和 V 操作。 P: 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； V ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P 操作。 P, V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; P(&amp;mutex); // 临界区 V(&amp;mutex);&#125;void P2() &#123; P(&amp;mutex); // 临界区 V(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE) &#123; int item = produce_item(); P(&amp;empty); P(&amp;mutex); insert_item(item); V(&amp;mutex); V(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE) &#123; P(&amp;full); P(&amp;mutex); int item = remove_item(); consume_item(item); V(&amp;mutex); V(&amp;empty); &#125;&#125; 六、关于管程:使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。c 语言不支持管程 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 七、进程的通信:进程同步与进程通信很容易混淆，它们的区别在于：进程同步：控制多个进程按一定顺序执行；进程通信：进程间传输信息 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 八、关于管道:管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 九、同步方法和同步代码块的区别是什么？①: 同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；②: 同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰；]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理层]]></title>
    <url>%2F%E7%89%A9%E7%90%86%E5%B1%82.html</url>
    <content type="text"><![CDATA[一、传输模式:单工（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户半双工（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信全双工（full-duplex）:发送的同时也可以接收数据 二、信道复用技术:2.1 频分复用:频分复用的所有主机在相同的时间占用不同的频率带宽资源。 2.2 时分复用:时分复用的所有主机在不同的时间占用相同的频率带宽资源。 2.3 波分复用:光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 2.4 码分复用:广泛应用于无线链路共享（如蜂窝网，卫星通信等）每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示各用户使用相同频率载波，利用各自的码片序列编码数据各用户码片序列相互正交码片序列与编码信号的内积 2.5 统计时分复用:是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 三、物理层的主要任务:确定与传输媒体的接口有关的一些特性(机械,电气,功能,过程特性) 四、物理层设备:转发器:集线器: 它的每个接口,是简单的转发比特,不进行碰撞检测中继器: 是一种简单的增加局域网传输距离的设备，如作为信号放大器，可使实际的网络跨越更大的距离，它工作在物理层 五、物理层基本单元:比特 六、常用编码方式:不归零: 与比特流一致归零: 到了高/低电平后,将回到低电平曼彻斯特: 中心向下为1差分曼彻斯特: 位开始无跳变为1,位中心始终跳变 七、物理层规范:物理层定义的是规范，不能说是协议例如: EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTTP]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EHTTP.html</url>
    <content type="text"><![CDATA[一、区分URI,URL,URN:URI 包含 URL 和 URN。 二、关于HTTP协议:2.1 是什么?是一个基于(客户端/服务器)请求与响应模式的、无连接, 无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 2.2 HTTP协议的主要特点?①: 无连接： 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 ②: 无状态： HTTP协议是无状态协议, 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 ③: 传输数据类型灵活： HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 ④: 传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2.3 HTTP请求报文:请求行,请求头,请求空行,请求体 2.4 HTTP响应报文:状态行,响应头,响应空行,响应体 2.5 HTTP方法:客户端发送的 请求报文 第一行为请求行，包含了方法字段。 有九种方法: get,post,put,delete,head,patch,options,connect,trace HEAD:①: 作用: 获取报文首部②: 和 GET 方法类似，但是不返回报文实体主体部分。③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST: 作用: 传输实体主体POST 主要用来传输数据，而 GET 主要用来获取资源。 PUT:①: 作用: 上传文件②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PATCH:①: 作用: 对资源进行部分修改②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 OPTIONS:①: 作用: 查询支持的方法②: 查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT:①: 要求在与代理服务器通信时建立隧道②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 TRACE:①: 追踪路径②: 服务器会将通信路径返回给客户端。③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 2.6 关于HTTP状态码:服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理100 ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应 2XX Success（成功状态码） 请求正常处理完毕200 OK 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求301 ：永久性重定向302：临时性重定向 4XX Client Error（客户端错误状态码） 服务器无法处理请求403 Forbidden ：请求被拒绝。404 Not Found 5XX Server Error（服务器错误状态码） 服务器处理请求出错500 Internal Server Error ：服务器正在执行请求时发生错误。503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 2.7 : 连接管理:2.7.1 短连接与长连接:①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2.7.2 流水线:①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。 2.7.3 Cookie:①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 ②: Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 ③: Cookie有什么用途? 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） ④: Cookie的创建过程: 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry ⑤: Cookie的分类: 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; ⑥: HttpOnly: 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。 跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly ⑦: Secure: 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 2.7.4 Session:①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 ③: 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 ④: 浏览器禁用 Cookie: 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 2.7.5 Cookie 与 Session 选择: Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 2.8 常见端口:Http端口80, HTTPS端口443 DNS端口 53 FTP 端口21 SMTP端口 25 三、HTTP/1.1 新特性:①: 默认是长连接②: 支持流水线③: 支持同时打开多个 TCP 连接④: 支持虚拟主机⑤: 新增状态码 100⑥: 支持分块传输编码⑦: 新增缓存处理指令 max-age 四、GET 和 POST 比较:从作用上来说: GET 用于获取资源，而 POST 用于传输实体主体。 从参数来说:GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 从缓存来说: 如果要对响应进行缓存，需要满足以下条件： ①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest: 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 ①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。②: 而 GET 方法 Header 和 Data 会一起发送。 五: 关于HTTPS:5.1 HTTP 有以下安全性问题：①: 使用明文进行通信，内容可能会被窃听；②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；③: 无法证明报文的完整性，报文有可能遭篡改。 5.2 什么是HTTPS?HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改） 5.3 什么是SSL?SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 5.4 什么是TLS?TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 5.5 HTTPS的缺点: ①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐②: HTTPS 降低用户访问速度（多次握手）③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密） 六、关于加密:6.1 对称密钥加密:(Symmetric-Key Encryption)①: 有流式、分组两种，加密和解密都是使用的同一个密钥。例如：DES、AES-GCM、ChaCha20-Poly1305等 优点：运算速度快；缺点：无法安全地将密钥传输给通信方。 6.2 非对称密钥加密:①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、DH、ECDHE ②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(发消息: 公钥加密,私钥解密)③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(签名: 私钥加密,公钥解密) 优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。 6.3 哈希算法:将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 6.4 数字签名:签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP 6.3 HTTPS 采用的加密方式:HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率. 七、关于认证:通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 签名: 签名者的私钥加密, 认证: 使用签名者公钥解密 八、完整性保护:①: SSL 提供报文摘要功能来进行完整性保护。②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 九、关于代理:9.1 代理服务器接受客户端的请求，并且转发给其它服务器。9.2 使用代理的主要目的是：①: 缓存②: 负载均衡③: 网络访问控制④: 访问日志记录 9.3 代理服务器分为正向代理和反向代理两种：举例: 十、关于缓存:10.1 优点:①: 缓解服务器压力；②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 10.2 实现方法①: 让代理服务器进行缓存；②: 让客户端浏览器进行缓存。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>关于HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2Fjava%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[一、先来看两张图: 二、集合的分类:2.1 Collection接口:List接口：存储有序，可重复的元素 ,遍历出来的顺序与添加顺序相同 Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的位置无序))，不可重复的元素(不可 重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都 是Collection下定义的 2.2 Map接口:注：Map接口不是Collection接口的子接口, 两者是并列关系 三、关于List接口:3.1 List接口：存储有序，可重复的元素 遍历出来的顺序与添加顺序相同 3.2 具体的实现类:①: ArrayList(主要的实现类)②: LinkedList(对于频繁的插入，删除操作 较适用)③: Vector(古老的实现类，线程安全的，但效率低于ArrayList) 四、关于Set接口:4.1 需要注意的是:①: 通常说的” Set是无序的, 不可重复的 “ 这句话中的无序是指的存储无序. ②: 无论是HashSet,还是LinkedHashSet 存储都是无序, 且不可重复的元素((指的是元素在底层存放的位置无序))③: 遍历是分为有序和无序的 , HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历. 4.2 如何保证set中元素不可重复?要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),重写hashCode（）方法让同一个对象能算出相同的hashCode值,, 进而保证Set中元素的不可重复性,, 注意:List只用重写equals方法就可以了 4.3 Set中元素是如何存储的呢？使用了哈希算法当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复). 要求：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false; ) 万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此） 4.4 具体的实现类:①: HashSet(主要的实现类)②: LinkedHashSet(HashSet的子类)③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口) 注: 一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer 又存储String类型) 4.4.1 关于TreeSet:当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）②定制排序：（实现Comparator接口，重写compare方法） 两种排序的区别: 前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法. 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 注: 只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 compareTo()与hashCode()以及equals()三者保持一致！ 五、关于Map接口:5.1 Map接口元素的存储原理: Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，需要重写hashCode和equals方法, 进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复 例如:向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(后面的会覆盖前面的,这个与HashSet不同,HashSet是后面的那个不能添加进来)。 5.2 遍历Map:有三类，分别是遍历key，遍历value，遍历key-value对 1234567891011121314151617181920//1.遍历key集Set set = map.keySet();//2.遍历value集Collection values = map.values();//3.遍历key-value对Set set2 = map.entrySet(); //所有entry的集合就是entrySetfor (Object obj:set2) &#123; //遍历entrySet得到entryMap.Entry entry = (Map.Entry)obj; //获取entry//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键 和 值 System.out.println(entry);&#125; 5.3 Map的初始化:不能初始化为: Map&lt;String,List&gt;map=null;而要用new对象的方式：Map&lt;String,List&gt;map=newHashMap&lt;String,List&gt;();否则会报错 5.4 从map中取值:正确方法: 123456方法一: String str = String.valueOf(map.get("键名"));方法二: String str = (String) map.get("ACCEPT_CHANNEL");if (null != str &amp;&amp; !"".equals(str)) &#123;…………&#125; 错误的取值方法： 1String str = map.get("键名").toString; //如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常 注: Map中的Key value可以是任何引用类型的数据 5.5 Map接口的具体实现类:①: HashTable : 古老的实现类，线程安全，不建议使用②: HashMap:③: LinkedHashMap(是HashMap的子类)④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口) 5.5.1 Properties介绍:Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的 123456789101112131415读取属性文件jdbc.properties: Properties pros = new Properties();FileInputStream fi = new FileInputStream(new File("jdbc.properties"));pros.load(fi);读取xml配置文件config.xml: Properties properties = new Properties();InputStream configInputStream = new FileInputStream("config/config.xml");properties.loadFromXML(configInputStream); 六、关于Collections 工具类:6.1 作用: 操作Collection以及Map 6.2 注意: 区分Collection与Collections 6.3 实现list的复制: 12345678910//错误的方式：出现java.lang.indexOutOfBoundsException//List list1=new ArrayList();//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1//System.out.println(list1); //正确的方式List list2 = Arrays.asList(newObject[list.size()]);Collections.copy(list2,list);System.out.println(list2);//[123,456,12,78,456] 6.4 考虑线程安全问题: List 是线程不安全的, synchronizedList方法可以保证List线程安全 123//通过如下的方法保证list的线程安全List list3=Collections.synchronizedList(list);System.out.println(list3); 6.5常用函数: 123456reverse(List)：反转List中元素的顺序shuffle(List)：对List集合元素进行随机排序sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序swap(List,int,int)：将指定list集合中的i处元素和j处元素进行交换void copy(List dest,List src)://将src中的内容复制到dest中 七、集合的遍历方法：四种①使用Iterator迭代器 ②增强型for循环 ③普通for循环 ④Iterator迭代器的”古老版本”Enumeration 接口 123456789//Enumeration 接口是Iterator迭代器的"古老版本"public class TestEnumeration &#123; public static void main(String[] args) &#123; Enumeration enu = new StringTokenizer("ab-c*-df-g", "-"); while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement()); &#125; &#125;&#125; 12345678910111213//面试题@Testpublic void test5()&#123; //结果: 输出MM MM MM AA BB DD String[]str=new String[]&#123;"AA","BB","DD"&#125;; //表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值 for(String s:str)&#123; //每循环一次, s都是一个新的局部变量 s="MM"; System.out.println(s); &#125; for(int i=0;i&lt;str.length;i++)&#123; System.out.println(str[i]); &#125;&#125; 八、关于数组:存储对象可以考虑：①数组，②集合数组存储对象的特点：Student[] stu = new Student[20]; stu[0]=new Student();…..弊端：①一旦创建，其长度不可变. ②真实的数组存放的对象的个数是不可知的 九、总结:①: 单类型: 一个TreeSet对象必须存储同一种数据类型,例如: 不能既存储Integer 又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型. ②: 一致性: 使用TreeSet时: compareTo()与hashCode()以及equals()三者保持一致！ ③: 执行流程： 向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法 ④: 顺序性: Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)Set而言: 遍历是分为有序和无序的 , 其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[一、数据类型:1.1 基本数据类型：1.1.1 整数类型：byte（1个字节） -128（-2^7）——– 127 (2^7-1)short（2） -32768(-2^15)——- 32767(2^15-1)int（4） （-2)^31 —— 2^31-1long(8) （-2)^63 —— 2^63-1 整数有三种表示形式： 八进制：以0开头，如012，-027 十进制： 十六进制：以0x 或0X开头，如0x123,-0X12 1.1.2 浮点类型：float（4） 6或7位有效数字double（8） 15位有效数字带小数点的数默认为：双精度浮点型（double），数字后带“d 或 D”，如“2.3d”，“d 或 D”可以省略注意：要表示单精度浮点型（float），必须在数字后面加“f 或 F”，如“13.23f”,“f 或 F”不可省略 1.1.3 字符类型：char（2） 1.1.4 布尔类型boolean：false（4）必须小写true（4）必须小写 JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 1.2 引用数据类型：①: 类(class) 如String类②: 接口(interface)③: 数组④: 枚举（enum） 1.3 包装类型:基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 二、常量与变量①: 常量：由final修饰的 ②: 变量： 局部变量（位于方法（一般方法，构造方法，程序入口方法）中） 全局变量（１.实例变量（无static修饰），２.类变量也称静态变量（有static修饰）） 三、强制类型转换:3.1 小的转换为大的，系统会自动完成强制类型转换如：short i = 10; int j; j=i; (系统自动完成j = (int)i )3.2 大的转换为小的，必须进行手动完成强制类型转换如：int i = 10; short j; j = (short)i; 四、构造方法:4.1 特点：①: 构造方法只能由new操作符调用，即建立对象时自动调用；②: 构造方法可以重载，即在同一个类中可以有多个构造方法③: 构造方法没有返回类型，甚至连void也没有④: 构造方法与类同名 注: 如果没有在类中写构造方法，系统会生成一个默认的无参构造方法，并使用默认值初始化对象的属性（int变量初始化为0，boolean 变量初始化为false）,如果写了有参构造方法,那么系统不会再自动生成无参构造方法,如果此时我们要用无参构造方法,需要我们手动写无参构造方法. 4.2 作用：初始化对象，如给数据成员赋值注意：一旦创建了一个有参数的构造方法，系统就不会自动添加默认的无参构造方法，要想用无参构造方法，需要人为的去创建一个无参构造方法 五、注释:①: 文件注释：在包名之上，“/*……*/”，描述文件名(java工程名)，版权信息②: 类注释：“/**……*/”，描述类的作用，版本version ，日期，作者③: 私有成员：“/*……*/” 或“//”；如局部变量，某一个语句的功能作用 * @param 描述方法的参数 * @return 描述返回值，对于无返回值的方法或构造方法，@return可以省略 * @throws 描述在什么情况下抛出什么类型的异常 * @author 描述作者 * @version 描述版本 * @since 描述该类可以运行的JDK版本 * @see 参考转向，也就是相关主题 * @link 转向成员的超链接。label为链接文字。package.class#member将被自动转换为指向package.class的member文件的URL ④: 共有成员：“/**……..*/”；如构造方法 六、继承（extends）6.1 含义:其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正每次调子类的时候都会“自动运行”它父类的构造函数，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”。 6.2 java中子类能不能继承父类构造方法？答案是不能*理由：其实每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。所以父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法 注意“调用”和继承不是一个含义，实质上是“自动运行”。 七、关于JavaBean:符合如下标准的Java类：①: 实现serializable接口（这个不是必须的）②: 必须有一个无参的公共的构造器（public修饰）③: 必须属性用private修饰，且有get，set方法 八、权限修饰符： 九、抽象类：特点：必须含抽象方法，其他的和一般类一样抽象方法：只有声明没有实现的方法 十、接口：10.1 特点：只含常量和抽象方法①: 接口中的常量都是public static final 类型(可以省略)，这是系统默认的②: 接口中的方法都是public abstract类型(可以省略)，这是系统默认的③: 接口 作为一种引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的该接口中的方法一个类要实现接口，必须实现这个接口中的所有方法 注意：通过一个接口变量只能调用该接口所声明的方法。 十一、重载和重写区别:方法重载（Overload）：一个类中有多个方法，名字相同，参数不同（如参数个数，种类，参数顺序不同），与返回值无关；方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同 十二、面向对象编程的四个基本特征:①：抽象:②：封装：把对象的数据和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节③：继承：④：多态性：多态的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。 多态的举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态的作用：消除类型之间的耦合关系 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 重载和重写都是多态的体现. 十三、异常与错误:12.1 异常:12.1.1 编译异常： 由于程序语法不合规范，编译不通过 12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）： 编译通过，运行时出现异常。如数组下标越界，除数为零，数字格式错误，空指针异常 12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）： 如类没找到，IO操作错误 12.1.4 逻辑异常： 输出的结果不符合预期的要求 12.1.5 try ,catch ,finally只有三种组合：​ a. try…catch…finally ​ b. try…catch ​ c. try…finally ①: 异常发生时，如果匹配的catch语句中抛出（有throw关键字）了异常，则finally之外的语句将不能被执行 ②: finally中的语句无论什么情况都会执行 ③: 得到有关异常信息：getMessage() ④: 用来跟踪异常事件发生时执行堆栈的内容：printStackTrace（） 12.1.6 throws 和 throw 的区别：throws 关键字用于方法的声明部分，说明方法可能抛出的异常类型throw 关键字用来抛出异常，如果抛出了检查性异常（非运行时异常），还必须在方法头部声明方法可能抛出的异常类，该方法的调用者还必须捕获处理抛出的异常,如果抛出非检查性异常（运行时异常），该方法的调用者可捕获可不捕获异常 12.2 错误（Error）：①：虚拟机错误（Virtual Machine Error）②：连接错误（LinkageError）③：图形界面错误（AWTError） 十四、日期与时间:13.1 java中主要使用三个类来处理日期和时间:①: java.util.Date(日期) , ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的毫秒数 ②: java.util.Calendar（日历） , ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分 ③: java.text.DateFormat（日期格式化）————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写有要求 13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 150658200000013.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 201713.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识java]]></title>
    <url>%2F%E5%88%9D%E8%AF%86java.html</url>
    <content type="text"><![CDATA[一、发展历史①: java语言前身是oak（橡树）语言②: java于1995年诞生于sun公司③: 1996第一个JDK诞生④: 1999 Sun发布J2SE，J2EE ,J2ME 二、语言特点①: 面向对象②: 分布式多线程③: 健壮性(异常处理)④: 安全⑤: 可移植性 三、Java技术体系分四个平台:①: Java Card: java小程序运行在小内存设备(智能卡)上的平台.②: Java ME: 移动终端(手机)③: JavaSE: 桌面级(Windows下的应用程序)④: JavaEE : 以前称J2EE ,企业级 四、JDK和JREJDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器) JDK目录结构:①: bin目录：包含编译器（javac.exe（c是compile（编译）的缩写）），解释器（java.exe），帮助文档生成器（javadoc.exe），打包工具（jar.exe），小应用程序浏览工具（appletviewer.exe） ②: lib目录：包含类库文件 ③: demo目录：包含各种演示例子 ④: include目录：包含C语言头文件，支持java本地接口 ⑤: jre目录：包含java虚拟机，java应用启动器，运行时的类包 ⑥: sample目录：sun配带的帮助学习者学习的java例子 ⑦: src.zip:源码压缩文件 JDK: Java程序设计语言 + Java 虚拟机 + JavaAPI类库 JRE : JavaAPI中的Java SE API + Java虚拟机 因此 JDK包含JRE 五、java虚拟机是什么？(Java Virtual Machine) 简称JVM Java语言写的代码是.java文件，它会被特定程序编译(javac.exe，它会被Eclipse之类的IDE调用)成字节码(bytecode)，字节码不能直接在CPU上运行，需要另一个程序读取并执行，这个部件就是java虚拟机，它像机器一样运行编译好的java字节码，就像机器直接执行机器码一样……java虚拟机的外部接口在windows下主要是jvm.dll这个文件……简言之：jvm是Java开发语言中，用来运行Java字节码文件的平台；提供对Java字节码的解释及运行，位于JRE中JRE: java运行环境,包含java虚拟机和java程序所需的核心类库(javaSE API) 。如果只是想跑java程序，那么只需安装JRE，如果要写java程序，那就需要JDK了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之内存分配和回收]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6.html</url>
    <content type="text"><![CDATA[一、内存分配策略:1. 对象优先在 Eden 分配:大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 2. 大对象直接进入老年代:①: 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。②: 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。⑤: -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 3. 长期存活的对象进入老年代:①: 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。②: -XX:MaxTenuringThreshold 用来定义年龄的阈值。 4. 动态对象年龄判定:虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保:在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Minor GC 的触发条件: 当 Eden 空间满时，就将触发一次 Minor GCFull GC 的触发条件:①: 老年代空间不足: 解决方案： ①：尽量不要创建过大的对象以及数组 ②：通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 ③：通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 ②: 空间分配担保失败 ③: 调用 System.gc(): 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 ④：JDK 1.7 及以前的永久代空间不足 解决方案： ①：可采用的方法为增大永久代空间 ②：转为使用 CMS GC。 二、内存回收：2.1 GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。2.1.1 Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。 2.1.2 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-3无重复字符的最长子串]]></title>
    <url>%2FLeetCode-3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    <content type="text"><![CDATA[题目:给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "kew"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 分析:给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。 我们先不考虑代码怎么实现，如果给一个例子中的例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉第一次出现的b，以此类推，最终发现最长的长度为3。 所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。 进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。 参考链接:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机之垃圾收集]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[一、垃圾收集:1.1哪些区域需要垃圾收集:①: 垃圾收集主要是针对堆和方法区进行。②: 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 二、判断一个对象是否可被回收:2.1 引用计数算法:为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011121314public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); &#125;&#125; 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。 2.2 可达性分析算法:以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： ①: 虚拟机栈中局部变量表中引用的对象 ②: 本地方法栈中 JNI 中引用的对象 ③: 方法区中类静态属性引用的对象 ④: 方法区中的常量引用的对象 2.3 方法区的回收①: 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 ②: 主要是对常量池的回收和对类的卸载。 ③: 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 ④: 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 2.4. finalize()类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 三、引用类型:无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型:3.1 强引用被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 3.2 软引用:被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.3 弱引用:被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 4. 虚引用:又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的: 是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 四、垃圾收集算法:4.1 标记 - 清除: 标记要回收的对象，然后清除。不足：标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 4.2 标记 - 整理:让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 4.3 复制: 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足: 是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 4.4 分代收集:现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 五、垃圾收集器:HotSpot 虚拟机中的 7 个垃圾收集器: 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 5.1 Serial 收集器:Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 5.2ParNew 收集器:它是 Serial 收集器的多线程版本。 它是Server场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 5.3 Parallel Scavenge 收集器:与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值 5.4 Serial Old 收集器:是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5.5 Parallel Old 收集器:是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 5.6 CMS 收集器:CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 具有以下缺点：①: 吞吐量低：②: 无法处理浮动垃圾: 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。③: 标记 - 清除算法导致空间碎片 5.7 G1 收集器:G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 参考链接:https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机]]></title>
    <url>%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA.html</url>
    <content type="text"><![CDATA[一、JVM是什么?JVM是Java Virtual Machine（Java虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 二、JVM的作用?JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码字节码，就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 三、从进程的角度解释JVM我们知道，虚拟机是运行在操作系统之中的，那么什么东西才能在操作系统中运行呢？当然是进程，因为进程是操作系统中的执行单位。可以这样理解，当它在运行的时候，它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放于文件系统中），可以把它叫做程序。 对命令行比较熟悉的同学，都知道其实一个命令对应一个可执行的二进制文件，当敲下这个命令并且回车后，就会创建一个进程，加载对应的可执行文件到进程的地址空间中，并且执行其中的指令。 四、Java版HelloWord程序的编译和执行形式:①: 首先编写源文件HelloWord.java ： 12345 public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; ②: 编译Java版的HelloWorld程序：$ javac HelloWorld.java ③: 运行Java版的HelloWorld程序：$ java -classpath . HelloWorld 4.1 从上面的过程可以看到， 我们在运行Java版的HelloWorld程序的时候， 敲入的命令并不是 ./HelloWorld.class 。 因为class文件并不是可以直接被操作系统识别的二进制可执行文件 。 我们敲入的是java这个命令。 这个命令说明， 我们首先启动的是一个叫做java的程序， 这个java程序在运行起来之后就是一个JVM进程实例. 4.2 上面的命令执行流程是这样的： java命令首先启动虚拟机进程，虚拟机进程成功启动后，读取参数“HelloWorld”，把他作为初始类加载到内存，对这个类进行初始化和动态链接，然后从这个类的main方法开始执行。 也就是说我们的.class文件不是直接被系统加载后直接在cpu上执行的，而是被一个叫做虚拟机的进程托管的。首先必须虚拟机进程启动就绪，然后由虚拟机中的类加载器加载必要的class文件，包括jdk中的基础类（如String和Object等），然后由虚拟机进程解释class字节码指令，把这些字节码指令翻译成本机cpu能够识别的指令，才能在cpu上运行. 4.3 从这个层面上来看，在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。 五、JVM体系结构简介: 根据上图表达的内容，我们编译之后的class文件是作为Java虚拟机的原料被输入到Java虚拟机的内部的，那么具体由谁来做这一部分工作呢？其实在Java虚拟机内部，有一个叫做类加载器的子系统，这个子系统用来在运行时根据需要加载类。注意上面一句话中的“根据需要”四个字。在Java虚拟机执行过程中，只有他需要一个类的时候，才会调用类加载器来加载这个类，并不会在开始运行时加载所有的类。就像一个人，只有饿的时候才去吃饭，而不是一次把一年的饭都吃到肚子里。一般来说，虚拟机加载类的时机，在第一次使用一个新的类的时候。 由虚拟机加载的类，被加载到Java虚拟机内存中之后，虚拟机会读取并执行它里面存在的字节码指令。虚拟机中执行字节码指令的部分叫做执行引擎。就像一个人，不是把饭吃下去就完事了，还要进行消化，执行引擎就相当于人的肠胃系统。在执行的过程中还会把各个class文件动态的连接起来。 Java虚拟机会进行自动内存管理。具体说来就是自动释放没有用的对象，而不需要程序员编写代码来释放分配的内存。这部分工作由垃圾收集子系统负责。 一个Java虚拟机实例在运行过程中有三个子系统来保障它的正常运行，分别是类加载器子系统， 执行引擎子系统和垃圾收集子系统。 如下图所示： 虚拟机的运行，必须加载class文件，并且执行class文件中的字节码指令。它做这么多事情，必须需要自己的空间。就像人吃下去的东西首先要放在胃中。虚拟机也需要空间来存放个中数据。首先，加载的字节码，需要一个单独的内存空间来存放；一个线程的执行，也需要内存空间来维护方法的调用关系，存放方法中的数据和中间计算结果；在执行的过程中，无法避免的要创建对象，创建的对象需要一个专门的内存空间来存放。 5.1 Java虚拟机 运行时数据区: 5.1.1程序计数器:①: 是一块较小的内存空间, 当前线程执行的字节码的行号指示器(记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。)②: 指向下一条需要执行的指令③: 每条线程都需要一个独立的程序计数器,彼此互不干扰(线程私有的内存) 5.1.2Java虚拟机栈:①: 线程私有的,生命周期与线程相同②: 描述java方法执行的内存模型,每个方法执行时都会创建一个栈帧,用来存放局部变量表,操作数栈,常量池引用等信息.③: 每个方法从调用到执行完成 就对应着栈帧在虚拟机栈帧中入栈和出栈.④: 两种异常: StackOverFlow异常 : 线程所请求的栈深度大于虚拟机允许的则抛出 OutOffMemoryError异常: 扩展时无法申请到足够的内存则抛出⑤: 我们常说的栈 和堆 中的栈就是Java虚拟机栈,更具体来说是Java虚拟机栈中的局部变量表部分.⑥: 局部变量表: 存放编译期可知的各种基本数据类型,对象引用类型 所需要的内存空间在编译期完成分配, 在方法运行期间不会改变其大小 64位长度的long 和 double 类型数据会占用2个局部变量空间(Slot) ,其余占一个. ⑦: 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：java -Xss512M HackTheJava 5.1.3本地方法栈:本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 上面三个区域随线程而生, 随线程而灭; 5.1.4Java堆( Java Heap) : 也称GC堆(Garbage Collected Heap )①: 是Java虚拟机管理的内存中最大的一块②: 被所有线程共享,的一块内存空间, 在虚拟机启动时候创建,③: 唯一目的: 存放对象实例, 几乎所有的对象实例 和 数组 都在这里这里分配内存.④: 是垃圾收集器管理的主要区域 ,所以也称GC堆⑤: 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M HackTheJava⑥: 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。 5.1.5方法区(永久代):①: 被所有线程共享,的一块内存空间②: 用来存储Class的相关信息如已经被Java虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。③: 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。④: 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。⑤: HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 5.1.5运行时常量池①: 运行时常量池是方法区的一部分。②: .Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。③: 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。④: 常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 参考链接:https://baike.baidu.com/item/JVMhttps://blog.csdn.net/zhangjg_blog/article/details/20380971https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.mdhttps://blog.csdn.net/gyqjn/article/details/49848473]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是策略模式?定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp;让算法可在不影响客户端的情况下发生变化简单来说：准备一组算法 &amp; 将每一个算法封装起来，让外部按需调用 &amp; 使得互换 二、如何使用?使用步骤?步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员步骤4：客户端调用-让销售员进行促销活动的落地 三、优点:①: 策略类之间可以自由切换,由于策略类都实现同一个接口，所以使它们之间可以自由切换②: 易于扩展,增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码③: 符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。 四、缺点:①: 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。②: 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 五、应用场景:动态选择多种复杂行为 六、实例:背景：小成有一家百货公司，最近在定年度的促销活动冲突：每个节日用同一个促销活动太枯燥，没吸引力解决方案：针对不同节目使用不同促销活动进行促销 123456789101112131415161718192021222324252627282930313233343536373839404142434445//步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口abstract class Strategy &#123; public abstract void show();&#125;//步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动//为春节准备的促销活动Aclass StrategyA extends Strategy &#123; @Override public void show() &#123; System.out.println("为春节准备的促销活动A"); &#125;&#125;//为中秋节准备的促销活动Bclass StrategyB extends Strategy &#123; @Override public void show() &#123; System.out.println("为中秋准备的促销活动A"); &#125;&#125;//为国庆准备的促销活动Cclass StrategyC extends Strategy &#123; @Override public void show() &#123; System.out.println("为国庆准备的促销活动C"); &#125;&#125;//步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员class Context_SaleMan &#123; //持有抽象策略角色的引用 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * * @param strategy 具体策略对象 */ public Context_SaleMan(Strategy strategy) &#123; this.strategy = strategy; &#125; //向客户展示促销活动 public void Sale_ManShow() &#123; strategy.show(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//步骤4：客户端调用-让销售员进行促销活动的落地public class StrategyPattern &#123; //程序入口 public static void main(String[] args) &#123; Context_SaleMan saleMan; // 选择并创建需要使用的策略对象 // 例如现在要做春节的活动 Strategy strategyA = new StrategyA(); System.out.println("对于春节："); // 创建环境 saleMan = new Context_SaleMan(strategyA); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做中秋节的活动 Strategy strategyB = new StrategyB(); System.out.println("对于中秋节："); // 创建环境 saleMan = new Context_SaleMan(strategyB); saleMan.Sale_ManShow(); // 选择并创建需要使用的策略对象 // 例如现在要做国庆节的活动 Strategy strategyC = new StrategyC(); System.out.println("对于国庆节："); // 创建环境 saleMan = new Context_SaleMan(strategyC); saleMan.Sale_ManShow(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[什么是抽象工厂模式?抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。 抽象工厂模式与工厂方法模式最大的区别?抽象工厂中每个工厂可以创建多种类的产品, 而工厂方法每个工厂只能创建一类. 使用步骤:(根据下图来理解:)步骤1： 创建抽象工厂类，定义具体工厂的公共接口；步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；步骤4： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例 优点:①: 降低耦合: 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来， 可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；②: 更符合开-闭原则: 新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 而简单工厂模式需要修改工厂类的判断逻辑 ③: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品， 而简单工厂中的工厂类存在复杂的switch逻辑判断④: 不使用静态工厂方法，可以形成基于继承的等级结构， 而简单工厂模式的工厂类使用静态工厂方法 缺点:①: 抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。②: 对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。 应用场景:①: 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。②: 这个系统有多个系列产品，而系统中只消费其中某一系列产品③: 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。 实例:背景： 小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂所在地的客户 也需要模具类产品，B厂所在地的客户也需要容器类产品；冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂.解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。 1234567//步骤1： 创建抽象工厂类，定义具体工厂的公共接口abstract class Factory &#123; public abstract Product ManufactureContainer();//容器 public abstract Product ManufactureMould();//模型&#125; 123public class Product &#123; public void show()&#123;&#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//步骤2： 创建抽象产品族类 ，定义具体产品的公共接口；abstract class AbstractProduct extends Product&#123; public abstract void show();&#125;//步骤3： 创建抽象产品类 ，定义具体产品的公共接口；//容器产品抽象类abstract class ContainerProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//模型产品抽象类abstract class MouldProduct extends AbstractProduct &#123; @Override public abstract void show();&#125;//步骤4： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；//容器产品Aclass ContainerProductA extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品A"); &#125;&#125;//容器产品Bclass ContainerProductB extends ContainerProduct&#123; @Override public void show() &#123; System.out.println("生产出了容器产品B"); &#125;&#125;//模具产品Aclass MouldProductA extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品A"); &#125;&#125;//模具产品Bclass MouldProductB extends MouldProduct&#123; @Override public void show() &#123; System.out.println("生产出了模具产品B"); &#125;&#125;//步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//A厂 - 生产模具+容器产品class FactoryA extends Factory &#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductA(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductA(); &#125;&#125;//B厂 - 生产模具+容器产品class FactoryB extends Factory&#123; @Override public Product ManufactureContainer() &#123; return new ContainerProductB(); &#125; @Override public Product ManufactureMould() &#123; return new MouldProductB(); &#125;&#125; 12345678910111213141516//步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例public class AbstractFactoryPattern &#123; public static void main(String[] args) &#123; Factory myfactoryA = new FactoryA(); Factory myfactoryB = new FactoryB(); //A厂当地客户需要容器产品A myfactoryA.ManufactureContainer().show(); //A厂当地客户需要模具产品A myfactoryA.ManufactureMould().show(); //B厂当地客户需要容器产品B myfactoryB.ManufactureContainer().show(); //B厂当地客户需要模具产品B myfactoryB.ManufactureMould().show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-2两数相加]]></title>
    <url>%2FLeetCode-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html</url>
    <content type="text"><![CDATA[题目:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例: 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析:建立一个新链表，然后把输入的两个链表从头往后遍历，每两个相加，添加一个新节点到新链表后面。为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后，由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点。好，可以开始让两个链表相加了，这道题好就好在最低位在链表的开头，所以我们可以在遍历链表的同时按从低到高的顺序直接相加。while循环的条件两个链表中只要有一个不为空行，由于链表可能为空，所以我们在取当前结点值的时候，先判断一下，若为空则取0，否则取结点值。然后把两个结点值相加，同时还要加上进位carry。然后更新carry，直接 sum/10 即可，然后以 sum%10 为值建立一个新结点，连到cur后面，然后cur移动到下一个结点。之后再更新两个结点，若存在，则指向下一个位置。while循环退出之后，最高位的进位问题要最后特殊处理一下，若carry为1，则再建一个值为1的结点，代码如下： 123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //l1,l2相当于指向两个链表表头的指针 //为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后 ListNode dummy = new ListNode(-1); //由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点 ListNode cur = dummy; //进位 int carry = 0; //至少有一个结点不为空 while (l1 != null || l2 != null) &#123; //结点为空,那么值就设置为0,不为空取出结点所存放的值 int d1 = l1 == null ? 0 : l1.val; int d2 = l2 == null ? 0 : l2.val; //两个链表中对应结点的值求和 int sum = d1 + d2 + carry; carry = sum &gt;= 10 ? 1 : 0; //sum不会超过二十,所以最多进1位 cur.next = new ListNode(sum % 10);//造一个新结点,将两个链表对应结点的两数之和,存到新链表的新结点 cur = cur.next;//移动cur指针,指向下一个结点 if (l1 != null) &#123; l1 = l1.next;//移动l1指针 &#125; if (l2 != null) &#123; l2 = l2.next;//移动l2指针 &#125; &#125;//循环结束 //如果最高位相加,产生进位,需要再造一个结点 if (carry == 1) &#123; cur.next = new ListNode(1); &#125; return dummy.next;&#125; 12345678910111213141516171819202122232425public class addTwoNumbers &#123; //程序入口函数 public static void main(String[] args) &#123; //建立第一个链表 ListNode listNode1 = new ListNode(2); ListNode listNode2 = new ListNode(4); ListNode listNode3 = new ListNode(3); listNode1.next=listNode2; listNode2.next=listNode3; listNode3.next=null; //建立第二个链表 ListNode listNode4 = new ListNode(5); ListNode listNode5 = new ListNode(6); ListNode listNode6 = new ListNode(4); listNode4.next=listNode5; listNode5.next=listNode6; listNode6.next=null; //调用方法 ListNode listNode = new addTwoNumbers().addTwoNumbers(listNode1,listNode4); //打印结果: ListNode&#123;val=7, next=ListNode&#123;val=0, next=ListNode&#123;val=8, next=null&#125;&#125;&#125; System.out.println(listNode); &#125;&#125; 参考链接:http://www.cnblogs.com/grandyang/p/4129891.htmlhttps://leetcode-cn.com/problems/two-sum/]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是工厂方法模式?①: 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口(抽象方法)，而子类重写接口(抽象方法)则负责生成具体的对象。③: 简言之:工厂里面造对象,对象所属类里面造产品 二、如何使用?使用步骤?步骤1： 创建抽象工厂类，定义具体工厂的公共接口(抽象方法)；步骤2： 创建抽象产品类 ，定义具体产品的公共接口(抽象方法)；步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤4： 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例(对象)的方法；步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 三、优点:①: 更符合开-闭原则: 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可, 而简单工厂模式需要修改工厂类的判断逻辑②: 符合单一职责原则: 每个具体工厂类只负责创建对应的产品, 而简单工厂中的工厂类存在复杂的switch逻辑判断, 它不使用静态工厂方法，可以形成基于继承的等级结构。 而简单工厂模式的工厂类使用静态工厂方法 四、缺点:①: 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；②: 同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；③: 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。④: 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；⑤: 一个具体工厂只能创建一种具体产品 五、应用场景:①: 当一个类不知道它所需要的对象的类时②: 当一个类希望通过其子类来指定创建对象时③: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。④: 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 六、实例:背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；解决方案：小成决定置办塑料分厂B来生产B类产品； //步骤1： 创建抽象工厂类 123abstract class Factory &#123; abstract Product Manufacture();&#125; //步骤2： 创建抽象产品类 ，定义具体产品的公共接口； 123abstract class Product &#123; public abstract void show();&#125; //步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下://步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下: //具体产品A类class ProductA extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品A"); &#125;&#125;//具体产品B类class ProductB extends Product&#123; @Override public void show() &#123; System.out.println("生产出产品B"); &#125;&#125;//步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; @Override Product Manufacture() &#123; return new ProductA(); &#125;&#125;//工厂B类 - 生产B类产品class FactoryB extends Factory&#123; @Override Product Manufacture() &#123; return new ProductB(); &#125;&#125;//生产工作流程public class FactoryPattern &#123; public static void main(String[] args) &#123; //客户要产品A FactoryA myfactoryA = new FactoryA(); myfactoryA.Manufacture().show(); //客户要产品B FactoryB myFactoryB = new FactoryB(); myFactoryB.Manufacture().show(); &#125; 七、总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是简单工厂模式?①: 简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法） ②: 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。 二、如何使用?使用步骤?:①: 创建抽象产品类 &amp; 定义具体产品的公共接口；②: 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；③: 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；④: 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例 三、优点:①: 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；②: 把初始化实例时的工作放到工厂里进行，使代码更容易维护。③: 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。 四、缺点:①: 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；②: 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。③: 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 五、应用场景:①: 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；②: 当工厂类负责创建的对象（具体产品）比较少时。 六、实例:背景：小成有一个塑料生产厂，用来做塑料加工生意目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产 //步骤1. 创建抽象产品类，定义具体产品的公共接口 123abstract class Product &#123; public abstract void show();&#125; //步骤2.创建具体产品类（继承抽象产品类），定义生产的具体产品, 代码如下://步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//具体产品类Aclass ProductA extends Product &#123; @Override public void show() &#123; System.out.println("生产出A产品!"); &#125;&#125;//具体产品类Bclass ProductB extends Product &#123; @Override public void show() &#123; System.out.println("生产出B产品!"); &#125;&#125;//具体产品类Cclass ProductC extends Product &#123; @Override public void show() &#123; System.out.println("生产出C产品!"); &#125;&#125;//步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例public class SimpleFactoryPattern &#123; public static void main(String[] args) &#123; //客户要A产品 try &#123; Factory.Manufacture("A").show(); &#125; catch (NullPointerException e) &#123; System.out.println("没有A产品"); &#125; //客户要B产品 try &#123; Factory.Manufacture("B").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有B产品"); &#125; //客户要C产品 try &#123; Factory.Manufacture("C").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有C产品"); &#125; //客户要D产品 try &#123; Factory.Manufacture("D").show(); &#125; catch (NullPointerException e)&#123; System.out.println("没有这一类产品"); &#125; &#125;&#125; //步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例 12345678910111213141516public class Factory &#123; public static Product Manufacture(String productName) &#123;//工厂类里用switch语句控制生产哪种商品；//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化 switch(productName) &#123; case "A": return new ProductA(); case "B": return new ProductB(); case "C": return new ProductC(); default: return null; &#125; &#125;&#125; 参考文章:https://www.jianshu.com/p/e55fbddc071c]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-三次握手和四次挥手]]></title>
    <url>%2FTCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[一、字段说明: 字段: 含义: SYN,seq 同步报文段 ACK,ack 确认报文段 ack 确认号 seq 序列号 SYN 同步位 FIN 终止位 ACK 确认位 二、三次握手:第一次: 连接请求报文段: SYN=1(请求连接) 初始序号seq=x(客户端初始序号)第二次: 确认报文段(同意连接): SYN =1(请求连接) seq= y(服务器自己的初始序号) ACK = 1(确认收到) ack = x+1(确认号)第三次: 确认报文段:ACK=1(确认收到) seq=x+1 (客户端序号) ack=y+1(确认号) 确认号ack是上一次的序号seq加1 总结: ack的值等于对方上一次发送的报文段中的seq的值加一,​ seq的值等于自己上一次发送的报文段中的seq的值加一(第一次seq值任意取) 简图: B 处于 LISTEN（监听）状态，等待来自 A 的连接请求。 A 向 B 发送连接请求报文 SYN。 B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN ACK。 A 收到 SYN ACK 后，还要向 B 发出确认报文 ACK。 B 收到 ACK 后，连接建立。 应该注意到，接收了 SYN 之后的所有报文都存在 ACK 字段。 三、三次握手的原因:第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四、四次挥手: 简图: 第一次: 连接释放报文段: FIN=1 seq=u(u为前面已经传送过的数据的最后一个字节的序号加一) 第二次: 连接释放确认报文段: 确认只断开A—B ACK= 1(确认收到) ack=u+1(确认号) seq=v(v为为前面已经传送过的数据的最后一个字节的序号加一) 第三次: 连接释放确认报文段: 断开B—-A FIN = 1 ACK =1 ack=u+1 seq=w(seq=v后还发送了数据, w是前面已经传送过的数据的最后一个字节的序号加一) 第四次: 连接释放确认报文段 : 确认断开B—A ACK=1 ack = w+1 seq=u+1 A 发送连接释放报文 FIN。 B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文 FIN。 A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。 B 收到 ACK 后释放连接。 五、四次挥手的原因:客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。 六、为什么还要设置一个Time-WAIT ?客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。 参考文章:https://mp.weixin.qq.com/s/tGlWTrr5KLAv1AflfeAejA]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP-三次握手和四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1两数之和]]></title>
    <url>%2FLeetCode-1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析:这道题给了我们一个数组，还有一个目标数target，让我们找到两个数字，使其和为target，乍一看就感觉可以用暴力搜索(遍历所有的两个数字的组合，然后算其和), 但是时间复杂度是O(n^2)。能否想个O(n)的算法来实现，一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢，我们可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，我们都知道HashMap是常数级的查找效率，这样，我们在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。代码如下： 法一: 暴力搜索(不采用) 123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int i = 0, j = 0, t = 0; int result[] = new int[2]; for (i = 0; i &lt; nums.length - 1; i++) &#123; //0 1 2 for (j = i; j &lt; nums.length - 1; j++) &#123; t = nums[i] + nums[j + 1]; if (t == target) &#123; result[0] = i; result[1] = j + 1; return result; &#125; &#125; &#125; return result; &#125; 法二: 使用HashMap 1234567891011121314151617public class TwoSum &#123; public int[] twoSum(int[] sums,int target) &#123; HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;Integer,Integer&gt;(); int[] result = new int[2]; for(int i = 0;i &lt; sums.length;i++)&#123; hashMap.put(sums[i],i);//把值存到HashMap,数作为键,下标作为值 &#125; for(int i = 0;i &lt; sums.length;i++) &#123; int t = target - sums[i]; if(hashMap.containsKey(t) &amp;&amp; hashMap.get(t) != i) &#123; result[0] = i; result[1] = hashMap.get(t); break;//一旦找到了,就立刻终止循环 &#125; &#125; return result; &#125; 1234567891011public class TwoSum &#123; //程序入口函数 public static void main(String[] args) &#123; int []nums = new int []&#123;2, 7, 11, 15&#125;; int target = 9; int[] result = new int[2]; result = new TwoSum().twoSum(nums,target); //打印结果: [0,1] System.out.println("["+result[0]+","+result[1]+"]"); &#125; 参考链接:https://leetcode-cn.com/problems/two-sum/http://www.cnblogs.com/grandyang/p/4130379.html]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、什么是单例模式? 实现1个类只有1个实例化对象并提供一个全局访问点. 二、工作原理: 保证在内存中只有一个对象存在. 在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的， 要是想实现一个类只有一个实例化对象，就要对类的构造方法下功夫 三、如何去保证内存中只有一个对象存在? ①: 构造函数私有化 ②: 自己创建当前类的对象 ③: 对外提供公共的方法(获取已经创建好的对象) 四、使用步骤: 创建私有变量 OurInstance,（用以记录 Singleton 的唯一实例）,内部进行实例化 把类的构造方法私有化，不让外部调用构造方法实例化(构造方法只能在本类中调用) 定义公有方法提供该类的全局唯一访问点外部通过调用newInstance()方法来返回唯一的实例 五、优点: 提供了对唯一实例的受控访问； 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能； 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式； 六、缺点: 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失。 七、单例模式的实现方式:可分为2大类、6种实现方式: 第一大类: 初始化单例类时 即 创建单例 实现方式1: 饿汉式 实现方式2: 枚举类型 第二大类: 按需,延迟创建单例 实现方式3: 懒汉式的基础实现 实现方式4: 懒汉式的改进—&gt;同步锁 实现方式5: 懒汉式的改进—&gt;双重检验锁 实现方式6: 静态内部类 八、饿汉式和懒汉式的区别: 饿汉式: 随类的加载而创建对象 懒汉式: 上来不创建对象,当调用的时候,再创建对象,以后使用的就是同一个对象了 懒汉式: 懒加载,延迟加载 九、实现方式详解:9.1 实现方式1: 饿汉式 ①: 这是 最简单的单例实现方式 ②: 原理: 依赖 JVM类加载机制，保证单例只会被创建1次，即 线程安全 JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化 ③: 应用场景: 除了初始化单例类时 即 创建单例外，继续延伸出来的是：单例对象 要求初始化速度快 &amp; 占用内存小 ④: 具体实现: 1234567891011121314class Singleton &#123; // 1. 加载该类时，单例就会自动被创建 private static Singleton ourInstance = new Singleton(); // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 通过调用静态方法获得创建的单例 public static Singleton newInstance() &#123; return ourInstance; &#125; &#125; 9.2 实现方式2: 枚举类型 ①: 原理: 根据枚举类型的下述特点，满足单例模式所需的 创建单例、线程安全、实现简洁的需求 ②: 具体实现: 12345678910public enum Singleton&#123; //定义1个枚举的元素，即为单例类的1个实例 INSTANCE; // 隐藏了1个空的、私有的 构造方法 // private Singleton () &#123;&#125; &#125; // 获取单例的方式： Singleton singleton = Singleton.INSTANCE;注：这是 最简洁、易用 的单例实现方式，借用《Effective Java》的话：单元素的枚举类型已经成为实现 Singleton的最佳方法 9.3实现方式3: 懒汉式（基础实现） ①: 原理: 与饿汉式 最大的区别是：单例创建的时机 饿汉式：单例创建时机不可控，即类加载时 自动创建 单例 懒汉式：单例创建时机可控，即有需要时，才 手动创建 单例 ②: 具体实现: 123456789101112131415161718class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 需要时才手动调用 newInstance（） 创建 单例 public static Singleton newInstance() &#123; // 先判断单例是否为空，以避免重复创建 if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; return ourInstance; &#125; &#125; ③: 缺点: 基础实现的懒汉式是线程不安全的，具体原因如下: 可能存在多个线程并发 调用 newInstance ( ),从而重复创建单例对象 ④:具体实例: 一个线程A执行到singleton=new Singleton( ); 但还没有获得对象(因对象初始化需要时间),此时,第2个线程也在执行,执行到if (singleton == null) 判断 (判断为真,于是继续运行,创建单例对象),最终线程A ,B 同时获得了一个单例对象, 在内存中就出现两个单例类的对象,造成单例模式失效. 9.4实现方式4: 懒汉式的改进—&gt;同步锁 ①: 原理: 使用同步锁 synchronized锁住创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建 即，getInstance（）方法块只能运行在1个线程中．若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待，而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下单例对象的唯一性． ②: 具体实现: 12345678910111213141516171819202122232425262728293031323334353637 // 写法1(同步方法)class Singleton &#123; // 1. 类加载时，先不自动创建单例 // 即，将单例的引用先赋值为 Null private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限 // 原因：禁止他人创建实例 private Singleton() &#123; &#125; // 3. 加入同步锁 public static synchronized Singleton getInstance()&#123; // 先判断单例是否为空，以避免重复创建 if ( ourInstance == null ) ourInstance = new Singleton(); return ourInstance; &#125; &#125; // 写法2 (同步代码块) // 该写法的作用与上述写法作用相同，只是写法有所区别 class Singleton&#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; // 加入同步锁 synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; return instance; &#125; &#125; ④: 缺点: 每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能） 注: 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步 9.5 实现方式5: 懒汉式的改进—&gt;双重检验锁 ①: 原理: 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能 ②: 具体实现: 1234567891011121314151617181920212223242526272829303132class Singleton &#123; private static Singleton ourInstance = null； private Singleton() &#123; &#125; public static Singleton newInstance() &#123; // 加入双重校验锁 // 校验锁1：第1个if if( ourInstance == null)&#123; // ① synchronized (Singleton.class)&#123; // ② // 校验锁2：第2个 if if( ourInstance == null)&#123; ourInstance = new Singleton(); &#125; &#125; &#125; return ourInstance; &#125; &#125; // 说明 // 校验锁1：第1个if // 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作 // 即直接跳到执行 return ourInstance // 校验锁2：第2个 if // 作用：防止多次创建单例问题 // 原理 // 1. 线程A调用newInstance()方法，当运行到②位置时，此时线程B也调用了newInstance()方法, // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕 // 3. 当线程A释放同步锁时，单例已创建，即instance已非空 // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 为非空（单例已创建），因此也不会创建多余的实例 ③: 缺点: 实现复杂 = 多种判断，易出错 9.6 实现方式6: 静态内部类 ①: 原理: 根据 静态内部类 的特性，同时解决了按需加载、线程安全的问题，同时实现简洁 在静态内部类里创建单例，在装载该内部类时才会去创建单例 线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例 ②: 具体实现: 123456789101112131415161718192021222324class Singleton &#123; // 1. 创建静态内部类 private static class Singleton2 &#123; // 在静态内部类里创建单例 private static Singleton ourInstance = new Singleton()； &#125; // 私有构造函数 private Singleton() &#123; &#125; // 延迟加载、按需创建 public static Singleton newInstance() &#123; return Singleton2.ourInstance; &#125; &#125; // 调用过程说明： // 1. 外部调用类的newInstance() // 2. 自动调用Singleton2.ourInstance // 2.1 此时单例类Singleton2得到初始化 // 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例； // 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性 // 3. 最终只创建1个单例 参考文章:https://www.jianshu.com/p/b8c578b07fbc]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识设计模式]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[前言: 我们学习程序设计语言，有必要学习它的设计模式吗？当然是有必要的，程序里有一些“模式”可以发掘的。因为你可以借鉴以往的经验，避免走很多弯路，更快的构造新的程序，提高开发效率。 一、设计模式是什么？ 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 简言之：模式：在某些场景下，针对某类问题的某种通用的解决方案。 二、设计模式历史背景? 埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides，后以“四人帮”（Gang of Four，GoF）著称，简称 GoF ，在 95年的时候整理归纳出 23 种最常用的设计模式，并编写成一本书 Design Patterns: Elements of Reusable Object-Oriented Software 就是：《设计模式：可复用面向对象软件的基础》 。 三、设计模式的六大原则:开闭原则（Open Close Principle)：模块应尽量在不修改原代码(闭)的情况下进行扩展(开)。即在程序需要进行拓展的时候，不能去修改原有的代码（闭），实现一个热插拔的效果。 里氏替换原则（Liskov Substitution Principle）：如果调用的是父类的话，那么换成子类也完全可以运行。 派生类能够在基类的基础上增加新的行为。只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒置原则（Dependence Inversion Principle）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。2、抽象不应该依赖于具体实现，具体实现应该依赖于抽象。要求对抽象/接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 接口隔离原则 (Interface Segregation Principle)：每一个接口应该是一种角色，不干不该干的事，该干的事都要干。降低类之间的耦合度。 合成复用原则 (Composite Reuse Principle)：要尽量使用组合/ 聚合，尽量不要使用继承。只有“Is - A” 关系才符合继承关系，“Has- A” 关系应当使用聚合来描述。 迪米特法则 (Demeter Principle)（也称最少知识原则）：一个对象应对其它对象有尽可能少的了解。即一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。简言之：只与直接的朋友通信 四、设计模式的三大分类:创建型模式：共5种, 对象实例化的模式，创建型模式用于解耦对象的实例化过程。 结构型模式：共7种, 把类或对象结合在一起形成一个更大的结构。 行为型模式：共11种, 类和对象如何交互，及划分责任和算法。 五、23种设计模式:单例模式：某个类只能有一个实例，提供一个全局的访问点。 工厂方法(Factory Method)：定义一个创建对象的接口，让子类决定实例化那个类。 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。 普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象 静态工厂方法模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。 原型模式：通过复制现有的实例来创建新的实例。 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。 组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。 装饰模式：动态的给对象添加新的功能。 代理模式：为其他对象提供一个代理以便控制这个对象的访问。 享元模式：通过共享技术来有效的支持大量细粒度的对象。 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。 观察者模式：对象间的一对多的依赖关系。 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。 中介者模式：用一个中介对象来封装一系列的对象交互。 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。 参考文章: https://zhuanlan.zhihu.com/p/28737945https://www.cnblogs.com/pony1223/p/7608955.htmlhttps://juejin.im/post/59b78dfe5188257e7e115caehttps://www.jianshu.com/p/72764b69d6cf]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子网划分的经典实例]]></title>
    <url>%2F%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[案例:例1:一家集团公司有12家子公司，每家子公司又有4个部门。上级给出一个172.16.0.0/16的网段，让给每家子公司以及子公司的部门分配网段。 例2:某集团公司给下属子公司甲分配了一段IP地址192.168.5.0/24，现在甲公司有两层办公楼（1楼和2楼），统一从1楼的路由器上公网。1楼有100台电脑联网，2楼有53台电脑联网。如果你是该公司的网管，你该怎么去规划这个IP？ 例3:请问 192.168.10.0/26 有多少子网?每个子网有多少主机?有多少合法子网?每个子网的广播地址是多少?哪些是合法主机号? 分析:例1：通过子网数来划分子网，未考虑主机数。 例2：通过计算主机数来划分子网。 例1 思路：既然有12家子公司，那么就要划分12个子网段，但是每家子公司又有4个部门，因此又要在每家子公司所属的网段中划分4个子网分配给各部门。 例1步骤：A. 先划分各子公司的所属网段。 有12家子公司，那么就有2的n次方≥12，n的最小值=4。因此，网络位需要向主机位借4位。那么就可以从172.16.0.0/16这个大网段中划出2的4次方=16个子网。 详细过程： 先将172.16.0.0/16用二进制表示 10101100.00010000.00000000.00000000/16 借4位后（可划分出16个子网）： 1) 10101100. 00010000 . 00000000.00000000/20【172.16.0.0/20】 2) 10101100.00010000.00010000.00000000/20【172.16.16.0/20】 3) 10101100.00010000.00100000.00000000/20【172.16.32.0/20】 4) 10101100.00010000.00110000.00000000/20【172.16.48.0/20】 5) 10101100.00010000.01000000.00000000/20【172.16.64.0/20】 6) 10101100.00010000.01010000.00000000/20【172.16.80.0/20】 7) 10101100.00010000.01100000.00000000/20【172.16.96.0/20】 8) 10101100.00010000.01110000.00000000/20【172.16.112.0/20】 9) 10101100.00010000.10000000.00000000/20【172.16.128.0/20】 10) 10101100.00010000.10010000.00000000/20【172.16.144.0/20】 11) 10101100.00010000.10100000.00000000/20【172.16.160.0/20】 12) 10101100.00010000.10110000.00000000/20【172.16.176.0/20】 13) 10101100.00010000.11000000.00000000/20【172.16.192.0/20】 14) 10101100.00010000.11010000.00000000/20【172.16.208.0/20】 15) 10101100.00010000.11100000.00000000/20【172.16.224.0/20】 16) 10101100.00010000.11110000.00000000/20【172.16.240.0/20】 我们从这16个子网中选择12个即可，就将前12个分给下面的各子公司。每个子公司最多容纳主机数目为2的12次方-2=4094。 B. 再划分子公司各部门的所属网段 以甲公司获得172.16.0.0/20为例，其他子公司的部门网段划分同甲公司。 有4个部门，那么就有2的n次方≥4，n的最小值=2。因此，网络位需要向主机位借2位。那么就可以从172.16.0.0/20这个网段中再划出2的2次方=4个子网，正符合要求。 详细过程： 先将172.16.0.0/20用二进制表示 \10101100. 00010000. 00000000.00000000/20 借2位后（可划分出4个子网）： ① 10101100.00010000.00000000.00000000/22【172.16.0.0/22】 ② 10101100.00010000.00000100.00000000/22【172.16.4.0/22】 ③ 10101100.00010000.00001000.00000000/22【172.16.8.0/22】 ④ 10101100.00010000.00001100.00000000/22【172.16.12.0/22】 将这4个网段分给甲公司的4个部门即可。每个部门最多容纳主机数目为2的10次方-2=1024 例2思路:我们在划分子网时优先考虑最大主机数来划分。在本例中，我们就先使用最大主机数来划分子网。101个可用IP地址，那就要保证至少7位的主机位可用（2的m次方-2≥101，m的最小值=7）。如果保留7位主机位，那就只能划出两个网段，剩下的一个网段就划不出来了。但是我们剩下的一个网段只需要2个IP地址并且2楼的网段只需要54个可用IP，因此，我们可以从第一次划出的两个网段中选择一个网段来继续划分2楼的网段和路由器互联使用的网段。 例2 步骤：根据需求，画出下面这个简单的拓扑。将192.168.5.0/24划成3个网段，1楼一个网段，至少拥有101个可用IP地址；2楼一个网段，至少拥有54个可用IP地址；1楼和2楼的路由器互联用一个网段，需要2个IP地址。 A. 先根据大的主机数需求，划分子网因为要保证1楼网段至少有101个可用IP地址，所以，主机位要保留至少7位。 先将192.168.5.0/24用二进制表示： 11000000.10101000.00000101.00000000/24 主机位保留7位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.00000000/25【192.168.5.0/25】 ② 11000000.10101000.00000101.10000000/25【192.168.5.128/25】 1楼网段从这两个子网段中选择一个即可，我们选择192.168.5.0/25。 2楼网段和路由器互联使用的网段从192.168.5.128/25中再次划分得到。 B. 再划分2楼使用的网段2楼使用的网段从192.168.5.128/25这个子网段中再次划分子网获得。因为2楼至少要有54个可用IP地址，所以，主机位至少要保留6位（2的m次方-2≥54，m的最小值=6）。 先将192.168.5.128/25用二进制表示： 11000000.10101000.00000101.10000000/25 主机位保留6位，即在现有基础上网络位向主机位借1位（可划分出2个子网）： ① 11000000.10101000.00000101.10000000/26【192.168.5.128/26】 ② 11000000.10101000.00000101.11000000/26【192.168.5.192/26】 2楼网段从这两个子网段中选择一个即可，我们选择192.168.5.128/26。 路由器互联使用的网段从192.168.5.192/26中再次划分得到。 C. 最后划分路由器互联使用的网段路由器互联使用的网段从192.168.5.192/26这个子网段中再次划分子网获得。因为只需要2个可用IP地址，所以，主机位只要保留2位即可（2的m次方-2≥2，m的最小值=2）。 先将192.168.5.192/26用二进制表示： 11000000.10101000.00000101.11000000/26 主机位保留2位，即在现有基础上网络位向主机位借4位（可划分出16个子网）： ① 11000000.10101000.00000101.11000000/30【192.168.5.192/30】 ② 11000000.10101000.00000101.11000100/30【192.168.5.196/30】 ③ 11000000.10101000.00000101.11001000/30【192.168.5.200/30】 ………………………………… ④ 11000000.10101000.00000101.11110100/30【192.168.5.244/30】 ⑤ 11000000.10101000.00000101.11111000/30【192.168.5.248/30】 ⑥ 11000000.10101000.00000101.11111100/30【192.168.5.252/30】 路由器互联网段我们从这16个子网中选择一个即可，我们就选择192.168.5.252/30。 D. 整理本例的规划地址1楼：网络地址：【192.168.5.0/25】 最小地址为11000000 10101000 00000101 00000000 即 192.168.5.0 最大地址为11000000 10101000 00000101 01111111 即 192.168.5.127 主机位全0全1的不能作为主机IP，因为主机位全1 的要用来作 广播地址即192.168.5.127 剩下的可以分配作为主机的IP 主机IP地址：【192.168.5.1/25—192.168.5.126/25】 广播地址：【192.168.5.127/25】 2楼：网络地址：【192.168.5.128/26】 主机IP地址：【192.168.5.129/26—192.168.5.190/26】 广播地址：【192.168.5.191/26】 路由器互联： 网络地址：【192.168.5.252/30】 两个IP地址：【192.168.5.253/30、192.168.5.254/30】 广播地址：【192.168.5.255/30】 快速划分子网确定IP: 以例2为例：题目需要我们将192.168.5.0/24这个网络地址划分成能容纳101/54/2个主机的子网。因此我们要先确定主机位，然后根据主机位决定网络位，最后确定详细的IP地址。 ① 确定主机位 将所需要的主机数自大而小的排列出来：101/54/2，然后根据网络拥有的IP数目确定每个子网的主机位：如果2的n次方-2≥该网段的IP数目，那么主机位就等于n。于是，得到：7/6/2。 ② 根据主机位决定网络位 用32减去主机位剩下的数值就是网络位，得到：25/26/30。 ③ 确定详细的IP地址 在二进制中用网络位数值掩盖IP前面相应的位数，然后后面的为IP位。选取每个子网的第一个IP为网络地址，最后一个为广播地址，之间的为有效IP。得到： 【网络地址】 【有效IP】 【广播地址】 【192.168.5.0/25】【192.168.5.1/25-192.168.5.126/25】【192.168.5.127/25】 【192.168.5.128/26】【192.168.5.129/26-192.168.5.190/26】【192.168.5.191/26】 【192.168.5.192/30】【192.168.5.193/30-192.168.5.194/30】【192.168.5.195/30】 例3: 分析首先就是要理解/26的意思。首先一看就是个C类地址，所以其默认子网掩码是255.255.255.0。这个子网掩码是由3个.来分隔的，而且这是10进制表示出来的，把它化为2进制=11111111.11111111.11111111.00000000前面是24个1。所以默认的C类子网掩码被写成/24。 这道题是/26，也就是有26个1，写出来就是11111111.11111111.11111111.11000000。把它划成10进制就是255.255.255.192, 现在知道了子网掩码就可以回答那5个问题了 1.有多少个子网？ 这有个公式的。子网数目=2的X次方，这里的X是指掩码位数，掩码为数可以用我们现在的子网掩码的1的为数减去默认的1的位数。这道题有子网掩码有26个1，而C类默认有24个1，所以就是26-24=2。子网数=2的2次方=4 2.每个子网的主机数？ 这还是由公式的。子网主机数=2的Y次方-2，这里的Y是非掩码位的位数，即子网掩码中0的个数，刚才已经知道有26个1了，那剩下的就都是0了，一共有32位，现在有26个1剩下的就只有6个0。所以子网主机数=2的6次方-2=62 3.哪些是合法子网？ 这里牵扯了块这个概念，块=256 - 子网掩码。这里就是 - 192 ，所以这道题块=64 ，知道了块就把块从0开始加，一直加到256，这之间的数就是合法子网。0+64=64 64+64=128 128+62=192 192+64=256 所以合法子网就是0 64 128 192 4.每个子网的广播地址是多少？ 广播地址=下一个子网号-1 所以0子网的广播地址是63；64子网的广播地址是127；128子网的广播地址是191；192子网的广播地址是255 5.哪些是合法主机号？ 合法主机号是那些介于个子网之间的取值，并要减去全0和全1的主机号，例如：64是子网号码，127是广播地址，那么65–126就是合法地址。 所以0子网的合法地址是1–62；64子网的合法地址是65–126；128子网的合法地址是129==190；192子网的合法地址是193–254 总结:子网划分无非涉及到这些内容: 1.有多少子网 2.每个子网有多少主机 3.有多少合法子网 4.每个子网的广播地址是多少: 广播地址下一个子网号-1 5.哪些是合法主机号]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>子网划分实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识计算机网络]]></title>
    <url>%2F%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[前言: 计算机网络可以说是连通世界的桥梁，推动发展的催化剂，正是计算机网络技术让信息传播速度更快，让我们能随时随地在线看视频、听音乐、查资料、看新闻、分享资源,试想一下如果没有计算机网络这门学科，我们的世界还会有今天这么繁荣吗？ 一、计算机网络是什么？ 计算机网络技术是通信技术与计算机技术相结合的产物。计算机网络是按照网络协议，将地球上分散的、独立的计算机相互连接的集合。连接介质可以是电缆、双绞线、光纤、微波、载波或通信卫星。计算机网络具有共享硬件、软件和数据资源的功能，具有对共享数据资源集中处理及管理和维护的能力． 二、发展历史：其发展经历了四个阶段: ①:20世纪50~60年代，出现以单个计算机为中心的远程连机系统，构成面向终端的计算机网络； ②:20世纪60~70年代，出现了多个主计算机通过通信线路互连的计算机网络。ARPANET投入使用； ③:20世纪70~80年代，出现具有统一的网络体系结构，遵循国际标准化协议的计算机网络。 ④:从90年代算起，网络互联与高速网络。 我国在1980年开始进行计算机联网实验，1989年，我国第一个分组交换网CNPAC建成运行. 三、特点：①: 连通性 ②: 共享 四、分类：4.1 按作用范围分类:①: WAN（Wide Area Network）广域网：几十到几千KM ②: MAN（Metropolitan Area Network）城域网：一个城市（5~50KM） ③: LAN（Local Area Network）局域网：1KM左右 ④: PAN（Personal Area Network）个人区域网：10m左右 4.2 按传输介质分类:①: 有线网：是采用同轴电缆或双绞线连接的计算机网络。同轴电缆网是常见的一种连网方式，它比较经济，安装较为便利，传输率和抗干扰能力一般，传输距离较短。双绞线网是目前最常见的连网方式。它价格便宜，安装方便，但易受干扰，传输率较低，传输距离比同轴电缆要短。 ②: 光纤网：也是有线网的一种，但由于其特殊性而单独列出。光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。但其成本较高，且需要高水平的安装技术。 ③: 无线网：用电磁波作为载体来传输数据，目前无线网联网费用较高，还不太普及。但由于联网方式灵活方便，是一种很有前途的连网方式。 局域网通常采用单一的传输介质，而城域网和广域网采用多种传输介质。 4.3 按通信方式分类:①: 点对点传输网络：数据以点到点的方式在计算机或通信设备中传输。星型网、环形网采用这种传输方式。 ②: 广播式传输网络：数据在公用介质中传输。无线网和总线型网络属于这种类型。 五、应用:①: 通信服务: 如在线聊天（飞信,MSN、QQ等）、E-mail 、IP 电话等服务 ②: 多媒体信息服务: 包括网上娱乐、网络电视、电视会议、WWW服务、远程教育和音乐点播等。 ④: 办公自动化: 将一个单位的其它办公设备与办公用计算机连接成网络, 加强了外部和单位内部的沟通与联系，加快单位内部的信息流动，提高工作效率，并有利于减少日常开支。 ⑤: 网上交易: 在线购物,转账等 六、什么是ISP:ISP(互联网服务提供商) 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。如中国移动,中国联通,中国电信就是ISP 七、主机之间的通信方式:7.1 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 7.2 对等（P2P）： ①：不区分客户和服务器。这里使用数字2，是因为英文的2是two，读音与to相同，所以to缩写为2②：任意端系统/节点之间可以直接通讯③：节点可能改变IP地址节点间歇性接入网络没有永远在线的服务器 八、电路交换与分组交换,报文交换:8.1 电路交换:①: 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 ②: 复用：时分多路复用：频分多路复用：在不同的频带（载波）上传输不同频道码分多路复用：广泛应用于无线链路共享（如蜂窝网，卫星通信等）每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示各用户使用相同频率载波，利用各自的码片序列编码数据各用户码片序列相互正交码片序列与编码信号的内积 8.2 分组交换:每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。报文分拆出来的一系列相对较小的数据包需要报文的拆分与重组会产生额外开销又称统计多路复用(按需共享链路) 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 8.3 报文交换:报文：源发送信息整体，比如一个文件 九、时延:总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 9.1 排队时延:分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 9.2 处理时延:主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 9.3 传输时延: 主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 9.4 传播时延:其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。 十、计算机网络体系结构 10.1 OSI模型:其中表示层和会话层用途如下：表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。会话层 ：建立及管理会话 10.2 五层协议模型:应用层 ： 为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ： 为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ： 负责源主机到目的主机数据分组（Packet）交付,可能穿越多个网络 功能: 分组转发,路由 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ： 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ： 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 10.3 TCP/IP模型: 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 十一、数据在各层之间的传递过程:在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络开篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、初始化配置:1.1 指定客户端用户名和邮箱，为了标记是谁向远程库传送数据 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 1.2查看用户名：$ git config user.name 1.3查看邮箱： $ git config user.email 1.4修改用户名：$ git config --global user.name &quot;cyx&quot; 1.5修改邮箱： $ git config --global user.email &quot;328978553@qq.com&quot; 1.6查看配置是否生效： $ git config --list 二、目录文件相关:2.1创建目录： $ mkdir /d/softwear/Program （“mkdir” 是“make Directory”; “/d/softwear/”是要创建目录的位置 “Program” 是新创建的目录） 2.2定位到Program指定目录： $ cd /d/软件/Program 2.3输出当前目录地址： $ pwd 2.4让之前创建的目录作为git可操作的仓库，此时再去刚才创建的program目录下会发现多了一个.git目录： $ git init 2.5查看当前仓库的隐藏目录，以及文件： $ ls –ah 2.6查看当前仓库的文件： $ ls 三、本地仓库关联远程库:3.1关联Github远程库：$ git remote add origin git@server-name(服务器名即github用户名)/repo-name.git(远程仓库名.git) 如：$ git remote add origin git@zzwwqq/blog.git； 3.2关联码云远程库：$ git remote add origin git@gitee.com:zwqzeq/Login_Register.git 四、操作远程仓库:4.1显示远程库的详细信息： $git remote -v 4.2本地master分支内容推送到远程库的master分支： 第一次$ git push -u origin master 以后 直接$ git push origin master 4.3删除远程库： $ git remote rm origin (origin远程库默认名称，建议不改) 4.4从远程库克隆： $ git clone git@github.com:zwqzeq/gitskills.git 4.5将本地仓库指定分支合并到远程仓库指定分支： $ git push origin dev_branch : dev_branch 4.6强行让本地分支覆盖远程分支： $ git push 远程库名 远程库的分支名 -f 4.7将远程仓库的某个分支合并到当前本地分支： $ git pull 远程仓库名 远程仓库的分支名 五、文件保存和提交:5.1将文件从工作区添加到暂存区： $ git add &lt;file&gt; 将所有文件从工作区添加到暂存区：$ git add . 5.2将文件从暂存区提交到版本库： $ git commit -m “提交说明” 5.3随时查看当前仓库的状态： $ git status 5.4查看修改了具体修改了那些内容： $ git diff &lt;file&gt; 六、日志相关：6.1查看提交历史（只有commit过的才能查到），以便确定要回退到哪个版本： $ git log 6.2如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline 6.3如果嫌输出信息太多，看得眼花缭乱的，可以不显示详细信息： $ git log --pretty=oneline --abbrev-commit 6.4查看命令历史（包括reset，commit，checkout），以便确定要回到未来的哪个版本（不包括从工作区添加（add）到暂存区的命令）： $ git reflog 七、版本回退:7.1退回到上一个版本： $ git reset --hard HEAD^ //针对版本库 7.2退回到上上个版本： $ git reset --hard HEAD^^ 7.3退回到上100个版本： $ git reset --hard HEAD~100 7.4退回到指定版本： $ git reset --hard commit_ID 7.5只丢弃暂存区修改： $ git reset HEAD &lt;file&gt; //针对暂存区，让暂存区恢复之前的状态 7.6只丢弃工作区的修改： $ git checkout --&lt;file&gt; //针对工作区，让工作区恢复之前的状态，即让工作区和暂存区一致，如果没有暂存区，则让工作区和版本库一致，如果该文件既没有添加到暂存区也没有提交到版本库，则工作区中该文件的修改不能被丢弃 八、分支相关:8.1查看分支： $ git branch 8.2创建分支： $ git branch &lt;name&gt; 8.3切换分支： $ git checkout &lt;name&gt;（注意与恢复文件的区别，此处checkout后面没有“–”） 8.4创建+切换分支： $ git checkout -b &lt;name&gt; 8.5合并某分支到当前分支： $ git merge &lt;name&gt; 8.6删除分支： $ git branch -d &lt;name&gt; 8.7重命名分支： $ git branch -m old_branch new_branch 8.8看到分支合并情况： $ git log --graph --pretty=oneline --abbrev-commit 8.9可以禁用快速合并dev方式： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev 8.10删除一般的分支： $ git branch -d &lt;name&gt; 8.11丢弃一个没有被合并过的分支，可以通过： $ git branch -D &lt;name&gt; //强行删除 九、标签相关：9.1默认标签是打在当前分支最新提交的commit上: $ git tag &lt;name&gt; 9.2指定一个commit id，给其打上标签，即以后标签可代表commit id: $ git tag &lt;name&gt; commit_id 9.3查看所有标签名： $ git tag 9.4查看标签信息： $ git show &lt;tagname&gt; 9.5指定标签信息： $ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; commit_ID 9.6删除本地标签： $ git tag -d v0.1 9.7推送某个标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin &lt;tagname&gt; 9.8推送所有标签到远程（origin 是默认的远程库名，也可换成自定义的名字）： $ git push origin --tags 9.9删除远程标签：如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除： $ git tag -d v0.9 $ git push origin :refs/tags/v0.9 十、临时保存工作现场：10.1前工作现场“储藏（或称隐藏）”起来，等以后恢复现场后继续工作： $ git stash 10.2查看某个分支上隐藏工作区： $ git stash list 10.3恢复工作现场：两种方式： 方式一：用$ git stash apply恢复,但是恢复后,stash内容并不删除,你需要用$ git stash drop来删除； 方式二：用$ git stash pop,恢复的同时把stash内容也删了 10.4 何时需要使用git stash临时保存工作现场? 在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。 可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。 该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Git]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Git.html</url>
    <content type="text"><![CDATA[前言: 你是否有这样的经历：写word文档时,想删除一部分内容，又怕将来想恢复找不回来怎么办？常见办法就是先把当前文件“另存为”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件.改到最后你自己都分不清,哪个文件里面是修改了什么. 如果有，那么恭喜你，以后不会再有这种事情发生了，git能帮你管理文件. 一、git是什么?Git是目前世界上最先进的分布式版本控制系统（没有之一）. 二、git的历史背景: 很多人都知道，Linus（李纳斯）在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。直到2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 三、分布式的git和集中式的CVS/SVN对比: 3.1 联网： 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式版本控制系统最大的毛病就是必须联网才能工作． 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。 3.2 安全性： 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 四、如何安装？在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，(或者鼠标右键,可以找到git Bash)蹦出一个类似命令行窗口的东西，就说明Git安装成功. 五、工作流:新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。 Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 中存有所有分支，使用一个 HEAD 指针指向当前分支。 git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset – files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。 git commit -a 直接把所有文件的修改添加到暂存区然后执行提交 git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作 六、冲突:当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。 Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 七、Fast forward:“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。 可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。 1$ git merge --no-ff -m "merge with no-ff" dev 八、分支管理策略:master 分支应该是非常稳定的，只用来发布新版本； 日常开发在开发分支 dev 上进行。 九、.gitignore 文件:忽略以下文件： 操作系统自动生成的文件，比如缩略图； 编译生成的中间文件，比如 Java 编译产生的 .class 文件； 自己的敏感信息，比如存放口令的配置文件。 不需要全部自己编写，可以到 https://github.com/github/gitignore 中进行查询。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>初识Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[前言:​ 为了方便查阅,这里将常用指令汇总. 简写指令:hexo n &quot;我的博客&quot; 等价于 hexo new &quot;我的博客&quot; 还等价于 hexo new post &quot;我的博客&quot; #新建一篇文章hexo p 等价于 hexo publishhexo g 等价于 hexo generatehexo s等价于 hexo serverhexo d 等价于 hexo deployhexo deploy -g 等价于 hexo deploy --generatehexo generate -d等价于hexo generate --deploy 注: hexo clean 没有 简写, git –version 没有简写 指令说明:hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。hexo server -s #以静态模式启动hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)hexo d #将本地数据部署到远端服务器(如github)hexo init 文件夹名称 #初始化XX文件夹名称npm update hexo -g#升级npm install hexo -g#安装node-v #查看node.js版本号npm -v #查看npm版本号git --version #查看git版本号hexo -v #查看hexo版本号 hexo publish [layout] &lt;title&gt; #通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 hexo new aaa &quot;bbb&quot; # 新建一篇文章,文章名称和标题分别为bbb.md 和 bbb. 文章采用aaa布局, 此时会在站点根目录下的—-&gt;source—–&gt;_post文件夹下生成bbb.md文件, bbb.md文件的顶部(—–分割线上方区域,也称作Front matter区),生成 layout: aaatitle:date:]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化配置]]></title>
    <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[前言: 如果你觉得我的博客界面不错，你可以参考这篇文章，在这篇文章中总结了几十个个性化配置，并不是都要安装，取你所需即可． 一、常用的个性化配置汇总： １．更换主题 ２．设置语言 ３．字数统计和阅读时长(网站底部/文章内) ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量） ５．本站已安全运行 XX天 XX小时XX分XX秒 ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例 ７．添加热度（文章阅读次数） ８．为博客加上宠物 ９．鼠标点击出现桃心效果 １０．网页底部的动态桃心图像 １１．添加顶部加载条 １２．设置网站的图标Favicon １３．DaoVoice 在线联系 １４．添加AddThis分享 １５．添加打赏 １６．文章加密访问 １７．在文章底部增加版权信息 １８．修改文章底部的那个带#号的标签 １９．在每篇文章末尾添加“本文结束”标记 ２０．修改作者头像并旋转 ２１．隐藏网页底部powered By Hexo / 强力驱动 ２２．在右上角或者左上角实现fork me on github ２３．修改代码块自定义样式（设置代码高亮主题） ２４．开启代码块复制 ２５．侧边栏社交链接 ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２７．修改背景图,以及侧边栏顶部颜色 ２８．侧边栏添加网易云音乐 ２９．底部添加公网安备 ３０．取消“文章目录”的自动编号 ３１．封面模式 １．更换主题: (以next主题为例)注: next 主题的 github仓库地址迁移了 １．１ 下载主题:旧版本next主题地址: 5以下的版本包含5: 旧版本5以下 安装指令: 首先打开git bash进入根目录即 “ /blog/“ 执行命令:git clone https://github.com/iissnan/hexo-theme-next themes/next 此时会从next主题的作者的github仓库克隆next主题到 我们本地的 /blog/theme/next文件夹下 最新版在这里下载: 新版本6开始 安装指令: 同上 git clone https://github.com/theme-next/hexo-theme-next themes/next 安装完成后，打开 站点配置文件,找到 theme 字段，并将其值更改为 next, 一定要保存 依次执行git clean，git g,git s 然后查看运行结果: nexT主题有四种选择，上面这个只是最简洁的一种，我选择的是Gemini布局。 １．２ 修改主题配置文件： 然后重新git clean，git g，git s查看效果: ２．设置语言：在站点配置文件中设置语言: 12language: zh-Hans next5以下版本(包含)language: zh-CN next6以上版本(包含) ３．字数统计和阅读时长(网站底部/文章内):３．１ 首先安装插件: $ npm install hexo-symbols-count-time --save ３．２ 然后修改主题配置文件如下: 123456symbols_count_time: separated_meta: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_post: true ＃显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true ＃底部footer是否显示字数统计属性文字(如站点总字数,站点阅读时长 ≈ 1 分钟) awl: 4 ＃计算字数的一个设置,没设置过 wpm: 275 ＃一分钟阅读的字数 ３．３ 站点配置文件中添加： 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 注意: 配置文件中的空格** ４．添加busuanzi: 统计浏览次数（本站总访客数，本站总访问量）打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站总访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;| &lt;/span&gt;&lt;span id="busuanzi_container_site_pv"&gt; &amp;nbsp;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; ５．本站已安全运行 XX天 XX小时XX分XX秒打开/blog/themes/next/layout/_partials/footer.swig 在文件底部添加下面的代码: 12345678910111213141516&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250);&lt;/script&gt; ６．添加评论系统(常见的有: 网易云跟帖但现在已失效，来必力，valine) ,这里以valine为例:先注册leancloud账号,获取自己的appid,appkey 打开主题配置文件,修改如下: 1234567891011valine: enable: true # 为true时启用评论 appid: # 这里填写上面得到的APP ID 注意空一格再输入ID和key, appkey: # 这里填写上面得到的APP KEY notify: false # 邮件通知 verify: false # 验证码 placeholder: #评论框中预设的文字,随意填写 avatar: mm # gravatar style 头像,采用gravatar头像,到http://cn.gravatar.com/了解 guest_info: nick,mail,link # custom comment header 访客信息,显示在评论框上面,三者可随意选择或全选 pageSize: 10 # pagination size 评论分页大小 visitor: false # ７．添加热度（文章阅读次数）修改主题配置文件 1234leancloud_visitors: enable: true app_id: #填入你leancloud账号的appid app_key: #填入你leancloud账号的appkey 打开/blog/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/blog/themes/next/languages/zh-Hans.yml,将画红框的改为热度就OK了 ８．为博客加上宠物８．１ 在hexo根目录下安装插件: $ npm install -save hexo-helper-live2d ８．２ 安装需要的宠物插件:宠物样式 源码地址 $ npm install {packagename} 其中{packagename} 替换为你要安装的宠物名,如live2d-widget-model-shizuku 具体指令: $ npm install live2d-widget-model-shizuku ８．３ 在站点配置文件中加上如下代码: 1234567891011live2d: enable: true #开启宠物 scriptFrom: local model: use: live2d-widget-model-shizuku display: position: right #指定宠物显示的位置 width: 70 #指定宠物显示的宽度 height: 120 #指定宠物显示的高度 mobile: show: true #是否在手机上显示 ９．鼠标点击出现桃心效果并且将代码复制进去，然后保存 在/themes/next/source/js/src里面 新建click-love.js文件: 粘贴如下代码: 12&lt;!-- 页面点击小桃心--&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 然后打开\themes\next\layout\_layout.swig文件,在末尾添加以下代码： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); １０．网页底部的动态桃心图像修改主题配置文件: 1234icon: name: heart #如果name的值为heart表示引用fontawesome网站上的心形图标 animated: true #如果想用动态图标应该将animated的值设为true color: "#ff0000" #图标的色--用16进制数 １１．添加顶部加载条在根目录打开git bash执行以下指令: 1git clone https://github.com/theme-next/theme-next-pace source /lib/pace 修改主题配置文件: 12pace: true #启用顶部加载条pace_theme: pace-theme-flash #指定顶部加载条样式 １２．设置网站的图标Favicon１２．１ 下载一个32*32的图片，并改名为favicon.ico, 然后放到/blog/themes/next/source/images目录 １２．２ 修改主题配置文件 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg １３． DaoVoice 在线联系１３．１ 注册地址: ,获取app_id １３．２ /blog/themes/next/layout/_partials/head/head.swig 添加下面的代码: 123456789101112131415&#123;% if theme.custom_file_path.head %&#125; &#123;% set custom_head = '../../../../../' + theme.custom_file_path.head %&#125;&#123;% else %&#125; &#123;% set custom_head = '../../_custom/head.swig' %&#125;&#123;% endif %&#125;&#123;% include custom_head %&#125;&#123;% if theme.daovoice %&#125; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0eeeae6f.js","daovoice") daovoice('init', &#123; app_id: "06289ecd"&#125;);daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; １３．３ 修改主题的配置文件 12daovoice: truedaovoice_app_id: 我们注册获取的id １４．添加AddThis分享１４．１ 在网站 AddThis 上注册账号。 可以使用 Google/Facebook/Twitter 账号进行第三方登陆 １４．２ 设置分享按钮的样式:(显示位置, 显示样式为扩展式,悬浮式等) １４．３ 修改主题配置文件 你Addthis账号ID ```123456789## １５．添加打赏:```javascript reward: enable: true ＃开启 comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ ＃图片上方显示的文本 wechatpay: ＃图片地址 alipay: ＃图片地址 １６．文章加密访问１６．１ 在 /blog/themes/next/layout/_partials/head/head.swig 文件中添加： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; １６．２ 在需要加密的文章的页面顶部(Front matter区域)加入 “password : 设置密码值” １７．在文章底部增加版权信息１７．１ 在/blog/themes/next/layout/_macro/ 下添加 my-copyright.swig文件： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;版权声明:&lt;/span&gt;本博客所有文章除特别声明外，均采用 &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt;BY-NC-SA &lt;/a&gt;许可协议。转载请注明出处!&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; １７．２ 在目录/blog/themes/next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; １７．３ 修改/blog/themes/next/layout/_macro/post.swig，在下面位置添加: 代码如下: 12345 &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １７．４ 修改/blog/themes/next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： @import &quot;my-post-copyright 保存重新生成即可。１７．５ 如果要在文章下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: hexo个性化配置date: 2017-05-22 22:53:53tags: hexo美化categories: Hexocopyright: true--- 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： １８．修改文章底部的那个带#号的标签修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; １９．在每篇文章末尾添加“本文结束”标记１９．１ 在路径 /blog/themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; １９．２ 接着打开/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer之前添加,即在如下位置添加 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; １９．３ 然后打开主题配置文件（_config.yml),在末尾添加： 123#文章末尾添加“本文结束”标记passage_end_tag: enabled: true ２０．修改侧边栏作者头像并旋转：２０．１ 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; ２１．隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： ２2．在右上角或者左上角实现fork me on github点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 /blog/themes/next/layout/_layout.swig文件中进行配置. next表示的是当前你使用的主题的样式. 注意的是: href 后面是自己的github的地址,记得修改哦! ２３．修改代码块自定义样式修改主题配置文件 highlight_theme: night bright #可选值: normal | night | night eighties | night blue | night bright ２４．开启代码块复制123codeblock: enable: true show_result: true ２５．侧边栏社交链接修改主题配置文件: 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址 123456789101112131415161718#设置侧边栏社交链social: GitHub: https://github.com/zzwwqq || github E-Mail: mailto:zwq13264860490@gmail.com || envelope Weibo: https://weibo.com/u/5564810309/home?wvr=5 || weibo 知乎: https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities || snapchat#这里键的值必须和上面social中的 "||" 后面指定的名称一致，在fontawesome官网找喜欢的小图标，将名字复制在如下位置，如E-Mail:对应的图标名称为envelope。social_icons: enable: true # `enable` 选项用于控制是否显示图标 icons_only: false transition: false #图标 GitHub: github E-Mail: envelope Weibo: weibo 知乎: snapchat ２６．图片处理(使用七牛云为Hexo存储图片等静态资源) ２６．１ 七牛是什么? 七牛 是一个云存储服务商，注册并实名认证之后1后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。七牛的定位不是像百度云一样的 网盘 ，也不是同坚果云一般的 同步云 ，而是 CDN 2 ，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源。对于个人博主来说，你可以把博客中的图片、音频、视频等媒体上传到七牛，在博客中引用；也可以将站点需要加载的CSS、JS等文件上传到七牛，以加速网站。 ２６．２ 与其他上传站点相比： 更稳定：七牛毕竟是老牌服务商，数据的安全性和稳定性都较有保证。如果上传到什么小网站，哪天发现图片都打不开了才是人间惨剧~ 更灵活：配合 hexo-qiniu-sync 插件4，就算是七牛以后更改了空间域名，也不用一篇一篇地去改外链地址，只要在配置文件中修改外链前缀即可。 更方便：配合 hexo-qiniu-sync 插件，不必”上传→复制链接→引用外链“，直接按照本地路径引用，然后键入一条命令同步到七牛就好。会自动识别哪些是新增、修改的文件需要上传，哪些是原有的文件不需改动，十分方便。 ２６．３ 七牛并非尽善尽美： 在线文件管理不支持目录 本地删除文件，云端不能同步删除文件 ２６．４ 开始安装： １．点击 这里 申请七牛账户 ２．创建存储空间（七牛叫作”Bucket“），注意添加的空间为”对象存储“，访问控制选择”公开空间“： ３．点击页面右上角头像→进入”密钥管理“→复制当前使用中的AK和SK，待会设置插件时会用到。 ４．安装插件：在hexo主目录下运行以下命令： npm install hexo-qiniu-sync --save ５．站点配置文件中添加下面内容: 1234567891011121314151617181920qiniu: offline: false #是否离线. 离线状态将使用本地地址渲染 sync: true #是否同步 bucket: blog #这里替换为你存储空间的名称 #secret_file: sec/qn.json or C: access_key: 2rRw0dG-jQYCoqs9rvsltVQqzSBVpwS #上传密钥AccessKey,替换为你自己的 secret_key: OCBcCU3tqKiBdOza9PlLoR6AcA-fV_u #上传密钥SecretKey,替换为你自己的 dirPrefix: static #上传的资源子目录前缀.如设置为static，那么urlPrefix后面也要加static urlPrefix: http://cdn.zzwwqq.xyz/static/ #这里替换为你自己的外链域名,如何获取,查看下面图示 up_host: http://upload.qiniu.com #这里不用改 local_dir: static #本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的static 文件夹（也就是与 source 目录平级）中。 update_exist: true #是否更新已经上传过的文件 #运行程序后,会自动在本地根目录生成static目录,static目录下生成三个文件夹,js,css,images image: folder: images extend: js: folder: js css: folder: css ６．如何引用七牛上的图片? 引用地址：urlPrefix＋dirPrefix＋images+ 相对于/blog/static/images/ 的文件路径 例如: http://cdn.zzwwqq.xyz/static/images/hexo/hexo-1.jpg ２７．修改背景图,以及侧边栏顶部颜色，主／副标题颜色效果图： 123456789101112131415161718192021//添加背景图片body &#123; background:url(http://cdn.zzwwqq.xyz/%E6%98%9F%E7%A9%BA.jpg)&#125;//改掉题头颜色.site-meta &#123;background:url(http://cdn.zzwwqq.xyz/static/images/hexo/hexo-0-site-meta.jpg) &#125;//主标题颜色.brand&#123; color: #4dfc23 &#125;//副标题颜色.site-subtitle&#123; color: #4dfc23&#125;.footer&#123; font-size: 14px; color: #ededed;&#125; ２８．侧边栏添加网易云音乐效果图: 打开网易云音乐官网，进入想插入的音乐的界面 点击“生成外链播放器” 复制代码 ##２９．底部添加公网安备 12345 &lt;div class="BbeiAn-info" style="color:#4dfc23"&gt; &#123;&#123; __('鄂ICP备') &#125;&#125; - &lt;a target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#4dfc23;" rel="nofollow"&gt;18025394&lt;/a&gt; &lt;!--a标签中增加nofollow属性，避免爬虫出站。--&gt;| &lt;a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42090202000295" style="text-decoration:none;color:#4dfc23;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow"&gt;&#123;&#123; __('鄂公网安备 42090202000295') &#125;&#125;&lt;/a&gt; &lt;!--这里将图标作为了背景，以使得能和后面的文字在同一行--&gt;&lt;/div&gt; ３０．取消“文章目录”的自动编号 修改如下 修改后: ３１．封面模式需要安装一个小插件是：hexo-less，安装指令: $ npm install --save hexo-less 该插件解决了什么问题呢？ 手动设置文章概要，但不影响章内䆟。只需在文章中写 &lt;!-- less --&gt; 作为分割线， &lt;!-- less --&gt; 上面的内容会作为摘要，但不作为文章内容的一部分。 举例，我想让这篇文章在主页列表中，只显示一张美图。 效果图： 文章中代码如下: 二、说明:修改hexo的站点配置文件,需要重启服务器(即执行 $ hexo s命令),才能生效. 修改其他文件如主题配置文件,不必重启服务器(即执行 $ hexo s命令), 直接刷新页面即可生效. 参考链接: http://theme-next.iissnan.com/getting-started.html https://www.jianshu.com/p/f054333ac9e6 https://www.jianshu.com/p/d0fe52c73950 https://xian6ge.cn/posts/40ba2cba/ https://me.idealli.com/post/e8d13fc.html http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/ https://www.jianshu.com/p/805bd0b65d98]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo发布文章]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[前言: 经过前面两节的操作，hexo的整个框架以及和github关联已经配置好了,现在我们要考虑的就是 如何用指令去创建一篇文章,然后发布? .我们先来看一下hexo的目录结构,了解每个目录的作用,这将让我们对hexo的运行原理有一个大概的认识,对于我们后面美化主题是有帮助的, 然后再来创建文章,并发布到本地服务器,最后查看效果. 一、Hexo的目录分析: １．.deploy_git: 这个目录是执行 hexo d 命令 后生成的,主要存放部署的信息. ２．node_modules: 这个目录存放的是一些插件包 ３．public : 这个目录是执行 hexo g后生成的, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下 ４．scaffolds: 用来存放模板文件。模板文件的正文部分一般为空，一般在模板文件顶部有一个区域 ( 以 --- 分隔的区域) 称作Front-matter,在这里配置的变量主要有title(即文章标题), date(即文章创建日期),comment(是否开启评论), tags(文章标签), categories(文章所属分类)等. 当你新建文章时，Hexo 会根据 scaffold 来建立文件，也就是说会在你创建的每个文件顶部自动加上模板文件中配置的这些内容. ５．source: 存放你的文章(.md后缀的文件) ６．static: 这个目录是我自己创建的，专门用来存放图片的 ７．themes: 这个目录是存放主题的(默认主题是landscape, 目前使用最多的是next主题) ８．.gitignore: 这个文件和git有关, 在这个文件里面可以配置哪些文件不被提交(例如: 配置 *.log ,那么在hexo d命令的时候, 任何以.log为后缀的文件将不会被提交到github) ９．_admin-config.yml: 这个文件是安装了hexo 后台管理插件后生成的,这里暂时不作介绍,后面再说 １０．_config.yml: 这个文件是hexo的核心配置文件(也称站点配置文件) １１．_config.yml.back.yml: 这个文件是我自己创建的,是站点配置文件的备份. 以防哪一天老眼昏花把内容改错了,到时可以恢复. １２．package.json: 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 １３．db.json： １４．package-lock.json: 二、使用Hexo指令创建一篇文章:​ $ hexo new [layout] &lt;title&gt; 这里有必要对指令作一些说明: 就[layout]即＂布局＂ 而言:Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局: 路径: 说明: post source/_posts 如果你输入的指令中[layout]参数空着,那么默认是post;例如:hexo new 我的第一篇文章;等价于:hexo new post 我的第一篇文章; 产生的作用就是: 在source/_posts路径下生成 “我的第一篇文章.md” 文件,这个就是你要写文章的那个文件. page source draft source/_drafts 你可以通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] &lt;title&gt;,草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 就&lt;title&gt;而言:默认是指定文章的标题和.md文件名称, 你可以任意指定一个名称来取代指令中的&lt;title&gt;参数. 注: 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 三、举例: 需求: 我要创建一篇文章,文件名为 “使用hexo发布文章” 文章标题为”使用hexo发布文章” 并且自动在文件顶部(Front-Matter区域),添加文章分类,标签 的键, 键对应的值由我们自己添加.最后发布到本地服务器查看效果. 首先修改模板文件: 打开git bash 执行指令: 查看生成文件所在目录以及文件名: 查看生成的文章, 文章标题,分类,标签等是否自动添加了: 给文章添加分类,和标签: 发布文章到本地服务器: $ hexo clean $ hexo g $ hexo s 查看效果: 四、给文章添加多个标签有两种方式: 第一种： tags: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39; ] 第二种： 1234tags: - abc- def- xxx 注意空格 五、说明: 通过上面的操作后，你可能会感到奇怪，为什么自己的界面和图示的不一样呢？这里我得解释下，在第一节安装hexo时,hexo默认给我们安装了ｌａｎｄｓｃａｐｅ主题. 这个主题可以在 “/blog/themes” 路径下找到. 而我安装的是next主题,并做了些个性化配置. 所以和你的界面不同. 如果你和我一样对默认主题不满意,喜爱折腾,追求完美,那么请关注下一节内容.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>使用hexo发布文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署到GitHub]]></title>
    <url>%2Fhexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub.html</url>
    <content type="text"><![CDATA[前言: 上一节我们已经将hexo部署到本地了，但是只有在你自己主机上才能查看博客，如果你想让任何人随时随地都能访问到你的博客，那么你可以考虑将hexo部署到github(属于国外,所以访问速度要慢一些)或者codying(国内),如果你是一个程序员,那么推荐你选择github, 你要是不知道GitHub， 那就太说不过去了， 我可能遇到了一个假的程序员！ 步骤: １．注册一个github账号: 注册 ２．回到你的本地机,打开git bash,设置用户名和邮箱:(目的是:上传文件的时候告诉github,是谁向远程仓库上传数据) $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 注: 这里”Your Name” 替换为你的GitHub的用户名,”email@example.com“替换为你的GitHub的邮箱 输入完后,通过以下命令检查你的设置是否正确: (如果你比较懒,那就忽略吧!) $ git config user.name $ git config user.email ３．生成ＳＳＨ密钥并添加到github： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 此时它会告诉你已经生成了.ssh的文件夹, 在你的电脑中找到它,复制id_rsa.pub 文件中的内容. 此时回到GitHub页面 ​ 然后回到gitbash中，输入指令查看是否添加成功: $ ssh -T git@github.com ；如果你看到以下内容，恭喜你配置成功了． ４．创建github仓库: ​ ​ 选择一个主题: (临时测试用,等会会覆盖的) 浏览器地址栏输入用户名.github.io：如果出现下面的界面说明你的域名已经生效 ５．将Hexo部署到github: 经过上面的操作后,此时我们就可以将hexo和GitHub关联起来了,也就是将hexo生成的文章部署到github 打开站点配置文件(/blog/_config.yml), 翻到最后,找到deploy: 修改为:​ 123deploy: type: git repo: github: git@github.com:zzwwqq/zzwwqq.github.io.git,master 说明: master 表示 部署到远程仓库的master分支上 git@github.com:zzwwqq/zzwwqq.github.io.git 改为你的仓库地址, 你可以去github网页上拷贝 安装deploy-git, 也就是部署的命令,这样你才能用命令部署到GitHub. $ npm install hexo-deployer-git --save 然后执行下述命令: hexo clean hexo g hexo d 执行了hexo d后 ,如果最后一行显示如下内容,说明部署成功, 现在你可以去浏览器地址栏输入 你的域名进行访问了.]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo部署到GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[１．帮助：(查看指令的详细信息)1.1 xxx --help (xxx -h) 1.2 man xxx ２．查看哪个程序占用了特定端口？占用某个端口的进程是谁?2.1 lsof -i -n -P | grep :80 //查看哪个程序占用了特定端口 2.2 lsof -i//显示所有打开的端口 2.3 lsof -i:80 //显示所有打开80端口的进程 2.4 lsof -n //不将IP转换为hostname，缺省是不加上-n参数 -P //port numbers to port names; ３．查看磁盘使用情况： 查看磁盘中指定目录的使用情况：du -ach --max-depth=1 指定目录的路径 查看系统磁盘占用情况：df -lh ４．进程相关操作： 查看系统执行的进程（不包括父进程）：ps -aux | more (ps -aux | grep xxxx) 查看当前所有进程，包括父进程：ps -ef | more (ps -ef | grep xxxx) 查看系统负载：w 动态查看负载: top 在 top 状态下: 按shift + m，可以按照内存使用大小排序。 按数字 1 可以列出各颗 cpu 的使用状态。 静态查看系统负载：top -bn1 和 top 命令唯一的区别就是，它一次性全部把所有信息输出出来而非动态显示。 查看系统当前剩余多少内存： free -h (-h及human，以方便人阅读方式显示) 杀死进程：kill 进程号 强制杀死进程：kill -9 进程号 按照进程名强制杀死该进程名的所有进程：pkill -9 进程名 按照进程名杀死进程：killall 进程名 ５．查看系统信息： 查看内核版本号：uname -r 查看系统内核版本，gcc编译器版本详细信息： cat /proc/version 查看系统信息：cat /etc/redhat-release 查看操作系统版本所有信息: lsb_release -a 查看内存信息 cat /proc/meminfo 查看网卡信息 dmesg | grep -i eth 查看机器型号 dmidecode | grep &quot;Product Name&quot; 查看硬盘信息命令 : fdisk -l 查看主板信息 dmidecode |grep -A16 &quot;System Information$&quot; 查看CPU信息（型号) cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看CPU的主频 cat /proc/cpuinfo |grep MHz|uniq 查看当前CPU运行在32bit还是64bit模式下 getconf LONG_BIT 查看是否支持64bit cat /proc/cpuinfo | grep flags | grep &#39;lm&#39; | wc -l (如果结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit) 查看CPU是几核: cat /proc/cpuinfo |grep &quot;cores&quot;|uniq 逻辑CPU个数：cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l 物理CPU个数： cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l 每个物理CPU中Core的个数： cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l ６．查看网络： 查看当前主机的ip地址和网卡信息: ifconfig （附加网卡的启用ifup eth0与停用stop eth0命令） 查看IP地址信息：ip addr (注：安装minimal版的CentOS系统时，ifconfig等网络相关的指令用不了，暂时可以用ip addr) 测试网络的连通性 : ping (网络统计)命令显示连接信息,路由表信息等: netstat 通常配合使用参数，这里只演示一个参数。netstat -? 打印网络连接状况：netstat -anp （-p表示显示进程名和进程ID） 当前系统启动哪些端口：netstat -lnp （-l表示显示正在监听的端口)netstat指令无效时：使用yum install net-tools安装 路由跟踪命令: traceroute 可以查看到你从源到目的的所经过的路由 查询DNS相关信息记录,CNAME,MX记录等等: dig 这个命令主要用于解决相关DNS查询； ​ nslookup 也具备查询DNS的功能，还可以显示一个ip地址的记录！ 查找到IP的名称或IP的名字在IPv4和IPv6 DNS记录和查询: host IP地址 例如host www.baidu.com 查看主机名: hostname 或者你可以到/etc/sysconfig/network中修改主机名。 查看路由表信息: route 增加和删除路由条目: root add -net 192.168.199.129/24 gw 192.168.199.1 查看默认的表使用: arp 为地址解析协议 查看网络模式和网络速度等信息: ethtool 有关配置可以到/etc/sysconfig/network-scripts/ifcfg-eth0下进行修改。 ７．任务调度： 编辑定时任务：crontab -e 删除：crontab -r 查询：crontab -l 重启：service crond restart ８．压缩/解压缩： 解压到当前目录：tar -zxvf xxx.tar.gz 解压到指定目录：tar -zxvf xxx.tar.gz -C 目标目录 压缩：tar -zcvf 打包后的文件名（以.tar.gz为后缀） 要压缩的文件名 tar里面没有针对xz格式的参数比如 -z是针对 gzip，-j是针对 bzip2） 解压tar.xz文件： 先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。 创建tar.xz文件： 先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件， 然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz ９．rpm：安装/查询/删除rpm包： 安装本地的rpm包：rpm -ivh rpm包全路径名 查询是否安装了某个rpm包：rpm -qa | grep 软件名 删除rpm方法安装的某个rpm包： rpm -e 软件包名 升级某个rpm包：rpm -Uvh 软件包名 １０．yum：安装/查询/删除rpm包： 查询公网的yum服务器中是否有我们要安装的某个软件源：yum list | grep 软件名 (或者用yum search 软件名) 安装最新版的某个软件（默认）：yum -y install 软件名 安装指定版本的某个软件：yum -y install 软件名-版本号 升级某个rpm包： yum update -y 软件名 （查看是否有新版本及版本号 yum update |grep 软件名） 删除yum方式安装的rpm包：yum remove 软件名 当要使用一个指令，系统提示不存在，于是用yum安装它但又不知道它属于哪个rpm包时：yum provides 指令名（以ifconfig为例：yum provides ifconfig） 查看包的关系：repoquery --nvr --whatprovides 包名 （ repoquery是yum扩展工具包yum-utils中的一个工具，所有如果你没有repoquery命令的话，可以先 sudo yum install yum-utils 安装yum-utils包） １１．防火墙： CentOS7查看防火墙状态：systemctl status firewalld (CentOS6查看防火墙状态:service iptables status) 临时关闭防火墙：systemctl stop firewalld 启动防火墙：systemctl start firewalld １２．关机/重启/注销linux： 关机：halt （或者shutdown -h 1 表示一分钟后关机；shutdown -h now立刻关机） 重启：reboot 注销：logout １３．文件/目录操作： 创建目录（父目录不存在时创建父目录，即级联创建目录）：mkdir -pv 目录名（目录名如./aaa/bbb/ccc/ddd） 创建文件：touch 文件名 递归且强制删除目录/文件：rm -rf 目录名 显示目录下的文件/目录：ls -a (-a 表示列出所有文件，包括隐藏文件) ls -d (-d表示针对目录的，只列出目录本身) 浏览小文件并显示行号：cat -n 文件名 （浏览大文件：cat -n 文件名 | more） 浏览大文件 并显示行号，百分比：less -mN 文件名 追加：向文件的内容后面追加内容：echo &quot;内容&quot; &gt;&gt; 文件名 覆盖：用文件1的内容覆盖文件2里面的内容 ： cat 文件1 &gt; 文件2 控制台打印内容：echo “xxxx” 查看文件后5行：tail -n 5 文件名 （查看前5行：head -n 文件名） 创建快捷方式（软链接）：ln -s 原文件 快捷方式名称 文件重命名 ： mv 原文件名/目录名 新文件名/目录名 剪切（移动）：mv 原文件名/目录 新的路径 复制：cp -r 原文件/目录 目标文件/目录 （注意：复制目录必须加-r，表递归复制） １４．搜索文件/目录： 按照名称查询某个目录下是否有某个文件：find 搜索的目录 -name 要搜索的文件名 查询某个目录下属于某个用户的所有文件： find 搜索的目录 -user 用户名 １５．用户操作： 切换为某个用户：su -用户名 切换为管理员用户即root用户：su - 以管理员权限执行一条命令 ：sudo 要执行的命令 创建用户/组：useradd/groupadd useradd -g 所属的组名 用户名（注意：指定用户所属的组（前提：组存在）） 改变文件所属用户/组：chown/chgrp 改变用户所属组：usermod 改权限：chmod 改运行级别：chkconfig --level 0到6的数字 服务名 on （on 表开启，off表关闭） 查看用户所属组：id 用户名 查看有哪些用户：cat /etc/passwd 查看有哪些组：cat /etc/group 设置密码 passwd 用户名 １６．查看以前敲过的所有命令：history （常与管道连用，history | more）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的安装]]></title>
    <url>%2FLinux%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[前言: 上一节我们了解了Linux的一些基本概念,这一节我们将开始安装Linux系统,Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习. 什么是虚拟机? 安装虚拟机软件VMware:Vmware 下载地址 VMWare10 创建虚拟机空间:安装好 vmware 后，就可以创建虚拟机空间了: 点击新建虚拟机 安装CentOS系统:安装系统之前，需要先去下载一个镜像文件: CentOS下载地址： ​ 网易镜像：网易镜像​ 搜狐镜像：搜狐镜像 ​ 阿里云CentOS7镜像: 可以选择第一个：CentOS-7-x86_64-DVD-1708.iso 进行下载即可。 这里找到Ｌｉｎｕｘ系统的iso镜像(即.iso后缀)文件 这里如果选择OK,此时会联网检查系统的完整性,会等待很久,所以这里选择skip.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux的安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Linux.html</url>
    <content type="text"><![CDATA[前言: 根据JoblabXTM整理，使用Linux操作系统占据了整个操作系统的绝大数量，已经接近99%！立志于互联网行业的工程师们掌握Linux这门技术对自身的职业发展，一定会起到事半功倍之效果,所有我们有必要学习Linux操作系统. 一、Linux是什么,怎么读? linux是一个开源、免费的类Unix操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目都会部署到Linux/unix系统上。 Linux 读作[里纽克斯, 利尼克斯,里纳克斯] 二、Linux 的历史背景: 最初是由芬兰赫尔辛基大学学生Linus Torvalds (林纳斯-托瓦斯)由于自己不满意教学中使用的MINIX操作系统,所有在1990年底由于个人爱好设计出了LINUX系统核心,后来发布于芬兰最大的ftp服务器上,用户可以免费下载,所有它的周边的程序越来越多,Linux本身也逐渐壮大起来,之后Linux在不到三年的时间里成为了一个功能完善,稳定可靠的操作系统. 三、Linux的版本和分类:3.1 Linux 版本分两种: 内核版本 和发行版本: 内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号. 发行版本是一些组织和公司根据自己发行版的不同而自定. 3.2 一般来说著名的linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等 Debian系列：Debian、Ubuntu(乌班图)等 RedHat(红帽)系列 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” 包管理工具 yum 支持tar包 Debian(蝶变)系列 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” 包管理工具 apt-get 支持tar包 四、Unix简介: Unix是一个强大的多用户、多任务操作系统.于1969年在AT&amp;T(美国电话电报公司)的贝尔实验室开发. UNIX的商标权由国际开放标准组织所拥有. UNIX操作系统是商业版,需要收费,价格比Windows正版要贵一些. 五、Linux和Unix的关系: 六、Linux和Windows的比较: 比较 Window Linux 免费与收费 收费且很贵 Linux 免费或少许费用 软件与支持 数量和质量的优势，不过大部分为收费软件；由微软官方提供支持和服务； 开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。 安全性 三天两头打补丁安装系统安全更新，还是会中病毒木马； 要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比Windows 平台要更加安全 使用习惯 普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易入门简单； 兼具图形界面操作和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高。 可定制性 封闭的，系统可定制性很差； 开源，可定制化非常强。 应用场景 桌面操作系统主要使用的是window。 支撑百度，谷歌，淘宝等应用软件和服务的，是后台成千上万的Linux服务器主机。世界上大部分软件和服务都是运行在Linux之上的。 七、Linux 在计算机中的位置: 八、Linux的目录结构: 目录 说明 / 根目录: 一般根目录下只存放目录,不存放文件 /bin (binaries) 存放二进制可执行文件，常用命令一般都在这里(如: ls,cat,mkdir等)。 /boot 存放用于系统启动时使用的各种文件 /dev (devices) 类似Windows的设备管理器, 把所有的硬件用文件的形式存储。 /etc (etcetera) 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /usr 用于存放系统应用程序，比较重要的目录 /usr/local [重点] : 一般通过编译源码方式安装的程序就存放在这里 /usr/sbin 超级用户的一些管理程序 /usr/share/man 帮助文档 /usr/bin 众多的应用程序 /var [重点] 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 /tmp 用于存放各种临时文件，是公用的临时文件存储点。 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统。 /opt 下载的未安装的软件一般放到这里 /media linux会自动识别一些设备,例如U盘,光驱等,当识别后会把识别的设备挂载到这个目录下 /lost+found 这个目录平时是空的，系统非正常关机会留下一些文件（windows下叫什么.chk）就存放在这里 ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>初识Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建Hexo基本框架]]></title>
    <url>%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[前言: 之前自己敲代码纯手工打造了一个博客,并成功部署到了阿里云服务器上,虽然界面不忍直视吧,但还是有一丝小小的成就感.最近看到朋友用Hexo框架搭建的一个博客,界面看起来很美观,于是乎爱折腾的我心动了,决定放手干,好了废话不多说,进入正题,先说一下我的思路:个人认为无论学习什么技术,首先要做的就是要了解这个技术是什么?然后为什么要用它,它有什么优势,特点?最后就是我该怎么用? 一、Hexo是什么? Hexo 是一款基于Node.js的静态博客生成程序，作者是中国台湾tommy351。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容． 二、Hexo有什么用,优势在哪? 如果你一直想拥有一个界面美观的,能在上面记录一些学习心得,个人日记,一些内容公开发布,一些内容私密访问,属于自己的博客平台,但是又愁于自己没有一定的编程能力难以实现这个想法,那么Hexo将会给你带来福音, 即使你没有一定的编程基础,你也可以快速使用Hexo打造一个你自己喜欢的博客,因为不需要你敲大量的代码,你要做的仅仅是不断的Ctrl+C,Ctrl+V改一改配置文件. 简单吧! 是不是有点心动了,心动就行动吧! ​ 三、如何安装?以Windows机为例:１．首先要安装的就是Git和Node.js这两个工具：（如果之前安装过,那么跳过这一步） Git下载地址: Git Node.js下载地址: Node.js ２．安装hexo: 打开git软件,通过node.js工具的npm命令来安装hexo: $ npm install -g hexo-cli ３．检测上述工具是否安装成功,如果成功会显示版本号：(如果你嫌麻烦可以忽略) node-v npm -v git --version hexo -v ４．在任意位置创建一个文件夹,例如:blog, 并进入该目录: 我这里是创建在E盘 $ cd /e/blog ５．运行下面的命令,hexo 将会在blog文件夹中生成所需要的文件 $ hexo init 会生成以下目录内容: ​ 注意: 将来自定义博客样式的时候别把站点配置文件和主题配置文件弄混淆了. ５．生成静态文件(hexo会将/blog/source/ 下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下): $ hexo g ６．启动服务器: $ hexo s 默认情况下，访问网址为： http://localhost:4000/ 在浏览器地址栏输入上面的地址: 如果看到下面这个界面，那么恭喜你安装成功了，这个就是hexo默认的博客主题,如果你不喜欢还有更酷炫的主题，如何操作，下节我们继续．现在你已经可以在这个主题下写博客了。 四、说明: $ hexo g 是 $ hexo generate 的简写形式,产生的作用是一样的 $ hexo s是 $ hexo server的简写, 表示启动本地服务器,让hexo在本地运行 $ hexo d 是 $ hexo deployed的简写, (这个指令是部署到远程服务器的,后面会讲到) $ hexo clean 没有简写,别写成了$ hexo c $ hexo server -p 5000 #更改端口 参考文档： Hexo]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo的安装</tag>
      </tags>
  </entry>
</search>
