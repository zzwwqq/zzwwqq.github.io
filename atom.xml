<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zwq</title>
  
  <subtitle>路漫漫其修远兮,吾将上下而求索!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zzwwqq.xyz/"/>
  <updated>2019-04-16T12:54:08.919Z</updated>
  <id>https://zzwwqq.xyz/</id>
  
  <author>
    <name>zwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信息系统项目管理师常考知识点</title>
    <link href="https://zzwwqq.xyz/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://zzwwqq.xyz/信息系统项目管理师常考知识点.html</id>
    <published>2019-04-13T03:24:19.000Z</published>
    <updated>2019-04-16T12:54:08.919Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.5.png" alt></p><a id="more"></a><h2 id="一、UML相关知识"><a href="#一、UML相关知识" class="headerlink" title="一、UML相关知识:"></a>一、UML相关知识:</h2><p>UML: 统一的建模语言(UnifiedModelingLanguage),<strong>独立于软件开发过程</strong>,它<strong>不是可视化的程序设计语言</strong>而是一种<strong>可视化建模语言</strong></p><h3 id="1-1-五种结构视图"><a href="#1-1-五种结构视图" class="headerlink" title="1.1 五种结构视图:"></a>1.1 五种结构视图:</h3><p>①: 逻辑视图(类图): 描述系统的功能需求</p><p>②: 用例视图(用例图)</p><!-- more --><p>③: 实现视图(构件图): 描述软件结构</p><p>构件图: 描述各种软件构件之间的依赖关系,是一种说明了<strong>系统静态实现</strong>视图</p><p>④: 进程视图(进程视图或过程视图): 并发问题, 关注进程,线程,对象等运行时概念,及<strong>并发,同步,通信</strong></p><p>⑤: 部署视图(部署图也称实施图): 分布问题</p><p>部署图: 显示系统软硬件之间的物理架构, 是一种说明了<strong>系统体系结构的静态实施</strong>视图</p><h3 id="1-2-UML2-0-中的14种图"><a href="#1-2-UML2-0-中的14种图" class="headerlink" title="1.2  UML2.0 中的14种图"></a>1.2  UML2.0 中的14种图</h3><p><strong>静态视图: </strong></p><p>①: 类图<br>②: 对象图<br>③: 用例图<br>④: 构件图<br>⑤: 组合结构图<br>⑥: 部署图<br>⑦: 包图<br>⑧: 制品图: 描述系统的物理结构,制品包括文件,数据库等</p><p><strong>动态视图: </strong></p><p>①: 顺序图<br>也称顺序图,按照<strong>时间顺序</strong>描述<strong>对象间的交互</strong>,强调对象间消息发送的顺序,显示对象间动态的合作关系.</p><p>②: 状态图<br>③: 活动图<br>④: 通信图(UML1.0中 称 协作图)<br>描述<strong>对象间</strong>的<strong>交互</strong>和链接,显示对象间<strong>如何发送</strong>消息,其中顺序号指明消息的嵌套关系,和发生顺序.</p><p>⑤: 定时图: 是一种交互图,强调消息跨越不同对象或参与者的实际时间,而不仅仅只是关心消息的相对顺序.<br>⑥: 交互概览图(活动图和顺序图的混合物)</p><h3 id="1-3-类之间的关系"><a href="#1-3-类之间的关系" class="headerlink" title="1.3 类之间的关系"></a>1.3 类之间的关系</h3><p>四种:<br>①: 关联(组合,聚合)<br>②: 泛化<br>③: 依赖<br>④: 实现</p><h3 id="1-4-用例图"><a href="#1-4-用例图" class="headerlink" title="1.4 用例图:"></a>1.4 用例图:</h3><p>从<strong>用户的角度</strong>描述系统功能,描述的是系统<strong>用户与系统</strong>,<strong>系统与外部系统的交互</strong>,是<strong>开发者与用户交流的工具.</strong></p><p>用例是系统的一个<strong>功能单元</strong></p><h4 id="1-4-1-用例图中用例之间的关系"><a href="#1-4-1-用例图中用例之间的关系" class="headerlink" title="1.4.1 用例图中用例之间的关系:"></a>1.4.1 用例图中用例之间的关系:</h4><p>①: 关联(association)<br>②: 泛化(generialize)关系.<br>③: 包含include(或使用User)<br>④: 扩展(extends)</p><h2 id="二、计算机组成原理相关"><a href="#二、计算机组成原理相关" class="headerlink" title="二、计算机组成原理相关"></a>二、计算机组成原理相关</h2><h3 id="2-1-关于总线"><a href="#2-1-关于总线" class="headerlink" title="2.1 关于总线:"></a>2.1 关于总线:</h3><p>总线: 计算机中各个部件相连的通信线,</p><h4 id="2-1-1-总线分以下4类"><a href="#2-1-1-总线分以下4类" class="headerlink" title="2.1.1 总线分以下4类:"></a>2.1.1 总线分以下4类:</h4><p>①: 中央处理器内部总线</p><p>寄存器与寄存器, 寄存器与运算器</p><p>②: 部件内总线</p><p>一块插卡的内部总线(片级总线), 如显卡,多功能卡等插卡都使用了~实现本卡上各芯片互联</p><p>③: 系统总线</p><p>各个功能部件(中央处理器,存储器,外设)之间互连的总线.</p><p>分为: 数据总线 ,地址总线 , 控制总线</p><p>④: 外部总线</p><p>计算机系统之间,或者是计算机和其他设备</p><h3 id="2-2-Cache"><a href="#2-2-Cache" class="headerlink" title="2.2 Cache:"></a>2.2 Cache:</h3><p>高速缓冲存储器,介于中央处理器和主存之间.</p><p>如果不命中则从主存中取出需要的块,同时送往CPU 和 Cache</p><p><strong>写回法: </strong>先写cache,并用标志位加以说明,直至经过重写的字块被从cache中替换出来时再写入主存</p><h2 id="三、信息系统"><a href="#三、信息系统" class="headerlink" title="三、信息系统:"></a>三、信息系统:</h2><p>一般指采集,处理,分析,存储,传输,检索信息的具有完整功能的集合体.</p><h3 id="3-1-信息库"><a href="#3-1-信息库" class="headerlink" title="3.1 信息库"></a>3.1 信息库</h3><p>存储大量数据,文档的资料库</p><p>包含内容:<br>①: 网络目录(存放了电子表格软件,项目信件和数据等)<br>②: 打印的文档<br>③: 一个或多个Case工具目录<br>②: 到上述组织的<strong>内联网网站接口</strong></p><h3 id="3-2-ERP"><a href="#3-2-ERP" class="headerlink" title="3.2 ERP"></a>3.2 ERP</h3><p>ERP: <strong>是一个软件</strong><br><strong>ERP项目: 管理变革项目</strong>,不像传统财务核算软件,只是替代用户的手工业务</p><p><strong>强调 事前计划,事中控制,事后分析</strong>的管理理念和<strong>及时调整</strong>的管理策略</p><h3 id="3-3-建立企业信息系统原则"><a href="#3-3-建立企业信息系统原则" class="headerlink" title="3.3 建立企业信息系统原则:"></a>3.3 建立企业信息系统原则:</h3><p>自上而下的<strong>规划</strong>, 自下而上的分布<strong>实现</strong></p><h3 id="3-4-计算机的数据环境类型"><a href="#3-4-计算机的数据环境类型" class="headerlink" title="3.4 计算机的数据环境类型:"></a>3.4 计算机的数据环境类型:</h3><p>按照管理层次从低到高排列: <strong>数据文件—&gt;应用数据库—&gt;主题数据库—-&gt;信息检索数据库</strong></p><h3 id="3-5-总监理工程师代表-不能拥有的职权"><a href="#3-5-总监理工程师代表-不能拥有的职权" class="headerlink" title="3.5 总监理工程师代表 不能拥有的职权:"></a>3.5 总监理工程师代表 不能拥有的职权:</h3><p>①: 不能主持编写项目监理<strong>规划</strong><br>②: 不能签发工程<strong>开工</strong>报审表,工程<strong>竣工</strong>监理报告, 工程款<strong>支付</strong>证书<br>③: 不能调解<strong>合同</strong>争议,处理<strong>索赔</strong>,审批工程延期<br>④: 不能<strong>调换人员</strong><br><strong>总结: 不能拥有与规划,开工,支付,索赔,人员,相关的职权</strong></p><h3 id="3-6-WebService协议和技术"><a href="#3-6-WebService协议和技术" class="headerlink" title="3.6 WebService协议和技术:"></a>3.6 WebService协议和技术:</h3><p>WebService体系结构是一种<strong>面向服务</strong>的体系结构(SOA),这种体系结构设置了<strong>3个角色和3种操作.</strong></p><p><strong>3个角色: </strong>服务提供者、服务请求者、服务注册中心(服务提供者在这里发布他们的服务描述)<br><strong>3种操作: </strong> <strong>发布</strong>服务描述、<strong>查询</strong>或查找服务描述、根据服务描述绑定或<strong>调用</strong>服务.</p><p>①: <strong>XML</strong> : 是WebService平台中表示<strong>数据的基本格式.</strong></p><p>②: <strong>SOAP:</strong> Simple Object Access Protocol <strong>简单对象访问协议</strong>, 实现系统间能用<strong>“软件-软件对话</strong>的方式相互调用”,打破了软件应用,网站,和各种设备之间格格不入的状态,实现<strong>基于Web无缝集成</strong>的目标</p><p>③: <strong>UDDI: </strong> 是一种<strong>规范</strong>,提供基于<strong>Web服务的注册</strong>和发现机制,目的是为电子商务建立标准.</p><p>UDDI它为Web服务提供3个重要的技术支持:</p><ul><li>①: 标准,透明,专门<strong>描述</strong>Web服务的机制</li><li>②: <strong>调用</strong>Web服务</li><li>③: <strong>访问</strong>Web服务注册中心</li></ul><h3 id="3-7-网络接入技术"><a href="#3-7-网络接入技术" class="headerlink" title="3.7 网络接入技术"></a>3.7 网络接入技术</h3><p>广义上说<strong>跟网络接入相关的都可以算是网络接入技术,</strong>如: LAN方式,拨号接入方式,DSL方式,光纤接入,Cabel Modem线缆调制解调器接入,IEEE802.11 无线局域网接入,GPRS和3G,HFC,XDSL,DDN,PSTN,ISDN</p><p>①: <strong>HFC: </strong>Hybrid Fiber Coaxial 混合光纤同轴电缆网,经济实用的综合数字服务宽带网接入技术,光纤干线,同轴电缆,用户配线网络三部分组成,有线电视台出来的节目信号,先变成光信号在干线上传输,到用户区后把光信号转为电信号,经过分配器分配后通过同轴电缆送到用户.</p><p>②:  <strong>XDSL :</strong>数字用户线路 (Digital Subscribe  Line)是各种DSL的总称,如ADSL,VDSL,SDSL等</p><ul><li>ADSL: Asymmetric Digital Subscribe  Line 非对称数字用户环路.所谓<strong>非对称指的是上行和下行带宽不对称.</strong></li><li>VDSL: Very Speed Digital Subscriber Line 超高速数字用户线路</li><li>CDMA: Code Division Multiple Access 码分多址</li></ul><p>③: <strong>DDN: </strong> (Digital  Data NetWork)<strong>专线上网方式</strong>,传输速率高,质量好,延时小等特点,将数万或数十万条光缆为主体的数字电路,通过数字电路管理设备构成的<strong>数据传输基础网络.</strong></p><p>注: <strong>NetBEUI: 不属于网络接入技术,它用于本地局域网</strong>,不能与其他网络的计算机进行沟通</p><h3 id="3-8-数据仓库"><a href="#3-8-数据仓库" class="headerlink" title="3.8 数据仓库"></a>3.8 数据仓库</h3><p>数据仓库的<strong>用户为管理层</strong>,它的数据随业务持续增长.</p><p>面向主题的,<strong>集成的</strong>,相对稳定的反映历史变化的<strong>数据集合</strong>,<strong>用于支持管理决策</strong></p><p>是对多个异构数据源(包括历史数据)的有效集成,集成后按照主题重组,<strong>其中的数据一般不再修改.</strong></p><h3 id="3-9-SAN-存储区域网络"><a href="#3-9-SAN-存储区域网络" class="headerlink" title="3.9 SAN(存储区域网络)"></a>3.9 SAN(存储区域网络)</h3><p>包括FCSAN 和 IPSAN</p><p>FCSAN 使用数据传输协议中的 <strong>FiberChannel</strong>(FC: 一种高速网络技术标准,千兆位数据传输的技术标准)</p><h3 id="3-10-ISCSI"><a href="#3-10-ISCSI" class="headerlink" title="3.10 ISCSI"></a>3.10 ISCSI</h3><p>Internet Small Computer System Interface, 它基于TCP/IP协议</p><h3 id="3-11-信息化项目监理"><a href="#3-11-信息化项目监理" class="headerlink" title="3.11 信息化项目监理"></a>3.11 信息化项目监理</h3><p>分三种:</p><p>①: 咨询式监理</p><p>②: 里程碑式监理</p><p>③: 全程式监理</p><h3 id="3-12-软件构件-软件中间件-的标准"><a href="#3-12-软件构件-软件中间件-的标准" class="headerlink" title="3.12 软件构件(软件中间件)的标准:"></a>3.12 软件构件(软件中间件)的标准:</h3><p>①: OMG组织(对象管理组织)提出的<strong>CORBA</strong></p><p>为解决<strong>分布式</strong>处理环境中<strong>软硬件的互连</strong>而提出.</p><p>②: 微软提出的<strong>COM</strong></p><p><strong>组件架构**</strong></p><p>③: SUN提出的<strong>EJB: </strong></p><p>用于<strong>封装业务,</strong> <strong>中间层业务功能由EJB构件实现,</strong>JSP用于实现业务逻辑处理结果的动态发布,构成动态的HTML页面,中间层也可用servlet实现更为灵活的动态页面.</p><h3 id="3-13-信息系统工程监理活动主要内容"><a href="#3-13-信息系统工程监理活动主要内容" class="headerlink" title="3.13 信息系统工程监理活动主要内容::"></a>3.13 信息系统工程监理活动主要内容::</h3><p><strong>四控,三管,一协调.</strong></p><p><strong>四控: </strong><br>信息系统工程的<strong>质量控制</strong><br><strong>进度</strong>控制<br><strong>投资</strong>控制<br><strong>变更</strong>控制</p><p><strong>三管:</strong></p><p>信息系统工程的<strong>合同管理</strong><br><strong>信息</strong>管理<br><strong>安全</strong>管理</p><p><strong>一协调: </strong></p><p>协调有关单位间的工作关系.</p><h3 id="3-14-监理文件"><a href="#3-14-监理文件" class="headerlink" title="3.14 监理文件"></a>3.14 监理文件</h3><h4 id="3-14-1-监理规划"><a href="#3-14-1-监理规划" class="headerlink" title="3.14.1 监理规划"></a>3.14.1 监理规划</h4><p>在监理委托合同签订后,由<strong>总监理工程师主持编写</strong>,监理单位技术负责人书面批准的<strong>指导监理开展工作</strong>的纲领性文件</p><p>作用:</p><p>①: 监理项目部<strong>职能</strong>的具体体现<br>②: <strong>指导</strong>监理项目部开展工作<br>③: <strong>信息系统工程监理管理部门</strong>进行<strong>监督</strong> <strong>监理单位</strong>的主要内容和依据<br>④: <strong>建设单位</strong> <strong>检查</strong> <strong>监理单位</strong>是否能认真,全面履行信息系统工程监理委托合同的重要依据</p><h4 id="3-14-2-监理实施细则"><a href="#3-14-2-监理实施细则" class="headerlink" title="3.14.2 监理实施细则"></a>3.14.2 监理实施细则</h4><p>在监理规划指导下,由专业监理工程师针对项目具体情况制定的更具有可实施,可操作的业务性文件,<strong>指导具体监理业务的开展.</strong></p><h4 id="3-14-3-监理大纲"><a href="#3-14-3-监理大纲" class="headerlink" title="3.14.3 监理大纲 :"></a>3.14.3 监理大纲 :</h4><p>是社会监理单位为了获得监理任务,在<strong>投标前</strong>由<strong>监理单位编制</strong>的项目监理方案性文件,是<strong>投标书</strong>的重要组成部分,</p><h3 id="3-16-进度控制"><a href="#3-16-进度控制" class="headerlink" title="3.16 进度控制"></a>3.16 进度控制</h3><p>技术手段:<br>①: 甘特图<br>②: 网络图<br>单代号网络图<br>双代号网络图<br>③: 香蕉 曲线图法<br>两条S型曲线组合而成的闭合曲线:<br><strong>ES曲线</strong>是: 计划以各项工作的<strong>最早开始</strong>时间安排进度而绘制<br><strong>LS曲线</strong>是: 计划以各项工作的<strong>最迟开始</strong>时间安排进度而绘制<br>ES各点均在LS各点的左边,ES和LS起点和终点相同,所以ES与LS围成的图形像香蕉.</p><p><strong>注: ABC分析法:帕累托分析法,把分析的对象分成A,B,C三类,从而有区别地确定管理方式</strong></p><h3 id="3-17-旁站监理"><a href="#3-17-旁站监理" class="headerlink" title="3.17 旁站监理:"></a>3.17 旁站监理:</h3><p>是监理单位<strong>控制工程质量</strong>的重要手段,主要在<strong>关键部位或关键工序</strong>施工过程中,由监理人员在现场进行的<strong>监督活动.</strong><br>网络综合布线,设备开箱检验,机房建设等活动涉及隐蔽工程,需要进行旁站监理,确保这些活动的过程质量.</p><h3 id="3-18-信息系统常用开发方法"><a href="#3-18-信息系统常用开发方法" class="headerlink" title="3.18 信息系统常用开发方法:"></a>3.18 信息系统常用开发方法:</h3><p>①: 结构化方法</p><p>三部分组成: 结构化方法.结构化设计,结构化程序设计.</p><p>基本思想: <strong>用户至上</strong>(开发人员始终与用户保持联系),<strong>自顶向下</strong>设计,<strong>自底向上</strong>逐步实现,<strong>模块化设计</strong></p><p>按照信息系统生命周期,应用结构化系统开发方法,将整个系统<strong>开发过程分为若干阶段,</strong>然后<strong>一步一步依次进行</strong>,前一阶段是后一阶段的依据.</p><p>包括数据流的分析方法: 数据流图,数据字典</p><p>缺点: 开发周期长, 难以适应需求变化,不适合开发大规模的复杂的系统</p><p>②: 原型方法</p><p><strong>需求不清, 快速开发</strong>一个原型系统, 通过反复修改来实现最终系统需求</p><p>③: 面向对象方法OO<br>面向对象法分三个阶段:</p><p><strong>分析:</strong></p><p>分析模型由 用例模型,类-对象模型,对象-关系模型,对象-行为模型组成.</p><p><strong>设计</strong></p><p>概要设计(软件基础架构),详细设计(完整的类架构)</p><p>主要是类设计,用例设计,子系统设计</p><p><strong>实现</strong></p><p>④: 面向服务的方法SO</p><p>跨构件的功能调用,进一步将接口定义和实现解耦,使信息系统快速响应需求与环境变化</p><h3 id="3-19-信息系统的生命周期"><a href="#3-19-信息系统的生命周期" class="headerlink" title="3.19 信息系统的生命周期:"></a>3.19 信息系统的生命周期:</h3><h4 id="3-19-1-项目的生命周期分四个阶段"><a href="#3-19-1-项目的生命周期分四个阶段" class="headerlink" title="3.19.1 项目的生命周期分四个阶段:"></a>3.19.1 项目的生命周期分四个阶段:</h4><p>①: 启动<br>②: 计划<br>③: 执行<br>④: 收尾</p><h4 id="3-19-2-信息系统的生命周期分四个阶段"><a href="#3-19-2-信息系统的生命周期分四个阶段" class="headerlink" title="3.19.2 信息系统的生命周期分四个阶段:"></a>3.19.2 信息系统的生命周期分四个阶段:</h4><p>①: 立项<br>②: 开发<br>③: 运维<br>④: 消亡</p><p><strong>开发阶段细分为5个阶段</strong></p><p>①: 系统规划阶段 (初步调查,可行性分析和项目开发计划)<br>做<strong>系统调查和可行性分析</strong></p><p>对现行系统的状况进行<strong>初步调查,</strong>研究建设新系统的必要性和可能性,拟定系统的备选方案,对这些方案进行<strong>可行性研究</strong>,写出可行性研究报告,可行性研究报告<strong>审议</strong>通过后,将新系统建设方案及实施计划编写成<strong>系统设计任务书.</strong></p><p>该阶段最终形成<strong>可行性研究报告</strong> <strong>系统设计任务书</strong></p><p>②: 系统分析阶段(需求分析) 又称逻辑设计阶段——–做什么</p><p>根据系统设计任务书所确定的范围,对<strong>现行系统</strong>进行<strong>详细调查</strong>,描述缺陷和不足,然后确定<strong>新系统的目标和功能.</strong></p><p>为设计阶段提供系统的逻辑模型,内容包括组织结构及功能分析,业务流程分析,数据和数据流程分析<br><strong>数据流图DFD</strong></p><p>系统说明书: 既是给用户看的,也是下一阶段的工作依据,也是将来验收系统的依据,用户通过它了解未来系统的功能,判断是否为要求的系统<br>该阶段最终形成<strong>系统说明书</strong></p><p>③: 系统设计阶段(概要设计,详细设计)————-怎么做</p><p>根据系统说明书中规定的功能要求,考虑实际条件,具体设计<strong>实现逻辑模型</strong>的技术方案.</p><p>系统架构设计,数据库设计,功能模块设计,安全控制方案设计等</p><p><strong>E-R图</strong>描述现实世界概念模型,用于数据库设计</p><p>④: 系统实施阶段(编码,测试)</p><p>将设计的系统付诸实施,这一阶段包括 计算机等设备的购置,安装和调试,程序的编写和调试,人员培训,系统调试等<br>系统实施按实施计划分阶段完成,每阶段写出实施进展报告,系统测试后写出系统测试分析报告.</p><p>该阶段最终形成<strong>实施进展报告,系统测试分析报告</strong></p><p>⑤: 系统维护阶段(运行维护)</p><h3 id="3-20-企业中信息系统的分类"><a href="#3-20-企业中信息系统的分类" class="headerlink" title="3.20 企业中信息系统的分类:"></a>3.20 企业中信息系统的分类:</h3><h3 id="3-20-1-根据服务对象而言分为"><a href="#3-20-1-根据服务对象而言分为" class="headerlink" title="3.20.1 根据服务对象而言分为:"></a>3.20.1 根据服务对象而言分为:</h3><p>①:  面向作业处理:</p><p>OA办公自动化系统,DAMS<strong>数据采集与监测*</strong>系统</p><p>②: 面向管理控制</p><p>KM知识管理系统,CIMS计算机<strong>集成制造</strong>系统</p><p>③: 面向决策计划</p><p>MES<strong>管理专家系统,</strong>DSS决策支持系统,SIS战略信息系统</p><h3 id="3-21-网络存储"><a href="#3-21-网络存储" class="headerlink" title="3.21: 网络存储"></a>3.21: 网络存储</h3><h4 id="3-21-1-现有存储的三大模式"><a href="#3-21-1-现有存储的三大模式" class="headerlink" title="3.21.1 现有存储的三大模式:"></a>3.21.1 现有存储的三大模式:</h4><p>①: 直接附加存储DAS</p><p>②: 网络附加存储NAS</p><p><strong>支持多种TCP/IP协议</strong>,支持即插即用</p><p>③: 存储区域网络</p><p>SAN :</p><p>注: <strong>哈希散列表存储:</strong> <strong>不是网络存储结构, </strong> 它是根据<strong>关键码值而直接进行访问</strong>的数据结构(也就是把关键码值映射到表中一个位置来访问记录,以加快查找速度)</p><h3 id="3-22-NET"><a href="#3-22-NET" class="headerlink" title="3.22 .NET"></a>3.22 .NET</h3><p>一般的高级程序语言(C#,VB)会直接将代码编译为机器语言,<br>而<strong>编译.NET是不同的,多了一个环节,就是先将高级语言编译成为中间语言(IL)</strong>,中间语言最终编译为机器代码.<br>这些中间语言是.NET框架中所有语言编译后的结果,比如C#,VB语言编写的两个类,编译后中间语言看起来一样,这就显示了.NET跨平台的事实.</p><h3 id="3-23-常见产品与语言"><a href="#3-23-常见产品与语言" class="headerlink" title="3.23 常见产品与语言:"></a>3.23 常见产品与语言:</h3><p>.NET Framework —&gt;可用于C#,C++,VB<br>WASP是web应用框架—–&gt;使用PHP5开发<br>DelPhi是集成开发环境IDE—-&gt;使用Pascal<br>GLUE是一种java扩展包</p><h3 id="3-24-CRM"><a href="#3-24-CRM" class="headerlink" title="3.24 CRM"></a>3.24 CRM</h3><p>是集成化的<strong>信息管理系统,</strong> <strong>存储了企业现有和潜在客户的信息</strong>,并且对这些信息进行<strong>自动的处理</strong>从而产生更人性化的市场管理策略.</p><p>它是<strong>以客户为中心</strong>的商业策略,而不是传统的以产品或市场为中心<br>将业务中心转移到客户,根据<strong>不同的客户有重点的采取不同的策略</strong></p><h3 id="3-25-工作流"><a href="#3-25-工作流" class="headerlink" title="3.25 工作流"></a>3.25 工作流</h3><p>工作流技术<strong>不是开发过程管理</strong>的技术,所以它<strong>不能提升开发过程的灵活性</strong></p><h3 id="3-26-2G-3G-4G标准"><a href="#3-26-2G-3G-4G标准" class="headerlink" title="3.26  2G/3G/4G标准"></a>3.26  2G/3G/4G标准</h3><p>GSM 是2G标准</p><p>GPRS是2G移动数据业务</p><p>四种国际3G标准: WCDMA,CDMA2000,WinMAX,<strong>TD-SCDMA(时同步码分多址,由中国自主研发) </strong></p><p>LTE是4G标准</p><h3 id="3-27-电子商务"><a href="#3-27-电子商务" class="headerlink" title="3.27 电子商务:"></a>3.27 电子商务:</h3><p>原始电子商务: 使用电子信息技术工具进行商务活动<br>凡使用诸如电报,电话,广播,点水,传真以及计算机,计算机网络等手段,工具进行商务活动,都可称之为电子商务.</p><h4 id="3-27-1-第四方物流"><a href="#3-27-1-第四方物流" class="headerlink" title="3.27.1 第四方物流"></a>3.27.1 第四方物流</h4><p>为第一,二,三方提供物流规划,咨询,物流信息系统,供应链管理等活动.它是一个供应链的集成商,是<strong>供需双方及第三方物流的领导力量.</strong></p><h4 id="3-27-2-第三方物流"><a href="#3-27-2-第三方物流" class="headerlink" title="3.27.2 第三方物流:"></a>3.27.2 第三方物流:</h4><p>生产经营企业为集中搞好业主,把原来属于自己处理的物流活动,<strong>以合同方式委托给专业物流服务企业</strong>,同时提供信息系统与物流企业保持密切联系,以达到对物流全程管理控制的一种物流运作和管理方式.</p><h3 id="3-28-经济计量分析"><a href="#3-28-经济计量分析" class="headerlink" title="3.28 经济计量分析:"></a>3.28 经济计量分析:</h3><p>工作程序顺序:<br><strong>设定</strong>模型—&gt;<strong>估计</strong>参数—&gt;<strong>检验</strong>模型—&gt;应用模型</p><h3 id="3-29-关于GCC"><a href="#3-29-关于GCC" class="headerlink" title="3.29 关于GCC"></a>3.29 关于GCC</h3><p>GNU Compiler Collection , 即GNU编译器套件 ,  它是以GPL许可证所发行的自由软件,也是GNU计划的关键部分.</p><h3 id="3-30-文件审批流程"><a href="#3-30-文件审批流程" class="headerlink" title="3.30 文件审批流程"></a>3.30 文件审批流程</h3><p><strong>承建方</strong>提交的&lt;&lt;项目质量管理计划&gt;&gt;先由<strong>建设方</strong>技术总监对内容,范围审核后,再送交<strong>监理方</strong>批准</p><h3 id="3-31-关于监理"><a href="#3-31-关于监理" class="headerlink" title="3.31 关于监理"></a>3.31 关于监理</h3><p>①: 当<strong>专业监理工程师需要调整时</strong>,<strong>总监理工程师应该</strong>  <strong>书面通知</strong> <strong>建设单位和承包单位.</strong></p><p>②: 当<strong>总监理工程师需要调整时</strong>,<strong>监理单位应该</strong>征得建设单位同意并书面通知建设单位</p><p><strong>监理单位</strong>应该于委托监理合同签订后<strong>10个工作日内</strong>将监理项目部的组织形式,人员构成及对总监理工程师的任命书书面形式通知<strong>建设单位.</strong></p><p><strong>建设单位</strong>应该将委托的监理单位,监理内容,<strong>书面通知承建单位.</strong></p><h3 id="3-32-企业信息化结构"><a href="#3-32-企业信息化结构" class="headerlink" title="3.32 企业信息化结构"></a>3.32 企业信息化结构</h3><p>分类:</p><p>①: 产品层<br>②: 作业层<br>③: 管理层<br>④: 决策层</p><h3 id="3-33-云计算"><a href="#3-33-云计算" class="headerlink" title="3.33 云计算"></a>3.33 云计算</h3><p>是一种服务<br>关键技术:<br>虚拟化 : 是一种资源管理技术,  包括服务器虚拟化 和 应用虚拟化<br>分布式系统: 分布式存储  和 分布式计算</p><h3 id="3-34-操作系统安全"><a href="#3-34-操作系统安全" class="headerlink" title="3.34 操作系统安全"></a>3.34 操作系统安全</h3><p>①: 切断: </p><p>可用性的威胁: 如非法用户破坏硬盘,破坏系统资源等</p><p>②: 截取</p><p>机密性的威胁:非法窃取和拷贝文件等</p><p>③: 篡改</p><p>完整性的威胁,非法用户修改网络中正在传送的消息等</p><p>④: 伪造</p><p>合法性的威胁,如非法用户把伪造的消息插入系统中等</p><h3 id="3-35-信息安全"><a href="#3-35-信息安全" class="headerlink" title="3.35 信息安全:"></a>3.35 信息安全:</h3><p>①: 设备安全: 是信息系统安全的<strong>首要问题</strong>,<strong>稳定,可靠,可用性</strong></p><p>②: 数据安全: <strong>秘密,完整,可用性</strong></p><p>③: 内容安全: <strong>政治,法律,道德层次</strong></p><p>④: 行为安全</p><p>3.36 信息安全</p><h3 id="3-36-物联网"><a href="#3-36-物联网" class="headerlink" title="3.36 物联网"></a>3.36 物联网</h3><p>传感器: 感受被测量的信息,将模拟信号转换为</p><p>嵌入式技术</p><h2 id="四、软件工程相关"><a href="#四、软件工程相关" class="headerlink" title="四、软件工程相关"></a>四、软件工程相关</h2><h3 id="4-1-数据流图"><a href="#4-1-数据流图" class="headerlink" title="4.1 数据流图:"></a>4.1 数据流图:</h3><h4 id="4-1-1-四个要素"><a href="#4-1-1-四个要素" class="headerlink" title="4.1.1 四个要素:"></a>4.1.1 四个要素:</h4><p>①: 数据流<br>②: 加工<br>③: 数据存储<br>④: <strong>外部实体</strong> : 存在于软件系统之外的<strong>人员或组织</strong></p><h3 id="4-2-软件维护"><a href="#4-2-软件维护" class="headerlink" title="4.2 软件维护:"></a>4.2 软件维护:</h3><p><strong>交付前和交付后,都要进行,</strong>是为需要提供软件支持的全部活动</p><h4 id="4-2-1-四种类型"><a href="#4-2-1-四种类型" class="headerlink" title="4.2.1 四种类型:"></a>4.2.1 四种类型:</h4><p>①: 适应性维护:  <strong>能适应变化</strong>(如<strong>迁移数据库</strong>,或操作系统),环境变化后能继续使用<br>②: 完善性维护: <strong>增加功能</strong><br>③: 更正性维护: 改正测试阶段未发现,投入生产<strong>运行一段时间后暴露</strong>的问题<br>④: 预防性维护: 更正<strong>潜在错误</strong>,为了改进软件未来的<strong>可维护性,和可靠性</strong>,或者给<strong>未来的改进</strong>提供更好的基础而做出的修改</p><p><strong>技巧: 题目中出现预防  /  未来  /  潜在 等字,基本可锁定预防性维护</strong></p><h3 id="4-3-开发方法"><a href="#4-3-开发方法" class="headerlink" title="4.3 开发方法:"></a>4.3 开发方法:</h3><h4 id="4-3-1-原型法"><a href="#4-3-1-原型法" class="headerlink" title="4.3.1 原型法:"></a>4.3.1 原型法:</h4><p><strong>需求不清, 快速开发</strong>一个原型系统, 通过反复修改来实现最终系统需求</p><h4 id="4-3-2瀑布模型"><a href="#4-3-2瀑布模型" class="headerlink" title="4.3.2瀑布模型:"></a>4.3.2瀑布模型:</h4><p><strong>需求明确,变更少</strong></p><h4 id="4-3-3-喷泉模型"><a href="#4-3-3-喷泉模型" class="headerlink" title="4.3.3 喷泉模型"></a>4.3.3 喷泉模型</h4><p>描述<strong>面向对象</strong>的软件开发过程</p><h3 id="4-4-CMMI-模型"><a href="#4-4-CMMI-模型" class="headerlink" title="4.4 CMMI 模型:"></a>4.4 CMMI 模型:</h3><p>Capability Maturity Model Integration 能力成熟度集成模型,整合了不同的CMM模型</p><p><strong>两种表示方法: </strong><br>①: 阶段式:  <strong>组织成熟度等级</strong><br>针对整个组织进行统一评价成熟度等级(初始级,<strong>可重复级</strong>,已定义级,<strong>已管理级(定量管理级)</strong>,优化级)</p><p><strong>已管理级 有7个过程域:</strong></p><p>过程和质量保证 : 使工作人员客观洞察过程和相关工作产品</p><p>②: 连续式:  <strong>过程能力等级</strong></p><p>针对组织的某些过程度评级,即评价组织的某个PA的能力等级为2级或3级.</p><h3 id="4-5-软件质量模型"><a href="#4-5-软件质量模型" class="headerlink" title="4.5 软件质量模型:"></a>4.5 软件质量模型:</h3><h4 id="4-5-1-McCall-质量模型"><a href="#4-5-1-McCall-质量模型" class="headerlink" title="4.5.1 McCall 质量模型:"></a>4.5.1 McCall 质量模型:</h4><p>三种视角来定义和识别软件质量</p><p>①: 产品<strong>转移</strong>: 可移植,可复用性</p><p>②: 产品<strong>修改</strong>: 可维护</p><p>③: 产品<strong>运行</strong>: 正确,可靠,效率,完整性</p><h3 id="4-6-需求分析"><a href="#4-6-需求分析" class="headerlink" title="4. 6 需求分析:"></a>4. 6 需求分析:</h3><h4 id="4-6-1-作用"><a href="#4-6-1-作用" class="headerlink" title="4.6.1 作用:"></a>4.6.1 作用:</h4><p>描述一个系统必须<strong>做什么</strong>,或者一个系统是什么(从用户那里了解需求的本质,知道软件需要做什么功能.)</p><h4 id="4-6-2-需求分析阶段用到的图形工具"><a href="#4-6-2-需求分析阶段用到的图形工具" class="headerlink" title="4.6.2 需求分析阶段用到的图形工具:"></a>4.6.2 需求分析阶段用到的图形工具:</h4><p>①: 层次方框图:</p><p>又称层次模块结构图, 将系统分为若干个子系统,子系统再划分为若干个模块,大模块再分为若干小模块,需求分析阶段可以用此图画出系统的功能蓝图.</p><p>②: 用例图:</p><p>从用户角度描述系统功能,是用户所能观察到的系统功能模型图,它可以用于需求分析阶段</p><p>③: IPO图:</p><p>Input Processing Output 输入加工输出, 描述功能需求的输入和输出,它可以用于需求分析阶段</p><p><strong>注: </strong> <strong>N-S图也称盒图,</strong>不能用于需求分析阶段, 在流程图中<strong>完全去掉流程线</strong>,全部算法写在一个矩形阵内,在框内还包含其他框的流程图形式.<strong>主要用于程序设计</strong></p><h4 id="4-6-3-产生的文档"><a href="#4-6-3-产生的文档" class="headerlink" title="4.6.3 产生的文档:"></a>4.6.3 产生的文档:</h4><p>软件需求规格说明,数据要求说明,<strong>初步用户手册</strong></p><p>初步用户手册通常是需求人员编写,写完需求文档,就可以写初步用户手册了(肯没有最终的功能界面,但已经可以作为联机帮助手册)</p><p><strong>注: 数据库设计是 详细设计的产物,    软件产品规格说明(产品说明书)  是 产品做出来后写的  </strong> </p><h3 id="4-7-软件需求"><a href="#4-7-软件需求" class="headerlink" title="4.7 软件需求"></a>4.7 软件需求</h3><h4 id="4-7-1-需求的层次"><a href="#4-7-1-需求的层次" class="headerlink" title="4.7.1 需求的层次:"></a>4.7.1 需求的层次:</h4><p>①: 业务需求</p><p>企业或客户对系统<strong>高层次</strong>的目标要求.</p><p>②: 用户需求</p><p>用户要求系统必须能完成的任务</p><p>③: 系统需求</p><p>包括<strong>功能需求</strong>,<strong>非功能需求</strong><br><strong>非功能性需求:</strong> 系统必须具备的<strong>属性或品质</strong>,及<strong>设计约束</strong></p><h4 id="4-7-2-系统需求分类"><a href="#4-7-2-系统需求分类" class="headerlink" title="4.7.2 系统需求分类"></a>4.7.2 系统需求分类</h4><p>①: 功能需求:</p><p><strong>必须完成</strong>的基本动作,用来完成具体的业务</p><p>例如: <strong>按照订单及原材料自动安排生产排序</strong><br><strong>定期生成销售分析报表</strong></p><p>②: 性能需求</p><p>软件或人与软件交互的静态或者动态<strong>数值需求</strong>.如响应<strong>速度</strong>,处理速度</p><p>③: 外部接口需求</p><p>用户接口,硬件接口,软件接口,通信接口</p><p>④: 设计约束和质量属性</p><p>设计约束: 受硬件限制<br>例如: 系统可实现对多字符集支持,GBK,BIG5,UTF-8等<br>必须运行在UNIX系统下等</p><p><strong>属性: 可用性,安全性,可维护性,可转移/转换性,效率</strong><br>例如: <strong>系统同时支持1000个独立站点的并发访问.</strong><br><strong>系统实行同城异地双机备份,保障数据安全</strong></p><p><strong>技巧:  </strong>看到”必须完成” 基本可以锁定功能需求<br>　　　看到”速度”基本可以锁定性能需求<br>　　　看到”安全,并发,字符集”基本可以锁定约束和质量属性</p><h4 id="4-7-3-质量功能部署QFD对需求的分类"><a href="#4-7-3-质量功能部署QFD对需求的分类" class="headerlink" title="4.7.3 质量功能部署QFD对需求的分类:"></a>4.7.3 质量功能部署QFD对需求的分类:</h4><p>QFD: Quality Function Deployment : 是一种将用户要求转换为软件需求的技术.</p><p>常规需求: 用户认为系统应具备的功能</p><p>期望需求: 用户<strong>想当然</strong>认为系统应具备的功能</p><p>意外需求: 用户没有提出的,开发人员自己加的</p><h3 id="4-8-敏捷方法"><a href="#4-8-敏捷方法" class="headerlink" title="4.8 敏捷方法"></a>4.8 敏捷方法</h3><p>敏捷软件开发宣言:<br>①: 个体和交互胜于过程和工具: <strong>以人为本</strong>的思想<br>②: 可以工作的<strong>软件胜于</strong>面面俱到的<strong>文档</strong><br>③: <strong>客户合作优于合同谈判</strong><br>④: 响应变化优于遵循计划</p><h3 id="4-9-软件过程改进"><a href="#4-9-软件过程改进" class="headerlink" title="4.9 软件过程改进"></a>4.9 软件过程改进</h3><h4 id="4-9-1-五条核心原则"><a href="#4-9-1-五条核心原则" class="headerlink" title="4.9.1 五条核心原则:"></a>4.9.1 五条核心原则:</h4><p>①: 注重问题<br>②: 强调知识创新<br>③: 鼓励参与<br>④: 领导层的统一<br>⑤: 计划不断改进</p><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.1.png" alt></p><h3 id="5-0-会话层"><a href="#5-0-会话层" class="headerlink" title="5.0 会话层"></a>5.0 会话层</h3><p>管理主机之间的会话进程,即<strong>负责建立,终止进程之间的会话</strong>,还利用在数据中插入校验点来实现<strong>数据同步.</strong></p><h3 id="5-1-传输层"><a href="#5-1-传输层" class="headerlink" title="5.1 传输层:"></a>5.1 传输层:</h3><p>传输层: 实现端用户之间可靠通信</p><p>SPX(序列分组交换协议)</p><h3 id="5-2-表示层"><a href="#5-2-表示层" class="headerlink" title="5.2 表示层"></a>5.2 表示层</h3><p>对上层数据或信息进行转换,以保证一个主机应用层信息,能被另一主机的应用程序理解.</p><p>MPEG协议</p><p><strong>数据加密,压缩,格式转换.</strong></p><h3 id="5-3-物理层"><a href="#5-3-物理层" class="headerlink" title="5.3 物理层:"></a>5.3 物理层:</h3><p>①: 集线器: 收集多个端口来的数据帧,并广播出去</p><p>是共享带宽式的,带宽由端口平均分配</p><p>②: 调制解调器: 模数/数模信号转换<br>③: 中继器: 用于<strong>完全相同的两类网络</strong>的互连,对数据信号<strong>重新发送或转发</strong>,来<strong>扩大网络传输距离</strong>. </p><p><strong>IEEE802.11</strong>: 标准定义了三种物理层通信技术:<br>直接序列扩频<br>调频扩频<br>漫反射红外线</p><h3 id="5-4-数据链路层"><a href="#5-4-数据链路层" class="headerlink" title="5.4 数据链路层:"></a>5.4 数据链路层:</h3><p>以太网交换机,根据以太帧中的地址转发数据帧.</p><p>IEEE802系列规范</p><h3 id="5-5-网络层"><a href="#5-5-网络层" class="headerlink" title="5.5 网络层"></a>5.5 网络层</h3><h4 id="5-5-1-路由器"><a href="#5-5-1-路由器" class="headerlink" title="5.5.1 路由器:"></a>5.5.1 路由器:</h4><h4 id="5-5-2-路由协议分类"><a href="#5-5-2-路由协议分类" class="headerlink" title="5.5.2 路由协议分类:"></a>5.5.2 路由协议分类:</h4><p><strong>内部网关协议IGP:</strong> 在一个AS(AutonomousSystem)<strong>自制系统</strong>(指有权自主决定在本系统应该采用何种路由选择协议的网络)内的路由协议</p><p><strong>外部网关协议: </strong> <strong>AS之间的路由协议</strong></p><h3 id="5-6-100BaseFX"><a href="#5-6-100BaseFX" class="headerlink" title="5.6 100BaseFX:"></a>5.6 100BaseFX:</h3><p>F: fiber光纤</p><p>是在<strong>光纤</strong>上实现的100Mbps标准, 运行于<strong>光缆</strong>上,适合<strong>长距离/骨干传输</strong>,<strong>802.3u</strong>标准</p><h3 id="5-7-层次化网络设计"><a href="#5-7-层次化网络设计" class="headerlink" title="5.7 层次化网络设计:"></a>5.7 层次化网络设计:</h3><h4 id="5-7-1-三个关键层概念"><a href="#5-7-1-三个关键层概念" class="headerlink" title="5.7.1 三个关键层概念:"></a>5.7.1 三个关键层概念:</h4><p>①: 核心层: Core Layer</p><p>目标: 高效速度传输,为网络提供骨干组件</p><p>②: 汇聚层: Distribution Layer</p><p>核心层与终端用户接入层的分界面</p><p>完成<strong>网络访问的策略控制</strong>,广播域的定义,过滤寻址等数据处理业务.</p><p>③: 接入层: Access Layer</p><p>网络分段,广播/多播能力,介质访问的安全性,路由发现,MAC地址的过滤</p><h3 id="5-8-关于TCP-UDP"><a href="#5-8-关于TCP-UDP" class="headerlink" title="5.8 关于TCP/UDP:"></a>5.8 关于TCP/UDP:</h3><h4 id="5-8-1-基于TCP协议"><a href="#5-8-1-基于TCP协议" class="headerlink" title="5.8.1 基于TCP协议 :"></a>5.8.1 基于TCP协议 :</h4><p>HTTP ,FTP,Telnet, SMTP ,POP3,  WWW</p><p>注: TFTP,NTP,SNMP是基于UDP</p><h3 id="5-9-网络交换"><a href="#5-9-网络交换" class="headerlink" title="5.9 网络交换"></a>5.9 网络交换</h3><h4 id="5-9-1-4-个发展阶段"><a href="#5-9-1-4-个发展阶段" class="headerlink" title="5.9.1   4 个发展阶段:"></a>5.9.1   4 个发展阶段:</h4><p>①: 电路交换<br><strong>面向连接</strong>,在通信前,需要为通信双方分配一条具有固定带宽的通信线路,通信双方在通信过程中将<strong>一直占用所分配的资源</strong>到通信结束.</p><p>②: 报文交换</p><p>采用<strong>存储转发机制</strong>,以报文为传送单元,用于实时性要求低,报文较短的通信业务</p><p>③: 分组交换</p><p><strong>面向无连接,采用存储转发方式,</strong>  将数据分割为小段并添加头部,作为数据传送的基本单元即分组, 比电路交换的电路利用率高,但时延大,适用于计算机网络,数据传输可靠,线路利用率较高</p><p>④: ATM   (Asynch-ronous TransferMode)</p><p><strong>异步传输模式</strong>,将<strong>面向连接机制和分组机制相结合</strong>,在通信开始前<strong>需要建立连接</strong>,但是该连接并<strong>不独占物理通道,</strong>而是和其他连接统计复用,同时所有的媒体信息,被分割并封装为<strong>固定长度的分组在网络中传送和交换.</strong></p><p>适合传送高速数据业务,ATM技术复杂性,导致ATM交换机造价及其昂贵</p><h3 id="5-10-双绞线"><a href="#5-10-双绞线" class="headerlink" title="5.10 双绞线"></a>5.10 双绞线</h3><p>屏蔽双绞线(Shielded  Twisted  Pair):</p><p>增加了全屏蔽层,减少了衰减和噪音, 价格贵重量重,不易安装,<strong>一般用于涉密信息等要求高的情况下</strong></p><p>非屏蔽双绞线(UnShielded  Twisted  Pair)</p><h3 id="5-11-AP"><a href="#5-11-AP" class="headerlink" title="5.11 AP"></a>5.11 AP</h3><p>AP接入点(Access Point) 是<strong>用于无线网络</strong>的无线HUB,是无线网络的核心.</p><p>它是移动计算机用户进入有线以太网骨干的接入点,AP可简单安装在天花板或墙壁,他在开放空间<strong>最大覆盖范围300米</strong>,无线<strong>传输速率11Mbps</strong>,理论上可<strong>同时接入1024 个移动设备</strong>.</p><h3 id="5-12-可用于查询IP地址的常见命令"><a href="#5-12-可用于查询IP地址的常见命令" class="headerlink" title="5.12 可用于查询IP地址的常见命令:"></a>5.12 可用于查询IP地址的常见命令:</h3><p>①: nslookup<br>②: tracert<br>③: ping</p><p>用法:    命令+ 域名 ,如 nslookup <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><strong>注: ipconfig 用于查询本地电脑IP,网关等信息的,命令后面不带网址.</strong></p><h3 id="5-13-网络分类"><a href="#5-13-网络分类" class="headerlink" title="5.13 网络分类"></a>5.13 网络分类</h3><h4 id="5-13-1-按照作用范围分"><a href="#5-13-1-按照作用范围分" class="headerlink" title="5.13.1 按照作用范围分:"></a>5.13.1 按照作用范围分:</h4><p>广域网WAN: (Wide Area Network)</p><p><strong>如北京到上海之间的网络按照作用范围分,它属于广域网</strong></p><p>城域网MAN</p><p>局域网LAN</p><h3 id="5-14-IEEE802"><a href="#5-14-IEEE802" class="headerlink" title="5.14 IEEE802"></a>5.14 IEEE802</h3><p>IEEE802.11 : 是WIFI 的技术标准<br>IEEE802.3 : 是以太网标准</p><h3 id="5-15-WLAN无线网络常用的认证与加密方式"><a href="#5-15-WLAN无线网络常用的认证与加密方式" class="headerlink" title="5.15 WLAN无线网络常用的认证与加密方式:"></a>5.15 WLAN无线网络常用的认证与加密方式:</h3><h4 id="5-15-1-WEP"><a href="#5-15-1-WEP" class="headerlink" title="5.15.1 WEP"></a>5.15.1 WEP</h4><p>Wired Equivalent Privacy ,有线等效保密,是对在两台设备间无线传输的数据进行加密的方式,用于防窃听</p><h4 id="5-15-2-WPA"><a href="#5-15-2-WPA" class="headerlink" title="5.15.2 WPA"></a>5.15.2 WPA</h4><p>WPA目前有四种认证方式:</p><p>WPA: 替代WEP, 加强了生成加密密钥的算法,增加了防数据中途被篡改的功能和认证功能</p><p>WPA2: 与WPA相比,增加了AES的加密方式</p><p>WPA-PSK</p><p>WPA2-PSK</p><h3 id="5-14-网络设备"><a href="#5-14-网络设备" class="headerlink" title="5.14 网络设备"></a>5.14 网络设备</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.2.png" alt></p><h2 id="六、数据库"><a href="#六、数据库" class="headerlink" title="六、数据库"></a>六、数据库</h2><h3 id="6-1-六种范式"><a href="#6-1-六种范式" class="headerlink" title="6.1 六种范式:"></a>6.1 六种范式:</h3><p>①: INF<br>②: 2NF<br>③: 3NF<br>④: BCNF<br>⑤: 4NF<br>⑥: 5NF</p><p><strong>范式级别越高,数据冗余程度越小,存储同样的数据就需要分解成更多张表,数据库性能(速度)将下降</strong></p><h2 id="七、项目范围管理"><a href="#七、项目范围管理" class="headerlink" title="七、项目范围管理:"></a>七、项目范围管理:</h2><h3 id="7-1-WBS的3种分解方法"><a href="#7-1-WBS的3种分解方法" class="headerlink" title="7.1 WBS的3种分解方法:"></a>7.1 WBS的3种分解方法:</h3><p>①: <strong>生命周期的各阶段</strong>作为分解的第二层,可交付性成功在第三层</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.3.png" alt></p><p>②: <strong>主要可交付性成果</strong>在第二层</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.4.png" alt></p><p>③:  子项目安排在第一层,再分解子项目的WBS</p><h3 id="7-2-WBS的分解过程注意事项"><a href="#7-2-WBS的分解过程注意事项" class="headerlink" title="7.2 WBS的分解过程注意事项:"></a>7.2 WBS的分解过程注意事项:</h3><p>①: 必须<strong>面向交付成果</strong></p><p>②: 必须<strong>由一个人负责</strong></p><p>③: 任务分解应该控制在<strong>4~6层</strong></p><p>④: <strong>分包</strong>出去的工作,和<strong>项目管理</strong>工作也在WBS中</p><p>⑤: 并非一成不变</p><p>④: <strong>工作单元从属唯一</strong>,避免交叉从属</p><p>⑤: 相同层次的工作单元有相同的性质</p><p>注: WBS中<strong>必须包含全部工作内容</strong>,即100%原则,未包括的则不属于项目范围,如果要增加必须遵循变更流程.</p><p><strong>大项目的WBS分解</strong>,可按照产品结构,生命周期,3个层次制定分解,<strong>不包含风险分解结构.</strong></p><h3 id="7-3-WBS过程的功能"><a href="#7-3-WBS过程的功能" class="headerlink" title="7.3 WBS过程的功能:"></a>7.3 WBS过程的功能:</h3><p>①: <strong>责任分工明确</strong><br>②: 定义<strong>绩效考核</strong>和控制基线<br>③: 提高成本、时间和资源<strong>估算的准确度</strong></p><h3 id="7-4-项目范围基线"><a href="#7-4-项目范围基线" class="headerlink" title="7.4 项目范围基线:"></a>7.4 项目范围基线:</h3><p>①: 项目范围说明书<br>②: WBS<br>③: WBS字典</p><h3 id="7-5-工作包"><a href="#7-5-工作包" class="headerlink" title="7.5 工作包"></a>7.5 工作包</h3><p>工作包是<strong>进度安排和成本估算</strong>,资源需求及控制的依据,是<strong>底层单元</strong></p><p>工作包<strong>必须</strong>是<strong>具体的</strong></p><h3 id="7-6-需求跟踪矩阵"><a href="#7-6-需求跟踪矩阵" class="headerlink" title="7.6 需求跟踪矩阵:"></a>7.6 需求跟踪矩阵:</h3><p>目的: <strong>追溯</strong>需求实现情况,和<strong>回溯</strong>需求来源,而<strong>不是确认需求</strong></p><p>可改善产品质量,降低维护成本,容易实现重用</p><p><strong>回溯:</strong> 又称逆向跟踪, 检查设计文档,代码测试用例等是否能在<strong>&lt;&lt;产品需求规格说明书&gt;&gt;</strong>中找到出处</p><h3 id="7-7-项目范围说明书"><a href="#7-7-项目范围说明书" class="headerlink" title="7.7 项目范围说明书:"></a>7.7 项目范围说明书:</h3><p>包含产品范围 和  项目范围</p><p>范围说明书的<strong>输入是  : 项目章程 </strong></p><p>范围说明书的 <strong>主要内容: 可交付成果,项目目标</strong></p><h3 id="7-8-创建WBS的输入"><a href="#7-8-创建WBS的输入" class="headerlink" title="7.8 创建WBS的输入:"></a>7.8 创建WBS的输入:</h3><p>①: 范围管理计划<br>②: 项目范围说明书<br>③: 需求文件<br>④: 组织过程资产</p><h3 id="7-9-范围确认的输入"><a href="#7-9-范围确认的输入" class="headerlink" title="7.9 范围确认的输入:"></a>7.9 范围确认的输入:</h3><p>①: 项目范围说明书<br>②: WBS<br>③: 项目范围管理计划<br>④: 可交付物</p><h3 id="7-10-WBS字典"><a href="#7-10-WBS字典" class="headerlink" title="7.10 WBS字典:"></a>7.10 WBS字典:</h3><p>包括账户编码,工作描述,执行组织,里程碑列表,资源需求,成本估算,活动列表等是对工作包的细节描述.<br><strong>不包含管理储备</strong></p><h3 id="7-11-控制账户"><a href="#7-11-控制账户" class="headerlink" title="7.11 控制账户:"></a>7.11 控制账户:</h3><p>控制账户是一个<strong>管理控制点</strong>,在该控制点上,把范围预算,实际成本和进度加以整合,并与挣值比较,以<strong>测量绩效.</strong></p><p>每个工作包分配到一个控制账户,并根据”账户编码”为工作包建立唯一的标识,是<strong>创建WBS的最后一步.</strong></p><p><strong>每个控制账户可能包括一个或多个工作包</strong>,但<strong>一个工作包只能属于一个控制账户.</strong></p><h3 id="7-12-追溯和回溯区别"><a href="#7-12-追溯和回溯区别" class="headerlink" title="7.12 追溯和回溯区别:"></a>7.12 追溯和回溯区别:</h3><p>追溯: 客户需求向前追溯到需求, <strong>跟踪需求,以免被做漏做偏</strong></p><p>回溯: 从需求回溯相应的客户需求, <strong>查清需求源头</strong>,了解为什么要做这个需求</p><h3 id="7-13-需求开发过程"><a href="#7-13-需求开发过程" class="headerlink" title="7.13 需求开发过程:"></a>7.13 需求开发过程:</h3><p>顺序如下:</p><p>①: 需求获取</p><p>②: 分析</p><p>③: 定义</p><p>④: 验证</p><p>⑤: 确定需求基线</p><p><strong>注:</strong>  <strong>先分析后定义</strong></p><h3 id="7-14-范围确认和-质量控制"><a href="#7-14-范围确认和-质量控制" class="headerlink" title="7.14 范围确认和 质量控制:"></a>7.14 范围确认和 质量控制:</h3><p>质量控制: 核实工作结果<strong>正确</strong>与否</p><p>范围确认: 有关工作结果是否<strong>可接受</strong><br>例如: ①对详细的范围说明书进行评审,提交客户签字确认<br>②:与客户开展审查,判断工作和交付成果是否符合标准.</p><h3 id="7-15-范围控制"><a href="#7-15-范围控制" class="headerlink" title="7.15 范围控制:"></a>7.15 范围控制:</h3><p>作用: 防止范围蔓延(范围蔓延就是范围不受控制)<br>例: 客户提出新的需求时,说服他放弃新需求</p><h3 id="7-16-滚动式计划"><a href="#7-16-滚动式计划" class="headerlink" title="7.16 滚动式计划"></a>7.16 滚动式计划</h3><p>创建工作分解结构时,<strong>近期的要分解详细,以便于安排核实,</strong>远期的可以放一个规划包,滚动规划和分解.</p><h3 id="7-17-项目范围管理的流程"><a href="#7-17-项目范围管理的流程" class="headerlink" title="7.17 项目范围管理的流程:"></a>7.17 项目范围管理的流程:</h3><p>顺序如下:<br>①: 收集需求<br>②: 定义范围<br>③: 创建工作分解结构<br>④: 核实范围<br>⑤: 控制范围</p><h3 id="7-18-范围管理和时间管理的顺序"><a href="#7-18-范围管理和时间管理的顺序" class="headerlink" title="7.18 范围管理和时间管理的顺序:"></a>7.18 范围管理和时间管理的顺序:</h3><p><strong>范围规划——&gt;范围定义——-&gt;活动定义——-&gt;活动排序——–&gt;活动历时估算</strong></p><p><strong>注: 先规划,后定义</strong></p><h2 id="八、项目整体管理"><a href="#八、项目整体管理" class="headerlink" title="八、项目整体管理:"></a>八、项目整体管理:</h2><h3 id="8-1-事业环境因素"><a href="#8-1-事业环境因素" class="headerlink" title="8.1 事业环境因素:"></a>8.1 事业环境因素:</h3><p>①: 国家标准或行业标准<br>②: <strong>帮助管理项目的工具</strong>(项目管理系统)<br>③: 实施单位的企业文化和组织机构<br>④: 市场状况<br>⑤: 行业数据库<br>⑥: 现有设施和固定资产等</p><h3 id="8-2-组织过程资产"><a href="#8-2-组织过程资产" class="headerlink" title="8.2 组织过程资产"></a>8.2 组织过程资产</h3><p><strong>①: 变更控制流程 </strong>  项目团队可以   <strong>选择,增补</strong>   是   <strong>组织过程资产范畴</strong><br><strong>②: 合同 也 属于 组织过程资产</strong><br><strong>③: 产品组件标准 也 属于 组织过程资产</strong></p><p><strong>组织内部形成的 而不是全行业 的 统一标准 则不能算组织过程资产</strong>.</p><h3 id="8-3-五大启动过程组-47个子过程"><a href="#8-3-五大启动过程组-47个子过程" class="headerlink" title="8.3 五大启动过程组,47个子过程"></a>8.3 五大启动过程组,47个子过程</h3><h4 id="8-3-1-启动过程组-项目启动"><a href="#8-3-1-启动过程组-项目启动" class="headerlink" title="8.3.1 启动过程组(项目启动)"></a>8.3.1 启动过程组(项目启动)</h4><p><strong>定义并批准</strong>项目或项目阶段, <strong>制定项目章程,和识别项目干系人</strong></p><h4 id="8-3-2-计划过程组-指定项目计划"><a href="#8-3-2-计划过程组-指定项目计划" class="headerlink" title="8.3.2 计划过程组(指定项目计划)"></a>8.3.2 计划过程组(指定项目计划)</h4><p>①: 建立WBS 和 WBS字典<br>②: 项目风险分析<br>③: 定义和细化目标,规划最佳的行动方案.</p><p>活动排序</p><h4 id="8-3-3-执行过程组-指导和管理项目执行"><a href="#8-3-3-执行过程组-指导和管理项目执行" class="headerlink" title="8.3.3 执行过程组(指导和管理项目执行)"></a>8.3.3 执行过程组(指导和管理项目执行)</h4><p>项目团队的组建<br>项目质量保证<br>询价<br>卖方选择</p><h4 id="8-3-4-监督和控制组"><a href="#8-3-4-监督和控制组" class="headerlink" title="8.3.4 监督和控制组"></a>8.3.4 监督和控制组</h4><h4 id="8-3-5-项目收尾"><a href="#8-3-5-项目收尾" class="headerlink" title="8.3.5 项目收尾"></a>8.3.5 项目收尾</h4><p>合同收尾<br>管理收尾 : 也叫行政收尾,指导项目收尾的程序和方法, 包括收尾的所有活动 及角色 职责.</p><h3 id="8-4-项目管理计划过程的输入"><a href="#8-4-项目管理计划过程的输入" class="headerlink" title="8.4 项目管理计划过程的输入"></a>8.4 项目管理计划过程的输入</h3><p>①: 项目章程:  用于确定项目地位,对项目经理授权<br>②: 事业环境因素<br>③: 组织过程资产</p><h3 id="8-5-项目初步范围说明书内容"><a href="#8-5-项目初步范围说明书内容" class="headerlink" title="8.5 项目初步范围说明书内容:"></a>8.5 项目初步范围说明书内容:</h3><p>项目范围和目标<br>项目需求和交付物<br>产品或服务的需求和特点</p><h3 id="8-6-项目工作说明书内容"><a href="#8-6-项目工作说明书内容" class="headerlink" title="8.6 项目工作说明书内容:"></a>8.6 项目工作说明书内容:</h3><p>①: 业务需求</p><p>②: 产品范围描述</p><h3 id="8-7-项目收尾的输出"><a href="#8-7-项目收尾的输出" class="headerlink" title="8.7 项目收尾的输出:"></a>8.7 项目收尾的输出:</h3><p>①: 合同收尾章程<br>②: 管理收尾章程<br>③: 组织过程资产更新</p><h3 id="8-8-合同收尾-的内容"><a href="#8-8-合同收尾-的内容" class="headerlink" title="8.8 合同收尾  的内容"></a>8.8 合同收尾  的内容</h3><p>项目验收</p><h3 id="8-9-项目评估"><a href="#8-9-项目评估" class="headerlink" title="8.9 项目评估"></a>8.9 项目评估</h3><p><strong>主要特征:</strong><br>①: 整体性 : 综合集成经济,环境 ,风险,技术运行<br>②: 目标性<br>③: 相关性: 时间,知识,逻辑<br>④: 动态性: 项目生命周期</p><h3 id="8-10-项目管理计划的内容"><a href="#8-10-项目管理计划的内容" class="headerlink" title="8.10 项目管理计划的内容:"></a>8.10 项目管理计划的内容:</h3><p><strong>注: 项目绩效信息 是在 项目执行中产生的,不包括在项目管理计划中</strong></p><h3 id="8-11-项目监控工作成果"><a href="#8-11-项目监控工作成果" class="headerlink" title="8.11 项目监控工作成果:"></a>8.11 项目监控工作成果:</h3><p>变更请求<br>工作绩效报告<br>项目管理计划更新<br>项目文件更新</p><h3 id="8-12-项目章程的内容-很重要"><a href="#8-12-项目章程的内容-很重要" class="headerlink" title="8.12 项目章程的内容: (很重要)"></a>8.12 项目章程的内容: (很重要)</h3><p>指定项目经理及授权级别<br>概要的里程碑计划<br>干系人的影响<br>职能组织<br>项目目的或论证结果<br>项目需求,商业需求,项目概述,产品需求<br>概要预算<br>假设及约束条件<br>项目的业务方案<br>投资回报率</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.5.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="考证" scheme="https://zzwwqq.xyz/categories/%E8%80%83%E8%AF%81/"/>
    
    
      <category term="信息系统项目管理师" scheme="https://zzwwqq.xyz/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>java网络编程之TCP-UDP</title>
    <link href="https://zzwwqq.xyz/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP.html"/>
    <id>https://zzwwqq.xyz/java网络编程之TCP-UDP/java网络编程之TCP-UDP.html</id>
    <published>2019-04-13T01:49:05.000Z</published>
    <updated>2019-04-13T03:22:20.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网络编程基础"><a href="#一、网络编程基础" class="headerlink" title="一、网络编程基础"></a>一、网络编程基础</h2><h3 id="1-1-网络编程有两个主要的问题"><a href="#1-1-网络编程有两个主要的问题" class="headerlink" title="1.1 网络编程有两个主要的问题:"></a>1.1 网络编程有两个主要的问题:</h3><p>①: 如何准确定位网络上的一台或多台主机<br>②: 定位后如何可靠高效的传输数据</p><a id="more"></a><p>在TCP/IP中,IP层主要负责网络主机的定位,数据传输的路由,由IP地址可以唯一的确定网络上的一台主机.<br>而TCP层提供面向应用的数据传输机制,这是网络编程的主要对象.</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2  基本概念:"></a>1.2  基本概念:</h3><p><strong>端口号:</strong>  网络通信时同一机器上的不同进程的标识（其中0~1023为系统保留的端口号）,<strong>端口范围: 0~65535</strong><br><strong>套接字:</strong>  <strong>IP : 端口号</strong><br><strong>资源名: </strong>是资源的完整地址,包括主机名,端口号,文件名,如<a href="http://www.sun.com" target="_blank" rel="noopener">http://www.sun.com</a> （协议名://主机名）<a href="http://home.netscape.com/home/welcome.html（协议名：/机器名+文件名）" target="_blank" rel="noopener">http://home.netscape.com/home/welcome.html（协议名：//机器名+文件名）</a><br><strong>协议名：</strong>指明获取资源时所使用的传输协议。  如http，ftp,gopher,file</p><h3 id="1-3-关于UDP"><a href="#1-3-关于UDP" class="headerlink" title="1.3 关于UDP:"></a>1.3 关于UDP:</h3><p>UDP: <strong>无连接</strong>的协议,<strong>每个数据报都是一个独立的信息</strong>,<strong>包括完整的源地址或目的地址</strong>,它在网络上任何可能路径传往目的地<br>,<strong>不可靠性</strong>(发送方发送的数据报不一定以相同次序到达接收方),<strong>传输效率高</strong>,<strong>有大小限制</strong>(每个数据报大小不超过64KB),.</p><h3 id="1-4-获取网络信息和资源"><a href="#1-4-获取网络信息和资源" class="headerlink" title="1.4 获取网络信息和资源:"></a>1.4 获取网络信息和资源:</h3><h4 id="1-4-1-非常重要的一个类-InetAddress-IP地址的封装类"><a href="#1-4-1-非常重要的一个类-InetAddress-IP地址的封装类" class="headerlink" title="1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)"></a>1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)</h4><p>java.net中很多类使用到了它,如ServerSocket, Socket , DatagramSocket等</p><h4 id="1-4-2-常用方法"><a href="#1-4-2-常用方法" class="headerlink" title="1.4.2 常用方法:"></a>1.4.2 常用方法:</h4><p><strong>获取本机主机名:</strong> InetAddress.getLocalHost().getHostName()<br><strong>获取本机IP:</strong>  InetAddress.getLocalHost().getHostAddress()<br><strong>获取本机端口: </strong>serverSocket = new ServerSocket(6666); serverSocket.getLocalPort();</p><p><strong>服务器端获取客户端IP: </strong>Socket socket = serverSocket.accept(); socket.getInetAddress().getHostAddress();<br><strong>服务器获取客户端端口: </strong>String.valueOf(socket.getPort())</p><h2 id="二、基于TCP的网络通信"><a href="#二、基于TCP的网络通信" class="headerlink" title="二、基于TCP的网络通信:"></a>二、基于TCP的网络通信:</h2><h3 id="2-1-通过套接字建立连接的过程"><a href="#2-1-通过套接字建立连接的过程" class="headerlink" title="2.1 通过套接字建立连接的过程:"></a>2.1 通过套接字建立连接的过程:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.1.png" alt></p><h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例:"></a>2.2 实例:</h3><p><strong>客户端:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Client();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Socket sock;</span><br><span class="line">    <span class="comment">//界面上显示的组件</span></span><br><span class="line">    JTextField txtMsgServerIP = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JTextField txtMsgServerPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    JButton btnConnect = <span class="keyword">new</span> JButton(<span class="string">"连接服务器"</span>);</span><br><span class="line">    JButton btnDisConnect = <span class="keyword">new</span> JButton(<span class="string">"断开连接"</span>);</span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据输入输出流</span></span><br><span class="line">    DataOutputStream out;</span><br><span class="line">    DataInputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> canWaite = <span class="keyword">true</span>;</span><br><span class="line">    CWaiter waiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器中完成初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//容器</span></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始状态时"连接服务器"按钮可点击</span></span><br><span class="line">        btnConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//初始状态时"断开连接"按钮不可点击</span></span><br><span class="line">        btnDisConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时文本域不可编辑,只能用于显示通话信息</span></span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时发送消息的编辑框不可输入</span></span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时发送按钮不可点</span></span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建面板</span></span><br><span class="line">        JPanel jp =  <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER));</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器IP"</span>));</span><br><span class="line">        jp_f1.add(txtMsgServerIP);</span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器端口号"</span>));</span><br><span class="line">        jp_f1.add(txtMsgServerPort);</span><br><span class="line"></span><br><span class="line">        jp_f2.add(btnConnect);</span><br><span class="line">        jp_f2.add(btnDisConnect);</span><br><span class="line"></span><br><span class="line">        jp.add(jp_f1);</span><br><span class="line">        jp.add(jp_f2);</span><br><span class="line">        <span class="comment">//创建面板,并把组件添加到面板</span></span><br><span class="line">        JScrollPane jsp =  <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp2 = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组件添加到面板</span></span><br><span class="line"></span><br><span class="line">        jp2.add(txtMsgSend);</span><br><span class="line">        jp2.add(btnSend);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//面板添加到容器</span></span><br><span class="line">        container.add(jp,<span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp,<span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp2,<span class="string">"South"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口标题</span></span><br><span class="line">        setTitle(<span class="string">"客户端"</span>);</span><br><span class="line">        <span class="comment">//窗口大小</span></span><br><span class="line">        setSize(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//是否可见</span></span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给组件添加监听器</span></span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnConnect.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnDisConnect.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加窗口监听器</span></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//窗口关闭事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    disconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String ServerIP,Integer ServerPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建套接字,用于连接服务器</span></span><br><span class="line">            sock = <span class="keyword">new</span> Socket(ServerIP,ServerPort);</span><br><span class="line">            <span class="comment">//由套接字获取输入输出流</span></span><br><span class="line">            InputStream is = sock.getInputStream();</span><br><span class="line">            OutputStream os = sock.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由输入输出流获取数据输入输出流</span></span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(is);</span><br><span class="line">            out = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向输出流(向服务器端)写数据</span></span><br><span class="line">            out.writeUTF(<span class="string">"客户进来"</span>);</span><br><span class="line">            <span class="comment">//客户端的文本域中显示连接信息</span></span><br><span class="line">            txtMsgArea.append(<span class="string">"连接成功\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//连接服务器按钮 设置为不可点击(因为现在已经连接了服务器,避免重复连接,所以按钮设置为不可点击)</span></span><br><span class="line">            btnConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//断开连接按钮 设置为 可点击</span></span><br><span class="line">            btnDisConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//发送信息按钮 设置为 可点击</span></span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//发送信息的编辑框 设置为可输入</span></span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动线程</span></span><br><span class="line">            waiter = <span class="keyword">new</span> CWaiter();</span><br><span class="line">            waiter.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"连接服务器失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端发送消息到服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发送的消息不为空</span></span><br><span class="line">       <span class="keyword">if</span>(!txtMsgSend.getText().equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//通过输出流向服务器发消息</span></span><br><span class="line">               out.writeUTF(txtMsgSend.getText());</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"发送消息失败!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"不能发送空消息!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置组件权限</span></span><br><span class="line">        btnConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        btnDisConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向服务器发消息,内容为disconnect,表示要断开连接</span></span><br><span class="line">            out.writeUTF(<span class="string">"disconnect"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            canWaite = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭输入输出流</span></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//关闭套接字</span></span><br><span class="line">                    sock.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果点击了发送按钮,就调用sendMsg函数,发送消息到服务器</span></span><br><span class="line">        <span class="keyword">if</span>(e.getSource() == btnSend || e.getSource() == txtMsgSend)&#123;</span><br><span class="line">            sendMsg();</span><br><span class="line">            txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == btnConnect)&#123; <span class="comment">//如果点击了连接按钮,就调用connect函数</span></span><br><span class="line">            <span class="comment">//都不为空</span></span><br><span class="line">            <span class="keyword">if</span>(!(txtMsgServerIP.getText().equals(<span class="string">""</span>) || txtMsgServerPort.getText().equals(<span class="string">""</span>)))&#123;</span><br><span class="line">                canWaite = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> ServerPort = Integer.parseInt(txtMsgServerPort.getText());</span><br><span class="line">                <span class="keyword">if</span>(!(ServerPort &gt; <span class="number">0</span>  &amp;&amp; ServerPort &lt; <span class="number">65535</span>)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"端口值必须在0~65535之间!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                connect(txtMsgServerIP.getText(),Integer.parseInt(txtMsgServerPort.getText()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//不都为空</span></span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"服务器IP或端口号不能为空!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == btnDisConnect)&#123;</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于接收信息的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CWaiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>(canWaite) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//从输入流中读取服务器返回的数据</span></span><br><span class="line">                    msg = in.readUTF();</span><br><span class="line">                    <span class="keyword">if</span>(msg.equals(<span class="string">"serverStop"</span>))&#123;</span><br><span class="line">                        txtMsgArea.append(<span class="string">"服务器停止!\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    txtMsgArea.append(<span class="string">"服务器说: "</span>+ msg + <span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            txtMsgArea.append(<span class="string">"客户离开\n"</span>);</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.2.png" alt></p><p><strong>服务器端: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义界面组件</span></span><br><span class="line">    JTextField txtServerPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">    JButton btnStart = <span class="keyword">new</span> JButton(<span class="string">"启动服务器"</span>);</span><br><span class="line">    JButton btnStop = <span class="keyword">new</span> JButton(<span class="string">"停止服务器"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端套接字</span></span><br><span class="line">    ServerSocket serverSocket;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="comment">//数据流</span></span><br><span class="line">    DataOutputStream out;</span><br><span class="line">    DataInputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制线程的逻辑变量</span></span><br><span class="line">    <span class="keyword">boolean</span> canWaiter = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canAccepter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    Accepter accepter;</span><br><span class="line">    SWaiter waiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器中完成界面初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        btnStart.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        btnStop.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网格布局</span></span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//流式布局</span></span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER));</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器端口号"</span>));</span><br><span class="line">        jp_f1.add(txtServerPort);</span><br><span class="line">        jp_f2.add(btnStart);</span><br><span class="line">        jp_f2.add(btnStop);</span><br><span class="line"></span><br><span class="line">        jp.add(jp_f1);</span><br><span class="line">        jp.add(jp_f2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp2 = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        jp2.add(txtMsgSend);</span><br><span class="line">        jp2.add(btnSend);</span><br><span class="line"></span><br><span class="line">        container.add(jp, <span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp, <span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp2, <span class="string">"South"</span>);</span><br><span class="line"></span><br><span class="line">        setTitle(<span class="string">"服务器"</span>);</span><br><span class="line">        setSize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        btnStart.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStop.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                stopServer();</span><br><span class="line">                dispose();</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(Integer txtServerPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(txtServerPort);</span><br><span class="line">            btnStart.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            btnStop.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            accepter = <span class="keyword">new</span> Accepter();</span><br><span class="line">            accepter.start();</span><br><span class="line">            <span class="comment">//System.out.println(InetAddress.getLocalHost().getHostName());</span></span><br><span class="line">            <span class="comment">//System.out.println(InetAddress.getLocalHost().getHostAddress());</span></span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器已成功启动...\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器主机名为: "</span> + InetAddress.getLocalHost().getHostName()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器IP地址为: "</span> + InetAddress.getLocalHost().getHostAddress()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器端口号为: "</span> + serverSocket.getLocalPort()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"启动服务器失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息到客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!txtMsgSend.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//向客户端写数据</span></span><br><span class="line">                out.writeUTF(txtMsgSend.getText());</span><br><span class="line">                txtMsgArea.append(<span class="string">"服务器说: "</span> + txtMsgSend.getText() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"发送消息失败!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"不能发送消息!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置组件的权限</span></span><br><span class="line">        btnStop.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnStart.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//停止等待客户端请求的线程</span></span><br><span class="line">        canAccepter = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向输出流写数据,通知客户端服务器已停止.</span></span><br><span class="line">            out.writeUTF(<span class="string">"serverStop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭服务器端套接字</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//断开连接</span></span><br><span class="line">                disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向输出流写数据,通知客户端服务器已停止.</span></span><br><span class="line">            out.writeUTF(<span class="string">"serverStop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//停止接收信息的线程</span></span><br><span class="line">            canWaiter = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭流</span></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//关闭套接字</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据套接字获得输入输出流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由输入输出流 建立数据输入输出流</span></span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(is);</span><br><span class="line">            out = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从输入流读取客户端写入的数据,并显示</span></span><br><span class="line">            String msg = in.readUTF();</span><br><span class="line">            txtMsgArea.append(msg + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置组件的权限</span></span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line">            canWaiter = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//建立 和 启动线程</span></span><br><span class="line">            waiter = <span class="keyword">new</span> SWaiter();</span><br><span class="line">            waiter.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件(如按钮被点击)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == btnSend || e.getSource() == txtMsgSend) &#123;</span><br><span class="line">            sendMsg();</span><br><span class="line">            <span class="comment">//发送完消息后清空输入框,以便下一次输入</span></span><br><span class="line">            txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">            <span class="comment">//定位焦点到输入框,以便下一次输入</span></span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == btnStart) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(txtServerPort.getText().equals(<span class="string">""</span>)))&#123;</span><br><span class="line">                <span class="keyword">int</span> ServerPort = Integer.parseInt(txtServerPort.getText());</span><br><span class="line">                <span class="keyword">if</span>(!(ServerPort &gt; <span class="number">0</span>  &amp;&amp; ServerPort &lt; <span class="number">65535</span>)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"端口值必须在0~65535之间!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                canAccepter = <span class="keyword">true</span>;</span><br><span class="line">                canWaiter = <span class="keyword">true</span>;</span><br><span class="line">                startServer(ServerPort);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == btnStop) &#123;</span><br><span class="line">            stopServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收客户端请求的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Accepter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (canAccepter) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                    acceptConnect();</span><br><span class="line">                    <span class="comment">//在服务器端窗口显示客户端的IP地址和端口格式为  "/192.168.56.1:9606"</span></span><br><span class="line">                    <span class="comment">//txtMsgArea.append(socket.getRemoteSocketAddress().toString()+"\n");</span></span><br><span class="line">                    <span class="comment">//在服务器端窗口显示客户端的IP地址</span></span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户端IP地址: "</span>+socket.getInetAddress().getHostAddress()+<span class="string">"\n"</span>);</span><br><span class="line">                    <span class="comment">//服务器端窗口显示客户端端口</span></span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户端端口号: "</span>+ String.valueOf(socket.getPort())+<span class="string">"\n"</span>);</span><br><span class="line">                    txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭服务器套接字</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待消息的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SWaiter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (canWaiter) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    msg = in.readUTF();</span><br><span class="line">                    <span class="keyword">if</span> (msg.equals(<span class="string">"disconnect"</span>)) &#123;</span><br><span class="line">                        txtMsgArea.append(<span class="string">"客户离开!\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户说: "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            txtMsgArea.append(<span class="string">"断开连接\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行图: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.3.png" alt></p><p><strong>客户端与服务器通信:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.4.png" alt></p><h2 id="三、基于UDP的网络通信"><a href="#三、基于UDP的网络通信" class="headerlink" title="三、基于UDP的网络通信:"></a>三、基于UDP的网络通信:</h2><h3 id="3-1-实例"><a href="#3-1-实例" class="headerlink" title="3.1 实例:"></a>3.1 实例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostComputer</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HostComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文本域</span></span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    <span class="comment">//输入框</span></span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//对方地址</span></span><br><span class="line">    JTextField txtToAddress = <span class="keyword">new</span> JTextField(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//对方端口</span></span><br><span class="line">    JTextField txtToPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//本地端口</span></span><br><span class="line">    JTextField txtLocalPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//按钮</span></span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">    JButton btnStart = <span class="keyword">new</span> JButton(<span class="string">"开始"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">byte</span>[]buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    InetAddress toAddress;</span><br><span class="line">    <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">int</span> toPort;</span><br><span class="line">    <span class="comment">//本地端口</span></span><br><span class="line">    <span class="keyword">int</span> localPort;</span><br><span class="line">    <span class="comment">//数据报套接字</span></span><br><span class="line">    DatagramSocket socket;</span><br><span class="line">    <span class="comment">//控制线程的逻辑变量</span></span><br><span class="line">    <span class="keyword">boolean</span> canWaiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置组件权限</span></span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        JPanel jp_G = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"对方地址"</span>));</span><br><span class="line">        jp_f1.add(txtToAddress);</span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"对方端口"</span>));</span><br><span class="line">        jp_f1.add(txtToPort);</span><br><span class="line"></span><br><span class="line">        jp_f2.add(<span class="keyword">new</span> JLabel(<span class="string">"本地端口"</span>));</span><br><span class="line">        jp_f2.add(txtLocalPort);</span><br><span class="line">        jp_f2.add(btnStart);</span><br><span class="line"></span><br><span class="line">        jp_G.add(jp_f1);</span><br><span class="line">        jp_G.add(jp_f2);</span><br><span class="line"></span><br><span class="line">        jp.add(txtMsgSend);</span><br><span class="line">        jp.add(btnSend);</span><br><span class="line"></span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStart.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        container.add(jp_G,<span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp,<span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp,<span class="string">"South"</span>);</span><br><span class="line">        setTitle(<span class="string">"基于数据报的UDP通信"</span>);</span><br><span class="line">        setSize(<span class="number">500</span>,<span class="number">300</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   stop();</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e1)&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               dispose();</span><br><span class="line">               System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            toAddress = InetAddress.getByName(txtToAddress.getText());</span><br><span class="line">            toPort = Integer.parseInt(txtToPort.getText());</span><br><span class="line">            localPort = Integer.parseInt(txtLocalPort.getText());</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(localPort);</span><br><span class="line">            canWaiter = <span class="keyword">true</span>;</span><br><span class="line">            (<span class="keyword">new</span> Waiter()).start();</span><br><span class="line">            <span class="comment">//设置组件权限</span></span><br><span class="line">            txtToAddress.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtToPort.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtLocalPort.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            btnStart.setText(<span class="string">"停止"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"启动失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置按钮权限</span></span><br><span class="line">       txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">       txtLocalPort.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       txtToPort.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       txtToAddress.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//txtMsgArea.setEditable(false);</span></span><br><span class="line">       btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       canWaiter = <span class="keyword">false</span>;</span><br><span class="line">       toAddress = <span class="keyword">null</span>;</span><br><span class="line">       socket.close();</span><br><span class="line">       btnStart.setText(<span class="string">"开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!txtMsgSend.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = txtMsgSend.getText().getBytes();</span><br><span class="line">            DatagramPacket packet =  <span class="keyword">new</span> DatagramPacket(b,b.length,toAddress,toPort);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                txtMsgArea.append(<span class="string">"发送的数据: "</span>+txtMsgSend.getText()+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgArea.append(<span class="string">"发送到"</span>+toAddress+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgArea.append(<span class="string">"数据长度为: "</span>+packet.getLength()+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">                txtMsgSend.requestFocus();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"不能发送空消息!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(canWaiter)&#123;</span><br><span class="line">           DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               socket.receive(packet);</span><br><span class="line">               String received = <span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">               txtMsgArea.append(<span class="string">"收到的数据: "</span>+received+<span class="string">"\n"</span>);</span><br><span class="line">               txtMsgArea.append(<span class="string">"数据来自于: "</span>+packet.getAddress()+<span class="string">"\n"</span>);</span><br><span class="line">               txtMsgArea.append(<span class="string">"数据长度为: "</span>+packet.getLength()+<span class="string">"\n"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.getSource() == txtMsgSend || e.getSource() == btnSend)&#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getActionCommand().equals(<span class="string">"开始"</span>))&#123;</span><br><span class="line">            start();</span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getActionCommand().equals(<span class="string">"停止"</span>))&#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行两次,出现两个窗口,在这两个窗口进行通信**</strong></p><p><strong>运行图: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.5.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、网络编程基础&quot;&gt;&lt;a href=&quot;#一、网络编程基础&quot; class=&quot;headerlink&quot; title=&quot;一、网络编程基础&quot;&gt;&lt;/a&gt;一、网络编程基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-网络编程有两个主要的问题&quot;&gt;&lt;a href=&quot;#1-1-网络编程有两个主要的问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 网络编程有两个主要的问题:&quot;&gt;&lt;/a&gt;1.1 网络编程有两个主要的问题:&lt;/h3&gt;&lt;p&gt;①: 如何准确定位网络上的一台或多台主机&lt;br&gt;②: 定位后如何可靠高效的传输数据&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="Java网络编程" scheme="https://zzwwqq.xyz/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android之UI</title>
    <link href="https://zzwwqq.xyz/Android%E4%B9%8BUI.html"/>
    <id>https://zzwwqq.xyz/Android之UI.html</id>
    <published>2019-04-09T04:28:34.000Z</published>
    <updated>2019-04-13T03:14:53.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、如何编写程序界面"><a href="#一、如何编写程序界面" class="headerlink" title="一、如何编写程序界面:"></a>一、如何编写程序界面:</h2><p>Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局.</p><h2 id="二、常见控件的使用方法"><a href="#二、常见控件的使用方法" class="headerlink" title="二、常见控件的使用方法"></a>二、常见控件的使用方法</h2><h3 id="2-1-TextView"><a href="#2-1-TextView" class="headerlink" title="2.1 TextView"></a>2.1 TextView</h3><p>主要用于在界面上显示一段文本信息,设置颜色,文本居中</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line"><span class="comment">//给当前控件定义了一个唯一标识符</span></span><br><span class="line">android:id=<span class="string">"@+id/text_view"</span></span><br><span class="line">         <span class="comment">//所有的控件都具有这两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="comment">//文本居中对齐    </span></span><br><span class="line">         android:gravity=<span class="string">"center"</span></span><br><span class="line">        <span class="comment">//设置字体大小     </span></span><br><span class="line">android:textSize=<span class="string">"24sp"</span></span><br><span class="line">        <span class="comment">//设置字体颜色</span></span><br><span class="line">android:textColor=<span class="string">"#00ff00"</span>   </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">android:text=<span class="string">"This is TextView"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">//match_parent 由父布局来决定当前控件的大小</span></span><br><span class="line"><span class="comment">//wrap_content 由控件内容决定当前控件的大小</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Button"><a href="#2-2-Button" class="headerlink" title="2.2 Button:"></a>2.2 Button:</h3><p>activity_main.xml 中添加代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">....</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>在 MainActivity 中为 Button 的点击事件注册一个监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//  在此处添加逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-EditText"><a href="#2-3-EditText" class="headerlink" title="2.3 EditText"></a>2.3 EditText</h3><p>它允许用户在控件里输入和编辑内容</p><p>修改 布局文件activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">...&gt;</span><br><span class="line">....</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/edit_text"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">       <span class="comment">//输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失     </span></span><br><span class="line">       android:hint=<span class="string">"Type something here"</span>   </span><br><span class="line">       <span class="comment">//通过 android:maxLines 指定了 EditText 的最大行数为两行，这样当输入的内容超过两行时，文本就会向</span></span><br><span class="line">       <span class="comment">//上滚动，而 EditText则不会再继续拉伸</span></span><br><span class="line">       android:maxLines=<span class="string">"2"</span>    </span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过点击按钮来获取EditText 中输入的内容。修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                String inputText = editText.getText().toString();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, inputText,</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ImageView"><a href="#2-4-ImageView" class="headerlink" title="2.4 ImageView"></a>2.4 ImageView</h3><p>修改 activity_main.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">....</span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=<span class="string">"@+id/image_view"</span></span><br><span class="line">         <span class="comment">//将 ImageView 的宽和高都设定为wrap_content，这样保证不管图片的尺寸是多少都可以完整地展示出来</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">          <span class="comment">//使用 android:src 属性给 ImageView指定了一张图片</span></span><br><span class="line">android:src=<span class="string">"@drawable/ic_launcher"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过代码动态地更改 ImageView 中的图片。这里我准备了另外一张图片，jelly_bean.png，将它复制到 res/drawable-hdpi 目录下，然后修改 MainActivity 的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> ImageView imageView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        imageView = (ImageView) findViewById(R.id.image_view);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="comment">//调用 ImageView 的 setImageResource()方法将显示的图片改成 jelly_bean</span></span><br><span class="line">                imageView.setImageResource(R.drawable.jelly_bean);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-ProgressBar"><a href="#2-5-ProgressBar" class="headerlink" title="2.5 ProgressBar"></a>2.5 ProgressBar</h3><p>用于在界面上显示一个进度条</p><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">... &gt;</span><br><span class="line">...</span><br><span class="line">&lt;ProgressBar</span><br><span class="line">android:id=<span class="string">"@+id/progress_bar"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="comment">//指定成水平进度条  </span></span><br><span class="line">         style=<span class="string">"?android:attr/progressBarStyleHorizontal"</span></span><br><span class="line">         <span class="comment">//给进度条设置一个最大值,然后在MainActivity类中动态地更改进度条的进度</span></span><br><span class="line">android:max=<span class="string">"100"</span></span><br><span class="line">     /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>Android控件的可见属性。可以通过android:visibility进行指定，可选值有三种，visible、invisible 和 gone。<br>visible 表示控件是可见的，这个值是默认值<br>invisible 表示控件不可见，但是它仍然占据着原来的位置和大小<br>gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。<br>还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 三种值。</p><p>点击一下按钮让进度条消失，再点击一下按钮让进度条出现的这种效果。修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">private</span> ProgressBar progressBar;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">        progressBar = (ProgressBar) findViewById(R.id.progress_bar);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="keyword">if</span> (progressBar.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    progressBar.setVisibility(View.VISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    progressBar.setVisibility(View.GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 activity_main.xml 中添加 android:max 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="keyword">int</span> progress = progressBar.getProgress();</span><br><span class="line">                progress = progress + <span class="number">10</span>;</span><br><span class="line">                progressBar.setProgress(progress);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-AlertDialog"><a href="#2-6-AlertDialog" class="headerlink" title="2.6 AlertDialog"></a>2.6 AlertDialog</h3><p>在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上,用于提示一些非常重要的内容或者警告信息</p><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="comment">//通过 AlertDialog.Builder 创建出一个 AlertDialog 的实例</span></span><br><span class="line">                AlertDialog.Builder dialog = <span class="keyword">new</span> AlertDialog.Builder</span><br><span class="line">                    (MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                dialog.setTitle(<span class="string">"This is Dialog"</span>);</span><br><span class="line">                dialog.setMessage(<span class="string">"Something important."</span>);</span><br><span class="line">                dialog.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//调用 setPositiveButton()方法为对话框设置确定按钮的点击事件</span></span><br><span class="line">                dialog.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.</span><br><span class="line">                       OnClickListener() &#123;</span><br><span class="line">                              <span class="meta">@Override</span></span><br><span class="line">                              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                              &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                <span class="comment">//调用 setNegativeButton()方法设置取消按钮的点击事件</span></span><br><span class="line">                dialog.setNegativeButton(<span class="string">"Cancel"</span>, <span class="keyword">new</span> DialogInterface.</span><br><span class="line">                       OnClickListener() &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                               &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                <span class="comment">//调用 show()方法将对话框显示出来</span></span><br><span class="line">                dialog.show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-ProgressDialog"><a href="#2-7-ProgressDialog" class="headerlink" title="2.7 ProgressDialog"></a>2.7 ProgressDialog</h3><p>在对话框中显示一个进度条,表示当前操作比较耗时，让用户耐心地等待</p><p>修改 MainActivity 中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                ProgressDialog progressDialog = <span class="keyword">new</span> ProgressDialog(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                progressDialog.setTitle(<span class="string">"This is ProgressDialog"</span>);</span><br><span class="line">                progressDialog.setMessage(<span class="string">"Loading..."</span>);</span><br><span class="line"><span class="comment">/*注意如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的   dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                progressDialog.setCancelable(<span class="keyword">true</span>);</span><br><span class="line">                progressDialog.show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、详解四种基本布局"><a href="#三、详解四种基本布局" class="headerlink" title="三、详解四种基本布局"></a>三、详解四种基本布局</h2><p>布局是一种可用于放置很多控件的容器,布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套</p><p>新建一个UILayoutTest项目，并让 ADT 自动帮我们创建好活动，活动名和布局名都使用默认值</p><h3 id="3-1-LinearLayout"><a href="#3-1-LinearLayout" class="headerlink" title="3.1 LinearLayout:"></a>3.1 LinearLayout:</h3><p>称作线性布局，是一种非常常用的布局,它所包含的控件在线性方向上依次排列</p><h4 id="3-1-1-通过-android-orientation-属性指定排列方向-vertical为垂直对齐-horizontal为水平对齐"><a href="#3-1-1-通过-android-orientation-属性指定排列方向-vertical为垂直对齐-horizontal为水平对齐" class="headerlink" title="3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐"></a>3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐</h4><p>修改activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">         <span class="comment">//指定了排列方向是 vertical(垂直方向), orientation(方向；定向；适应；情况介绍)</span></span><br><span class="line">android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">            &lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span> /&gt;              </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><strong>垂直对齐:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.1.png" alt></p><p>android:gravity 是用于指定文字在控件中的对齐方式</p><p>android:layout_gravity 是用于指定控件在布局中的对齐方式</p><p><strong>需要注意，当LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水<br>平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式,同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效.</strong></p><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">         ....</span><br><span class="line">         <span class="comment">/*LinearLayout 的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向(即只能指定上,中,下,而不能指定左右)，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_vertical*/</span></span><br><span class="line">android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Button</span><br><span class="line">....</span><br><span class="line">android:layout_gravity=<span class="string">"top"</span></span><br><span class="line">android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">            &lt;Button</span><br><span class="line">....</span><br><span class="line">android:layout_gravity=<span class="string">"center_vertical"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span> /&gt;              </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.3.png" alt></p><h4 id="3-1-2-android-layout-weight。这个属性允许我们使用比例的方式来指定控件的大小"><a href="#3-1-2-android-layout-weight。这个属性允许我们使用比例的方式来指定控件的大小" class="headerlink" title="3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小"></a>3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小</h4><p>编写一个消息发送界面，需要一个文本编辑框和一个发送按钮</p><p>修改activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    ....</span><br><span class="line">   android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/input_message"</span></span><br><span class="line">        <span class="comment">/*这里竟然将 EditText 和 Button 的宽度都指定成了 0，这样文本编辑框和按钮还能显示出来吗？不用担</span></span><br><span class="line"><span class="comment">         心，由于我们使用了 android:layout_weight 属性，此时控件的宽度,就不应该再android:layout_width </span></span><br><span class="line"><span class="comment">         来决定，这里指定成 0 是一种比较规范的写法 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">android:hint=<span class="string">"Type something"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/send"</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">         <span class="comment">/* EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示EditText 和 </span></span><br><span class="line"><span class="comment">         Button 将在水平方向平分宽度*/</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">android:text=<span class="string">"Send"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">/*为什么将 android:layout_weight 属性的值同时指定为 1 就会平分屏幕宽度呢？</span></span><br><span class="line"><span class="comment">系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，</span></span><br><span class="line"><span class="comment">然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。</span></span><br><span class="line"><span class="comment">因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的</span></span><br><span class="line"><span class="comment">layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。*/</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.4.png" alt></p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回</span></span><br><span class="line"><span class="comment">wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏</span></span><br><span class="line"><span class="comment">幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且</span></span><br><span class="line"><span class="comment">看起来也更加舒服*/</span></span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....</span><br><span class="line">android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/input_message"</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">...</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/send"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">....</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.5.png" alt></p><h3 id="3-2-RelativeLayout"><a href="#3-2-RelativeLayout" class="headerlink" title="3.2 RelativeLayout"></a>3.2 RelativeLayout</h3><p>通过相对定位的方式让控件出现在布局的任何位置</p><h4 id="3-2-1-每个控件相对于父布局进行定位"><a href="#3-2-1-每个控件相对于父布局进行定位" class="headerlink" title="3.2.1 每个控件相对于父布局进行定位"></a>3.2.1 每个控件相对于父布局进行定位</h4><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">.... &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">         <span class="comment">//Button 1和父布局的左上角对齐</span></span><br><span class="line">android:layout_alignParentLeft=<span class="string">"true"</span></span><br><span class="line">android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">.../&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_alignParentRight=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">        ... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_centerInParent=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button4"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentLeft=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button5"</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//Button 5 和父布局的右下角对齐</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentRight=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.6.png" alt></p><h4 id="3-2-2-控件相对于控件进行定位"><a href="#3-2-2-控件相对于控件进行定位" class="headerlink" title="3.2.2 控件相对于控件进行定位"></a>3.2.2 控件相对于控件进行定位</h4><p>修改 activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">"true"</span></span><br><span class="line">        android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">       ....</span><br><span class="line">        <span class="comment">//android:layout_above属性让一个控件位于另一个控件的上方</span></span><br><span class="line">        <span class="comment">//@id/button3，表示让该控件位于 Button 3 的上方</span></span><br><span class="line">        android:layout_above=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_above=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button4"</span></span><br><span class="line">       ....</span><br><span class="line">        android:layout_below=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button5"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_below=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br><span class="line"><span class="comment">/*另外一组相对于控件进行定位的属性</span></span><br><span class="line"><span class="comment">  如android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.7.png" alt></p><h3 id="3-3-FrameLayout"><a href="#3-3-FrameLayout" class="headerlink" title="3.3 FrameLayout"></a>3.3 FrameLayout</h3><p>没有任何的定位方式，所有的控件都会摆放在布局的左上角,它的应用场景并不多</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line"><span class="comment">//按钮</span></span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        ....</span><br><span class="line">        /&gt;</span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">        android:id=<span class="string">"@+id/image_view"</span></span><br><span class="line">        ....</span><br><span class="line">        android:src=<span class="string">"@drawable/ic_launcher"</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.8.png" alt></p><h3 id="3-4-TableLayout"><a href="#3-4-TableLayout" class="headerlink" title="3.4 TableLayout"></a>3.4 TableLayout</h3><p>使用表格的方式来排列控件</p><p>设计一个登录界面，用户输入账号密码后登录</p><p>activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    <span class="comment">// TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行</span></span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line"><span class="comment">//在 TableRow中每加入一个控件，就表示在该行中加入了一列</span></span><br><span class="line"><span class="comment">//TableRow 中的控件是不能指定宽度的</span></span><br><span class="line">&lt;TextView</span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Account:"</span> /&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/account"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:hint=<span class="string">"Input your account"</span> /&gt;</span><br><span class="line">&lt;/TableRow&gt;</span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:text=<span class="string">"Password:"</span> /&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/password"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:inputType=<span class="string">"textPassword"</span> /&gt;</span><br><span class="line">&lt;/TableRow&gt;</span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">            android:id=<span class="string">"@+id/login"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="comment">//对单元格进行合并</span></span><br><span class="line">            android:layout_span=<span class="string">"2"</span></span><br><span class="line">            android:text=<span class="string">"Login"</span> /&gt;</span><br><span class="line">    &lt;/TableRow&gt;</span><br><span class="line">&lt;/TableLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.9.png" alt></p><p>android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列<br>进行拉伸，以达到自动适应屏幕宽度的作用</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="comment">// android:stretchColumns 的值指定为 1，表示如果表格不能完全占满屏幕宽度，就将第二列进行拉伸</span></span><br><span class="line">    <span class="comment">//指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列</span></span><br><span class="line">android:stretchColumns=<span class="string">"1"</span></span><br><span class="line">&gt;</span><br><span class="line">....</span><br><span class="line">&lt;/TableLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="四、创建自定义控件"><a href="#四、创建自定义控件" class="headerlink" title="四、创建自定义控件"></a>四、创建自定义控件</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.10.png" alt></p><p>所有控件都是直接或间接继承自 View,<br>所有布局都是直接或间接继承自 ViewGroup </p><p>创建一个 UICustomViews 项目:</p><h3 id="4-1-引入布局"><a href="#4-1-引入布局" class="headerlink" title="4.1 引入布局"></a>4.1 引入布局</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android:background 用于为布局或控件指定一个背景</span></span><br></pre></td></tr></table></figure><p>修改activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//引入标题栏布局    </span></span><br><span class="line">&lt;include layout=<span class="string">"@layout/title"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>别忘了在 MainActivity 中将系统自带的标题栏隐藏掉</p><p>修改MainActivity类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-创建自定义控件"><a href="#4-2-创建自定义控件" class="headerlink" title="4.2 创建自定义控件"></a>4.2 创建自定义控件</h3><p>引入布局确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码,这种情况最好是使用自定义控件的方式来解决</p><p>新建 TitleLayout类 继承自 LinearLayout，让它成为我们自定义的标题栏控件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在布局中引入 TitleLayout</span></span><br><span class="line"><span class="comment">控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借</span></span><br><span class="line"><span class="comment">助 LayoutInflater 来实现了,LayoutInflater 的 from()方法可以构建出一个 LayoutInflater</span></span><br><span class="line"><span class="comment">对象，然后调用 inflate()方法就可以动态加载一个布局文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//第一个参数是要加载的布局文件的 id,第二个参数是给加载好的布局再添加一个父布局,这里我们想要指定为 TitleLayout，于是直接传入 this</span></span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在自定义控件已经创建好了，然后在布局文件中添加这个自定义控件</p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候我们需要指明控件的完整类名，包名在这里是不可以省略的</span></span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;com.example.uicustomviews.TitleLayout</span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>&gt;</span><br><span class="line">&lt;/com.example.uicustomviews.TitleLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>为标题栏中的按钮注册点击事件</p><p>修改 TitleLayout中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// findViewById()方法得到按钮的实例</span></span><br><span class="line">        Button titleBack = (Button) findViewById(R.id.title_back);</span><br><span class="line">        Button titleEdit = (Button) findViewById(R.id.title_edit);</span><br><span class="line">        <span class="comment">//分别调用 setOnClickListener()方法给两个按钮注册了点击事件</span></span><br><span class="line">        titleBack.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                ((Activity) getContext()).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        titleEdit.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getContext(), <span class="string">"You clicked Edit button"</span>,</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、最常用最难用控件ListView"><a href="#五、最常用最难用控件ListView" class="headerlink" title="五、最常用最难用控件ListView"></a>五、最常用最难用控件ListView</h2><p>ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕</p><h3 id="5-1-ListView-的简单用法"><a href="#5-1-ListView-的简单用法" class="headerlink" title="5.1 ListView 的简单用法"></a>5.1 ListView 的简单用法</h3><p>首先新建一个 ListViewTest 项目,都默认</p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    &lt;ListView</span><br><span class="line">android:id=<span class="string">"@+id/list_view"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    &lt;/ListView&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String[] data = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Watermelon"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Pineapple"</span>, <span class="string">"Strawberry"</span>,<span class="string">"Cherry"</span>, <span class="string">"Mango"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成</span></span><br><span class="line">        <span class="comment">//android.R.layout.simple_list_item_1 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本</span></span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(MainActivity.<span class="keyword">this</span>,                           android.R.layout.simple_list_item_1,data);</span><br><span class="line">ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">       <span class="comment">// setAdapter()方法，将构建好的适配器对象传递进去,这样 ListView和数据之间的关联就建立完成了</span></span><br><span class="line">listView.setAdapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.15.png" alt></p><h3 id="5-2-定制-ListView-的界面"><a href="#5-2-定制-ListView-的界面" class="headerlink" title="5.2 定制 ListView 的界面"></a>5.2 定制 ListView 的界面</h3><p>新建类 Fruit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> imageId;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name, <span class="keyword">int</span> imageId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.imageId = imageId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImageId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 目录下新建fruit_item.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">        <span class="comment">// ImageView 用于显示水果的图片</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=<span class="string">"@+id/fruit_image"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span> /&gt;</span><br><span class="line">            <span class="comment">//TextView用于显示水果的名称</span></span><br><span class="line">&lt;TextView</span><br><span class="line">        android:id=<span class="string">"@+id/fruit_name"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">"10dip"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建类 FruitAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context, <span class="keyword">int</span> textViewResourceId, List&lt;Fruit&gt; objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, textViewResourceId, objects);</span><br><span class="line">resourceId = textViewResourceId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// getItem()方法得到当前项的 Fruit 实例</span></span><br><span class="line">Fruit fruit = getItem(position); <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line"><span class="comment">//LayoutInflater 来为这个子项加载我们传入的布局，</span></span><br><span class="line">View view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// findViewById()方法分别获取到 ImageView 和 TextView 的实例</span></span><br><span class="line">ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line"><span class="comment">// setImageResource()和 setText()方法来设置显示的图片和文字</span></span><br><span class="line">fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">fruitName.setText(fruit.getName());</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Watermelon"</span>,</span><br><span class="line">                             <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Pineapple"</span>, <span class="string">"Strawberry"</span>, <span class="string">"Cherry"</span>, <span class="string">"Mango"</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initFruits(); <span class="comment">//  初始化水果数据</span></span><br><span class="line">        FruitAdapter adapter = <span class="keyword">new</span> FruitAdapter(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                                                R.layout.fruit_item, fruitList);</span><br><span class="line">        ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFruits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Fruit(<span class="string">"Apple"</span>, R.drawable.apple_pic);</span><br><span class="line">        fruitList.add(apple);</span><br><span class="line">        Fruit banana = <span class="keyword">new</span> Fruit(<span class="string">"Banana"</span>, R.drawable.banana_pic);</span><br><span class="line">        fruitList.add(banana);</span><br><span class="line">        Fruit orange = <span class="keyword">new</span> Fruit(<span class="string">"Orange"</span>, R.drawable.orange_pic);</span><br><span class="line">        fruitList.add(orange);</span><br><span class="line">        Fruit watermelon = <span class="keyword">new</span> Fruit(<span class="string">"Watermelon"</span>, R.drawable.watermelon_pic);</span><br><span class="line">        fruitList.add(watermelon);</span><br><span class="line">        Fruit pear = <span class="keyword">new</span> Fruit(<span class="string">"Pear"</span>, R.drawable.pear_pic);</span><br><span class="line">        fruitList.add(pear);</span><br><span class="line">        Fruit grape = <span class="keyword">new</span> Fruit(<span class="string">"Grape"</span>, R.drawable.grape_pic);</span><br><span class="line">        fruitList.add(grape);</span><br><span class="line">        Fruit pineapple = <span class="keyword">new</span> Fruit(<span class="string">"Pineapple"</span>, R.drawable.pineapple_pic);</span><br><span class="line">        fruitList.add(pineapple);</span><br><span class="line">        Fruit strawberry = <span class="keyword">new</span> Fruit(<span class="string">"Strawberry"</span>, R.drawable.strawberry_pic);</span><br><span class="line">        fruitList.add(strawberry);</span><br><span class="line">        Fruit cherry = <span class="keyword">new</span> Fruit(<span class="string">"Cherry"</span>, R.drawable.cherry_pic);</span><br><span class="line">        fruitList.add(cherry);</span><br><span class="line">        Fruit mango = <span class="keyword">new</span> Fruit(<span class="string">"Mango"</span>, R.drawable.mango_pic);</span><br><span class="line">        fruitList.add(mango);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-提升-ListView-的运行效率"><a href="#5-3-提升-ListView-的运行效率" class="headerlink" title="5.3 提升 ListView 的运行效率"></a>5.3 提升 ListView 的运行效率</h3><p>修改 FruitAdapter中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getView()方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view;</span><br><span class="line">       <span class="comment">//如果 convertView 为空，则使用LayoutInflater 去加载布局，如果不为空则直接对 convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候也可以表现出更好的性能。</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView;</span><br><span class="line">        &#125;</span><br><span class="line">        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">        fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        fruitName.setText(fruit.getName());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然现在已经不会再重复去加载布局，但是每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个 ViewHolder来对这部分性能进行优化</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以继续优化</p><p>修改 FruitAdapter 中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view;</span><br><span class="line">        ViewHolder viewHolder;</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">            viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">            viewHolder.fruitImage = (ImageView) view.findViewById</span><br><span class="line">                (R.id.fruit_image);</span><br><span class="line">            viewHolder.fruitName = (TextView) view.findViewById</span><br><span class="line">                (R.id.fruit_name);</span><br><span class="line">            view.setTag(viewHolder); <span class="comment">//  将ViewHolder 存储在View 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView;</span><br><span class="line">            viewHolder = (ViewHolder) view.getTag(); <span class="comment">//  重新获取ViewHolder</span></span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        viewHolder.fruitName.setText(fruit.getName());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ViewHolder，用于对控件的实例进行缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        ImageView fruitImage;</span><br><span class="line">        TextView fruitName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 convertView为空的时候:</span></span><br><span class="line"><span class="comment">创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View的 setTag()方法，将 ViewHolder 对象存储在 View 中。</span></span><br><span class="line"><span class="comment">当 convertView 不为空的时候:</span></span><br><span class="line"><span class="comment">则调用View的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="5-4-ListView-的点击事件"><a href="#5-4-ListView-的点击事件" class="headerlink" title="5.4 ListView 的点击事件"></a>5.4 ListView 的点击事件</h3><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"> <span class="comment">//通过 position 参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来</span></span><br><span class="line">        listView.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">                Fruit fruit = fruitList.get(position);</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, fruit.getName(),</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、单位和尺寸"><a href="#六、单位和尺寸" class="headerlink" title="六、单位和尺寸"></a>六、单位和尺寸</h2><p>布局文件中指定宽高的固定大小有以下常用单位可供选择：px、pt、dp 和 sp</p><p>px 是像素的意思，即屏幕中可以显示的最小元素单元</p><p>pt 是磅数的意思，1 磅等于 1/72 英寸，一般 pt 都会作为字体的单位来使用</p><p>新建好一个 UISizeTest 项目</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button"</span></span><br><span class="line"><span class="comment">// android:layout_width 属性将按钮的宽指定为 200px</span></span><br><span class="line">android:layout_width=<span class="string">"200px"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.16.png" alt></p><p>接着创建一个 240*320 像素的低分辨率模拟器，在这个模拟器上重新运行程序</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.17.png" alt></p><p>dp 是密度无关像素的意思，也被称作 dip，和 px 相比，它在不同密度的屏幕中的显示比例将保持一致。</p><p>sp 是可伸缩像素的意思，它采用了和 dp 同样的设计理念，解决了文字大小的适配问题</p><p>什么叫密度？Android 中的密度就是屏幕每英寸所包含的像素数，通常以 dpi为单位</p><p>比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果它的分辨率是 320<em>480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640</em>960，那这个屏幕的密度就是 320dpi</p><p><strong>如何得知当前屏幕的密度值?</strong></p><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">float</span> xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line">        <span class="keyword">float</span> ydpi = getResources().getDisplayMetrics().ydpi;</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"xdpi is "</span> + xdpi);</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"ydpi is "</span> + ydpi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Android 的规定，在 160dpi 的屏幕上，1dp 等于 1px，而在 320dpi 的屏幕上，1dp就等于 2px。因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的显示比例保持一致</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        android:layout_width=<span class="string">"200dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:text=<span class="string">"Button"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="七、编写界面的最佳实践"><a href="#七、编写界面的最佳实践" class="headerlink" title="七、编写界面的最佳实践:"></a>七、编写界面的最佳实践:</h2><p>创建一个 UIBestPractice 项目</p><h3 id="7-1-制作-Nine-Patch-图片"><a href="#7-1-制作-Nine-Patch-图片" class="headerlink" title="7.1 制作 Nine-Patch 图片"></a>7.1 制作 Nine-Patch 图片</h3><p><strong>Nine-Patch 图片,它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸而哪些区域不可以。</strong></p><p>准备一张普通的气泡样式的png图片 message_left.png (google上直接搜索message_left.png就可找到)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.19.png" alt></p><p>将这张图片设置为一个 LinearLayout 的背景图片,修改 activity_main.xml </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:background=<span class="string">"@drawable/message_left"</span> &gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.20.png" alt></p><p>可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差.</p><p>这时我们就可以使用 Nine-Patch 图片来进行改善</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.21.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.22.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.23.png" alt></p><p>在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。绘制完成后效果如图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.24.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.25.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.26.png" alt></p><p><strong>注意：制作完成后，应该将原始文件删除，否则AS会分不清楚而报错。</strong></p><p>重新运行程序</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.27.png" alt></p><p>这样当图片需要拉伸的时候，就可以只拉伸指定的区域，程序在外观上也是有了很大的改进</p><h3 id="7-2-编写精美的聊天界面"><a href="#7-2-编写精美的聊天界面" class="headerlink" title="7.2 编写精美的聊天界面"></a>7.2 编写精美的聊天界面</h3><p>再制作一张message_right.9.png作为发出消息的背景图</p><p>修改 activity_main.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:background=<span class="string">"#d8e0e8"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line"><span class="comment">// ListView 用于显示聊天的消息内容</span></span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=<span class="string">"@+id/msg_list_view"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_weight=<span class="string">"1"</span></span><br><span class="line"><span class="comment">// android:divider属性，它可以指定 ListView分隔线的颜色，这里#0000 表示将分隔线设为透明色</span></span><br><span class="line">        android:divider=<span class="string">"#0000"</span> &gt;</span><br><span class="line">    &lt;/ListView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span> &gt;</span><br><span class="line"><span class="comment">//EditText用于输入消息</span></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/input_text"</span></span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_weight=<span class="string">"1"</span></span><br><span class="line">            android:hint=<span class="string">"Type somthing here"</span></span><br><span class="line">            android:maxLines=<span class="string">"2"</span> /&gt;</span><br><span class="line"><span class="comment">// Button 用于发送消息</span></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=<span class="string">"@+id/send"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:text=<span class="string">"Send"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>定义消息的实体类，新建 Msg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TYPE_RECEIVED 表示这是一条收到的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_RECEIVED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//TYPE_SENT 表示这是一条发出的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SENT = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//content 表示消息的内容</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line">    <span class="comment">//type 表示消息的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Msg</span><span class="params">(String content, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.content = content;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 ListView子项的布局，新建 msg_item.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:padding=<span class="string">"10dp"</span> &gt;</span><br><span class="line"><span class="comment">//让收到的消息居左对齐</span></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">"@+id/left_layout"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"left"</span></span><br><span class="line">        android:background=<span class="string">"@drawable/message_left"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">"@+id/left_msg"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">            android:layout_margin=<span class="string">"10dp"</span></span><br><span class="line">            android:textColor=<span class="string">"#fff"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">//发出的消息居右对齐</span></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">"@+id/right_layout"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"right"</span></span><br><span class="line">        android:background=<span class="string">"@drawable/message_right"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">"@+id/right_msg"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">            android:layout_margin=<span class="string">"10dp"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>创建 ListView 的适配器类，让它继承自 ArrayAdapter，并将泛型指定为 Msg类。新建类 MsgAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Msg</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MsgAdapter</span><span class="params">(Context context, <span class="keyword">int</span> textViewResourceId, List&lt;Msg&gt; objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, textViewResourceId, objects);</span><br><span class="line">resourceId = textViewResourceId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">Msg msg = getItem(position);</span><br><span class="line">View view;</span><br><span class="line">ViewHolder viewHolder;</span><br><span class="line"><span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">viewHolder.leftLayout = (LinearLayout) view.findViewById(R.id.left_layout);</span><br><span class="line">viewHolder.rightLayout = (LinearLayout) view.findViewById(R.id.right_layout);</span><br><span class="line">viewHolder.leftMsg = (TextView) view.findViewById(R.id.left_msg);</span><br><span class="line">viewHolder.rightMsg = (TextView) view.findViewById(R.id.right_msg);</span><br><span class="line">view.setTag(viewHolder);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">view = convertView;</span><br><span class="line">viewHolder = (ViewHolder) view.getTag();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.getType() == Msg.TYPE_RECEIVED) &#123;</span><br><span class="line"><span class="comment">// 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏</span></span><br><span class="line">viewHolder.leftLayout.setVisibility(View.VISIBLE);</span><br><span class="line">viewHolder.rightLayout.setVisibility(View.GONE);</span><br><span class="line">viewHolder.leftMsg.setText(msg.getContent());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.getType() == Msg.TYPE_SENT) &#123;</span><br><span class="line"><span class="comment">// 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏</span></span><br><span class="line">viewHolder.rightLayout.setVisibility(View.VISIBLE);</span><br><span class="line">viewHolder.leftLayout.setVisibility(View.GONE);</span><br><span class="line">viewHolder.rightMsg.setText(msg.getContent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">LinearLayout leftLayout;</span><br><span class="line">LinearLayout rightLayout;</span><br><span class="line">TextView leftMsg;</span><br><span class="line">TextView rightMsg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码，来为 ListView初始化一些数据，并给发送按钮加入事件响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListView msgListView;</span><br><span class="line"><span class="keyword">private</span> EditText inputText;</span><br><span class="line"><span class="keyword">private</span> Button send;</span><br><span class="line"><span class="keyword">private</span> MsgAdapter adapter;</span><br><span class="line"><span class="keyword">private</span> List&lt;Msg&gt; msgList = <span class="keyword">new</span> ArrayList&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">initMsgs(); <span class="comment">// 初始化消息数据</span></span><br><span class="line">adapter = <span class="keyword">new</span> MsgAdapter(MainActivity.<span class="keyword">this</span>, R.layout.msg_item, msgList);</span><br><span class="line">inputText = (EditText) findViewById(R.id.input_text);</span><br><span class="line">send = (Button) findViewById(R.id.send);</span><br><span class="line">msgListView = (ListView) findViewById(R.id.msg_list_view);</span><br><span class="line">msgListView.setAdapter(adapter);</span><br><span class="line">send.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">//获取 EditText 中的内容</span></span><br><span class="line">String content = inputText.getText().toString();</span><br><span class="line">                <span class="comment">//如果内容不为空则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="string">""</span>.equals(content)) &#123;</span><br><span class="line">Msg msg = <span class="keyword">new</span> Msg(content, Msg.TYPE_SENT);</span><br><span class="line">msgList.add(msg);</span><br><span class="line">                    <span class="comment">//调用了适配器的 notifyDataSetChanged()方法，用于通知列表的数据发生了变化</span></span><br><span class="line">adapter.notifyDataSetChanged(); <span class="comment">// 当有新消息时，刷新ListView中的显示</span></span><br><span class="line">                     <span class="comment">// 将ListView定位到最后一行,以保证一定可以看得到最后发出的一条消息 </span></span><br><span class="line">msgListView.setSelection(msgList.size()); </span><br><span class="line">inputText.setText(<span class="string">""</span>); <span class="comment">// 清空输入框中的内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMsgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化几条数据用于在 ListView 中显示</span></span><br><span class="line">Msg msg1 = <span class="keyword">new</span> Msg(<span class="string">"Hello guy."</span>, Msg.TYPE_RECEIVED);</span><br><span class="line">msgList.add(msg1);</span><br><span class="line">Msg msg2 = <span class="keyword">new</span> Msg(<span class="string">"Hello. Who is that?"</span>, Msg.TYPE_SENT);</span><br><span class="line">msgList.add(msg2);</span><br><span class="line">Msg msg3 = <span class="keyword">new</span> Msg(<span class="string">"This is Tom. Nice talking to you. "</span>, Msg.TYPE_RECEIVED);</span><br><span class="line">msgList.add(msg3);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.29.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、如何编写程序界面&quot;&gt;&lt;a href=&quot;#一、如何编写程序界面&quot; class=&quot;headerlink&quot; title=&quot;一、如何编写程序界面:&quot;&gt;&lt;/a&gt;一、如何编写程序界面:&lt;/h2&gt;&lt;p&gt;Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局.&lt;/p&gt;
&lt;h2 id=&quot;二、常见控件的使用方法&quot;&gt;&lt;a href=&quot;#二、常见控件的使用方法&quot; class=&quot;headerlink&quot; title=&quot;二、常见控件的使用方法&quot;&gt;&lt;/a&gt;二、常见控件的使用方法&lt;/h2&gt;&lt;h3 id=&quot;2-1-TextView&quot;&gt;&lt;a href=&quot;#2-1-TextView&quot; class=&quot;headerlink&quot; title=&quot;2.1 TextView&quot;&gt;&lt;/a&gt;2.1 TextView&lt;/h3&gt;&lt;p&gt;主要用于在界面上显示一段文本信息,设置颜色,文本居中&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="Android之UI" scheme="https://zzwwqq.xyz/tags/Android%E4%B9%8BUI/"/>
    
  </entry>
  
  <entry>
    <title>java字符串</title>
    <link href="https://zzwwqq.xyz/java%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://zzwwqq.xyz/java字符串.html</id>
    <published>2019-04-08T10:51:55.000Z</published>
    <updated>2019-04-09T13:33:18.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字符串的特性"><a href="#一、字符串的特性" class="headerlink" title="一、字符串的特性:"></a>一、字符串的特性:</h2><p>String 被声明为 final，因此它不可被继承。</p><h2 id="二、不同JDK版本中String的区别"><a href="#二、不同JDK版本中String的区别" class="headerlink" title="二、不同JDK版本中String的区别:"></a>二、不同JDK版本中String的区别:</h2><p>①: 在 Java 8 中，String 内部使用 char 数组存储数据。</p><a id="more"></a><p>②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。<br>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2 id="三、String-与StringBuffer-StringBuilder的区别："><a href="#三、String-与StringBuffer-StringBuilder的区别：" class="headerlink" title="三、String 与StringBuffer,StringBuilder的区别："></a>三、String 与StringBuffer,StringBuilder的区别：</h2><h3 id="3-1-可变性"><a href="#3-1-可变性" class="headerlink" title="3.1 可变性:"></a>3.1 可变性:</h3><p>String的长度是<strong>不可变的</strong>，而StringBuffer和StringBuilder长度是<strong>可变的.</strong></p><p>也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”<br><strong>并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中.</strong></p><h3 id="3-2-线程安全"><a href="#3-2-线程安全" class="headerlink" title="3.2 线程安全:"></a>3.2 线程安全:</h3><p>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p><p><strong>StringBuffer的常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.1.png" alt></p><p><strong>String常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.4.png" alt></p><p><strong>StringBuffer和StringBuilder和String的效率比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">String text = <span class="string">""</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、字符串与其他数据类型的转换"><a href="#四、字符串与其他数据类型的转换" class="headerlink" title="四、字符串与其他数据类型的转换:"></a>四、字符串与其他数据类型的转换:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.2.png" alt></p><h3 id="4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法"><a href="#4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法" class="headerlink" title="4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)"></a>4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)</h3><p><strong>A ———&gt; B:      调用B的方法:</strong><br>①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)<br>②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法</p><h3 id="4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器"><a href="#4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器" class="headerlink" title="4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)"></a>4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)</h3><p>字符串———&gt;数组         调用字符串的方法<br>数组————&gt;字符串     调用字符串的构造器</p><p>③: 字符串——-&gt;字节数组 调用字符串的getBytes()<br>④: 字符串——-&gt;字符数组 调用字符串的toCharArray()</p><p>⑤: 字节数组——&gt;字符串  调用字符串的构造器<br>⑥: 字符数组——&gt;字符串   调用字符串的构造器</p><h2 id="五、字符串常量池（String-Pool）"><a href="#五、字符串常量池（String-Pool）" class="headerlink" title="五、字符串常量池（String Pool）:"></a>五、字符串常量池（String Pool）:</h2><p>①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在<strong>编译时期</strong>就确定。<br>还可以使用 String 的 intern() 方法在<strong>运行过程中</strong>将字符串添加到 String Pool 中。</p><p>②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="六、字符串字面量-和字符串对象"><a href="#六、字符串字面量-和字符串对象" class="headerlink" title="六、字符串字面量 和字符串对象:"></a>六、字符串字面量 和字符串对象:</h2><p>字面量指的是能够使用简单结构和符号创建对象的表达式。<br>如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。</p><h2 id="七、new-String-“abc”-创建了几个对象"><a href="#七、new-String-“abc”-创建了几个对象" class="headerlink" title="七、new String(“abc”)创建了几个对象?"></a>七、new String(“abc”)创建了几个对象?</h2><p><strong>使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。</strong></p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h2 id="八、关于”-”-和”equals”和String的intern-方法"><a href="#八、关于”-”-和”equals”和String的intern-方法" class="headerlink" title="八、关于”==” 和”equals”和String的intern()方法:"></a>八、关于”==” 和”equals”和String的intern()方法:</h2><p>①: “==”比较的是地址<br>②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.<br>所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.<br>③: String类重写了equals方法<br>④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><p><strong>关于intern():</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String s0= “kvill”; </span><br><span class="line">String s1=<span class="keyword">new</span> String(”kvill”); </span><br><span class="line">String s2=<span class="keyword">new</span> String(“kvill”); </span><br><span class="line">System.out.println( s0==s1 ); </span><br><span class="line">System.out.println( “**********” ); </span><br><span class="line">s1.intern(); </span><br><span class="line">s2=s2.intern(); <span class="comment">//把常量池中“kvill”的引用赋给s2 </span></span><br><span class="line">System.out.println( s0==s1); </span><br><span class="line">System.out.println( s0==s1.intern() ); </span><br><span class="line">System.out.println( s0==s2 );</span><br><span class="line"></span><br><span class="line">结果为： </span><br><span class="line"><span class="keyword">false</span> </span><br><span class="line">********** </span><br><span class="line"><span class="keyword">false</span> <span class="comment">//虽然执行了s1.intern(),但它的返回值没有赋给s1 </span></span><br><span class="line"><span class="keyword">true</span> <span class="comment">//说明s1.intern()返回的是常量池中”kvill”的引用 </span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>几个结论: </strong></p><ol><li><p>直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。</p></li><li><p>new出来的字符串是存放在堆里面。</p></li><li><p>对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</p><ul><li><p>表达式右边是纯字符串常量，那么存放在常量池里面。</p></li><li><p>表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;        <span class="comment">//str1存放的值是字符串常量池中字符串aaa对象的地址.</span></span><br><span class="line">String str2 = <span class="string">"bbb"</span>;</span><br><span class="line">String str3 = <span class="string">"aaabbb"</span>;</span><br><span class="line">String str4 = str1 + str2;  <span class="comment">//str4存放的是堆中字符串aaabbb对象的地址</span></span><br><span class="line">String str5 = <span class="string">"aaa"</span> + <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析:</span></span><br><span class="line">结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而</span><br><span class="line">str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。</span><br><span class="line">其实Integer这种包装类型的-<span class="number">128</span> ~ +<span class="number">127</span>也是存放在常量池里面，比如Integer i1 = <span class="number">10</span>;Integer i2 = <span class="number">10</span>; i1 == i2结果是<span class="keyword">true</span>，估计也是为了性能优化。</span><br></pre></td></tr></table></figure><h2 id="九、五个关于字符串的算法题"><a href="#九、五个关于字符串的算法题" class="headerlink" title="九、五个关于字符串的算法题:"></a>九、五个关于字符串的算法题:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="number">1</span>. 模拟一个trim方法，去除字符串两端的空格 。</span><br><span class="line"> * <span class="number">2</span>. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 </span><br><span class="line"> * <span class="number">3</span>. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。</span><br><span class="line"> * <span class="number">4</span>. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = <span class="string">"abcwercvhelloobnm"</span>。</span><br><span class="line"> * <span class="number">5</span>.对字符串中字符进行自然排序</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. 模拟trim方法，去除字符串两端的空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断字符串str前面是否有空格</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(start) == <span class="string">' '</span>) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(start);</span><br><span class="line"><span class="comment">// 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(end) == <span class="string">' '</span>) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(end);</span><br><span class="line"> <span class="comment">// 方法一：</span></span><br><span class="line"> <span class="keyword">char</span>[]a = <span class="keyword">new</span> <span class="keyword">char</span>[end-start+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++,j++) &#123;</span><br><span class="line"> System.out.print(i+<span class="string">" "</span>);</span><br><span class="line"> a[j] = str.charAt(i);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println();</span><br><span class="line"> <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line"> String str1 = <span class="keyword">new</span> String(a);</span><br><span class="line"> <span class="keyword">return</span> str1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 方法二：</span></span><br><span class="line"><span class="comment">//return str.substring(start, end + 1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverseString</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符串转换为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="keyword">return</span> myreverseArray(c, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myreverseArray</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start,j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line"><span class="keyword">char</span> temp = c[i];</span><br><span class="line">c[i] = c[j];</span><br><span class="line">c[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符数组转换为字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">String str1 = str.substring(<span class="number">0</span>,start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            str1 += c;</span><br><span class="line">&#125;</span><br><span class="line">str1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3. 获取一个字符串在另一个字符串中出现的次数.</span></span><br><span class="line"><span class="comment">// 判断str2 在 str1 中出现的次数</span></span><br><span class="line"><span class="comment">// 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">while</span> ((length = str1.indexOf(str2)) != -<span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">str1 = str1.substring(length + str2.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 获取两个字符串中最大相同字串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getMaxSubString</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">String maxStr = (str1.length() &gt; str2.length())? str1:str2;</span><br><span class="line">String minStr = (str1.length() &lt; str2.length())? str1:str2;</span><br><span class="line">        <span class="keyword">int</span> length = minStr.length();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = length - i; y &lt;= length; x++,y++) &#123;</span><br><span class="line">String str = minStr.substring(x,y);</span><br><span class="line">   <span class="keyword">if</span> (maxStr.contains(str)) &#123;</span><br><span class="line">   list.add(str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//5.对字符串中字符进行自然排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mySort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[]c = str.toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// @Test-myTrim</span></span><br><span class="line">String testString1 = <span class="string">"    abc  d    "</span>;</span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line">String testString2 = <span class="string">"              "</span>;</span><br><span class="line">        </span><br><span class="line">String str1 = StringDemo.myTrim(testString1);</span><br><span class="line">String str2 = StringDemo.myTrim(testString2);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str1 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str2 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">String str3 = str1.trim();</span><br><span class="line">String str4 = str2.trim();</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str3 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str4 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// @Test-myReverseString and myReverseArray</span></span><br><span class="line">String str5 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str6 = myReverseString(str5, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"原字符串："</span> + str5);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法一："</span> + str6);</span><br><span class="line">String str7 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str8 = reverseString2(str7, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法二："</span> + str8);</span><br><span class="line"><span class="keyword">int</span> count = getTime(<span class="string">"abkkcadkabkebfkabkskab"</span>, <span class="string">"abk"</span>);</span><br><span class="line">System.out.println(<span class="string">"出现次数为："</span> + count);</span><br><span class="line">    List&lt;String&gt; str9 = getMaxSubString(<span class="string">"abcwerathelloyuiodef"</span>, <span class="string">"abcwercvhellobnm"</span>);</span><br><span class="line">    System.out.println(str9);  </span><br><span class="line">    String str10 = <span class="string">"aediewfn"</span>;</span><br><span class="line">    String str11 = mySort(str10);</span><br><span class="line">    System.out.println(str11);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、字符串的特性&quot;&gt;&lt;a href=&quot;#一、字符串的特性&quot; class=&quot;headerlink&quot; title=&quot;一、字符串的特性:&quot;&gt;&lt;/a&gt;一、字符串的特性:&lt;/h2&gt;&lt;p&gt;String 被声明为 final，因此它不可被继承。&lt;/p&gt;
&lt;h2 id=&quot;二、不同JDK版本中String的区别&quot;&gt;&lt;a href=&quot;#二、不同JDK版本中String的区别&quot; class=&quot;headerlink&quot; title=&quot;二、不同JDK版本中String的区别:&quot;&gt;&lt;/a&gt;二、不同JDK版本中String的区别:&lt;/h2&gt;&lt;p&gt;①: 在 Java 8 中，String 内部使用 char 数组存储数据。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java字符串" scheme="https://zzwwqq.xyz/tags/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://zzwwqq.xyz/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/数据链路层.html</id>
    <published>2019-04-07T07:37:34.000Z</published>
    <updated>2019-04-09T13:33:42.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据链路层设备"><a href="#一、数据链路层设备" class="headerlink" title="一、数据链路层设备:"></a>一、数据链路层设备:</h2><p>①: 网桥或桥接器:<br>②: 交换机:<br>　　<strong>实质: </strong>是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器<br>　　<strong>特点:</strong></p><ul><li><strong>全双工:</strong></li><li><strong>并行性: </strong>即能同时连通多对接口，使多对主机能同时通信</li><li><strong>自学习: </strong>即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。</li></ul><a id="more"></a><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.4.png" alt></p><p><strong>优点:</strong></p><p>对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s.</p><p>③:  网络适配器又称网络接口卡，网卡</p><p><strong>网络适配器是什么?</strong></p><p>网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。</p><p><strong>网络适配器的主要作用：</strong></p><ul><li>它是主机与介质的桥梁设备</li><li>实现主机与介质之间的电信号匹配</li><li>提供数据缓冲能力</li><li>控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。)</li></ul><p>网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。</p><h2 id="二、数据链路层协议"><a href="#二、数据链路层协议" class="headerlink" title="二、数据链路层协议:"></a>二、数据链路层协议:</h2><h3 id="2-1-PPP协议-Point-to-Point-Protocal-（点到点）"><a href="#2-1-PPP协议-Point-to-Point-Protocal-（点到点）" class="headerlink" title="2.1 PPP协议:  Point-to-Point Protocal; （点到点）"></a>2.1 PPP协议:  Point-to-Point Protocal; （点到点）</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点:"></a>2.1.1 特点:</h3><p>①: 简单<br>②: 只检错,不纠错<br>③: 不使用序号,不进行流量控制</p><h3 id="2-1-2-PPP-的帧格式："><a href="#2-1-2-PPP-的帧格式：" class="headerlink" title="2.1.2 PPP 的帧格式："></a>2.1.2 PPP 的帧格式：</h3><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.3.png" alt></p><h3 id="2-2-PPPoE协议"><a href="#2-2-PPPoE协议" class="headerlink" title="2.2 PPPoE协议:"></a>2.2 PPPoE协议:</h3><p>是为宽带上网的主机使用的链路层协议</p><h3 id="2-3-CSMA-CD协议"><a href="#2-3-CSMA-CD协议" class="headerlink" title="2.3 CSMA/CD协议:"></a>2.3 CSMA/CD协议:</h3><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h3 id="2-4-IEEE-802-3-2协议"><a href="#2-4-IEEE-802-3-2协议" class="headerlink" title="2.4 IEEE 802.3/.2协议"></a>2.4 IEEE 802.3/.2协议</h3><h3 id="2-5-ATM协议"><a href="#2-5-ATM协议" class="headerlink" title="2.5 ATM协议"></a>2.5 ATM协议</h3><h3 id="2-6-HDLC协议"><a href="#2-6-HDLC协议" class="headerlink" title="2.6 HDLC协议"></a>2.6 HDLC协议</h3><h2 id="三、数据链路层基本单元"><a href="#三、数据链路层基本单元" class="headerlink" title="三、数据链路层基本单元:"></a>三、数据链路层基本单元:</h2><p>帧</p><h2 id="四、数据链路层三个基本问题"><a href="#四、数据链路层三个基本问题" class="headerlink" title="四、数据链路层三个基本问题:"></a>四、数据链路层三个基本问题:</h2><h3 id="4-1-封装成帧"><a href="#4-1-封装成帧" class="headerlink" title="4.1 封装成帧:"></a>4.1 封装成帧:</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.1.png" alt></p><h3 id="4-2-透明传输"><a href="#4-2-透明传输" class="headerlink" title="4.2 透明传输:"></a>4.2 透明传输:</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.2.png" alt></p><h3 id="4-3-差错检测"><a href="#4-3-差错检测" class="headerlink" title="4.3 差错检测:"></a>4.3 差错检测:</h3><p>循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.7.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.8.png" alt></p><h2 id="五、数据链路层使用的信道"><a href="#五、数据链路层使用的信道" class="headerlink" title="五、数据链路层使用的信道:"></a>五、数据链路层使用的信道:</h2><h3 id="5-1-点对点信道"><a href="#5-1-点对点信道" class="headerlink" title="5.1 点对点信道:"></a>5.1 点对点信道:</h3><p><strong>一对一通信。</strong><br>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h3 id="5-2-广播信道"><a href="#5-2-广播信道" class="headerlink" title="5.2 广播信道:"></a>5.2 广播信道:</h3><p>①: <strong>一对多通信</strong>，一个节点发送的数据能够被广播信道上所有的节点接收到。<br>②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。<br>③: 主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用<strong>CSMA/CD 协议。</strong></p><h2 id="六、数据链路层功能："><a href="#六、数据链路层功能：" class="headerlink" title="六、数据链路层功能："></a>六、数据链路层功能：</h2><p>①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输<br>②: 组帧（Framing）<br>③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端<br>④: 流量控制（Flow control）:避免淹没接收端<br>⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧<br>⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权</p><h2 id="七、数据链路层任务"><a href="#七、数据链路层任务" class="headerlink" title="七、数据链路层任务:"></a>七、数据链路层任务:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.9.png" alt></p><h2 id="八、MAC-地址"><a href="#八、MAC-地址" class="headerlink" title="八、MAC 地址:"></a>八、MAC 地址:</h2><p>MAC 地址是<strong>链路层地址</strong>，长度为 6 字节（48 位），用于<strong>唯一标识网络适配器（网卡）</strong>。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="九、以太网"><a href="#九、以太网" class="headerlink" title="九、以太网:"></a>九、以太网:</h2><h3 id="9-1-以太网是一种星型拓扑结构局域网。"><a href="#9-1-以太网是一种星型拓扑结构局域网。" class="headerlink" title="9.1 以太网是一种星型拓扑结构局域网。"></a>9.1 以太网是一种星型拓扑结构局域网。</h3><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h3 id="9-2-特点"><a href="#9-2-特点" class="headerlink" title="9.2 特点:"></a>9.2 特点:</h3><p>采用的协议: CSMA/CD<br>采用无连接,半双工通信<br>对数据帧不进行编号<br>尽最大努力交付(不可靠)<br>不要求对方确认<br>发送的数据都以曼彻斯特编码<br>收到错帧就丢弃</p><h3 id="9-3-以太网帧格式："><a href="#9-3-以太网帧格式：" class="headerlink" title="9.3 以太网帧格式："></a>9.3 以太网帧格式：</h3><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.5.png" alt></p><h2 id="十、局域网"><a href="#十、局域网" class="headerlink" title="十、局域网:"></a>十、局域网:</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.6.png" alt></p><h2 id="十一、10BASE-T"><a href="#十一、10BASE-T" class="headerlink" title="十一、10BASE-T:"></a>十一、10BASE-T:</h2><p>10 代表 10Mbit/s<br>BASE : 连接线上的信号为基带信号<br>T: 双绞线</p><h2 id="十二、数据链路层功能"><a href="#十二、数据链路层功能" class="headerlink" title="十二、数据链路层功能:"></a>十二、数据链路层功能:</h2><p>将网络层接收到的数据分割成特定的可被物理层传输的帧</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据链路层设备&quot;&gt;&lt;a href=&quot;#一、数据链路层设备&quot; class=&quot;headerlink&quot; title=&quot;一、数据链路层设备:&quot;&gt;&lt;/a&gt;一、数据链路层设备:&lt;/h2&gt;&lt;p&gt;①: 网桥或桥接器:&lt;br&gt;②: 交换机:&lt;br&gt;　　&lt;strong&gt;实质: &lt;/strong&gt;是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器&lt;br&gt;　　&lt;strong&gt;特点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全双工:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行性: &lt;/strong&gt;即能同时连通多对接口，使多对主机能同时通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自学习: &lt;/strong&gt;即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数据链路层" scheme="https://zzwwqq.xyz/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Markdown用法</title>
    <link href="https://zzwwqq.xyz/Markdown%E7%94%A8%E6%B3%95.html"/>
    <id>https://zzwwqq.xyz/Markdown用法.html</id>
    <published>2019-04-06T12:23:12.000Z</published>
    <updated>2019-04-09T13:31:46.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常用操作"><a href="#一、常用操作" class="headerlink" title="一、常用操作:"></a>一、常用操作:</h2><h3 id="1-1-代码块"><a href="#1-1-代码块" class="headerlink" title="1.1 代码块:"></a>1.1 代码块:</h3><p>①: 添加代码块 :<br><strong>一行代码时: </strong> 使用一对单引号(ESC键下面的单引号键),代码放在这对单引号之间</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.4.png" alt>    </p><p>效果图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.2.png" alt>    </p><p><strong>多行代码:</strong> 连按三个单引号(ESC键下面的单引号键) ,然后回车.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.5.png" alt>   </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.6.png" alt> </p><p>效果图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.3.png" alt>     </p><p>②: 代码快速排版: 先把光标定位到代码块中, 然后Ctrl+ A选中所有代码,  最后  <code>Shift + tab</code></p><p>拍版前:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.7.png" alt>  </p><p> 排版后:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.8.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;768px&quot; height=&quot;367px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://zzwwqq.xyz/categories/Markdown/"/>
    
    
      <category term="Markdown用法指南" scheme="https://zzwwqq.xyz/tags/Markdown%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>初识Android</title>
    <link href="https://zzwwqq.xyz/%E5%88%9D%E8%AF%86Android.html"/>
    <id>https://zzwwqq.xyz/初识Android.html</id>
    <published>2019-04-05T11:35:08.000Z</published>
    <updated>2019-04-09T13:31:06.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Android系统四大组件"><a href="#一、Android系统四大组件" class="headerlink" title="一、Android系统四大组件:"></a>一、Android系统四大组件:</h2><h3 id="1-1-活动（Activity）"><a href="#1-1-活动（Activity）" class="headerlink" title="1.1 活动（Activity）:"></a>1.1 活动（Activity）:</h3><p>凡是在应用中你看得到的东西，都是放在活动中的。</p><h3 id="1-2-服务（Service）"><a href="#1-2-服务（Service）" class="headerlink" title="1.2 服务（Service）:"></a>1.2 服务（Service）:</h3><p>你无法看到它，但它会一直在后台默默地运行</p><h3 id="1-3-广播接收器（Broadcast-Receiver）"><a href="#1-3-广播接收器（Broadcast-Receiver）" class="headerlink" title="1.3 广播接收器（Broadcast Receiver）:"></a>1.3 广播接收器（Broadcast Receiver）:</h3><p>接收来自各处的广播消息，比如电话、短信等</p><h3 id="1-4-内容提供器（ContentProvider）"><a href="#1-4-内容提供器（ContentProvider）" class="headerlink" title="1.4 内容提供器（ContentProvider）:"></a>1.4 内容提供器（ContentProvider）:</h3><p>为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现</p><h2 id="二、创建并运行HelloWorld程序"><a href="#二、创建并运行HelloWorld程序" class="headerlink" title="二、创建并运行HelloWorld程序:"></a>二、创建并运行HelloWorld程序:</h2><h3 id="2-1-创建程序"><a href="#2-1-创建程序" class="headerlink" title="2.1 创建程序"></a>2.1 创建程序</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.1.png" alt></p><p>Application Name 代表应用名称，此应用安装到手机之后会在手机上显示该名称:<br>Project Name 代表项目名称，在项目创建完成后该名称会显示在 Eclipse 中<br>Minimum Required SDK 是指程序最低兼容的版本<br>Target SDK 是指你在该目标版本上已经做过了充分的测试，系统不会再帮你在这个版本上做向前兼容的操作了<br>Compile With是指程序将使用哪个版本的 SDK 进行编译<br>最后一个 Theme是指程序 UI 所使用的主题，我个人比较喜欢选择 None</p><h4 id="2-1-1-创建活动"><a href="#2-1-1-创建活动" class="headerlink" title="2.1.1 创建活动:"></a>2.1.1 创建活动:</h4><p>选择一个你想创建的活动类型，这里我们就选择 Blank Activity 了</p><h3 id="2-2-启动模拟器"><a href="#2-2-启动模拟器" class="headerlink" title="2.2 启动模拟器:"></a>2.2 启动模拟器:</h3><p>点击 Eclipse 导航栏中的 Window→Open Perspective→DDMS<br>如果你的 Devices 窗口中有一个设备显示是 Online 的，那就说明目前一切正常，你的模拟器是在线的</p><h3 id="2-3-执行程序代码"><a href="#2-3-执行程序代码" class="headerlink" title="2.3 执行程序代码:"></a>2.3 执行程序代码:</h3><p>右击 HelloWorld 项目→Run As→Android Application</p><h2 id="三、程序的目录结构"><a href="#三、程序的目录结构" class="headerlink" title="三、程序的目录结构:"></a>三、程序的目录结构:</h2><h3 id="3-1-gen"><a href="#3-1-gen" class="headerlink" title="3.1 gen"></a>3.1 gen</h3><p>自动生成的，主要有一个 R.java 文件,你在项目中添加的任何资源都会在其中生成一个相应的资源 id,<strong>永远不要手动去修改它。</strong></p><h3 id="3-2-bin"><a href="#3-2-bin" class="headerlink" title="3.2 bin"></a>3.2 bin</h3><p>存放<strong>编译时自动产生</strong>的文件, 目录下有HelloWorld.apk，把这个文件拷到手机上就可以直接安装了</p><h3 id="3-3-libs"><a href="#3-3-libs" class="headerlink" title="3.3 libs"></a>3.3 libs</h3><p>存放第三方 Jar包, 会被<strong>自动添加</strong>到构建路径里去</p><h3 id="3-4-assets"><a href="#3-4-assets" class="headerlink" title="3.4 assets"></a>3.4 assets</h3><p>存放一些<strong>随程序打包的文件</strong>,所有<strong>网页相关的文件</strong>也都存放在这个目录下</p><h3 id="3-5-res-resources即资源目录"><a href="#3-5-res-resources即资源目录" class="headerlink" title="3.5 res: (resources即资源目录)"></a>3.5 res: (resources即资源目录)</h3><p>图片、布局、字符串等资源都要存放在这个目录下<br>图片放在 drawable 目录下<br>布局放在 layout 目录下<br>字符串放在 values 目录下</p><h3 id="3-6-AndroidManifest-xml"><a href="#3-6-AndroidManifest-xml" class="headerlink" title="3.6 AndroidManifest.xml"></a>3.6 AndroidManifest.xml</h3><p>整个 Android 项目的配置文件，四大组件都需要在这个文件里注册,还可以添加权限声明,版本兼容修改</p><h3 id="3-7-project-properties"><a href="#3-7-project-properties" class="headerlink" title="3.7 project.properties"></a>3.7 project.properties</h3><p>指定编译程序时所使用的 SDK 版本</p><h2 id="四、程序的运行流程分析"><a href="#四、程序的运行流程分析" class="headerlink" title="四、程序的运行流程分析:"></a>四、程序的运行流程分析:</h2><h3 id="4-1-AndroidManifest-xml-文件"><a href="#4-1-AndroidManifest-xml-文件" class="headerlink" title="4.1 AndroidManifest.xml 文件:"></a>4.1 AndroidManifest.xml 文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 HelloWorldActivity 这个活动进行注册,没有在 AndroidManifest.xml 里面注册的活动是不能使用的。</span></span><br><span class="line">&lt;activity</span><br><span class="line">　　　android:name=<span class="string">"com.test.helloworld.HelloWorldActivity"</span></span><br><span class="line">　　　android:label=<span class="string">"@string/app_name"</span> &gt;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//主活动，在手机上点击应用图标，首先启动的就是这个活动。</span></span><br><span class="line">　　　&lt;intent-filter&gt;</span><br><span class="line">　　　　　&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">　　　　　&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">　　　&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-再来看src-HelloWorldActivity-java文件"><a href="#4-2-再来看src-HelloWorldActivity-java文件" class="headerlink" title="4.2 再来看src/HelloWorldActivity.java文件"></a>4.2 再来看src/HelloWorldActivity.java文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 调用了setContentView()方法，给当前的活动引入了一个 hello_world_layout 布局</span></span><br><span class="line">        setContentView(R.layout.hello_world_layout);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Activity</strong> 是 Android 系统提供的一个活动基类，项目中<strong>所有的活动都必须要继承它才能拥有活动的特性</strong></p><p><strong>onCreate()方法</strong>是一个<strong>活动被创建时必定要执行的方法</strong></p><p>Android程序的设计讲究逻辑和视图分离,在<strong>布局文件中编写界面</strong>，然后<strong>在活动中引入进来。</strong></p><h3 id="4-3-看-res-layout-hello-world-layout-xml-布局文件"><a href="#4-3-看-res-layout-hello-world-layout-xml-布局文件" class="headerlink" title="4.3 看 res/layout/hello_world_layout.xml 布局文件:"></a>4.3 看 res/layout/hello_world_layout.xml 布局文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">.......</span><br><span class="line">&lt;TextView</span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">......</span><br><span class="line">android:text=<span class="string">"@string/hello_world"</span> /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><strong>TextView</strong>，这是 Android 系统提供的一个控件，用于在<strong>布局中显示文字的</strong><br>hello_world_layout.xml布局文件中就是通过引用了 hello_world这个键，才找到了相应的值</p><h3 id="4-4-查看res-values-strings-xml-文件"><a href="#4-4-查看res-values-strings-xml-文件" class="headerlink" title="4.4 查看res/values/strings.xml 文件:"></a>4.4 查看res/values/strings.xml 文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;string name="app_name"&gt;Hello World&lt;/string&gt;</span><br><span class="line">....</span><br><span class="line">&lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p>一 般 是 把 字 符 串 定 义 在res/values/strings.xml 里，然后可以在布局文件或代码中引用<br>Hello world!字符串就是定义在这个文件里的<br>可以在这里通过修改 app_name 对应的值，来改变此应用程序的名称,在哪儿引用了app_name 这个键呢？在AndroidManifest.xml查找.</p><h2 id="五、关于资源目录res"><a href="#五、关于资源目录res" class="headerlink" title="五、关于资源目录res:"></a>五、关于资源目录res:</h2><p>drawable开头的文件夹都是用来放图片的<br>values开头的文件夹都是用来放字符串<br>layout 文件夹是用来放布局文件<br>menu 文件夹是用来放菜单文件</p><p>之所以有这么多 drawable开头的文件夹，是为了让程序能够兼容更多的设备, 最好能够给同一张图片提供几个不同分辨率的副本<br><strong>只有一份图片时,所有图片都放在 drawable-hdpi下即可</strong></p><h2 id="六、如何引用资源"><a href="#六、如何引用资源" class="headerlink" title="六、如何引用资源?"></a>六、如何引用资源?</h2><p> strings.xml 中的 Hello world!字符串，有两种方式引用它：</p><p>①: 代码中通过 <code>R.string.hello_world</code> 可以获得该字符串的引用；<br>②: 在 XML 中通过<code>@string/hello_world</code>可以获得该字符串的引用。</p><p>string 部分是可以替换的,如果是<strong>引用的图片资源就可以替换成 drawable,</strong>如果是引用的布局文件就可以替换成 layout,以此类推</p><h2 id="七、日志"><a href="#七、日志" class="headerlink" title="七、日志:"></a>七、日志:</h2><h3 id="7-1-打印日志"><a href="#7-1-打印日志" class="headerlink" title="7.1 打印日志:"></a>7.1 打印日志:</h3><p>打开 HelloWorldActivity，在 onCreate()方法中添加一行打印日志的语句，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">Log.d(<span class="string">"HelloWorldActivity"</span>, <span class="string">"onCreate execute"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Log.d 第一个参数是 tag，一般传入当前的类名，主要用于对打印信息进行过滤。<br>第二个参数是 msg，即想要打印的具体的内容。</p><h3 id="7-2-日志过滤器"><a href="#7-2-日志过滤器" class="headerlink" title="7.2 日志过滤器:"></a>7.2 日志过滤器:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.3.png" alt></p><p>给过滤器起名叫 data，并且让它对名为 data 的 Tag进行过滤</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.4.png" alt></p><p>在 onCreate()方法中把打印日志的语句改成 Log.d(“data”,”onCreate execute”)，然后再次运行程序，你就会在 data 过滤器下看到这行日志了。</p><h3 id="7-3-日志级别"><a href="#7-3-日志级别" class="headerlink" title="7.3 日志级别:"></a>7.3 日志级别:</h3><p>选中debug级别，这时只有使用 debug 及以上级别方法打印的日志才会显示出来<br>如果你把LogCat 中的级别选中为 info、warn 或者 error 时，我们在 onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是 Log.d()方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Android系统四大组件&quot;&gt;&lt;a href=&quot;#一、Android系统四大组件&quot; class=&quot;headerlink&quot; title=&quot;一、Android系统四大组件:&quot;&gt;&lt;/a&gt;一、Android系统四大组件:&lt;/h2&gt;&lt;h3 id=&quot;1-1-活动（Acti
      
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="初识Android" scheme="https://zzwwqq.xyz/tags/%E5%88%9D%E8%AF%86Android/"/>
    
  </entry>
  
  <entry>
    <title>PV操作</title>
    <link href="https://zzwwqq.xyz/PV%E6%93%8D%E4%BD%9C%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html"/>
    <id>https://zzwwqq.xyz/PV操作经典实例.html</id>
    <published>2019-04-04T07:58:18.000Z</published>
    <updated>2019-04-09T13:29:56.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是PV操作"><a href="#一、什么是PV操作" class="headerlink" title="一、什么是PV操作?"></a>一、什么是PV操作?</h2><p>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：<br>P（S）：<br>①将信号量S的值减1，即S=S-1；<br>②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。<br><a id="more"></a></p><p>V（S）：<br>①将信号量S的值加1，即S=S+1；</p><h2 id="二、PV操作的意义："><a href="#二、PV操作的意义：" class="headerlink" title="二、PV操作的意义："></a>二、PV操作的意义：</h2><p>我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。</p><h2 id="三、什么是信号量？"><a href="#三、什么是信号量？" class="headerlink" title="三、什么是信号量？"></a>三、什么是信号量？</h2><p>信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。<br><strong>信号量的值与相应资源的使用情况有关: </strong><br>①: 当信号量的值大于0时，表示当前可用资源的数量<br>②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数<br><strong>注意，信号量的值仅能由PV操作来改变。</strong></p><h2 id="四、使用PV操作注意事项："><a href="#四、使用PV操作注意事项：" class="headerlink" title="四、使用PV操作注意事项："></a>四、使用PV操作注意事项：</h2><p>①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。<br>②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。<br>③: 互斥信号量的初值一般为1。</p><h2 id="五、PV操作实例"><a href="#五、PV操作实例" class="headerlink" title="五、PV操作实例:"></a>五、PV操作实例:</h2><h2 id="5-1-例题1-吃苹果问题"><a href="#5-1-例题1-吃苹果问题" class="headerlink" title="5.1 例题1: 吃苹果问题:"></a>5.1 例题1: 吃苹果问题:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.1.png" alt></p><p><strong>解题过程:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty=<span class="number">2</span>； <span class="comment">//定义empty对应盘子的剩余放水果的位置个数初值为2(      空缓冲区个数       ) </span></span><br><span class="line">    semaphore apple=<span class="number">0</span>； <span class="comment">//定义信号量apple对应盘子里的苹果数量初值为0 </span></span><br><span class="line">    semaphore orange=<span class="number">0</span>； <span class="comment">//定义信号量orange对于盘子里的橘子数量初值为0 </span></span><br><span class="line">    semaphore mutex=<span class="number">1</span>： <span class="comment">//定义信号量mutex来保护盘子被互斥地访问 </span></span><br><span class="line">    father()&#123; <span class="comment">//爸爸进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(empty)； <span class="comment">//盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放苹果</span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            在盘子里放一个苹果 </span><br><span class="line">            V(mutex)； </span><br><span class="line">            V(apple)；<span class="comment">//盘中苹果数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mother()&#123; <span class="comment">//妈妈进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">        P(empty)； <span class="comment">//盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放橘子</span></span><br><span class="line">            P(mutex)； <span class="comment">//互斥变量减一，如果&lt;0，则说明有进程在临界区。则当前进程必须等待。</span></span><br><span class="line">            在盘子里放一个橘子</span><br><span class="line">            V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。</span><br><span class="line">            V(orange)； <span class="comment">//盘中橘子数加一</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">son()&#123; <span class="comment">//用这段程序产生两个儿子进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">        P(orange)； <span class="comment">//盘中橘子个数减一，如果结果&gt;=0时,说明盘中有橘子，可以取 </span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            从盘子里拿一个橘子</span><br><span class="line">            V(mutex)； </span><br><span class="line">            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123; <span class="comment">//用这段程序产生两个女儿进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span> )  &#123; </span><br><span class="line">        P(apple)；   <span class="comment">//盘中苹果个数减一，如果结果&gt;=0时,说明盘中有苹果，可以取</span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            从盘子里拿出一个苹果 </span><br><span class="line">            V(mutex)；</span><br><span class="line">            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-和尚打水"><a href="#5-2-和尚打水" class="headerlink" title="5.2 : 和尚打水:"></a>5.2 : 和尚打水:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.2.png" alt></p><p><strong>分析:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.3.png" alt></p><p><strong>解题过程:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Semaphore   mutexA = <span class="number">1</span>;    <span class="comment">//保护井被互斥地访问 </span></span><br><span class="line">Semaphore   mutexB = <span class="number">1</span>;    <span class="comment">//保护缸被互斥地访问 </span></span><br><span class="line">Semaphore   Count = <span class="number">3</span>；    <span class="comment">//桶总数为3</span></span><br><span class="line">Semaphore   full = <span class="number">0</span>;      <span class="comment">//控制出水，刚开始，缸是空的，能取出0桶水</span></span><br><span class="line">Semaphore   empty = <span class="number">10</span> ;   <span class="comment">//控制入水，刚开始，缸是空的，能倒入10桶水</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小和尚打水：</span></span><br><span class="line">Progress（小和尚）&#123;</span><br><span class="line">          <span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">                   P（empty）  <span class="comment">//判断缸是否满了（结果如果&gt;=0,未满），决定是否需要打水</span></span><br><span class="line">                   P（count）  <span class="comment">//拿桶（判断是否有空闲的桶，结果如果&gt;=0,有桶）</span></span><br><span class="line">                   P（mutexA）&#123;   <span class="comment">//对井互斥访问</span></span><br><span class="line">                    从井中打水；</span><br><span class="line">                    V（mutexA）    <span class="comment">//互斥</span></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                    P（mutexB）&#123;   <span class="comment">//对缸互斥访问</span></span><br><span class="line">                    向缸中倒水；</span><br><span class="line">                    V（mutexB）    <span class="comment">//互斥</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   V（count）<span class="comment">//还桶，空闲桶的数量加一</span></span><br><span class="line">                   V（full）   <span class="comment">//缸中水的数量加一，（通知老和尚取水）</span></span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老和尚取水：</span></span><br><span class="line">progress（老和尚）&#123;</span><br><span class="line">             <span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">                      P（full） <span class="comment">//判断缸中是否有水，（结果如果&gt;=0,说明缸中有水，可取水）</span></span><br><span class="line">                      P（count）<span class="comment">//拿桶</span></span><br><span class="line">                      P（mutexB) <span class="comment">//互斥</span></span><br><span class="line">                      从缸中取水；</span><br><span class="line">                      V（mutexB）<span class="comment">//互斥</span></span><br><span class="line">                      V(count)   <span class="comment">//还桶</span></span><br><span class="line">                      V（empty）<span class="comment">//缸中还能容纳的水数量加一，（通知小和尚打水）</span></span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是PV操作&quot;&gt;&lt;a href=&quot;#一、什么是PV操作&quot; class=&quot;headerlink&quot; title=&quot;一、什么是PV操作?&quot;&gt;&lt;/a&gt;一、什么是PV操作?&lt;/h2&gt;&lt;p&gt;PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：&lt;br&gt;P（S）：&lt;br&gt;①将信号量S的值减1，即S=S-1；&lt;br&gt;②如果S&amp;gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="PV操作" scheme="https://zzwwqq.xyz/tags/PV%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://zzwwqq.xyz/%E6%AD%BB%E9%94%81.html"/>
    <id>https://zzwwqq.xyz/死锁.html</id>
    <published>2019-04-03T07:10:16.000Z</published>
    <updated>2019-04-03T08:40:59.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是死锁"><a href="#一、什么是死锁" class="headerlink" title="一、什么是死锁:"></a>一、什么是死锁:</h2><p>是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种<strong>互相等待</strong>的现象,若无<strong>外力</strong>作用,它们都将无法推进下去.</p><h2 id="二、产生死锁的原因"><a href="#二、产生死锁的原因" class="headerlink" title="二、产生死锁的原因:"></a>二、产生死锁的原因:</h2><a id="more"></a><p>①: 因为系统资源不足<br>②: 进程运行推进顺序不合适<br>③: 资源分配不当等</p><h2 id="三、产生死锁的必要条件"><a href="#三、产生死锁的必要条件" class="headerlink" title="三、产生死锁的必要条件:"></a>三、产生死锁的必要条件:</h2><p>①: 互斥：一个资源每次只能被一个进程使用<br>②: 占有和等待(请求与保持)：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>③:  不剥夺: 进程已获得的资源，在使用完之前，不能强行被抢占,它只能被占有它的进程显式地释放。<br>④: 环路等待: 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p><p><strong>注: 只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong></p><h2 id="四、处理死锁的方法"><a href="#四、处理死锁的方法" class="headerlink" title="四、处理死锁的方法:"></a>四、处理死锁的方法:</h2><p>主要有以下四种方法：</p><h3 id="4-1-鸵鸟策略"><a href="#4-1-鸵鸟策略" class="headerlink" title="4.1 鸵鸟策略"></a>4.1 鸵鸟策略</h3><p><strong>4.1.1 原理: </strong><br>把头埋在沙子里，假装根本没发生问题, 也就是忽略死锁<br><strong>4.1.2 什么时候用?</strong><br>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><h3 id="4-2-死锁检测与死锁恢复"><a href="#4-2-死锁检测与死锁恢复" class="headerlink" title="4.2 死锁检测与死锁恢复"></a>4.2 死锁检测与死锁恢复</h3><p><strong>4.2.1 原理: </strong><br>不试图阻止死锁，而是当<strong>检测到死锁发生时</strong>，<strong>再采取措施</strong>进行恢复。<br><strong>4.2.2 死锁检测:</strong><br><strong>4.2.2.1 每种类型一个资源的死锁检测:</strong><br>通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>4.2.2.2 每种类型多个资源的死锁检测:</strong><br>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。<br>①: 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。<br>②: 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。<br>③: 如果没有这样一个进程，算法终止。</p><h3 id="4-2-3-死锁恢复"><a href="#4-2-3-死锁恢复" class="headerlink" title="4.2.3 死锁恢复:"></a>4.2.3 死锁恢复:</h3><p>①: 利用抢占恢复<br>②: 利用回滚恢复<br>③:     通过杀死进程恢复</p><h3 id="4-3-死锁预防"><a href="#4-3-死锁预防" class="headerlink" title="4.3 死锁预防"></a>4.3 死锁预防</h3><h3 id="4-3-1-原理"><a href="#4-3-1-原理" class="headerlink" title="4.3.1 原理:"></a>4.3.1 原理:</h3><p>在程序<strong>运行之前</strong>预防发生死锁</p><h3 id="4-3-2-采取方法"><a href="#4-3-2-采取方法" class="headerlink" title="4.3.2 采取方法:"></a>4.3.2 采取方法:</h3><p>破坏死锁的四个必要条件<br><strong>①: 破坏互斥：</strong><br><strong>②: 破坏占有和等待(请求与保持):</strong><br>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p><strong>③: 破坏不剥夺:</strong><br><strong>④: 破坏环路等待:</strong><br>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="4-4-死锁避免"><a href="#4-4-死锁避免" class="headerlink" title="4.4 死锁避免"></a>4.4 死锁避免</h3><p>在程序<strong>运行时</strong>避免发生死锁</p><h2 id="五、银行家算法"><a href="#五、银行家算法" class="headerlink" title="五、银行家算法:"></a>五、银行家算法:</h2><p><strong>例题: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-3.1.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-3.2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是死锁&quot;&gt;&lt;a href=&quot;#一、什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;一、什么是死锁:&quot;&gt;&lt;/a&gt;一、什么是死锁:&lt;/h2&gt;&lt;p&gt;是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种&lt;strong&gt;互相等待&lt;/strong&gt;的现象,若无&lt;strong&gt;外力&lt;/strong&gt;作用,它们都将无法推进下去.&lt;/p&gt;
&lt;h2 id=&quot;二、产生死锁的原因&quot;&gt;&lt;a href=&quot;#二、产生死锁的原因&quot; class=&quot;headerlink&quot; title=&quot;二、产生死锁的原因:&quot;&gt;&lt;/a&gt;二、产生死锁的原因:&lt;/h2&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="https://zzwwqq.xyz/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Android之活动</title>
    <link href="https://zzwwqq.xyz/Android%E4%B9%8B%E6%B4%BB%E5%8A%A8.html"/>
    <id>https://zzwwqq.xyz/Android之活动.html</id>
    <published>2019-04-02T13:31:03.000Z</published>
    <updated>2019-04-03T08:25:55.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、活动的基本用法"><a href="#一、活动的基本用法" class="headerlink" title="一、活动的基本用法:"></a>一、活动的基本用法:</h2><p>项目名可以叫做 ActivityTest ,为了手动创建活动 <strong>不再勾选 Create Activity</strong></p><h3 id="1-1-手动创建活动"><a href="#1-1-手动创建活动" class="headerlink" title="1.1 手动创建活动:"></a>1.1 手动创建活动:</h3><p>src 目录下先添加一个包,使用的默认包名com.example.activitytest<br>新建FirstActivity 类继承自 Activity<br>任何活动都应该重写 Activity 的 onCreate()方法</p><h3 id="1-2-创建布局"><a href="#1-2-创建布局" class="headerlink" title="1.2 创建布局"></a>1.2 创建布局</h3><p>每一个活动对应一个布局，布局就是用来显示界面内容<br>在res/layout 目录下新建 名为first_layout.xml的文件(菜单中点击Android XMLFile),根元素就默认选择为 LinearLayout</p><p><strong>添加一个按钮:</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_1"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>XML 中引用一个 id，就使用@id/id_name 这种语法<br>XML 中定义一个 id，则要使用@+id/id_name 这种语法<br>android:layout_width 指定了当前元素的宽度，match_parent表示让当前元素和父元素一样宽。<br>android:layout_height 指定了高度， wrap_content，表示当前元素的高度只要能刚好包含里面的内容就行。<br>android:text 指定了元素中显示的文字内容</p><h3 id="1-3-在活动中加载这个布局"><a href="#1-3-在活动中加载这个布局" class="headerlink" title="1.3 在活动中加载这个布局:"></a>1.3 在活动中加载这个布局:</h3><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            setContentView(R.layout.first_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id，因此我们刚才创建的 first_layout.xml 布局的 id 现在应该是已经添加到 R 文件中了。<br><strong>在代码中引用布局文件:  R.layout.first_layout </strong><br><strong>注意: </strong>这里我们使用的 R，是com.example.activitytest 包下的 R 文件<br>Android SDK 还会自动提供一个 android 包下的 R 文件，千万别使用错了。</p><h3 id="1-4-在-AndroidManifest-文件中注册"><a href="#1-4-在-AndroidManifest-文件中注册" class="headerlink" title="1.4 在 AndroidManifest 文件中注册:"></a>1.4 在 AndroidManifest 文件中注册:</h3><p>所有的活动都要在 AndroidManifest.xml 中进行注册才能生效    </p><p>在AndroidManifest.xml 来给 FirstActivity 注册:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"com.example.activitytest"</span> &gt;</span><br><span class="line">....</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">....</span><br><span class="line">&lt;activity</span><br><span class="line"><span class="comment">/*.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity 的</span></span><br><span class="line"><span class="comment">缩写由于最外层的&lt;manifest&gt;标签中已经通过 package 属性指定了程序的包名是</span></span><br><span class="line"><span class="comment">             com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">             android:label=<span class="string">"This is FirstActivity"</span> &gt;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果你想让 FirstActivity 作为我们这个程序的主活动，即点击桌面应用程序图标时首先打开的就是这</span></span><br><span class="line"><span class="comment">             个活动，那就一定要加入下面这两句声明。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他的应用在内部进行调用的，如支付宝快捷支付服务。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>活动的注册声明要放在<code>&lt;application&gt;</code>标签内, 通过<code>&lt;activity&gt;</code>标签来对活动进行注册的<br>android:name 来指定具体注册哪一个活动<br>android:label指定活动中标题栏的内容</p><h3 id="1-5-隐藏标题栏"><a href="#1-5-隐藏标题栏" class="headerlink" title="1.5 隐藏标题栏"></a>1.5 隐藏标题栏</h3><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注意这句代码一定要在 setContentView()之前执行，不然会报错</span></span><br><span class="line">    requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-在活动中使用-Toast"><a href="#1-6-在活动中使用-Toast" class="headerlink" title="1.6 在活动中使用 Toast:"></a>1.6 在活动中使用 Toast:</h3><p>toast是什么?<br>界面弹出短小的信息通知给用户，这些信息会在一段时间后自动消失</p><p>首先需要定义一个弹出 Toast 的触发点,    如点击按钮的时候弹出一个 Toast </p><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// findViewById()方法获取在布局文件中定义的元素，传入 R.id.button_1，来得到按钮的实例</span></span><br><span class="line">        Button button1 = (Button) findViewById(R.id.button_1);<span class="comment">//findViewById返回的是一个 View 对象</span></span><br><span class="line">        <span class="comment">//注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法</span></span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* makeText()创建出一个 Toast对象, show()是将 Toast 显示出来</span></span><br><span class="line"><span class="comment">            第一个参数是 Context，也就是 Toast 要求的上下文，活动本身就是一个 Context 对象</span></span><br><span class="line"><span class="comment">            第二个参数是Toast显示的文本内容</span></span><br><span class="line"><span class="comment">            第三个参数是Toast显示的时长</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Toast.makeText(FirstActivity.<span class="keyword">this</span>, <span class="string">"You clicked Button 1"</span>,</span><br><span class="line">                           Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-在活动中使用-Menu"><a href="#1-7-在活动中使用-Menu" class="headerlink" title="1.7 在活动中使用 Menu"></a>1.7 在活动中使用 Menu</h3><p>在 res 目录下新建一个 menu 文件夹<br>新建一个 main.xml 文件(点击Android XML File)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line"><span class="comment">//&lt;item&gt;标签就是用来创建具体的某一个菜单项</span></span><br><span class="line">    &lt;item</span><br><span class="line">         <span class="comment">//给这个菜单项指定一个唯一标识符，</span></span><br><span class="line">android:id=<span class="string">"@+id/add_item"</span></span><br><span class="line">         <span class="comment">//给这个菜单项指定一个名称</span></span><br><span class="line">android:title=<span class="string">"Add"</span>/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><p>然后打开 FirstActivity类，重写 onCreateOptionsMenu()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* inflate()方法就可以给当前活动创建菜单</span></span><br><span class="line"><span class="comment">    第一个参数:通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main</span></span><br><span class="line"><span class="comment">    第二个参数:用于指定我们的菜单项将添加到哪一个 Menu对象当中，这里直接使用 onCreateOptionsMenu()方法中传</span></span><br><span class="line"><span class="comment">    入的 menu参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="comment">//返回 true，表示允许创建的菜单显示出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义菜单响应事件"><a href="#定义菜单响应事件" class="headerlink" title="定义菜单响应事件:"></a>定义菜单响应事件:</h3><p> FirstActivity 中重写 onOptionsItemSelected()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// item.getItemId()来判断我们点击的是哪一个菜单项</span></span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Add"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Remove"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-销毁一个活动"><a href="#1-8-销毁一个活动" class="headerlink" title="1.8 销毁一个活动:"></a>1.8 销毁一个活动:</h3><p>Activity 类提供了一个 finish()方法:</p><p>打开 FirstActivity类,onCreate方法中, 修改按钮监听器中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一样的。</span></span><br></pre></td></tr></table></figure><h2 id="二、使用-Intent-在活动之间穿梭"><a href="#二、使用-Intent-在活动之间穿梭" class="headerlink" title="二、使用 Intent 在活动之间穿梭:"></a>二、使用 Intent 在活动之间穿梭:</h2><h3 id="2-1-使用显式-Intent"><a href="#2-1-使用显式-Intent" class="headerlink" title="2.1 使用显式 Intent:"></a>2.1 使用显式 Intent:</h3><p>Intent的“意图”非常明显，因此我们称之为显式 Intent</p><p>在 ActivityTest 项目中再创建一个活动。新建一个 second_layout.xml 布局文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//定义了一个按钮，按钮上显示 Button 2</span></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_2"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建活动 SecondActivity 继承自Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 AndroidManifest.xml 中为 SecondActivity 进行注册。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">   ...&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">android:label=<span class="string">"This is FirstActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"><span class="comment">// SecondActivity 不是主活动，因此不需要配置&lt;intent-filter&gt;标签里的内容</span></span><br><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure><p><strong>Intent 一般可被用于启动活动、启动服务、以及发送广播等场景</strong><br>Intent 是 各组件之间进行<strong>交互</strong>的一种重要方式，它可以<strong>指明</strong>当前组件想要<strong>执行的动作</strong>，还可以在不同组件之间<strong>传递数据</strong></p><p>Intent(Context packageContext, Class&lt;?&gt; cls):<br>这个构造函数接收两个参数，第一个参数: 启动活动的上下文，第二个参数 指定想要启动的目标活动</p><p>Activity 类中 startActivity()方法，用于启动活动的，它接收一个Intent参数</p><p>修改 FirstActivity 中按钮的点击事件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在FirstActivity活动的基础上打开 SecondActivity活动,startActivity()方法来执行这个Intent</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-使用隐式-Intent"><a href="#2-2-使用隐式-Intent" class="headerlink" title="2.2 使用隐式 Intent:"></a>2.2 使用隐式 Intent:</h3><p><strong>不明确指出</strong>我们想要启动哪一个活动，而是指定了一系列更为抽象的 action和 category等信息,<strong>由系统去分析Intent</strong>，并找出合适的活动(响应隐式 Intent的活动)去启动</p><p> AndroidManifest.xml添加如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    <span class="comment">//指明当前活动可以响应 ACTION_START这个 action</span></span><br><span class="line">&lt;action android:name=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span><br><span class="line">         <span class="comment">// 精确地指明当前的活动能够响应的 Intent 中还可能带有的 category  </span></span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"><span class="comment">//只有&lt;action&gt;和&lt;category&gt;中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。</span></span><br></pre></td></tr></table></figure><p>修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用了Intent 的另一个构造函数,传入action的字符串,表明要启动能够响应ACTION_START这个action的活动</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注: &lt;action&gt;和&lt;category&gt;同时匹配上才能响应,而这里没有指定category,这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中</span></span><br></pre></td></tr></table></figure><p><strong>每个 Intent 中只能指定一个 action，但却能指定多个 category</strong></p><p>修改 FirstActivity 中按钮的点击事件,增加一个category</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        <span class="comment">// addCategory()方法来添加一个 category</span></span><br><span class="line">        intent.addCategory(<span class="string">"com.example.activitytest.MY_CATEGORY"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中 SecondActivity的<code>&lt;intent-filter&gt;</code>中再添加一个 category 的声明:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">....</span><br><span class="line">&lt;category android:name=<span class="string">"com.example.activitytest.MY_CATEGORY"</span>/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-更多隐式-Intent-的用法"><a href="#2-3-更多隐式-Intent-的用法" class="headerlink" title="2.3 更多隐式 Intent 的用法"></a>2.3 更多隐式 Intent 的用法</h3><p>修改 FirstActivity 中按钮点击事件的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器来打开这个网页就行了</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Intent.ACTION_VIEW，这是一个 Android 系统内置的动作</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        <span class="comment">// Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以在<code>&lt;intent-filter&gt;</code>标签中再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容:</p><p>android:scheme<br>用于指定数据的协议部分，如上例中的 http 部分</p><p><strong>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data完全一致时，当前活动才能够响应该 Intent。</strong><br>如上面浏览器示例中，其实只需要<strong>指定 android:scheme 为 http，就可以响应所有的 http 协议的 Intent 了</strong>。</p><h3 id="2-4-自己建立一个活动，让它也能响应打开网页的Intent"><a href="#2-4-自己建立一个活动，让它也能响应打开网页的Intent" class="headerlink" title="2.4 自己建立一个活动，让它也能响应打开网页的Intent"></a>2.4 自己建立一个活动，让它也能响应打开网页的Intent</h3><p>新建 third_layout.xml 布局文件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_3"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 3"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建活动 ThirdActivity 类继承自 Activity<br>将布局添加到活动中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.third_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 AndroidManifest.xml 中为 ThirdActivity 进行注册</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".ThirdActivity"</span> &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">     &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">          <span class="comment">//数据的协议必须是 http协议</span></span><br><span class="line">          &lt;data android:scheme=<span class="string">"http"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p><strong>调用系统拨号界面</strong></p><p>除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示<br>拨打电话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL);</span><br><span class="line">        <span class="comment">// data部分指定了协议是 tel，号码是 10086</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-5-向下一个活动传递数据"><a href="#2-5-向下一个活动传递数据" class="headerlink" title="2.5 向下一个活动传递数据:"></a>2.5 向下一个活动传递数据:</h3><p> Intent 还可以在启动活动的时候传递数据, </p><p>putExtra()的重载，可把想要传递的数据暂存在 Intent 中，启动另一个活动后，只需把这些数据从Intent 中取出就可</p><p>SecondActivity 类中,修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity中</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String data = <span class="string">"Hello SecondActivity"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">//第一个参数是键,用于后面从 Intent中取值，第二个参数才是真正要传递的数据。</span></span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>, data);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// getIntent()方法获取到用于启动 SecondActivity 的 Intent</span></span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        <span class="comment">//如果传递的是布尔型数据，则使用 getBooleanExtra()方法</span></span><br><span class="line">        <span class="comment">//getStringExtra()方法，传入相应的键值，就可以得到传递的数据了</span></span><br><span class="line">        String data = intent.getStringExtra(<span class="string">"extra_data"</span>);</span><br><span class="line">        Log.d(<span class="string">"SecondActivity"</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-返回数据给上一个活动"><a href="#2-6-返回数据给上一个活动" class="headerlink" title="2.6 返回数据给上一个活动:"></a>2.6 返回数据给上一个活动:</h3><p>Activity 中 <strong>startActivityForResult()</strong>方法也是用于<strong>启动活动</strong>的，但这个方法期望在活动<strong>销毁的时</strong>候能够<strong>返回一个结果给上一个活动</strong>。</p><p>修改 FirstActivity 中按钮的点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">//第一个参数还是 Intent,第二个参数是请求码，用于在之后的回调中判断数据的来源,请求码只要是一个唯一值就可以了</span></span><br><span class="line">        startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SecondActivity 中给按钮注册点击事件并在点击事件中添加返回数据的逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">        Button button2 = (Button) findViewById(R.id.button_2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">                intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">                <span class="comment">//setResult()专门用于向上一个活动返回数据的</span></span><br><span class="line">                <span class="comment">//第一个参数用于向上一个活动返回处理结果,第二个参数则是把带有数据的 Intent 传递回去</span></span><br><span class="line">                setResult(RESULT_OK, intent);</span><br><span class="line">                <span class="comment">//销毁当前活动</span></span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数 requestCode，启动活动时传入的请求码,</span></span><br><span class="line"><span class="comment">//第二个参数 resultCode，返回数据时传入的处理结果</span></span><br><span class="line"><span class="comment">//第三个参数 data，即携带着返回数据的 Intent</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到 onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作</p><p>如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下Back 键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通过重写 onBackPressed()方法来解决这个问题，代码如下所示：</p><p>SecondActivity 类中修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的话，当用户按下 Back 键，就会去执行 onBackPressed()方法中的代码，我们在这里添加返回数据的逻辑就行了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">    setResult(RESULT_OK, intent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-活动的生命周期"><a href="#2-7-活动的生命周期" class="headerlink" title="2.7 活动的生命周期:"></a>2.7 活动的生命周期:</h3><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.5.png" alt></p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期中最多可能会有四种状态。<br>运行状态:位于返回栈的栈顶时<br>暂停状态:不再处于栈顶位置，但仍然可见<br>停止状态:不再处于栈顶位置，并且完全不可见<br>销毁状态:从返回栈中移除后就变成了销毁状态</p><h3 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h3><p>Activity 类中定义了七个回调方法:</p><p>onCreate():<br>每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</p><p>onStart():<br>在活动由不可见变为可见的时候调用</p><p>onResume():<br>在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</p><p>onPause():<br>准备去启动或者恢复另一个活动的时候调用</p><p>onStop():<br>在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。</p><p>onDestroy():<br>活动被销毁之前调用</p><p>onRestart():<br>活动由停止状态变为运行状态之前调用</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.6.png" alt></p><h3 id="2-6-活动被回收了怎么办"><a href="#2-6-活动被回收了怎么办" class="headerlink" title="2.6 活动被回收了怎么办"></a>2.6 活动被回收了怎么办</h3><p>Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p><p>onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法<br>用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据，<br>以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，<br>第二个参数是真正要保存的内容。<br>在 MainActivity 中添加如下代码就可以将临时数据进行保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">String tempData = <span class="string">"Something you just typed"</span>;</span><br><span class="line">outState.putString(<span class="string">"data_key"</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我<br>们一直使用的 onCreate()方法其实也有一个 Bundle类型的参数。这个参数在一般情况下都是<br>null，但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参<br>数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。<br>修改 MainActivity 的 onCreate()方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String tempData = savedInstanceState.getString(<span class="string">"data_key"</span>);</span><br><span class="line">        Log.d(TAG, tempData);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-活动的启动模式"><a href="#2-7-活动的启动模式" class="headerlink" title="2.7 活动的启动模式"></a>2.7 活动的启动模式</h3><p>启动模式一共有四种，分别是 standard、singleTop、singleTask 和 singleInstance​    </p><p>AndroidManifest.xml 中通 过给<code>&lt;activity&gt;</code> 标签 指定android:launchMode属性来选择启动模式</p><p>standard</p><p>活动默认的启动模式,系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</p><p>singleTop</p><p>在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</p><p>修改 AndroidManifest.xml 中 FirstActivity 的启动模式，<br>如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">android:launchMode=<span class="string">"singleTop"</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>singleTask</p><p>很好地解决重复创建栈顶活动的问题</p><p>singleInstance</p><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、活动的基本用法&quot;&gt;&lt;a href=&quot;#一、活动的基本用法&quot; class=&quot;headerlink&quot; title=&quot;一、活动的基本用法:&quot;&gt;&lt;/a&gt;一、活动的基本用法:&lt;/h2&gt;&lt;p&gt;项目名可以叫做 ActivityTest ,为了手动创建活动 &lt;strong&gt;不
      
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="Android之活动" scheme="https://zzwwqq.xyz/tags/Android%E4%B9%8B%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之适配器模式.html</id>
    <published>2019-04-02T08:44:27.000Z</published>
    <updated>2019-04-02T09:10:19.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是适配器模式"><a href="#一、什么是适配器模式" class="headerlink" title="一、什么是适配器模式?"></a>一、什么是适配器模式?</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br>举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><a id="more"></a><h2 id="二、-分类"><a href="#二、-分类" class="headerlink" title="二、 分类:"></a>二、 分类:</h2><h3 id="2-1-类的适配器模式"><a href="#2-1-类的适配器模式" class="headerlink" title="2.1 类的适配器模式:"></a>2.1 类的适配器模式:</h3><p><strong>使用步骤:</strong><br>步骤1： 创建Target接口<br>步骤2： 创建源类（Adaptee）<br>步骤3： 创建适配器类Adapter (适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。)<br>步骤4： 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</p><h3 id="2-2-对象的适配器模式"><a href="#2-2-对象的适配器模式" class="headerlink" title="2.2 对象的适配器模式:"></a>2.2 对象的适配器模式:</h3><p><strong>原理:</strong><br>与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。<br><strong>步骤:</strong><br>①: 创建Target接口<br>②: 创建源类（Adaptee）<br>③: 创建适配器类（Adapter）（不适用继承而是委派）<br>④: 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</p><h3 id="2-3-对象的适配器模式与类的适配器模式比较"><a href="#2-3-对象的适配器模式与类的适配器模式比较" class="headerlink" title="2.3 对象的适配器模式与类的适配器模式比较:"></a>2.3 对象的适配器模式与类的适配器模式比较:</h3><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。</p><h3 id="2-4-什么时候用类的适配器模式"><a href="#2-4-什么时候用类的适配器模式" class="headerlink" title="2.4 什么时候用类的适配器模式?"></a>2.4 什么时候用类的适配器模式?</h3><p> ①: 仅仅希望使用方便时<br>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。<br>对于对象适配器，需要额外的引用来间接得到Adaptee。<br>②: 需要重新定义Adaptee的部分行为<br>对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。<br>对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</p><h3 id="2-5-什么时候用对象的适配器模式"><a href="#2-5-什么时候用对象的适配器模式" class="headerlink" title="2.5 什么时候用对象的适配器模式?"></a>2.5 什么时候用对象的适配器模式?</h3><p>①: 灵活使用时<br>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。<br>②: 需要同时配源类和其子类<br>对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了；</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结:"></a>2.6 总结:</h3><p>建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。</p><h2 id="三、主要作用"><a href="#三、主要作用" class="headerlink" title="三、主要作用:"></a>三、主要作用:</h2><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><h2 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点:"></a>三、优点:</h2><p>①: 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。<br>②: 解耦性:    将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码<br>③: 符合开放-关闭原则:  同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类<br>④: 更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。<br>⑤: 透明、简单:  客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接, 过多的使用适配器，会让系统非常零乱，不易整体进行把握</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景:"></a>四、应用场景:</h2><p>系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><h2 id="五、实例"><a href="#五、实例" class="headerlink" title="五、实例:"></a>五、实例:</h2><p>背景：小成买了一个进口的电视机<br>冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容<br>解决方案：设置一个适配器将插头输出的220V转变成110V</p><p><strong>使用类的适配器模式解题:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将220V转换输出110V（原有插头（Adaptee）没有的）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建源类（Adaptee）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerPort220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原有的插口只能输出220V</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OutPut_220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）</span></span><br><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter220V</span> <span class="keyword">extends</span> <span class="title">PowerPort220V</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//期待的插头要求调用Convert_110v()，但原有插头没有</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.OutPut_220V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="comment">//通过Adapter类从而调用所需要的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用户拿着进口机器插上适配器（调用Convert_110v()方法）</span></span><br><span class="line">        <span class="comment">//再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V）</span></span><br><span class="line">        <span class="comment">//适配器只是个外壳，对外提供110V，但本质还是220V进行供电</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter220V();</span><br><span class="line">        target.Convert_110V();</span><br><span class="line">        ImportMachine importMachine =  <span class="keyword">new</span> ImportMachine();</span><br><span class="line">        importMachine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进口机器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImportMachine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进口机器正常工作!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的适配器模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//源类Adapteree没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建源类（Adaptee） ；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapteree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）</span></span><br><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adapteree</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的</span></span><br><span class="line"><span class="comment">//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的适配器模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapteree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapteree adapteree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接关联被适配类Adapteree</span></span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adapteree adapteree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapteree = adapteree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里是使用委托的方式完成特殊功能</span></span><br><span class="line">        <span class="keyword">this</span>.adapteree.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adapteree());</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是适配器模式&quot;&gt;&lt;a href=&quot;#一、什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是适配器模式?&quot;&gt;&lt;/a&gt;一、什么是适配器模式?&lt;/h2&gt;&lt;p&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。&lt;br&gt;这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。&lt;br&gt;举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之适配器模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="https://zzwwqq.xyz/%E5%BA%94%E7%94%A8%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/应用层.html</id>
    <published>2019-04-02T03:06:32.000Z</published>
    <updated>2019-04-08T08:03:06.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、应用层协议"><a href="#一、应用层协议" class="headerlink" title="一、应用层协议:"></a>一、应用层协议:</h2><p>应用层的许多协议是基于客户服务器方式的</p><h3 id="1-1-DNS"><a href="#1-1-DNS" class="headerlink" title="1.1 DNS:"></a>1.1 DNS:</h3><p><strong>1.1.1 是什么? </strong><br>DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。<br><a id="more"></a></p><p><strong>1.1.2 作用:</strong><br>用于域名解析服务,将域名(机器名) 转换为 IP地址<br><strong>1.1.3 原理: </strong><br>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。<br>客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。<br><strong>1.1.4 特点:</strong><br><strong>基于UDP服务</strong>，该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。<strong>端口号53</strong><br>DNS 可以使用 UDP 或者 TCP 进行传输，大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性<br><strong>1.1.5 在两种情况下会使用 TCP 进行传输：</strong></p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h3 id="1-2-HTTP"><a href="#1-2-HTTP" class="headerlink" title="1.2 : HTTP:"></a>1.2 : HTTP:</h3><p><strong>1.2.1 是什么? </strong><br>这是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页<br><strong>1.2.2 特点: </strong><br>本身是<strong>无连接，无状态的</strong>,使用<strong>TCP</strong>连接进行可靠的传送</p><h3 id="1-3-FTP"><a href="#1-3-FTP" class="headerlink" title="1.3 : FTP:"></a>1.3 : FTP:</h3><p><strong>1.3.1 是什么? </strong><br>文件传输协议<br><strong>1.3.2 特点: </strong><br>提供交互式的访问 ,基于<strong>客户服务器模式</strong>，<strong>面向连接 </strong>,<strong>使用TCP</strong>可靠的运输服务 ,使用<strong>21端口</strong><br><strong>1.3.3 主要功能:</strong><br>减少/消除不同操作系统下文件的不兼容性 </p><p><strong>1.3.4 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</strong></p><ul><li>控制连接：服务器打开<strong>端口号 21</strong>等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。<strong>端口号20</strong></li></ul><p><strong>1.3.5 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</strong></p><ul><li><strong>主动模式：</strong>服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.3.png" alt></p><ul><li><strong>被动模式：</strong>客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.4.png" alt></p><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h3 id="1-4-简单文件传送协议TFTP"><a href="#1-4-简单文件传送协议TFTP" class="headerlink" title="1.4 : 简单文件传送协议TFTP:"></a>1.4 : 简单文件传送协议TFTP:</h3><p><strong>1.4.1 特点: </strong><br>客户服务器模式 ,使用UDP数据报 ,只支持文件传输，不支持交互 ,TFTP代码占内存小 </p><h3 id="1-5-TELNET"><a href="#1-5-TELNET" class="headerlink" title="1.5 : TELNET:"></a>1.5 : TELNET:</h3><p><strong>1.5.1 作用:</strong><br>用于远程登陆<br><strong>1.5.2 特点:</strong><br>客户服务器模式  <strong>使用23端口</strong>，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务,TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h3 id="1-6-简单网络管理协议（SNMP）"><a href="#1-6-简单网络管理协议（SNMP）" class="headerlink" title="1.6 : 简单网络管理协议（SNMP）:"></a>1.6 : 简单网络管理协议（SNMP）:</h3><p><strong>1.6.1 SNMP模型的4个组件：</strong><br>被管理结点、管理站、管理信息、管理协议<br><strong>1.6.2 SNMP代理：</strong><br>运行SNMP管理进程的被管理结点<br>对象：描述设备的变量<br>管理信息库（MIB）：保存所有对象的数据结构 </p><h3 id="1-7-DHCP"><a href="#1-7-DHCP" class="headerlink" title="1.7 : DHCP:"></a>1.7 : DHCP:</h3><p><strong>1.7.1 什么是DHCP?</strong></p><p>动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。<br>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。<br><strong>1.7.2 DHCP 工作过程如下：</strong></p><p>①: 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<br>②: DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。<br>③: 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。<br>④: DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.5.png" alt></p><h3 id="1-8-电子邮件协议"><a href="#1-8-电子邮件协议" class="headerlink" title="1.8 :电子邮件协议:"></a>1.8 :电子邮件协议:</h3><p>一个电子邮件系统由三部分组成：<br>用户代理、邮件服务器以及邮件协议。<br>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h3 id="1-8-1-SMTP"><a href="#1-8-1-SMTP" class="headerlink" title="1.8.1 : SMTP:"></a>1.8.1 : SMTP:</h3><p><strong>1.8.1.1 是什么? </strong><br>简单邮件传输协议<br><strong>1.8.1.2 作用: </strong><br>用于发送邮件。<br><strong>1.8.1.3 特点: </strong><br>Client/Server模式，面向连接 ,服务器开放的是<strong>25号端口。</strong>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。<br><strong>1.8.1.4 基本功能：</strong><br>写信、传送、报告传送情况、显示信件、接收方处理信件 </p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.7.png" alt></p><h3 id="1-8-2-POP3"><a href="#1-8-2-POP3" class="headerlink" title="1.8.2 : POP3:"></a>1.8.2 : POP3:</h3><p><strong>1.8.2.1 是什么? </strong><br>它是和SMTP对应<br><strong>1.8.2.2 作用: </strong><br>用于接收邮件<br><strong>1.8.2.3 特点: </strong><br>①: 只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。<br>②：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”。POP3协议所用的是<strong>110端口。</strong></p><h3 id="1-8-3-IMAP"><a href="#1-8-3-IMAP" class="headerlink" title="1.8.3 : IMAP:"></a>1.8.3 : IMAP:</h3><p><strong>1.8.3.1 作用: </strong><br>读取邮件<br><strong>1.8.3.2 特点: </strong><br>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.6.png" alt></p><h2 id="二、关于域名"><a href="#二、关于域名" class="headerlink" title="二、关于域名:"></a>二、关于域名:</h2><h3 id="2-1-域名规范"><a href="#2-1-域名规范" class="headerlink" title="2.1 域名规范:"></a>2.1 域名规范:</h3><p><strong>DNS规定:</strong><br>①: 域名中标号必须是英文或数字<br>②: 不区分大小写<br>③: 除连字符外不能用其他标点<br>④: 级别最低的域名写在最左边<br>⑤: 域名总长度不超过255个字符. </p><h3 id="2-2-域名分类"><a href="#2-2-域名分类" class="headerlink" title="2.2 域名分类:"></a>2.2 域名分类:</h3><p>顶级域名(TLD: TOP Level Domain):<br>①: 国家顶级域名:<br>　　　　　　　　cn代表中国 ,US代表美国<br>②:通用顶级域名:<br>　　　　　　　　com(公司,企业)<br>　　　　　　　　net(网络服务机构)<br>　　　　　　　　edu(教育机构)</p><p>mail.cctv.com: 其中com为一级域名(即顶级域名), cctv是二级域名,mail是三级域名.<br>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><h3 id="2-3-域名管理"><a href="#2-3-域名管理" class="headerlink" title="2.3 域名管理:"></a>2.3 域名管理:</h3><p>①: 在国家顶级域名下注册的二级域名均由该国家自由确定.<br>②: 各级域名由其上一级域名管理机构管理<br>③: 最高的顶级域名由ICANN管理<br><strong>注: 域名中的点与点分十进制IP地址中的点无一一对应的关系</strong></p><h3 id="2-4-为什么机器在处理IP数据报时要使用IP地址-而不用域名-机器名"><a href="#2-4-为什么机器在处理IP数据报时要使用IP地址-而不用域名-机器名" class="headerlink" title="2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?"></a>2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?</h3><p><strong>原因: </strong>IP地址长度固定(32位)而域名长度不固定,机器处理起来困难.</p><h2 id="三、关于域名服务器"><a href="#三、关于域名服务器" class="headerlink" title="三、关于域名服务器:"></a>三、关于域名服务器:</h2><p>一个域名服务器所负责管理的范围叫做<strong>区</strong>,每个区 设置相应的权限域名服务器<br>为了减轻根域名服务器的压力,域名服务器中广泛使用<strong>高速缓存.</strong></p><h3 id="3-1-域名服务器分类"><a href="#3-1-域名服务器分类" class="headerlink" title="3.1 域名服务器分类:"></a>3.1 域名服务器分类:</h3><p><strong>①: 根域名服务器: </strong><br>所有根域名服务器都知道所有顶级域名服务器的域名和IP地址<br><strong>②: 顶级域名服务器: </strong><br>管理在该顶级域名服务器下注册的所有二级域名,当收到查询请求,就给出查询结果,或者下一步应当找的域名服务器地址<br><strong>③: 权限域名服务器: </strong><br>负责一个区的域名服务器,当它不能给出最后的查询结果时,就告诉客户下一步应当查找哪个权限域名服务器<br><strong>④: 本地域名服务器: </strong><br>离用户较近,一般不超过几个路由器的距离</p><p><strong>迭代查询: </strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.1.png" alt></p><p><strong>递归查询:</strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.2.png" alt></p><h2 id="四、常用端口"><a href="#四、常用端口" class="headerlink" title="四、常用端口:"></a>四、常用端口:</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用</td><td>应用层协议</td><td>端口号</td><td>传输层协议</td><td>备注</td></tr><tr><td>域名解析</td><td><strong>DNS</strong></td><td>53</td><td>UDP/TCP</td><td>长度超过 512 字节时使用 TCP</td></tr><tr><td>动态主机配置协议</td><td>DHCP</td><td>67/68</td><td>UDP</td><td></td></tr><tr><td>简单网络管理协议</td><td>SNMP</td><td>161/162</td><td>UDP</td><td></td></tr><tr><td>文件传送协议</td><td><strong>FTP</strong></td><td>20/21</td><td>TCP</td><td>控制连接 21，数据连接 20</td></tr><tr><td>远程终端协议</td><td><strong>TELNET</strong></td><td>23</td><td>TCP</td><td></td></tr><tr><td>超文本传送协议</td><td>HTTP</td><td>80</td><td>TCP</td><td></td></tr><tr><td></td><td><strong>HTTPS</strong></td><td><strong>443</strong></td><td></td><td></td></tr><tr><td>简单邮件传送协议</td><td><strong>SMTP</strong></td><td>25</td><td>TCP</td><td></td></tr><tr><td>邮件读取协议</td><td><strong>POP3</strong></td><td>110</td><td>TCP</td><td></td></tr><tr><td>网际报文存取协议</td><td><strong>IMAP</strong></td><td>143</td><td>TCP</td></tr></tbody></table><h2 id="五、Web-页面请求过程"><a href="#五、Web-页面请求过程" class="headerlink" title="五、Web 页面请求过程:"></a>五、Web 页面请求过程:</h2><h3 id="5-1-DHCP-配置主机信息"><a href="#5-1-DHCP-配置主机信息" class="headerlink" title="5.1 DHCP 配置主机信息:"></a>5.1 DHCP 配置主机信息:</h3><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。<br>①: <strong>主机生成一个 DHCP 请求报文</strong>，并将这个报文<strong>放入</strong>具有目的端口 67 和源端口 68 的 <strong>UDP 报文段</strong>中。<br>②: 该报文段则被放入在一个具有<strong>广播 IP</strong> 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 <strong>IP 数据报</strong>中。<br>③: 该数据报则被放置在<strong>MAC 帧</strong>中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。<br>④: 连接在交换机的 DHCP 服务器收到广播帧之后，<strong>不断地向上分解</strong>得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。<br>⑤: 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。<br>⑥: 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p><h3 id="5-2-ARP-解析-MAC-地址"><a href="#5-2-ARP-解析-MAC-地址" class="headerlink" title="5.2 ARP 解析 MAC 地址"></a>5.2 ARP 解析 MAC 地址</h3><p>①: 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。<br>②: 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。<br>③: 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中<br>④: 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。<br>⑤: DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。<br>⑥: 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。<br>⑦: 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p><h3 id="5-3-DNS-解析域名"><a href="#5-3-DNS-解析域名" class="headerlink" title="5.3 DNS 解析域名:"></a>5.3 DNS 解析域名:</h3><p>①: 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。<br>②: 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。<br>③: 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。<br>④: 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。<br>⑤: 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p><h3 id="5-4-HTTP-请求页面"><a href="#5-4-HTTP-请求页面" class="headerlink" title="5.4  HTTP 请求页面:"></a>5.4  HTTP 请求页面:</h3><p>①: 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。<br>②: 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。<br>③: HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。<br>④: 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。<br>⑤: HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。<br>⑥: 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p><h2 id="六、应用层功能"><a href="#六、应用层功能" class="headerlink" title="六、应用层功能:"></a>六、应用层功能:</h2><p>负责对软件提供接口以使程序能使用网络服务</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、应用层协议&quot;&gt;&lt;a href=&quot;#一、应用层协议&quot; class=&quot;headerlink&quot; title=&quot;一、应用层协议:&quot;&gt;&lt;/a&gt;一、应用层协议:&lt;/h2&gt;&lt;p&gt;应用层的许多协议是基于客户服务器方式的&lt;/p&gt;
&lt;h3 id=&quot;1-1-DNS&quot;&gt;&lt;a href=&quot;#1-1-DNS&quot; class=&quot;headerlink&quot; title=&quot;1.1 DNS:&quot;&gt;&lt;/a&gt;1.1 DNS:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.1.1 是什么? &lt;/strong&gt;&lt;br&gt;DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="应用层" scheme="https://zzwwqq.xyz/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="https://zzwwqq.xyz/%E4%BC%A0%E8%BE%93%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/传输层.html</id>
    <published>2019-04-01T13:08:40.000Z</published>
    <updated>2019-04-08T08:05:33.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传输层协议"><a href="#一、传输层协议" class="headerlink" title="一、传输层协议:"></a>一、传输层协议:</h2><p>TCP协议,UDP协议,SPX协议</p><h3 id="10-1-关于TCP协议"><a href="#10-1-关于TCP协议" class="headerlink" title="10.1 关于TCP协议:"></a>10.1 关于TCP协议:</h3><p><strong>特点:</strong><br>①: 面向连接<br>②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点</p><p><strong>使用场合: </strong>一般用于传输数据量少,且对可靠性要求高的场合.</p><a id="more"></a><p><strong>注: 这2个端点并不是主机,也不是主机的IP地址,不是应用进程,也不是运输层协议端口, 而是指 套接字 </strong><br>③: 提供可靠交付服务: 无差错 ,  不丢失  ,   不重复  ,  按序到达<br>④: 全双工<br>⑤: 拥塞控制,流量控制<br>⑥: 检错, 分用复用<br>⑦: 面向字节流: (把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)<br>套接字socket = IP地址  ：端口号</p><h3 id="10-2-使用TCP协议的各种应用层协议："><a href="#10-2-使用TCP协议的各种应用层协议：" class="headerlink" title="10.2 使用TCP协议的各种应用层协议："></a>10.2 使用TCP协议的各种应用层协议：</h3><p>SMTP: 简单邮件传送协议<br>TELNET: 远程终端协议<br>HTTP: 超文本传输协议<br>FTP: 文件传送协议</p><h3 id="10-3-TCP首部格式"><a href="#10-3-TCP首部格式" class="headerlink" title="10.3 TCP首部格式:"></a>10.3 TCP首部格式:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.2.png" alt></p><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="10-4-关于UDP协议"><a href="#10-4-关于UDP协议" class="headerlink" title="10.4 关于UDP协议:"></a>10.4 关于UDP协议:</h3><p><strong>特点:</strong></p><p>①: 无连接: 发数据前不需要建立连接(即不需要使用套接字(即 IP: 端口号)来建立连接)<br>②: 交互通信: 一对多,一对一,多对一,多对多等<br>③: 尽最大努力交付(不可靠)<br>④: 首部开销小,8字节  而TCP是20字节<br>⑤: 无拥塞控制<br>⑥: 检错, 分用复用<br>⑦: 面向报文: UDP一次交付一个完整报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)</p><h3 id="10-5-UDP首部格式"><a href="#10-5-UDP首部格式" class="headerlink" title="10.5 UDP首部格式:"></a>10.5 UDP首部格式:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.1.png" alt></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><p><strong>使用场合: </strong>一般用于传输数据量大,且对可靠性要求不是很高,但要求速度快的场合.</p><h2 id="二、传输层数据单元"><a href="#二、传输层数据单元" class="headerlink" title="二、传输层数据单元:"></a>二、传输层数据单元:</h2><p>数据段</p><h2 id="三、关于端口"><a href="#三、关于端口" class="headerlink" title="三、关于端口:"></a>三、关于端口:</h2><p>运输层用16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口</p><h2 id="四、传输层功能"><a href="#四、传输层功能" class="headerlink" title="四、传输层功能:"></a>四、传输层功能:</h2><p>①: 负责源-目的（端-端）（进程间）完整报文传输<br>②: 分段与重组<br>③: SAP寻址: 确保将完整报文提交给正确进程，如端口号<br>④: 连接控制<br>⑤: 流量控制<br>⑥: 差错控制<br>⑦: 确保数据可靠,顺序,无错地从A点传输到B点</p><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="五、TCP-可靠传输"><a href="#五、TCP-可靠传输" class="headerlink" title="五、TCP 可靠传输:"></a>五、TCP 可靠传输:</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.3.png" alt></p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.4.png" alt></p><p>其中 RTTd 为偏差的加权平均值。</p><h2 id="六、TCP-滑动窗口"><a href="#六、TCP-滑动窗口" class="headerlink" title="六、TCP 滑动窗口:"></a>六、TCP 滑动窗口:</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.5.png" alt></p><h2 id="七、TCP-流量控制"><a href="#七、TCP-流量控制" class="headerlink" title="七、TCP 流量控制:"></a>七、TCP 流量控制:</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="八、TCP-拥塞控制"><a href="#八、TCP-拥塞控制" class="headerlink" title="八、TCP 拥塞控制:"></a>八、TCP 拥塞控制:</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br>拥塞窗口的大小取决于网络的拥塞程度<br>判断网络拥塞的依据是出现了超时.<br>发送方的发送窗口 =  拥塞窗口.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.8.png" alt></p><p><strong>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</strong></p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.6.png" alt></p><h3 id="8-1-慢开始与拥塞避免"><a href="#8-1-慢开始与拥塞避免" class="headerlink" title="8.1 慢开始与拥塞避免"></a>8.1 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="8-2-快重传与快恢复"><a href="#8-2-快重传与快恢复" class="headerlink" title="8.2. 快重传与快恢复"></a>8.2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.7.png" alt></p><p><strong>拥塞控制的具体流程: </strong></p><p>①: 初始拥塞窗口 cwnd  =  1</p><p>②: 发送方每收到一个确认就使cwnd = cwnd + 1;如果按照传输轮次考虑就是指数增长: 第一轮: cwnd =  1, 第二轮: cwnd =  2, 第三轮: cwnd =  4, …….第N轮: cwnd =  2^N</p><p>cwnd &lt; ssthresh 时,使用慢开始</p><p>cwnd = ssthresh 时,既可以使用慢开始,也可以使用拥塞避免算法</p><p>cwnd &gt;= ssthresh 时,使用拥塞避免算法</p><p>③: 网络超时时: 使ssthresh = cwnd / 2<br>然后令 cwnd = 1 </p><p>然后进入慢开始阶段,步骤同上<br>④: 直到连续接收到三个重复确认,启动快重传(立即重传) </p><p>⑤: 启动快恢复算法 ssthresh = cwnd / 2</p><p>和cwnd=ssthresh</p><p>拥塞避免: 拥塞窗口控制为按照线性增长(每个传输轮次结束时,cwnd就增加1)</p><p><strong>快重传优点: </strong></p><p>可以使整个网络的吞吐量提高20%<br>尽早让发送方知道发生了个别报文段的丢失</p><p>规定: 发送方只要一连收到3个重复确认,就知道接收方确实未收到某个报文,应当立即重传(即快重传),这样就不会出现超时,发送方也就不会误认为出现了网络拥塞.</p><p><strong>快恢复: </strong><br>调整ssthresh = cwnd / 2<br>同时设置cwnd = ssthresh;<br>然后执行拥塞避免.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、传输层协议&quot;&gt;&lt;a href=&quot;#一、传输层协议&quot; class=&quot;headerlink&quot; title=&quot;一、传输层协议:&quot;&gt;&lt;/a&gt;一、传输层协议:&lt;/h2&gt;&lt;p&gt;TCP协议,UDP协议,SPX协议&lt;/p&gt;
&lt;h3 id=&quot;10-1-关于TCP协议&quot;&gt;&lt;a href=&quot;#10-1-关于TCP协议&quot; class=&quot;headerlink&quot; title=&quot;10.1 关于TCP协议:&quot;&gt;&lt;/a&gt;10.1 关于TCP协议:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt;&lt;br&gt;①: 面向连接&lt;br&gt;②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场合: &lt;/strong&gt;一般用于传输数据量少,且对可靠性要求高的场合.&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="传输层" scheme="https://zzwwqq.xyz/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>交换机的基本配置</title>
    <link href="https://zzwwqq.xyz/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html"/>
    <id>https://zzwwqq.xyz/交换机的基本配置.html</id>
    <published>2019-04-01T11:05:44.000Z</published>
    <updated>2019-04-01T11:24:00.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、交换机的基本配置与管理："><a href="#一、交换机的基本配置与管理：" class="headerlink" title="一、交换机的基本配置与管理："></a>一、交换机的基本配置与管理：</h2><h3 id="10-1-交换机的管理方式："><a href="#10-1-交换机的管理方式：" class="headerlink" title="10.1 交换机的管理方式："></a>10.1 交换机的管理方式：</h3><p>基本分为两种: 带内管理和带外管理。<br><strong>带外管理: </strong>通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置<br><strong>带内管理: </strong>通过远程Telnet，拨号等方式属于带内管理<br><a id="more"></a></p><h2 id="二、交换机的命令行操作模式分类："><a href="#二、交换机的命令行操作模式分类：" class="headerlink" title="二、交换机的命令行操作模式分类："></a>二、交换机的命令行操作模式分类：</h2><p>①: 用户模式:  <code>Switch&gt;</code><br>②: 特权模式: <code>Switch#</code><br>③: 全局配置模式: <code>Switch(config)#</code><br>④: 端口模式: <code>Switch(config-if)#</code></p><h2 id="三、交换机命令行"><a href="#三、交换机命令行" class="headerlink" title="三、交换机命令行:"></a>三、交换机命令行:</h2><p>进入特权模式: <code>en</code><br>命令自动补齐: <code>Tab</code><br>进入全局配置模式: <code>configure terminal</code><br>命令简写：<code>conf  t</code><br>进入交换机端口视图模式: <code>int f 0/1</code><br>返回上一级操作模式: <code>exit</code><br>从全局以下级别直接返回到特权模式: <code>end</code><br>帮助信息: <code>？，co?  ,copy ?</code><br>修改交换机名称: <code>hostname  X</code><br>配置交换机端口参数: <code>speed，duplex</code><br>查看交换机版本信息: <code>show  version</code><br>查看当前生效的配置信息: <code>show run</code></p><h2 id="四、换机的Telnet远程登录配置"><a href="#四、换机的Telnet远程登录配置" class="headerlink" title="四、换机的Telnet远程登录配置:"></a>四、换机的Telnet远程登录配置:</h2><ol><li>新建packet tracer 拓扑图</li><li>配置交换机管理IP地址</li></ol><p>　　　　switch&gt; <code>enable 回车</code></p><p>　　　　switch#<code>configuration terminal 回车</code></p><p>　　　　switch（config）#<code>interface vlan 1 回车</code></p><p>　　　　默认情况下交换机所有端口都处于VLAN1中</p><p>　　　　switch(config-if) <code>ip address xxxx.xxxx.xxxx.xxxx  回车</code></p><p>　　　　switch(config-if) <code>no shutdown  回车</code></p><p>　　　　开启interface vlan 1的工作状态</p><p>　　　　switch(config-if)# <code>exit</code></p><p>　　　　返回上一级</p><ol start="3"><li>配置用户登录密码</li></ol><p>　　　　Switch(config)# <code>enable password xxxx</code></p><p>　　　　设置进入特权模式的密码</p><p>　　　　Switch(config)# <code>line vty 0 4</code></p><p>　　　　Switch(config-line)# <code>password xxxxxxx</code></p><p>　　　　设置远程登录密码</p><p>　　　　Switch(config-line)# <code>end</code></p><p>　　　　Switch# <code>show run</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、交换机的基本配置与管理：&quot;&gt;&lt;a href=&quot;#一、交换机的基本配置与管理：&quot; class=&quot;headerlink&quot; title=&quot;一、交换机的基本配置与管理：&quot;&gt;&lt;/a&gt;一、交换机的基本配置与管理：&lt;/h2&gt;&lt;h3 id=&quot;10-1-交换机的管理方式：&quot;&gt;&lt;a href=&quot;#10-1-交换机的管理方式：&quot; class=&quot;headerlink&quot; title=&quot;10.1 交换机的管理方式：&quot;&gt;&lt;/a&gt;10.1 交换机的管理方式：&lt;/h3&gt;&lt;p&gt;基本分为两种: 带内管理和带外管理。&lt;br&gt;&lt;strong&gt;带外管理: &lt;/strong&gt;通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置&lt;br&gt;&lt;strong&gt;带内管理: &lt;/strong&gt;通过远程Telnet，拨号等方式属于带内管理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="交换机的配置" scheme="https://zzwwqq.xyz/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://zzwwqq.xyz/%E7%BD%91%E7%BB%9C%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/网络层.html</id>
    <published>2019-04-01T05:36:50.000Z</published>
    <updated>2019-04-08T07:56:38.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网络层协议"><a href="#一、网络层协议" class="headerlink" title="一、网络层协议:"></a>一、网络层协议:</h2><h3 id="1-1-什么是协议（protocol）"><a href="#1-1-什么是协议（protocol）" class="headerlink" title="1.1 什么是协议（protocol）?"></a>1.1 什么是协议（protocol）?</h3><p>通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”.</p><h3 id="1-2-什么是实体（entity）"><a href="#1-2-什么是实体（entity）" class="headerlink" title="1.2 什么是实体（entity）?"></a>1.2 什么是实体（entity）?</h3><p>表示任何可发送或接收消息的硬件或软件进程<br><a id="more"></a></p><h3 id="1-3-通信协议的三要素："><a href="#1-3-通信协议的三要素：" class="headerlink" title="1.3 通信协议的三要素："></a>1.3 通信协议的三要素：</h3><p>语法,语义,时序<br><strong>语义 :</strong><br>语义是指对协议中各协议元素的含义的解释，例如：在HDLC协议中，标志Flag(7EH)表示报文的开始和结束；在BSC协议中，SOH(01H)表示报文的开始，STX(02H)表示报文正文的开始，ETX(03H)表示报文正文的结束。<br><strong>语法 :</strong><br>语法是指协议元素与数据的组合格式，也就是 报文格式，如下图所示：<br><strong>时序 :</strong><br>时序是指在通信过程中，通信双方操作的执行顺序与规则，如本节开头的图示。<br><strong>总的来说，语法是语义的载体，而时序又是对语义的有序组织。正是基于这种关系，计算机在通信时才得以保持高度默契。</strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.1.png" alt></p><h3 id="1-4-通信模型"><a href="#1-4-通信模型" class="headerlink" title="1.4 通信模型:"></a>1.4 通信模型:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.2.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.3.png" alt></p><p>我们在网络中的任何一个系统都是按照上图中的层次结构模型来组织的，该模型具有以下特点：<br>①: 同一网络中，任意两个端系统必须具有相同的层次；<br>②: 每层使用其下层提供的服务，并向其上层提供服务；<br>③: 通信只在对等层间进行，当然这里所指的通信是间接的、逻辑的、虚拟的，非对等层之间不能互相“通信”；<br>④: 实际的物理通信只在最底层完成；<br>⑤: Pn代表第n层的协议，即第n层对等实体间通信时必须遵循的规则或约定。</p><h3 id="1-5-网络层有哪些协议"><a href="#1-5-网络层有哪些协议" class="headerlink" title="1.5 网络层有哪些协议?"></a>1.5 网络层有哪些协议?</h3><p><strong>①: IP协议: </strong>这种<strong>不可靠的、无连接的</strong>传送机制称为Internet协议(网际协议)<br>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protcol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><p><strong>IP协议三个定义：</strong></p><p>IP定义了在TCP/IP互联网上数据传送的基本单元和数据格式。<br>IP软件完成路由选择功能，选择数据传送的路径。<br>IP包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</p><p><strong>②: ICMP协议: </strong><br>网际控制报文协议<br>作用：用于在IP主机、路由器之间传递控制消息,更有效的转发IP数据报和提高交付成功的机会,<br>应用: ICMP的一个重要应用就是分组网间探测PING（Package Internet Grouper）用来测试两台主机的连通性,,Ping是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP<br>详解见下文</p><p><strong>③: IGMP:</strong><br>网际组管理协议</p><p><strong>④: ARP协议:</strong><br>地址解析协议<br>自动把IP地址解析为数据链路层所需要的硬件地址(MAC地址)<br><strong>IP —–&gt;MAC 地址</strong><br><strong>工作原理:</strong></p><ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li><li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据,如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></li></ol><p><strong>广播发送ARP请求，单播发送ARP响应。</strong></p><p><strong>⑤: RARP协议:</strong><br>逆地址解析协议, 与ARP相反:<br><strong>MAC地址——&gt;IP地址</strong><br><strong>作用: </strong> 是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。<br><strong>工作流程：</strong>在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP 地址装入响应报文中发回给请求者。<br>因为需要广播请求报文，因此<strong>RARP只能用于具有广播能力的网络。</strong></p><p><strong>⑥: RIP协议:</strong><br>内部网关协议<br>基于距离向量的路由选择协议, 距离是指跳数，直接相连的路由器跳数为 1,跳数最多为 15(即允许一条路径最多包含15个路由器)，超过 15 表示不可达。<br>可见<strong>RIP只适用于小型互联网</strong></p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p><strong>距离向量算法：</strong></p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p><strong>优点:</strong><br>实现简单，开销小。<br><strong>缺点:</strong><br>①: RIP 能使用的最大距离为 15，限制了网络的规模。<br>②: 并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。<br>③: 路由器间交换的信息是完整的路由表,随着网络规模的增大,开销也增大.</p><p><strong>⑦: OSPF协议: </strong></p><p>开放最短路径优先 OSPF，是为了<strong>克服 RIP 的缺点</strong>而开发出来的。<br>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。<br>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示,  而RIP只包含距离,和下一跳路由器地址.</li><li>只有当链路状态发生变化时，路由器才会发送信息, 而 RIP不管有无变化,总是定期更新.</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，<strong>OSPF 的更新过程收敛的很快</strong>。</p><p><strong>⑧: BGP：外部网关协议</strong>:</p><p>BGP（Border Gateway Protocol，边界网关协议）</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.23.png" alt></p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。<br>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</p><h3 id="1-6-网络层特点"><a href="#1-6-网络层特点" class="headerlink" title="1.6 网络层特点:"></a>1.6 网络层特点:</h3><p>向上只提供 :<br>①:  无连接的<br>②: 尽最大努力交付<br>③: 不提供服务质量的保证(不保证分组交付的时限,所传送的分组有可能出错丢失,重复失序)<br>⑤: 进程间通信可靠性由传输层负责</p><h2 id="二、网络层设备"><a href="#二、网络层设备" class="headerlink" title="二、网络层设备:"></a>二、网络层设备:</h2><p>①: 路由器</p><h2 id="三、网络层基本单元"><a href="#三、网络层基本单元" class="headerlink" title="三、网络层基本单元:"></a>三、网络层基本单元:</h2><h3 id="3-1-什么是协议数据单元"><a href="#3-1-什么是协议数据单元" class="headerlink" title="3.1 什么是协议数据单元?"></a>3.1 什么是协议数据单元?</h3><p>协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。 </p><h3 id="3-2-每一层协议数据单元分别是什么"><a href="#3-2-每一层协议数据单元分别是什么" class="headerlink" title="3.2 每一层协议数据单元分别是什么?"></a>3.2 每一层协议数据单元分别是什么?</h3><p>从下层到上层:<br>物理层的 PDU是数据位,又称<strong>比特</strong>（bit），<br>数据链路层的 PDU是数据帧,又称<strong>帧</strong>（frame），<br>网络层的PDU是数据包又称<strong>IP数据报</strong>（packet/datagram），<br>传输层的 PDU是<strong>数据段</strong>（segment），在报文中加一个运输层的头<br>其他更高层次(即会话层,表现层,应用层)的PDU是<strong>报文</strong>（message）。</p><p>从下层往上层是拆封.<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.4.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.5.1.png" alt></p><h2 id="四、网络层功能"><a href="#四、网络层功能" class="headerlink" title="四、网络层功能:"></a>四、网络层功能:</h2><p>①: 负责源主机到目的主机数据分组（Packet）交付(可能穿越多个网络)逻辑寻址（Logical  addressing ）<br>②: 全局唯一的逻辑地址，确保数据分组被送到目的主机，如IP地址<br>③: 路由（Routing）:<br>路由器（或网关）互连网络，并路由分组至最终目的主机<br>路径选择<br>④: 分组转发<br>⑤: 网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>⑥: 将网络地址(例如IP地址)翻译为对应的物理地址(例如,网卡地址),并决定如何将数据从发送方路由到接收方</p><h3 id="4-1-核心功能"><a href="#4-1-核心功能" class="headerlink" title="4.1 核心功能:"></a>4.1 核心功能:</h3><p>分组转发 与 路由选择（forwarding)</p><h3 id="4-1-什么是转发"><a href="#4-1-什么是转发" class="headerlink" title="4.1 什么是转发?"></a>4.1 什么是转发?</h3><p>将分组从路由器的输入端口转移到合适的输出端口<br>转发表确定在本路由器如何转发分组</p><h3 id="4-2-转发表是怎么得到的呢？"><a href="#4-2-转发表是怎么得到的呢？" class="headerlink" title="4.2 转发表是怎么得到的呢？"></a>4.2 转发表是怎么得到的呢？</h3><p>路由算法（协议）确定通过网络的端到端路径</p><h3 id="4-3-什么叫路由呢？"><a href="#4-3-什么叫路由呢？" class="headerlink" title="4.3 什么叫路由呢？"></a>4.3 什么叫路由呢？</h3><p>路由（routing）：确定分组从源到目的经过的路径</p><h2 id="五、网络层任务"><a href="#五、网络层任务" class="headerlink" title="五、网络层任务:"></a>五、网络层任务:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.6.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.8.png" alt></p><h2 id="六、为什么需要数据封装"><a href="#六、为什么需要数据封装" class="headerlink" title="六、为什么需要数据封装?"></a>六、为什么需要数据封装?</h2><p>增加控制信息—构造协议数据单元（PDU—protocol  Data  Unit）<br>控制信息主要包括：<br>地址：标志发送端/接收端<br>差错检测编码（error-detecting code）：用于差错检测或纠正<br>协议控制（Protocol  control）：实现协议功能的附加信息，如优先级（priority），服务质量（QoS）和安全控制等<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.7.png" alt></p><h2 id="七、IP-数据报格式"><a href="#七、IP-数据报格式" class="headerlink" title="七、IP 数据报格式:"></a>七、IP 数据报格式:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.9.png" alt></p><p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p><p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p><p><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</p><p><strong>总长度</strong> : 包括首部长度和数据部分长度</p><p><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p><p><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p><p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.10.png" alt></p><h2 id="八、地址解析协议-ARP"><a href="#八、地址解析协议-ARP" class="headerlink" title="八、地址解析协议 ARP:"></a>八、地址解析协议 ARP:</h2><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.11.png" alt></p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.12.png" alt></p><h2 id="九、网际控制报文协议-ICMP"><a href="#九、网际控制报文协议-ICMP" class="headerlink" title="九、网际控制报文协议 ICMP:"></a>九、网际控制报文协议 ICMP:</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.13.png" alt></p><p>ICMP 报文分为差错报告报文和询问报文。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.14.png" alt></p><h3 id="9-1-ICMP协议的应用"><a href="#9-1-ICMP协议的应用" class="headerlink" title="9.1 ICMP协议的应用:"></a>9.1 ICMP协议的应用:</h3><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>Ping 是 ICMP 的一个重要应用，主要用来<strong>测试两台主机之间的连通性</strong>。<br><strong>Ping 的原理: </strong></p><p>是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute:"></a>Traceroute:</h4><p>用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。<br><strong>Traceroute的工作原理: </strong></p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="十、IP-地址编址方式"><a href="#十、IP-地址编址方式" class="headerlink" title="十、IP 地址编址方式:"></a>十、IP 地址编址方式:</h2><h3 id="10-1-IP-地址的编址方式经历了三个历史阶段："><a href="#10-1-IP-地址的编址方式经历了三个历史阶段：" class="headerlink" title="10.1 IP 地址的编址方式经历了三个历史阶段："></a>10.1 IP 地址的编址方式经历了三个历史阶段：</h3><p>①: 分类<br>②: 子网划分<br>③: 无分类</p><p><strong>分类: </strong><br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>网络号:用于识别主机所在的网络；<br>主机号: 用于识别该网络中的主机<br>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.15.png" alt></p><p><strong>IP地址分为五类，</strong>A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。</p><table><thead><tr><th>IP地址类别:</th><th>高八位</th><th>占总IP地址数的比例:</th></tr></thead><tbody><tr><td>A类：前一位固定为0</td><td>第一个八位的范围是0-127<br>目的: 保证了最小为0,最大为127  即255(全一)-128(最高位为1,其他为0)=127</td><td>(127-0+1）/ 256=50%</td></tr><tr><td>B类：前两位固定为10</td><td>第一个八位的范围是：128-191<br>前两位固定为10的目的是：为了让前八位表示的数最小为128</td><td>(191-128+1) / 256=25%</td></tr><tr><td>C类：前三位固定为110</td><td>第一个八位的范围是：192-223<br>前两位固定为110的目的是：保证最小192</td><td>(223-192+1) / 256=12.5%</td></tr><tr><td>D类：前四位固定为1110     不分网络地址和主机地址</td><td>第一个八位的范围是：224-239</td><td>(239-224+1) / 256=6.25%</td></tr><tr><td>E类：前四位固定为1111   不区分网络地址和主机地址</td><td>第一个八位的范围是：240-255</td><td>(255-240+1) / 256=6.25%</td></tr></tbody></table><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.19.png" alt>　</p><p><strong>A类地址:</strong><br>1）A类地址第1字节为网络地址，其它3个字节为主机地址。它的第1个字节的第一位固定为0，因此只有7位可供使用.<br>可指派的网络号为126个（即2^7-2=126），<br><strong>减2 的原因：</strong><br>第一：   IP地址中的<strong>全0表示“这个（或者本）</strong>”，<strong>全1表示所有的</strong>。      网络号字段全0   的IP地址是个保留地址， 意思是本网络<br>第二：   网络号为127（即01111111）保留作为本地软件环回测试（loop back test）本主机的进程之间的通信之用。<br>2）A类地址可指派网络号范围：1—126<br>3）<strong>A类地址中的私有地址和保留地址：</strong><br>① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址),且<br>范围是（10.0.0.0—10.255.255.255）<br>② 127.X.X.X是保留地址，用做循环测试用的。<br>A类地址主机号占三个字节，因此每个A类网络中最大主机数： 2^24-2=16777214<br><strong>这里减2 的原因：</strong>   全0的主机号字段，  表示该IP地址 是”本主机“所连结到的单个网络地址，（例如： 一主机的IP地址为5.6.7.8 ，则该主机所在的网络地址就是5.0.0.0）， 而全1表示”所有的“  ，因此主机号全1表示该网络上的所有主机，<br>4）IP地址空间共2^32 个地址，整个A类地址2^31,占整个IP地址空间的50%. </p><p>关于全0全1 还可以再举两个例子：<br>例如：  B类地址： 128.7.255.255 表示在网络128.7.0.0 上的所有主机，  而A类地址0.0.0.35 则表示  在这个网络上主机号为35 的主机；</p><p><strong>B类地址:</strong></p><p>B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。它的第1个字节的前两位固定为10，只剩下16-2=14位可以分配， </p><p>因为网络号字段后面的14位无论取什么值， 也不可能出现使整个2字节的网络号字段成为全0或全1， 所以这里就不存在网络总数减2的问题。</p><p>但是实际上B类网络地址的128.0.0.0 是不指派的，而可以指派的B类最小网络地址是128.1.0.0   ，   因此B类地址可指派的网络数为  2^14-1=16383.</p><p>B 类地址的每个网络上的最大主机数2^16-2=65534<br>这里减2 的原因：   要扣除主机号全0全1的。  （全0表示该IP地址 是”本主机“所连结到的单个网络地址，全1 作为广播地址）<br>整个B类地址空间2^30, 占整个IP地址空间的25%.</p><p>2） B类地址可指派网络号范围：128.1—191.255。  </p><p>3） B类地址的私有地址和保留地址</p><p>① 172.16.0.0—172.31.255.255是私有地址</p><p>② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</p><p>191.255.255.255是广播地址，不能分配。</p><p><strong>C类地址</strong></p><p>1）C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110,   还有21位可以分配，C类网络地址192.0.0.0也是不分配的， 可以指派的C类最小网络地址192.0.1.0，因此C类  地址可指派的网络总数 ， 2^21-1=2097151 ,   每一个C类网络地址的最大主机数2^8-2=254, 整个C类地址空间2^29 个地址，占整个IP地址空间的12.5%。</p><p>2）C类地址网络号范围：192.0.1—223.255.255。</p><p>3） C类地址中的私有地址：</p><p>192.168.X.X是私有地址。（192.168.0.0—192.168.255.255)</p><h3 id="10-2-特殊IP地址："><a href="#10-2-特殊IP地址：" class="headerlink" title="10.2 特殊IP地址："></a>10.2 特殊IP地址：</h3><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.16.png" alt>　</p><h3 id="10-3-私有（Private）IP地址"><a href="#10-3-私有（Private）IP地址" class="headerlink" title="10.3 私有（Private）IP地址:"></a>10.3 私有（Private）IP地址:</h3><p><strong>实体IP:</strong><br>在网络的世界里，为了要辨识每一部计算机的位置，因此有了计算机 IP 位址的定义。一个 IP 就好似一个门牌！例如，你要去微软的网站的话，就要去『 64.4.11.42 』这个 IP 位置！这些可以直接在网际网络上沟通的 IP 就被称为『实体 IP 』了。</p><p><strong>虚拟IP:</strong><br>不过，众所皆知的，IP 位址仅为 xxx.xxx.xxx.xxx 的资料型态，其中， xxx 为 1-255 间的整数，由于计算机的成长速度太快，实体的 IP 已经有点不足了，好在早在规划 IP 时就已经预留了三个网段的 IP 做为内部网域的虚拟 IP 之用。这三个预留的 IP 分别为：<br>除去主机段全零/全一:</p><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.17.png" alt></p><p>由于是虚拟 IP ，所以当您使用这些地址的时候﹐当然是有所限制的，限制如下：<br>私有位址的路由信息不能对外散播<br>使用私有位址作为来源或目的地址的封包﹐不能透过Internet来转送<br>关于私有位址的参考纪录（如DNS）﹐只能限于内部网络使用</p><p>由于虚拟 IP 的计算机并不能直接连上 Internet ，因此需要特别的功能才能上网。不过，这给我们架设IP网络提供了很大的方便﹐比如﹕您的公司还没有连上Internet﹐但这不保证将来不会。使用公共IP的话﹐如果没经过注册﹐在以后真正连上网络的时候﹐就很可能和别人冲突了。也正如前面所分析的﹐到时候再重新规划IP的话﹐将是件非常头痛的问题。这时候﹐我们可以先利用私有位址来架设网络﹐等到真要连上internet的时候﹐我们可以使用IP转换协定﹐如 NAT (Network Addresss Translation)等技术﹐配合新注册的IP就可以了。</p><h3 id="10-4-组播地址"><a href="#10-4-组播地址" class="headerlink" title="10.4 组播地址"></a>10.4 组播地址</h3><p>注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机， 224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP（Internet路由发现协议，使用组播功能）功能，那么你的主机路由表中应该有这样一条路由: 169.254.x.x</p><p>如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Windows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</p><h3 id="10-5-受限广播地址"><a href="#10-5-受限广播地址" class="headerlink" title="10.5 受限广播地址"></a>10.5 受限广播地址</h3><p>广播通信是<strong>一个主机对所有主机</strong>的通信方式。若一个IP地址的2进制数全为1，也就是255.255.255.255，则这个地址用于定义整个互联网。如果设备想使IP数据报被整个Internet所接收，就发送这个目的地址全为1的广播包，但这样会给整个互联网带来灾难性的负担。因此网络上的所有路由器都阻止具有这种类型的分组被转发出去，使这样的广播仅限于本地网段。</p><h3 id="10-6-直接广播地址"><a href="#10-6-直接广播地址" class="headerlink" title="10.6 直接广播地址"></a>10.6 直接广播地址</h3><p>一个网络中的最后一个地址为直接广播地址，也就是HostID全为1的地址。主机使用这种地址把一个IP数据报发送到本地网段的所有设备上，路由器会转发这种数据报到特定网络上的所有主机。<br><strong>注意：这个地址在IP数据报中只能作为目的地址。另外，直接广播地址使一个网段中可分配给设备的地址数减少了1个。</strong></p><h3 id="10-7-源IP地址"><a href="#10-7-源IP地址" class="headerlink" title="10.7 源IP地址:"></a>10.7 源IP地址:</h3><p>若IP地址全为0，也就是0.0.0.0，则这个IP地址在IP数据报中只能用作源IP地址，这发生在当设备启动时但又不知道自己的IP地址情况下。在使用DHCP分配IP地址的网络环境中，这样的地址是很常见的。用户主机为了获得一个可用的IP地址，就给DHCP服务器发送IP分组，并用这样的地址作为源地址，目的地址为255.255.255.255（因为主机这时还不知道DHCP服务器的IP地址）。</p><h3 id="10-8-环回地址"><a href="#10-8-环回地址" class="headerlink" title="10.8 环回地址:"></a>10.8 环回地址:</h3><p>127网段的所有地址都称为环回地址，主要用来测试网络协议是否工作正常的作用。比如使用ping.<br>127.0.0.1就可以测试本地TCP/IP协议是否已正确安装。另外一个用途是当客户进程用环回地址发送报文给位于同一台机器上的服务器进程，比如在浏览器里输入127.1.2.3，这样可以在排除网络路由的情况下用来测试IIS是否正常启动。</p><h3 id="10-9-NetID为0的地址"><a href="#10-9-NetID为0的地址" class="headerlink" title="10.9 NetID为0的地址:"></a>10.9 NetID为0的地址:</h3><p>当某个主机向同一网段上的其他主机发送报文时就可以使用这样的地址，分组也不会被路由器转发。比如12.12.12.0/24这个网络中的一台主机12.12.12.2/24在与同一网络中的另一台主机12.12.12.8/24通信时，目的地址可以是0.0.0.8。</p><h3 id="10-10-关于子网掩码"><a href="#10-10-关于子网掩码" class="headerlink" title="10.10: 关于子网掩码:"></a>10.10: 关于子网掩码:</h3><p>为了标识IP地址的网络部分和主机部分，要和地址掩码（Address Mask）结合，掩码跟IP地址一样也是32 bits，用点分十进制表示。IP地址网络部分对应的掩码部分全为“1”，主机部分对应的掩码全为“0”。</p><p>缺省状态下，如果没有进行子网划分，A类网络的子网掩码为255.0.0.0，B类网络的子网掩码为255.255.0.0，C类网络的子网掩码为255.255.255.0。利用子网，网络地址的使用会更加有效。</p><p>有了子网掩码后，IP地址的标识方法如下：<br>例：192.168.1.1 255.255.255.0或者标识成192.168.1.1/24（掩码中“1”的个数）</p><p><strong>子网划分</strong></p><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><p><strong>无分类</strong></p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="十一、虚拟专用网-VPN"><a href="#十一、虚拟专用网-VPN" class="headerlink" title="十一、虚拟专用网 VPN"></a>十一、虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255  共有2的24次方个地址</li><li>172.16.0.0 ~ 172.31.255.255  共有2的20次方个地址</li><li>192.168.0.0 ~ 192.168.255.255  共有2的16次方个地址</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.18.png" alt></p><h2 id="十二、网络地址转换-NAT"><a href="#十二、网络地址转换-NAT" class="headerlink" title="十二、网络地址转换 NAT:"></a>十二、网络地址转换 NAT:</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.20.png" alt></p><h2 id="十三、路由器的结构"><a href="#十三、路由器的结构" class="headerlink" title="十三、路由器的结构:"></a>十三、路由器的结构:</h2><h3 id="13-1-路由器的功能："><a href="#13-1-路由器的功能：" class="headerlink" title="13.1 路由器的功能："></a>13.1 路由器的功能：</h3><p>路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p>　　　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.21.png" alt></p><h3 id="13-2-路由器分组转发流程"><a href="#13-2-路由器分组转发流程" class="headerlink" title="13.2 路由器分组转发流程:"></a>13.2 路由器分组转发流程:</h3><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p>　　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.22.png" alt></p><h3 id="13-3-路由选择协议"><a href="#13-3-路由选择协议" class="headerlink" title="13.3 路由选择协议:"></a>13.3 路由选择协议:</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。<br>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。<br>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><p>参考链接:<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、网络层协议&quot;&gt;&lt;a href=&quot;#一、网络层协议&quot; class=&quot;headerlink&quot; title=&quot;一、网络层协议:&quot;&gt;&lt;/a&gt;一、网络层协议:&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是协议（protocol）&quot;&gt;&lt;a href=&quot;#1-1-什么是协议（protocol）&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是协议（protocol）?&quot;&gt;&lt;/a&gt;1.1 什么是协议（protocol）?&lt;/h3&gt;&lt;p&gt;通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”.&lt;/p&gt;
&lt;h3 id=&quot;1-2-什么是实体（entity）&quot;&gt;&lt;a href=&quot;#1-2-什么是实体（entity）&quot; class=&quot;headerlink&quot; title=&quot;1.2 什么是实体（entity）?&quot;&gt;&lt;/a&gt;1.2 什么是实体（entity）?&lt;/h3&gt;&lt;p&gt;表示任何可发送或接收消息的硬件或软件进程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络层" scheme="https://zzwwqq.xyz/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="https://zzwwqq.xyz/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://zzwwqq.xyz/进程与线程.html</id>
    <published>2019-03-31T12:38:19.000Z</published>
    <updated>2019-04-03T07:46:54.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关于进程"><a href="#一、关于进程" class="headerlink" title="一、关于进程:"></a>一、关于进程:</h2><h3 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1 什么是进程?"></a>1.1 什么是进程?</h3><p>进程是具有独立功能的<strong>程序在某个数据集合上的一次运行活动</strong>，也是操作系统进行<strong>资源分配和保护的基本单位。</strong>有挂起状态</p><h3 id="1-2-进程的组成部分"><a href="#1-2-进程的组成部分" class="headerlink" title="1.2 进程的组成部分:"></a>1.2 进程的组成部分:</h3><a id="more"></a><p><strong>进程由四个部分组成:</strong></p><p>①: 程序块<br>②: 数据块: 程序和数据刻画的是静态特征<br>③: 进程控制块 (Process Control Block, PCB) :  每个进程只有一个进程控制块Process  Control  Block (进程描述符),  包含管理进程所需的全部信息.<br>④: 核心栈:  进程运行过程中产生中断或者执行系统调用时又要运行操作系统内核函数  , 核心栈就是存放内核函数在工作时产生的信息</p><p><strong>PCB包含三类信息: </strong><br>①: 标识信息:   数值型进程号0~32767  是进程存在的唯一标识<br>②: 现场信息:   包括通用寄存器,  控制寄存器, 栈指针,  程序状态字   进程让出处理器时,必须将此时的现场信息保存到PCB<br>③: 控制信息:   用于管理和调度进程</p><h3 id="1-3-进程状态的切换"><a href="#1-3-进程状态的切换" class="headerlink" title="1.3 进程状态的切换:"></a>1.3 进程状态的切换:</h3><p><strong>进程的三种基本状态:</strong></p><ul><li><p>运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着</p></li><li><p>阻塞状态：等待资源;   由于进程等待某种条件（如等待I/O操作的完成，或等待另一个进程发来消息(即进程同步)），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行</p></li><li><p>就绪状态：等待被调度 ; 进程已获得除CPU外的所需资源，由于其他进程占用CPU而暂时无法运行的一种状态</p></li></ul><p><strong>注意: </strong><br>①: <strong>只有就绪态和运行态可以相互转换，其它的都是单向转换。</strong><br>就绪状态的进程通过<strong>调度算法</strong>从而获得 CPU 时间，转为运行状态；<br>而运行状态的进程，在分配给它的<strong>CPU 时间片用完</strong>之后就会转为就绪状态，等待下一次调度。<br>②: <strong>阻塞状态是缺少需要的资源</strong>从而由运行状态转换而来，但是<strong>该资源不包括 CPU 时间，</strong>缺少 CPU 时间会从运行态转换为就绪态。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-1.1.1.png" alt></p><h3 id="1-4-进程的特点"><a href="#1-4-进程的特点" class="headerlink" title="1.4 进程的特点:"></a>1.4 进程的特点:</h3><p>动态性:  程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。<br>共享性: 多个不同的进程,可以执行相同的程序, 进程和程序不是一 一对应的<br>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进<br>独立性: 每个进程是操作系统中的一个独立的实体,  有独立的虚存空间,程序计数器,内部状态<br>并发性:  在单处理器系统中可并发执行,  多处理器环境中并行执行.</p><h3 id="1-5-进程的挂起"><a href="#1-5-进程的挂起" class="headerlink" title="1.5 进程的挂起:"></a>1.5 进程的挂起:</h3><p><strong>目的:</strong> 平滑系统负荷<br><strong>什么时候挂起?</strong>  当系统资源尤其是内存资源已经不能满足进程运行的要求时,必须把某些进程挂起.<br><strong>特点:</strong>  将不参与低级调度, 直到它们被对换到内存,  该进程不能立即执行<br><strong>如何结束挂起状态? </strong>  只能由操作系统或者父进程发出</p><h3 id="1-6-进程挂起和激活"><a href="#1-6-进程挂起和激活" class="headerlink" title="1.6 进程挂起和激活:"></a>1.6 进程挂起和激活:</h3><p>挂 起 原 语 既 可 以 由 进 程 自 己 也 可 以 由 其 他 进 程 调 用,      激 活 原 语 只 能 由 其 他 进 程 调 用 </p><h3 id="1-7-进程阻塞和唤醒"><a href="#1-7-进程阻塞和唤醒" class="headerlink" title="1.7 进程阻塞和唤醒:"></a>1.7 进程阻塞和唤醒:</h3><p>阻塞: 进程让出处理器,转而等待一个事件,如等待资源,等待IO操作完成, 等待事件发生.<br>进程通常调用阻塞原语来阻塞自己,    因此阻塞是自主行为<br>唤醒: 等待事件完成时会产生中断,激活操作系统,在操作系统控制下,与其相关的另一个进程调用唤醒原语将阻塞进程唤醒.</p><h2 id="二、关于线程"><a href="#二、关于线程" class="headerlink" title="二、关于线程:"></a>二、关于线程:</h2><h3 id="1-1-什么是线程"><a href="#1-1-什么是线程" class="headerlink" title="1.1 什么是线程?"></a>1.1 什么是线程?</h3><p>是进程中能并发执行的实体,   是进程的组成部分,有时被称为轻量级进程(Lightweight Process，LWP）, 是处理器调度和分派的基本单位, 是一条执行路径,有独立的程序计数器   无挂起状态 </p><h3 id="1-2-线程的重要特征"><a href="#1-2-线程的重要特征" class="headerlink" title="1.2 线程的重要特征:"></a>1.2 线程的重要特征:</h3><p>①: 一个进程中可以有多个线程，它们共享进程资源。<br>②: 线程是轻量级的进程<br>③: 线程是由进程创建的(寄生在进程)<br>④: 线程没有独立的地址空间(内存空间)<br>⑤: 线程是系统独立调度和分配的基本单位<br>⑥: 可并发执行<br>⑦: 线程是一种轻型实体<br>线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。<strong>TCB包括以下信息：</strong></p><ul><li>线程状态</li><li>存放每个线程的局部变量主存区</li><li>访问同一个进程中的主存和其它资源</li><li>当线程不运行时，被保存的现场资源</li></ul><h3 id="1-3-创建线程的不同方式"><a href="#1-3-创建线程的不同方式" class="headerlink" title="1.3 创建线程的不同方式:"></a>1.3 创建线程的不同方式:</h3><p><strong>有4种方式可以用来创建线程：</strong><br>①继承Thread类<br>②实现Runnable接口<br>③应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。<br>④还有一种方式是实现Callable接口</p><h3 id="1-4-进程状态的切换"><a href="#1-4-进程状态的切换" class="headerlink" title="1.4 进程状态的切换:"></a>1.4 进程状态的切换:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-1.2.png" alt></p><p>新建( new )：新创建了一个线程对象。</p><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。</p><p><strong>阻塞的情况分三种：</strong></p><p>(一). 等待阻塞：</p><p>运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p><p>(二). 同步阻塞：</p><p>运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p><p>(三). 其他阻塞: </p><p>运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            </p><p>当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><h3 id="1-4-优点"><a href="#1-4-优点" class="headerlink" title="1.4 优点:"></a>1.4 优点:</h3><p>快速切换 : 同一个进程中的多线程只需要改变堆栈和寄存器, 地址空间不变<br>通信容易: 不必经过内核, 可自由访问全局数据,自动共享进程的内存和文件<br>减少管理开销: 线程的创建和撤销工作比进程少很多,并且无需再分配存储空间,和各种资源<br>并发程度提高:</p><h2 id="三、进程与线程的区别"><a href="#三、进程与线程的区别" class="headerlink" title="三、进程与线程的区别:"></a>三、进程与线程的区别:</h2><h3 id="3-1-就资源而言"><a href="#3-1-就资源而言" class="headerlink" title="3.1 就资源而言:"></a>3.1 就资源而言:</h3><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><h3 id="3-2-就调度而言"><a href="#3-2-就调度而言" class="headerlink" title="3.2 就调度而言:"></a>3.2 就调度而言:</h3><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h3 id="3-3-就系统开销而言"><a href="#3-3-就系统开销而言" class="headerlink" title="3.3 就系统开销而言:"></a>3.3 就系统开销而言:</h3><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h3 id="3-4-就通信而言"><a href="#3-4-就通信而言" class="headerlink" title="3.4 就通信而言:"></a>3.4 就通信而言:</h3><p>线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。但是进程通信需要借助 IPC。</p><h3 id="3-5-就组成而言"><a href="#3-5-就组成而言" class="headerlink" title="3.5 就组成而言:"></a>3.5 就组成而言:</h3><p>进程可分为两部分:  资源集合  和  线程集合<br>进程封装管理信息,线程封装执行信息</p><h2 id="四、进程的调度算法"><a href="#四、进程的调度算法" class="headerlink" title="四、进程的调度算法:"></a>四、进程的调度算法:</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="4-1-批处理系统"><a href="#4-1-批处理系统" class="headerlink" title="4.1 批处理系统"></a>4.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证<strong>吞吐量和周转时间</strong>（从提交到终止的时间）。</p><p><strong>①: 先来先服务 first-come first-serverd（FCFS）</strong><br>按照请求的顺序进行调度。<br>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>②: 短作业优先 shortest job first（SJF）</strong><br>按估计运行时间最短的顺序进行调度。<br>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>③: 最短剩余时间优先 shortest remaining time next（SRTN）</strong><br>按估计剩余时间最短的顺序进行调度。</p><h3 id="4-2-交互式系统"><a href="#4-2-交互式系统" class="headerlink" title="4.2 交互式系统:"></a>4.2 交互式系统:</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。<br><strong>④: 时间片轮转</strong><br>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p><strong>时间片轮转算法的效率和时间片的大小有很大关系：</strong></p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><strong>⑤: 优先级调度</strong></p><p>为每个进程分配一个优先级，按优先级进行调度。<br>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p>⑥: <strong>多级反馈队列</strong></p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此<strong>只有上一个队列没有进程在排队，才能调度当前队列上的进程。</strong></p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><h3 id="4-3-实时系统"><a href="#4-3-实时系统" class="headerlink" title="4.3 实时系统"></a>4.3 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="五、进程同步"><a href="#五、进程同步" class="headerlink" title="五、进程同步:"></a>五、进程同步:</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区:"></a>临界区:</h3><p>对临界资源进行访问的那段代码称为临界区。<br>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥:"></a>同步与互斥:</h3><p>同步：多个进程按一定顺序执行；<br>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量:"></a>信号量:</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 P 和 V 操作。</p><ul><li><strong>P</strong>: 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>V</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P 操作。</li></ul><p>P, V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p><strong>如果信号量的取值只能为 0 或者 1</strong>，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用信号量实现生产者-消费者问题</strong> </p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p><strong>注意，不能先对缓冲区进行加锁，再测试信号量。</strong>也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、关于管程"><a href="#六、关于管程" class="headerlink" title="六、关于管程:"></a>六、关于管程:</h2><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。<br><strong>c 语言不支持管程</strong></p><p><strong>管程有一个重要特性：</strong><br>在一个时刻只能有一个进程使用管程。<br>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。<br>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。<br>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。<br>signal() 操作用于唤醒被阻塞的进程。</p><h2 id="七、进程的通信"><a href="#七、进程的通信" class="headerlink" title="七、进程的通信:"></a>七、进程的通信:</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：<br>进程同步：控制多个进程按一定顺序执行；<br>进程通信：进程间传输信息</p><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="八、关于管道"><a href="#八、关于管道" class="headerlink" title="八、关于管道:"></a>八、关于管道:</h2><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><p>它具有以下限制：</p><ul><li><p>只支持半双工通信（单向交替传输）；</p></li><li><p>只能在父子进程中使用。</p></li></ul><h2 id="九、同步方法和同步代码块的区别是什么？"><a href="#九、同步方法和同步代码块的区别是什么？" class="headerlink" title="九、同步方法和同步代码块的区别是什么？"></a>九、同步方法和同步代码块的区别是什么？</h2><p>①: 同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；<br>②: 同步方法使用关键字 synchronized修饰方法，<br>而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、关于进程&quot;&gt;&lt;a href=&quot;#一、关于进程&quot; class=&quot;headerlink&quot; title=&quot;一、关于进程:&quot;&gt;&lt;/a&gt;一、关于进程:&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是进程&quot;&gt;&lt;a href=&quot;#1-1-什么是进程&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是进程?&quot;&gt;&lt;/a&gt;1.1 什么是进程?&lt;/h3&gt;&lt;p&gt;进程是具有独立功能的&lt;strong&gt;程序在某个数据集合上的一次运行活动&lt;/strong&gt;，也是操作系统进行&lt;strong&gt;资源分配和保护的基本单位。&lt;/strong&gt;有挂起状态&lt;/p&gt;
&lt;h3 id=&quot;1-2-进程的组成部分&quot;&gt;&lt;a href=&quot;#1-2-进程的组成部分&quot; class=&quot;headerlink&quot; title=&quot;1.2 进程的组成部分:&quot;&gt;&lt;/a&gt;1.2 进程的组成部分:&lt;/h3&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程管理" scheme="https://zzwwqq.xyz/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://zzwwqq.xyz/%E7%89%A9%E7%90%86%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/物理层.html</id>
    <published>2019-03-31T07:16:47.000Z</published>
    <updated>2019-04-01T07:13:35.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传输模式"><a href="#一、传输模式" class="headerlink" title="一、传输模式:"></a>一、传输模式:</h2><p><strong>单工</strong>（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户<br><strong>半双工</strong>（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信<br><strong>全双工</strong>（full-duplex）:发送的同时也可以接收数据</p><a id="more"></a><h2 id="二、信道复用技术"><a href="#二、信道复用技术" class="headerlink" title="二、信道复用技术:"></a>二、信道复用技术:</h2><h3 id="2-1-频分复用"><a href="#2-1-频分复用" class="headerlink" title="2.1 频分复用:"></a>2.1 频分复用:</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.1.png" alt></p><h3 id="2-2-时分复用"><a href="#2-2-时分复用" class="headerlink" title="2.2 时分复用:"></a>2.2 时分复用:</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.2.png" alt></p><h3 id="2-3-波分复用"><a href="#2-3-波分复用" class="headerlink" title="2.3 波分复用:"></a>2.3 波分复用:</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="2-4-码分复用"><a href="#2-4-码分复用" class="headerlink" title="2.4 码分复用:"></a>2.4 码分复用:</h3><p>广泛应用于无线链路共享（如蜂窝网，卫星通信等）<br>每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示<br>各用户使用相同频率载波，利用各自的码片序列编码数据<br>各用户码片序列相互正交<br>码片序列与编码信号的内积</p><h3 id="2-5-统计时分复用"><a href="#2-5-统计时分复用" class="headerlink" title="2.5 统计时分复用:"></a>2.5 统计时分复用:</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.4.png" alt></p><h2 id="三、物理层的主要任务"><a href="#三、物理层的主要任务" class="headerlink" title="三、物理层的主要任务:"></a>三、物理层的主要任务:</h2><p>确定与传输媒体的接口有关的一些特性(机械,电气,功能,过程特性)</p><h2 id="四、物理层设备"><a href="#四、物理层设备" class="headerlink" title="四、物理层设备:"></a>四、物理层设备:</h2><p>转发器:<br>集线器: 它的每个接口,是简单的转发比特,不进行碰撞检测<br>中继器: 是一种简单的增加局域网传输距离的设备，如作为信号放大器，可使实际的网络跨越更大的距离，它工作在物理层</p><h2 id="五、物理层基本单元"><a href="#五、物理层基本单元" class="headerlink" title="五、物理层基本单元:"></a>五、物理层基本单元:</h2><p>比特</p><h2 id="六、常用编码方式"><a href="#六、常用编码方式" class="headerlink" title="六、常用编码方式:"></a>六、常用编码方式:</h2><p>不归零: 与比特流一致<br>归零: 到了高/低电平后,将回到低电平<br>曼彻斯特: 中心向下为1<br>差分曼彻斯特: 位开始无跳变为1,位中心始终跳变</p><h2 id="七、物理层规范"><a href="#七、物理层规范" class="headerlink" title="七、物理层规范:"></a>七、物理层规范:</h2><p><strong>物理层定义的是规范，不能说是协议</strong><br>例如: EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、传输模式&quot;&gt;&lt;a href=&quot;#一、传输模式&quot; class=&quot;headerlink&quot; title=&quot;一、传输模式:&quot;&gt;&lt;/a&gt;一、传输模式:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单工&lt;/strong&gt;（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户&lt;br&gt;&lt;strong&gt;半双工&lt;/strong&gt;（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信&lt;br&gt;&lt;strong&gt;全双工&lt;/strong&gt;（full-duplex）:发送的同时也可以接收数据&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="物理层" scheme="https://zzwwqq.xyz/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP</title>
    <link href="https://zzwwqq.xyz/%E5%85%B3%E4%BA%8EHTTP.html"/>
    <id>https://zzwwqq.xyz/关于HTTP.html</id>
    <published>2019-03-30T12:52:15.000Z</published>
    <updated>2019-03-30T16:07:53.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、区分URI-URL-URN"><a href="#一、区分URI-URL-URN" class="headerlink" title="一、区分URI,URL,URN:"></a>一、区分URI,URL,URN:</h2><p>URI 包含 URL 和 URN。</p><a id="more"></a><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.1.png" alt></p><h2 id="二、关于HTTP协议"><a href="#二、关于HTTP协议" class="headerlink" title="二、关于HTTP协议:"></a>二、关于HTTP协议:</h2><h3 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么?"></a>2.1 是什么?</h3><p>是一个基于(客户端/服务器)请求与响应模式的、<strong>无连接,</strong>  <strong>无状态的</strong>、<strong>应用层的协议</strong>，<strong>常基于TCP的连接方式</strong>，<strong>HTTP1.1</strong>版本中给出一种<strong>持续连接的机制</strong>，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</p><h3 id="2-2-HTTP协议的主要特点"><a href="#2-2-HTTP协议的主要特点" class="headerlink" title="2.2 HTTP协议的主要特点?"></a>2.2 HTTP协议的主要特点?</h3><p>①:   无连接：  限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>②:   无状态： HTTP协议是无状态协议,   无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>③:  传输数据类型灵活：     HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</p><p>④:  传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><h3 id="2-3-HTTP请求报文"><a href="#2-3-HTTP请求报文" class="headerlink" title="2.3 HTTP请求报文:"></a>2.3 HTTP请求报文:</h3><p>请求行,请求头,请求空行,请求体</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.2.png" alt></p><h3 id="2-4-HTTP响应报文"><a href="#2-4-HTTP响应报文" class="headerlink" title="2.4 HTTP响应报文:"></a>2.4 HTTP响应报文:</h3><p>状态行,响应头,响应空行,响应体</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.3.png" alt></p><h3 id="2-5-HTTP方法"><a href="#2-5-HTTP方法" class="headerlink" title="2.5 HTTP方法:"></a>2.5 HTTP方法:</h3><p>客户端发送的 <strong>请求报文</strong> <strong>第一行为请求行，</strong>包含了方法字段。</p><p>有九种方法: get,post,put,delete,head,patch,options,connect,trace</p><p><strong>HEAD:</strong><br>①: 作用: 获取报文首部<br>②: 和 GET 方法类似，但是不返回报文实体主体部分。<br>③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><p><strong>POST: </strong><br>作用: 传输实体主体<br>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p><strong>PUT:</strong><br>①: 作用: 上传文件<br>②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><p><strong>PATCH:</strong><br>①: 作用: 对资源进行部分修改<br>②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><p><strong>OPTIONS:</strong><br>①: 作用: 查询支持的方法<br>②: 查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><p><strong>CONNECT:</strong><br>①: 要求在与代理服务器通信时建立隧道<br>②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p><strong>TRACE:</strong><br>①: 追踪路径<br>②: 服务器会将通信路径返回给客户端。<br>③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h3 id="2-6-关于HTTP状态码"><a href="#2-6-关于HTTP状态码" class="headerlink" title="2.6 关于HTTP状态码:"></a>2.6 关于HTTP状态码:</h3><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（<strong>信息性状态码</strong>）</td><td>接收的请求正在处理<br><strong>100</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</td></tr><tr><td>2XX</td><td>Success（<strong>成功</strong>状态码）</td><td>请求正常处理完毕<br><strong>200 OK</strong></td></tr><tr><td>3XX</td><td>Redirection（<strong>重定向</strong>状态码）</td><td>需要进行附加操作以完成请求<br><strong>301</strong> ：永久性重定向<br><strong>302</strong>：临时性重定向</td></tr><tr><td>4XX</td><td>Client Error（<strong>客户端错误</strong>状态码）</td><td>服务器无法处理请求<br><strong>403 Forbidden</strong> ：请求被拒绝。<br><strong>404 Not Found</strong></td></tr><tr><td>5XX</td><td>Server Error（<strong>服务器错误</strong>状态码）</td><td>服务器处理请求出错<br><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。<br><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</td></tr></tbody></table><h3 id="2-7-连接管理"><a href="#2-7-连接管理" class="headerlink" title="2.7 : 连接管理:"></a>2.7 : 连接管理:</h3><h4 id="2-7-1-短连接与长连接"><a href="#2-7-1-短连接与长连接" class="headerlink" title="2.7.1 短连接与长连接:"></a>2.7.1 短连接与长连接:</h4><p>①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。<br>②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始<strong>默认是长连接的</strong>，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h4 id="2-7-2-流水线"><a href="#2-7-2-流水线" class="headerlink" title="2.7.2 流水线:"></a>2.7.2 流水线:</h4><p>①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<br>②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p><h4 id="2-7-3-Cookie"><a href="#2-7-3-Cookie" class="headerlink" title="2.7.3 Cookie:"></a>2.7.3 Cookie:</h4><p>①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 <strong>Cookie 来保存状态信息</strong>。</p><p>②: <strong>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>③: <strong>Cookie有什么用途?</strong></p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>④: <strong>Cookie的创建过程:</strong></p><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>⑤: <strong>Cookie的分类:</strong></p><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure><p>⑥: <strong>HttpOnly:</strong></p><ul><li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。</li><li>跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>⑦: <strong>Secure:</strong></p><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id="2-7-4-Session"><a href="#2-7-4-Session" class="headerlink" title="2.7.4 Session:"></a>2.7.4 Session:</h4><p>①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>③: <strong>使用 Session 维护用户登录状态的过程如下：</strong></p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><p>④: 浏览器禁用 Cookie:</p><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 <strong>URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</strong></p><h4 id="2-7-5-Cookie-与-Session-选择"><a href="#2-7-5-Cookie-与-Session-选择" class="headerlink" title="2.7.5 Cookie 与 Session 选择:"></a>2.7.5 Cookie 与 Session 选择:</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="2-8-常见端口"><a href="#2-8-常见端口" class="headerlink" title="2.8 常见端口:"></a>2.8 常见端口:</h3><p>Http端口80,        HTTPS端口443      DNS端口 53    FTP 端口21     SMTP端口 25</p><h2 id="三、HTTP-1-1-新特性"><a href="#三、HTTP-1-1-新特性" class="headerlink" title="三、HTTP/1.1 新特性:"></a>三、HTTP/1.1 新特性:</h2><p>①: 默认是长连接<br>②: 支持流水线<br>③: 支持同时打开多个 TCP 连接<br>④: 支持虚拟主机<br>⑤: 新增状态码 100<br>⑥: 支持分块传输编码<br>⑦: 新增缓存处理指令 max-age</p><h2 id="四、GET-和-POST-比较"><a href="#四、GET-和-POST-比较" class="headerlink" title="四、GET 和 POST 比较:"></a>四、GET 和 POST 比较:</h2><p><strong>从作用上来说: </strong><br>GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>从参数来说:</strong><br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。<br>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/<span class="number">1.1</span></span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p><strong>从缓存来说: </strong><br>如果要对响应进行缓存，需要满足以下条件：</p><p>①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。<br>②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。<br>③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。</p><p><strong>XMLHttpRequest: </strong></p><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><p>①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会<strong>先发送 Header 再发送 Data</strong>。但并不是所有浏览器会这么做，例如火狐就不会。<br>②: 而 GET 方法 <strong>Header 和 Data 会一起发送。</strong></p><h2 id="五-关于HTTPS"><a href="#五-关于HTTPS" class="headerlink" title="五: 关于HTTPS:"></a>五: 关于HTTPS:</h2><h3 id="5-1-HTTP-有以下安全性问题："><a href="#5-1-HTTP-有以下安全性问题：" class="headerlink" title="5.1 HTTP 有以下安全性问题："></a>5.1 HTTP 有以下安全性问题：</h3><p>①: 使用明文进行通信，内容可能会被窃听；<br>②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；<br>③: 无法证明报文的完整性，报文有可能遭篡改。</p><h3 id="5-2-什么是HTTPS"><a href="#5-2-什么是HTTPS" class="headerlink" title="5.2 什么是HTTPS?"></a>5.2 什么是HTTPS?</h3><p>HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.8.png" alt></p><p><strong>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong></p><h3 id="5-3-什么是SSL"><a href="#5-3-什么是SSL" class="headerlink" title="5.3 什么是SSL?"></a>5.3 什么是SSL?</h3><p>SSL（Secure Socket Layer，安全套接字层）：<br>1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><h3 id="5-4-什么是TLS"><a href="#5-4-什么是TLS" class="headerlink" title="5.4 什么是TLS?"></a>5.4 什么是TLS?</h3><p>TLS（Transport Layer Security，传输层安全）：<br>其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><strong>5.5 HTTPS的缺点: </strong></p><p>①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐<br>②: HTTPS 降低用户访问速度（多次握手）<br>③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）<br>④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密）</p><h2 id="六、关于加密"><a href="#六、关于加密" class="headerlink" title="六、关于加密:"></a>六、关于加密:</h2><h3 id="6-1-对称密钥加密-Symmetric-Key-Encryption"><a href="#6-1-对称密钥加密-Symmetric-Key-Encryption" class="headerlink" title="6.1 对称密钥加密:(Symmetric-Key Encryption)"></a>6.1 对称密钥加密:(Symmetric-Key Encryption)</h3><p>①: 有流式、分组两种，加密和解密都是使用的同一个密钥。<br>例如：DES、AES-GCM、ChaCha20-Poly1305等</p><p>优点：运算速度快；<br>缺点：无法安全地将密钥传输给通信方。</p><h3 id="6-2-非对称密钥加密"><a href="#6-2-非对称密钥加密" class="headerlink" title="6.2 非对称密钥加密:"></a>6.2 非对称密钥加密:</h3><p>①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p><p>例如：RSA、DSA、ECDSA、DH、ECDHE</p><p>②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(<strong>发消息: 公钥加密,私钥解密</strong>)<br>③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(<strong>签名: 私钥加密,公钥解密</strong>)</p><p>优点：可以更安全地将公开密钥传输给通信发送方；<br>缺点：运算速度慢。</p><h3 id="6-3-哈希算法"><a href="#6-3-哈希算法" class="headerlink" title="6.3 哈希算法:"></a>6.3 哈希算法:</h3><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p><p>例如：MD5、SHA-1、SHA-2、SHA-256 等</p><h3 id="6-4-数字签名"><a href="#6-4-数字签名" class="headerlink" title="6.4 数字签名:"></a>6.4 数字签名:</h3><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p><p>HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP</p><h3 id="6-3-HTTPS-采用的加密方式"><a href="#6-3-HTTPS-采用的加密方式" class="headerlink" title="6.3 HTTPS 采用的加密方式:"></a>6.3 HTTPS 采用的加密方式:</h3><p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输对称密钥</strong>来保证传输过程的安全性，之后使用<strong>对称密钥加密进行通信</strong>来保证通信过程的效率.</p><h2 id="七、关于认证"><a href="#七、关于认证" class="headerlink" title="七、关于认证:"></a>七、关于认证:</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p><strong>服务器</strong>的运营人员向 CA 提出<strong>公开密钥的申请</strong>，CA 在判明提出申请者的身份之后，会<strong>对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后<strong>绑定</strong>在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.4.png" alt></p><p>签名: 签名者的私钥加密,</p><p>认证: 使用签名者公钥解密</p><h2 id="八、完整性保护"><a href="#八、完整性保护" class="headerlink" title="八、完整性保护:"></a>八、完整性保护:</h2><p>①: SSL 提供报文摘要功能来进行完整性保护。<br>②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。<br>③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="九、关于代理"><a href="#九、关于代理" class="headerlink" title="九、关于代理:"></a>九、关于代理:</h2><h3 id="9-1-代理服务器接受客户端的请求，并且转发给其它服务器。"><a href="#9-1-代理服务器接受客户端的请求，并且转发给其它服务器。" class="headerlink" title="9.1 代理服务器接受客户端的请求，并且转发给其它服务器。"></a>9.1 代理服务器接受客户端的请求，并且转发给其它服务器。</h3><h3 id="9-2-使用代理的主要目的是："><a href="#9-2-使用代理的主要目的是：" class="headerlink" title="9.2 使用代理的主要目的是："></a>9.2 使用代理的主要目的是：</h3><p>①: 缓存<br>②: 负载均衡<br>③: 网络访问控制<br>④: 访问日志记录</p><h3 id="9-3-代理服务器分为正向代理和反向代理两种："><a href="#9-3-代理服务器分为正向代理和反向代理两种：" class="headerlink" title="9.3 代理服务器分为正向代理和反向代理两种："></a>9.3 代理服务器分为正向代理和反向代理两种：</h3><p><strong>举例: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.5.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.6.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.7.png" alt></p><h2 id="十、关于缓存"><a href="#十、关于缓存" class="headerlink" title="十、关于缓存:"></a>十、关于缓存:</h2><h3 id="10-1-优点"><a href="#10-1-优点" class="headerlink" title="10.1 优点:"></a>10.1 优点:</h3><p>①: 缓解服务器压力；<br>②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p><h3 id="10-2-实现方法"><a href="#10-2-实现方法" class="headerlink" title="10.2 实现方法"></a>10.2 实现方法</h3><p>①: 让代理服务器进行缓存；<br>②: 让客户端浏览器进行缓存。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、区分URI-URL-URN&quot;&gt;&lt;a href=&quot;#一、区分URI-URL-URN&quot; class=&quot;headerlink&quot; title=&quot;一、区分URI,URL,URN:&quot;&gt;&lt;/a&gt;一、区分URI,URL,URN:&lt;/h2&gt;&lt;p&gt;URI 包含 URL 和 URN。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="关于HTTP" scheme="https://zzwwqq.xyz/tags/%E5%85%B3%E4%BA%8EHTTP/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="https://zzwwqq.xyz/java%E9%9B%86%E5%90%88.html"/>
    <id>https://zzwwqq.xyz/java集合.html</id>
    <published>2019-03-29T06:49:49.000Z</published>
    <updated>2019-03-29T08:58:08.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、先来看两张图"><a href="#一、先来看两张图" class="headerlink" title="一、先来看两张图:"></a>一、先来看两张图:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.1.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.2.png" alt></p><h2 id="二、集合的分类"><a href="#二、集合的分类" class="headerlink" title="二、集合的分类:"></a>二、集合的分类:</h2><h3 id="2-1-Collection接口"><a href="#2-1-Collection接口" class="headerlink" title="2.1 Collection接口:"></a>2.1 Collection接口:</h3><p>List接口：存储有序，可重复的元素  ,遍历出来的顺序与添加<strong>顺序相同</strong></p><p>Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的<strong>位置无序</strong>))，不可重复的元素(不可</p><p>　　　　重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都</p><p>　　　　是Collection下定义的</p><h3 id="2-2-Map接口"><a href="#2-2-Map接口" class="headerlink" title="2.2 Map接口:"></a>2.2 Map接口:</h3><p><strong>注：Map接口不是Collection接口的子接口, 两者是并列关系</strong></p><h2 id="三、关于List接口"><a href="#三、关于List接口" class="headerlink" title="三、关于List接口:"></a>三、关于List接口:</h2><h3 id="3-1-List接口："><a href="#3-1-List接口：" class="headerlink" title="3.1 List接口："></a>3.1 List接口：</h3><p>存储有序，可重复的元素             遍历出来的顺序与添加顺序相同</p><h3 id="3-2-具体的实现类"><a href="#3-2-具体的实现类" class="headerlink" title="3.2 具体的实现类:"></a>3.2 具体的实现类:</h3><p>①: ArrayList(主要的实现类)<br>②: LinkedList(对于频繁的插入，删除操作   较适用)<br>③: Vector(古老的实现类，线程安全的，但效率低于ArrayList)</p><h2 id="四、关于Set接口"><a href="#四、关于Set接口" class="headerlink" title="四、关于Set接口:"></a>四、关于Set接口:</h2><h3 id="4-1-需要注意的是"><a href="#4-1-需要注意的是" class="headerlink" title="4.1 需要注意的是:"></a>4.1 需要注意的是:</h3><p>①: 通常说的” Set是无序的,  不可重复的 “  这句话中的无序是指的<strong>存储无序. </strong><br>②: 无论是HashSet,还是LinkedHashSet 存储都是无序,  且不可重复的元素((指的是元素在底层存放的位置无序))<br>③: <strong>遍历是分为有序和无序的 </strong>,   HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.  </p><h3 id="4-2-如何保证set中元素不可重复"><a href="#4-2-如何保证set中元素不可重复" class="headerlink" title="4.2 如何保证set中元素不可重复?"></a>4.2 如何保证set中元素不可重复?</h3><p><strong>要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.</strong><br>让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),<br>重写hashCode（）方法让同一个对象能算出相同的hashCode值,,   进而保证Set中元素的不可重复性,,    注意:List只用重写equals方法就可以了</p><h3 id="4-3-Set中元素是如何存储的呢？"><a href="#4-3-Set中元素是如何存储的呢？" class="headerlink" title="4.3 Set中元素是如何存储的呢？"></a>4.3 Set中元素是如何存储的呢？</h3><p><strong>使用了哈希算法</strong><br>当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复).</p><p><strong>要求</strong>：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false;    )</p><p>万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此）</p><h3 id="4-4-具体的实现类"><a href="#4-4-具体的实现类" class="headerlink" title="4.4  具体的实现类:"></a>4.4  具体的实现类:</h3><p>①: HashSet(主要的实现类)<br>②: LinkedHashSet(HashSet的子类)<br>③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口)</p><p><strong>注:  一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer  又存储String类型)</strong></p><h4 id="4-4-1-关于TreeSet"><a href="#4-4-1-关于TreeSet" class="headerlink" title="4.4.1 关于TreeSet:"></a>4.4.1 关于TreeSet:</h4><p>当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序<br>①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）<br>②定制排序：（实现Comparator接口，重写compare方法）</p><p><strong>两种排序的区别:  </strong> </p><p>前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法<br>后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法.</p><p>向TreeSet中添加元素时，<strong>首先执行元素所属类的compareTo方法</strong>比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来</p><p><strong>注: </strong>只有当<strong>compareTo</strong>比较后得两个对象不相同时，再调用执行元素所属类的<strong>hashCode方法</strong>，最后调用<strong>equals方法</strong>   <strong>compareTo()与hashCode()以及equals()三者保持一致！</strong></p><h2 id="五、关于Map接口"><a href="#五、关于Map接口" class="headerlink" title="五、关于Map接口:"></a>五、关于Map接口:</h2><h3 id="5-1-Map接口元素的存储原理"><a href="#5-1-Map接口元素的存储原理" class="headerlink" title="5.1 Map接口元素的存储原理:"></a>5.1 Map接口元素的存储原理:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.3.png" alt></p><p>Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，<strong>需要重写hashCode和equals方法, </strong>     进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复</p><p><strong>例如:</strong><br>向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(<strong>后面的会覆盖前面的</strong>,这个与HashSet不同,HashSet是后面的那个不能添加进来)。</p><h3 id="5-2-遍历Map"><a href="#5-2-遍历Map" class="headerlink" title="5.2 遍历Map:"></a>5.2 遍历Map:</h3><p>有三类，分别是遍历key，遍历value，遍历key-value对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.遍历key集</span></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.遍历value集</span></span><br><span class="line"></span><br><span class="line">Collection values = map.values();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.遍历key-value对</span></span><br><span class="line"></span><br><span class="line">Set set2 = map.entrySet();   <span class="comment">//所有entry的集合就是entrySet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj:set2)   &#123;        <span class="comment">//遍历entrySet得到entry</span></span><br><span class="line"></span><br><span class="line">Map.Entry entry = (Map.Entry)obj;   <span class="comment">//获取entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键  和  值</span></span><br><span class="line"></span><br><span class="line">   System.out.println(entry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Map的初始化"><a href="#5-3-Map的初始化" class="headerlink" title="5.3 Map的初始化:"></a>5.3 Map的初始化:</h3><p>不能初始化为:      Map&lt;String,List<score>&gt;map=null;<br>而要用new对象的方式：Map&lt;String,List<score>&gt;map=newHashMap&lt;String,List<score>&gt;();否则会报错</score></score></score></p><h3 id="5-4-从map中取值"><a href="#5-4-从map中取值" class="headerlink" title="5.4 从map中取值:"></a>5.4 从map中取值:</h3><p>正确方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一:  String str = String.valueOf(map.get(<span class="string">"键名"</span>));</span><br><span class="line">方法二:  </span><br><span class="line">String str = (String) map.get(<span class="string">"ACCEPT_CHANNEL"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != str &amp;&amp; !<span class="string">""</span>.equals(str)) &#123;</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的取值方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = map.get(<span class="string">"键名"</span>).toString;  <span class="comment">//如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常</span></span><br></pre></td></tr></table></figure><p><strong>注: Map中的Key  value可以是任何引用类型的数据</strong></p><h3 id="5-5-Map接口的具体实现类"><a href="#5-5-Map接口的具体实现类" class="headerlink" title="5.5 Map接口的具体实现类:"></a>5.5 Map接口的具体实现类:</h3><p>①: HashTable : 古老的实现类，线程安全，不建议使用<br>②: HashMap:<br>③: LinkedHashMap(是HashMap的子类)<br>④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口)</p><h4 id="5-5-1-Properties介绍"><a href="#5-5-1-Properties介绍" class="headerlink" title="5.5.1  Properties介绍:"></a>5.5.1  Properties介绍:</h4><p>Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">读取属性文件jdbc.properties: </span><br><span class="line"></span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"jdbc.properties"</span>));</span><br><span class="line"></span><br><span class="line">pros.load(fi);</span><br><span class="line"></span><br><span class="line">读取xml配置文件config.xml: </span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">InputStream configInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"config/config.xml"</span>);</span><br><span class="line"></span><br><span class="line">properties.loadFromXML(configInputStream);</span><br></pre></td></tr></table></figure><h2 id="六、关于Collections-工具类"><a href="#六、关于Collections-工具类" class="headerlink" title="六、关于Collections 工具类:"></a>六、关于Collections 工具类:</h2><p>6.1 作用:  </p><p>　　　　操作Collection以及Map</p><p>6.2 注意:<br>　　　　区分Collection与Collections</p><p>6.3 实现list的复制: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的方式：出现java.lang.indexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//List list1=new ArrayList();</span></span><br><span class="line"><span class="comment">//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1</span></span><br><span class="line"><span class="comment">//System.out.println(list1);</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//正确的方式</span></span><br><span class="line">List list2 = Arrays.asList(newObject[list.size()]);</span><br><span class="line">Collections.copy(list2,list);</span><br><span class="line">System.out.println(list2);<span class="comment">//[123,456,12,78,456]</span></span><br></pre></td></tr></table></figure><p>6.4 考虑线程安全问题:  </p><p>List 是线程不安全的, synchronizedList方法可以保证List线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过如下的方法保证list的线程安全</span></span><br><span class="line">List list3=Collections.synchronizedList(list);</span><br><span class="line">System.out.println(list3);</span><br></pre></td></tr></table></figure><p>6.5常用函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转List中元素的顺序</span><br><span class="line">shuffle(List)：对List集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序</span><br><span class="line">sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</span><br><span class="line">swap(List,<span class="keyword">int</span>,<span class="keyword">int</span>)：将指定list集合中的i处元素和j处元素进行交换</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>:<span class="comment">//将src中的内容复制到dest中</span></span></span><br></pre></td></tr></table></figure><h2 id="七、集合的遍历方法：四种"><a href="#七、集合的遍历方法：四种" class="headerlink" title="七、集合的遍历方法：四种"></a>七、集合的遍历方法：四种</h2><p>①使用Iterator迭代器</p><p>②增强型for循环</p><p>③普通for循环</p><p>④Iterator迭代器的”古老版本”Enumeration 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Enumeration 接口是Iterator迭代器的"古老版本"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumeration</span> </span>&#123;</span><br><span class="line">　　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　　　　　　Enumeration enu = <span class="keyword">new</span> StringTokenizer(<span class="string">"ab-c*-df-g"</span>, <span class="string">"-"</span>);</span><br><span class="line">　　　　　　　<span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line">　　　　　　　　　　　System.out.println(enu.nextElement());</span><br><span class="line">　　　　　　　&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;    <span class="comment">//结果: 输出MM MM  MM   AA   BB   DD </span></span><br><span class="line">    String[]str=<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"DD"</span>&#125;;</span><br><span class="line">    <span class="comment">//表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值</span></span><br><span class="line">    <span class="keyword">for</span>(String s:str)&#123;   <span class="comment">//每循环一次, s都是一个新的局部变量</span></span><br><span class="line">        s=<span class="string">"MM"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        System.out.println(str[i]);          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、关于数组"><a href="#八、关于数组" class="headerlink" title="八、关于数组:"></a>八、关于数组:</h2><p>存储对象可以考虑：①数组，②集合<br>数组存储对象的特点：Student[] stu = new Student[20];  stu[0]=new Student();…..<br>弊端：①一旦创建，其长度不可变.      ②真实的数组存放的对象的个数是不可知的</p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结:"></a>九、总结:</h2><p>①:   单类型: 　　一个TreeSet对象<strong>必须存储同一种数据类型</strong>,例如: 不能既存储Integer  又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型.</p><p>②: 一致性:　　使用TreeSet时:   compareTo()与hashCode()以及equals()三者保持一致！</p><p>③:  执行流程：　向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法</p><p>④: 顺序性:    Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)<br>Set而言: 遍历是分为有序和无序的 ,   其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、先来看两张图&quot;&gt;&lt;a href=&quot;#一、先来看两张图&quot; class=&quot;headerlink&quot; title=&quot;一、先来看两张图:&quot;&gt;&lt;/a&gt;一、先来看两张图:&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.zzwwqq.xyz/static/image
      
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java集合" scheme="https://zzwwqq.xyz/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识</title>
    <link href="https://zzwwqq.xyz/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>https://zzwwqq.xyz/java基础知识.html</id>
    <published>2019-03-29T05:29:08.000Z</published>
    <updated>2019-03-29T10:40:35.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型:"></a>一、数据类型:</h2><h3 id="1-1-基本数据类型："><a href="#1-1-基本数据类型：" class="headerlink" title="1.1 基本数据类型："></a>1.1 基本数据类型：</h3><h4 id="1-1-1-整数类型："><a href="#1-1-1-整数类型：" class="headerlink" title="1.1.1 整数类型："></a>1.1.1 整数类型：</h4><p>byte（1个字节）      -128（-2^7）——–   127 (2^7-1)<br>short（2）     -32768(-2^15)——-   32767(2^15-1)<br>int（4）            （-2)^31 ——   2^31-1<br>long(8)             （-2)^63 ——   2^63-1  </p><a id="more"></a><p><strong>整数有三种表示形式：</strong><br>　　　八进制：以0开头，如012，-027<br>　　　十进制：<br>　　　十六进制：以0x 或0X开头，如0x123,-0X12</p><h4 id="1-1-2-浮点类型："><a href="#1-1-2-浮点类型：" class="headerlink" title="1.1.2 浮点类型："></a>1.1.2 浮点类型：</h4><p>float（4）     6或7位有效数字<br>double（8）    15位有效数字<br><strong>带小数点的数默认为：双精度浮点型</strong>（double），数字后带“d  或  D”，如“2.3d”，“d  或  D”可以省略<br><strong>注意：要表示单精度浮点型（float），必须在数字后面加“f  或  F”，如“13.23f”,“f 或  F”不可省略</strong></p><h4 id="1-1-3-字符类型："><a href="#1-1-3-字符类型：" class="headerlink" title="1.1.3 字符类型："></a>1.1.3 字符类型：</h4><p>char（2）</p><h4 id="1-1-4-布尔类型boolean："><a href="#1-1-4-布尔类型boolean：" class="headerlink" title="1.1.4 布尔类型boolean："></a>1.1.4 布尔类型boolean：</h4><p>false（4）必须小写<br>true（4）必须小写</p><p>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><h3 id="1-2-引用数据类型："><a href="#1-2-引用数据类型：" class="headerlink" title="1.2 引用数据类型："></a>1.2 引用数据类型：</h3><p>①: 类(class) 如String类<br>②: 接口(interface)<br>③: 数组<br>④: 枚举（enum）</p><h3 id="1-3-包装类型"><a href="#1-3-包装类型" class="headerlink" title="1.3 包装类型:"></a>1.3 包装类型:</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-2.2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><h2 id="二、常量与变量"><a href="#二、常量与变量" class="headerlink" title="二、常量与变量"></a>二、常量与变量</h2><p>①: 常量：由final修饰的</p><p>②: 变量：<br>　　　局部变量（位于方法（一般方法，构造方法，程序入口方法）中）<br>　　　全局变量（１.实例变量（无static修饰），２.类变量也称静态变量（有static修饰））</p><h2 id="三、强制类型转换"><a href="#三、强制类型转换" class="headerlink" title="三、强制类型转换:"></a>三、强制类型转换:</h2><p>3.1 小的转换为大的，系统会自动完成强制类型转换<br>如：short i = 10;<br>　　int j;<br>　　j=i;   (系统自动完成j = (int)i )<br>3.2 大的转换为小的，<strong>必须进行手动完成</strong>强制类型转换<br>如：int i = 10;<br>　　short j;<br>　　j = (short)i;</p><h2 id="四、构造方法"><a href="#四、构造方法" class="headerlink" title="四、构造方法:"></a>四、构造方法:</h2><h4 id="4-1-特点："><a href="#4-1-特点：" class="headerlink" title="4.1 特点："></a>4.1 特点：</h4><p>①: 构造方法只能由new操作符调用，即建立对象时自动调用；<br>②: 构造方法可以重载，即在同一个类中可以有多个构造方法<br>③: 构造方法没有返回类型，甚至连void也没有<br>④: 构造方法与类同名</p><p>注: 如果没有在类中写构造方法，系统会生成一个默认的无参构造方法，并使用默认值初始化对象的属性（int变量初始化为0，boolean 变量初始化为false）,如果写了有参构造方法,那么系统不会再自动生成无参构造方法,如果此时我们要用无参构造方法,需要我们手动写无参构造方法.</p><h4 id="4-2-作用：初始化对象，如给数据成员赋值"><a href="#4-2-作用：初始化对象，如给数据成员赋值" class="headerlink" title="4.2 作用：初始化对象，如给数据成员赋值"></a>4.2 作用：初始化对象，如给数据成员赋值</h4><p><strong>注意：一旦创建了一个有参数的构造方法，系统就不会自动添加默认的无参构造方法，要想用无参构造方法，需要人为的去创建一个无参构造方法</strong></p><h2 id="五、注释"><a href="#五、注释" class="headerlink" title="五、注释:"></a>五、注释:</h2><p>①: 文件注释：在包名之上，“/*……*/”，描述文件名(java工程名)，版权信息<br>②: 类注释：“/**……*/”，描述类的作用，版本version ，日期，作者<br>③: 私有成员：“/*……*/” 或“//”；如局部变量，某一个语句的功能作用</p><p> * @param 描述方法的参数</p><p> * @return 描述返回值，对于无返回值的方法或构造方法，@return可以省略</p><p> * @throws 描述在什么情况下抛出什么类型的异常</p><p> * @author 描述作者</p><p> * @version 描述版本 </p><p> * @since 描述该类可以运行的JDK版本</p><p> * @see 参考转向，也就是相关主题</p><p> * @link 转向成员的超链接。label为链接文字。package.class#member将被自动转换为指向package.class的member文件的URL</p><p>④: 共有成员：“/**……..*/”；如构造方法</p><h2 id="六、继承（extends）"><a href="#六、继承（extends）" class="headerlink" title="六、继承（extends）"></a>六、继承（extends）</h2><h4 id="6-1-含义"><a href="#6-1-含义" class="headerlink" title="6.1 含义:"></a>6.1 含义:</h4><p>其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正<strong>每次调子类的时候都会“自动运行”它父类的构造函数</strong>，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。<br>“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”。</p><h4 id="6-2-java中子类能不能继承父类构造方法？"><a href="#6-2-java中子类能不能继承父类构造方法？" class="headerlink" title="6.2 java中子类能不能继承父类构造方法？"></a>6.2 java中子类能不能继承父类构造方法？</h4><p><strong>答案是不能*</strong><br><strong>理由：</strong>其实每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。所以父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法</p><p><strong>注意“调用”和继承不是一个含义，实质上是“自动运行”。</strong></p><h2 id="七、关于JavaBean"><a href="#七、关于JavaBean" class="headerlink" title="七、关于JavaBean:"></a>七、关于JavaBean:</h2><p>符合如下标准的Java类：<br>①: 实现serializable接口（这个不是必须的）<br>②: 必须有一个无参的公共的构造器（public修饰）<br>③: 必须属性用private修饰，且有get，set方法</p><h2 id="八、权限修饰符："><a href="#八、权限修饰符：" class="headerlink" title="八、权限修饰符："></a>八、权限修饰符：</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-2.1.png" alt></p><h2 id="九、抽象类："><a href="#九、抽象类：" class="headerlink" title="九、抽象类："></a>九、抽象类：</h2><p>特点：必须含抽象方法，其他的和一般类一样<br>抽象方法：只有声明没有实现的方法</p><h2 id="十、接口："><a href="#十、接口：" class="headerlink" title="十、接口："></a>十、接口：</h2><h4 id="10-1-特点："><a href="#10-1-特点：" class="headerlink" title="10.1 特点："></a>10.1 特点：</h4><p><strong>只含常量和抽象方法</strong><br>①: 接口中的常量都是public static final 类型(可以省略)，这是系统默认的<br>②: 接口中的方法都是public abstract类型(可以省略)，这是系统默认的<br>③: 接口 作为一种引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的该接口中的方法<br><strong>一个类要实现接口，必须实现这个接口中的所有方法</strong></p><p><strong>注意：通过一个接口变量只能调用该接口所声明的方法</strong>。 </p><h2 id="十一、重载和重写区别"><a href="#十一、重载和重写区别" class="headerlink" title="十一、重载和重写区别:"></a>十一、重载和重写区别:</h2><p>方法重载（Overload）：一个类中有多个方法，名字相同，参数不同（如参数个数，种类，参数顺序不同），与返回值无关；<br>方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同</p><h2 id="十二、面向对象编程的四个基本特征"><a href="#十二、面向对象编程的四个基本特征" class="headerlink" title="十二、面向对象编程的四个基本特征:"></a>十二、面向对象编程的四个基本特征:</h2><p>①：抽象:<br>②：封装：把对象的数据和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节<br>③：继承：<br>④：多态性：<br><strong>多态的定义：</strong>是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。</p><p><strong>多态的举例：</strong>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。<br>同一个事件发生在不同的对象上会产生不同的结果。</p><p><strong>多态的作用：</strong>消除类型之间的耦合关系</p><p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p><strong>重载和重写都是多态的体现.</strong></p><h2 id="十三、异常与错误"><a href="#十三、异常与错误" class="headerlink" title="十三、异常与错误:"></a>十三、异常与错误:</h2><h3 id="12-1-异常"><a href="#12-1-异常" class="headerlink" title="12.1 异常:"></a>12.1 异常:</h3><h4 id="12-1-1-编译异常："><a href="#12-1-1-编译异常：" class="headerlink" title="12.1.1 编译异常："></a>12.1.1 编译异常：</h4><p>　　　　　　　由于程序语法不合规范，编译不通过</p><h4 id="12-1-2-运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）："><a href="#12-1-2-运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）：" class="headerlink" title="12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）："></a>12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）：</h4><p>　　　　　　　编译通过，运行时出现异常。如数组下标越界，除数为零，数字格式错误，空指针异常</p><h4 id="12-1-3-非运行时异常（又称检查性异常，此类异常必须被捕获处理）："><a href="#12-1-3-非运行时异常（又称检查性异常，此类异常必须被捕获处理）：" class="headerlink" title="12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）："></a>12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）：</h4><p>　　　　　　　如类没找到，IO操作错误</p><h4 id="12-1-4-逻辑异常："><a href="#12-1-4-逻辑异常：" class="headerlink" title="12.1.4 逻辑异常："></a>12.1.4 逻辑异常：</h4><p>　　　　　　　输出的结果不符合预期的要求</p><h4 id="12-1-5-try-catch-finally只有三种组合："><a href="#12-1-5-try-catch-finally只有三种组合：" class="headerlink" title="12.1.5 try ,catch ,finally只有三种组合："></a>12.1.5 try ,catch ,finally只有三种组合：</h4><p>​                                   a. try…catch…finally</p><p>​                                   b. try…catch</p><p>​                                   c. try…finally</p><p>①: 异常发生时，如果匹配的catch语句中抛出（有throw关键字）了异常，则finally之外的语句将不能被执行</p><p>②: finally中的语句无论什么情况都会执行</p><p>③: 得到有关异常信息：getMessage()</p><p>④: 用来跟踪异常事件发生时执行堆栈的内容：printStackTrace（）</p><h4 id="12-1-6-throws-和-throw-的区别："><a href="#12-1-6-throws-和-throw-的区别：" class="headerlink" title="12.1.6 throws 和 throw 的区别："></a>12.1.6 throws 和 throw 的区别：</h4><p>throws 关键字用于方法的声明部分，说明方法可能抛出的异常类型<br>throw 关键字用来抛出异常，如果抛出了检查性异常（非运行时异常），还必须在方法头部声明方法可能抛出的异常类，该方法的调用者还必须捕获处理抛出的异常,如果抛出非检查性异常（运行时异常），该方法的调用者可捕获可不捕获异常</p><h3 id="12-2-错误（Error）："><a href="#12-2-错误（Error）：" class="headerlink" title="12.2 错误（Error）："></a>12.2 错误（Error）：</h3><p>①：虚拟机错误（Virtual Machine Error）<br>②：连接错误（LinkageError）<br>③：图形界面错误（AWTError）</p><h2 id="十四、日期与时间"><a href="#十四、日期与时间" class="headerlink" title="十四、日期与时间:"></a>十四、日期与时间:</h2><h4 id="13-1-java中主要使用三个类来处理日期和时间"><a href="#13-1-java中主要使用三个类来处理日期和时间" class="headerlink" title="13.1 java中主要使用三个类来处理日期和时间:"></a>13.1 java中主要使用三个类来处理日期和时间:</h4><p>①: java.util.Date(日期) ,            ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的<strong>毫秒数</strong></p><p>②: java.util.Calendar（日历） ,      ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分</p><p>③: java.text.DateFormat（日期格式化）————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat<br>月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的<strong>大小写有要求</strong></p><h4 id="13-2-具体类Date的对象调用getTime（）方法得到的是毫秒数，形如：-1506582000000"><a href="#13-2-具体类Date的对象调用getTime（）方法得到的是毫秒数，形如：-1506582000000" class="headerlink" title="13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 1506582000000"></a>13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 1506582000000</h4><h4 id="13-3-抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun-Jul-23-12-15-52-PDT-2017"><a href="#13-3-抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun-Jul-23-12-15-52-PDT-2017" class="headerlink" title="13.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017"></a>13.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017</h4><h4 id="13-4-对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23-12-15-52"><a href="#13-4-对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23-12-15-52" class="headerlink" title="13.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52"></a>13.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据类型&quot;&gt;&lt;a href=&quot;#一、数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型:&quot;&gt;&lt;/a&gt;一、数据类型:&lt;/h2&gt;&lt;h3 id=&quot;1-1-基本数据类型：&quot;&gt;&lt;a href=&quot;#1-1-基本数据类型：&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本数据类型：&quot;&gt;&lt;/a&gt;1.1 基本数据类型：&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-整数类型：&quot;&gt;&lt;a href=&quot;#1-1-1-整数类型：&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 整数类型：&quot;&gt;&lt;/a&gt;1.1.1 整数类型：&lt;/h4&gt;&lt;p&gt;byte（1个字节）      -128（-2^7）——–   127 (2^7-1)&lt;br&gt;short（2）     -32768(-2^15)——-   32767(2^15-1)&lt;br&gt;int（4）            （-2)^31 ——   2^31-1&lt;br&gt;long(8)             （-2)^63 ——   2^63-1  &lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java基础" scheme="https://zzwwqq.xyz/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
