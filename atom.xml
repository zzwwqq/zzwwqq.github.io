<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zwq</title>
  
  <subtitle>路漫漫其修远兮,吾将上下而求索!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zzwwqq.xyz/"/>
  <updated>2019-03-31T14:45:43.035Z</updated>
  <id>https://zzwwqq.xyz/</id>
  
  <author>
    <name>zwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程与线程</title>
    <link href="https://zzwwqq.xyz/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://zzwwqq.xyz/进程与线程.html</id>
    <published>2019-03-31T12:38:19.000Z</published>
    <updated>2019-03-31T14:45:43.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关于进程"><a href="#一、关于进程" class="headerlink" title="一、关于进程:"></a>一、关于进程:</h2><h3 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1 什么是进程?"></a>1.1 什么是进程?</h3><p>进程是具有独立功能的<strong>程序在某个数据集合上的一次运行活动</strong>，也是操作系统进行<strong>资源分配和保护的基本单位。</strong></p><h3 id="1-2-进程的组成部分"><a href="#1-2-进程的组成部分" class="headerlink" title="1.2 进程的组成部分:"></a>1.2 进程的组成部分:</h3><a id="more"></a><p><strong>进程由三个部分组成:</strong></p><p>①: 程序<br>②: 数据<br>③: 进程控制块 (Process Control Block, PCB) : 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。PCB随着进程的创建而建立，撤销而消亡。系统根据PCB感知一个进程的存在，<strong>PCB是进程存在的唯一物理标识</strong></p><h3 id="1-3-进程状态的切换"><a href="#1-3-进程状态的切换" class="headerlink" title="1.3 进程状态的切换:"></a>1.3 进程状态的切换:</h3><p><strong>进程的三种基本状态:</strong></p><ul><li>运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着</li><li>阻塞状态：等待资源;   为了等待某个外部事件的发生（如等待I/O操作的完成，等待另一个进程发来消息），暂时无法运行。也成为等待状态</li><li>就绪状态：等待被调度 ;  具备了一切运行需要的条件，由于其他进程占用CPU而暂时无法运行</li></ul><p><strong>注意: </strong><br>①: <strong>只有就绪态和运行态可以相互转换，其它的都是单向转换。</strong><br>就绪状态的进程通过<strong>调度算法</strong>从而获得 CPU 时间，转为运行状态；<br>而运行状态的进程，在分配给它的<strong>CPU 时间片用完</strong>之后就会转为就绪状态，等待下一次调度。<br>②: <strong>阻塞状态是缺少需要的资源</strong>从而由运行状态转换而来，但是<strong>该资源不包括 CPU 时间，</strong>缺少 CPU 时间会从运行态转换为就绪态。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-1.1.png" alt></p><h2 id="二、关于线程"><a href="#二、关于线程" class="headerlink" title="二、关于线程:"></a>二、关于线程:</h2><h3 id="1-1-什么是线程"><a href="#1-1-什么是线程" class="headerlink" title="1.1 什么是线程?"></a>1.1 什么是线程?</h3><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。是被系统独立调度和分派的基本单位。</p><h3 id="1-2-线程的重要特征"><a href="#1-2-线程的重要特征" class="headerlink" title="1.2 线程的重要特征:"></a>1.2 线程的重要特征:</h3><p>①: 一个进程中可以有多个线程，它们共享进程资源。<br>②: 线程是轻量级的进程<br>③: 线程是由进程创建的(寄生在进程)<br>④: 线程没有独立的地址空间(内存空间)<br>⑤: 线程是系统独立调度和分配的基本单位<br>⑥: 可并发执行<br>⑦: 线程是一种轻型实体<br>线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。<strong>TCB包括以下信息：</strong></p><ul><li>线程状态</li><li>存放每个线程的局部变量主存区</li><li>访问同一个进程中的主存和其它资源</li><li>当线程不运行时，被保存的现场资源</li></ul><h3 id="1-3-创建线程的不同方式"><a href="#1-3-创建线程的不同方式" class="headerlink" title="1.3 创建线程的不同方式:"></a>1.3 创建线程的不同方式:</h3><p><strong>有4种方式可以用来创建线程：</strong><br>①继承Thread类<br>②实现Runnable接口<br>③应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。<br>④还有一种方式是实现Callable接口</p><h3 id="1-4-进程状态的切换"><a href="#1-4-进程状态的切换" class="headerlink" title="1.4 进程状态的切换:"></a>1.4 进程状态的切换:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-1.2.png" alt></p><p>新建( new )：新创建了一个线程对象。</p><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。</p><p><strong>阻塞的情况分三种：</strong></p><p>(一). 等待阻塞：</p><p>运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p><p>(二). 同步阻塞：</p><p>运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p><p>(三). 其他阻塞: </p><p>运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            </p><p>当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><h2 id="三、进程与线程的区别"><a href="#三、进程与线程的区别" class="headerlink" title="三、进程与线程的区别:"></a>三、进程与线程的区别:</h2><h3 id="3-1-就资源而言"><a href="#3-1-就资源而言" class="headerlink" title="3.1 就资源而言:"></a>3.1 就资源而言:</h3><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><h3 id="3-2-就调度而言"><a href="#3-2-就调度而言" class="headerlink" title="3.2 就调度而言:"></a>3.2 就调度而言:</h3><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h3 id="3-3-就系统开销而言"><a href="#3-3-就系统开销而言" class="headerlink" title="3.3 就系统开销而言:"></a>3.3 就系统开销而言:</h3><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h3 id="3-4-就通信而言"><a href="#3-4-就通信而言" class="headerlink" title="3.4 就通信而言:"></a>3.4 就通信而言:</h3><p>线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。但是进程通信需要借助 IPC。</p><h2 id="四、进程的调度算法"><a href="#四、进程的调度算法" class="headerlink" title="四、进程的调度算法:"></a>四、进程的调度算法:</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="4-1-批处理系统"><a href="#4-1-批处理系统" class="headerlink" title="4.1 批处理系统"></a>4.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证<strong>吞吐量和周转时间</strong>（从提交到终止的时间）。</p><p><strong>①: 先来先服务 first-come first-serverd（FCFS）</strong><br>按照请求的顺序进行调度。<br>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>②: 短作业优先 shortest job first（SJF）</strong><br>按估计运行时间最短的顺序进行调度。<br>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>③: 最短剩余时间优先 shortest remaining time next（SRTN）</strong><br>按估计剩余时间最短的顺序进行调度。</p><h3 id="4-2-交互式系统"><a href="#4-2-交互式系统" class="headerlink" title="4.2 交互式系统:"></a>4.2 交互式系统:</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。<br><strong>④: 时间片轮转</strong><br>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p><strong>时间片轮转算法的效率和时间片的大小有很大关系：</strong></p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><strong>⑤: 优先级调度</strong></p><p>为每个进程分配一个优先级，按优先级进行调度。<br>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p>⑥: <strong>多级反馈队列</strong></p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此<strong>只有上一个队列没有进程在排队，才能调度当前队列上的进程。</strong></p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><h3 id="4-3-实时系统"><a href="#4-3-实时系统" class="headerlink" title="4.3 实时系统"></a>4.3 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="五、进程同步"><a href="#五、进程同步" class="headerlink" title="五、进程同步:"></a>五、进程同步:</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区:"></a>临界区:</h3><p>对临界资源进行访问的那段代码称为临界区。<br>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥:"></a>同步与互斥:</h3><p>同步：多个进程按一定顺序执行；<br>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量:"></a>信号量:</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 P 和 V 操作。</p><ul><li><strong>P</strong>: 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>V</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P 操作。</li></ul><p>P, V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p><strong>如果信号量的取值只能为 0 或者 1</strong>，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用信号量实现生产者-消费者问题</strong> </p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p><strong>注意，不能先对缓冲区进行加锁，再测试信号量。</strong>也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、关于管程"><a href="#六、关于管程" class="headerlink" title="六、关于管程:"></a>六、关于管程:</h2><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。<br><strong>c 语言不支持管程</strong></p><p><strong>管程有一个重要特性：</strong><br>在一个时刻只能有一个进程使用管程。<br>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。<br>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。<br>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。<br>signal() 操作用于唤醒被阻塞的进程。</p><h2 id="七、进程的通信"><a href="#七、进程的通信" class="headerlink" title="七、进程的通信:"></a>七、进程的通信:</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：<br>进程同步：控制多个进程按一定顺序执行；<br>进程通信：进程间传输信息</p><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="八、关于管道"><a href="#八、关于管道" class="headerlink" title="八、关于管道:"></a>八、关于管道:</h2><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程中使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、关于进程&quot;&gt;&lt;a href=&quot;#一、关于进程&quot; class=&quot;headerlink&quot; title=&quot;一、关于进程:&quot;&gt;&lt;/a&gt;一、关于进程:&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是进程&quot;&gt;&lt;a href=&quot;#1-1-什么是进程&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是进程?&quot;&gt;&lt;/a&gt;1.1 什么是进程?&lt;/h3&gt;&lt;p&gt;进程是具有独立功能的&lt;strong&gt;程序在某个数据集合上的一次运行活动&lt;/strong&gt;，也是操作系统进行&lt;strong&gt;资源分配和保护的基本单位。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2-进程的组成部分&quot;&gt;&lt;a href=&quot;#1-2-进程的组成部分&quot; class=&quot;headerlink&quot; title=&quot;1.2 进程的组成部分:&quot;&gt;&lt;/a&gt;1.2 进程的组成部分:&lt;/h3&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程管理" scheme="https://zzwwqq.xyz/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://zzwwqq.xyz/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/数据链路层.html</id>
    <published>2019-03-31T07:37:34.000Z</published>
    <updated>2019-03-31T09:03:58.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据链路层设备"><a href="#一、数据链路层设备" class="headerlink" title="一、数据链路层设备:"></a>一、数据链路层设备:</h2><p>①: 网桥或桥接器:<br>②: 交换机:<br>　　<strong>实质: </strong>是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器<br>　　<strong>特点:</strong></p><ul><li><strong>全双工:</strong></li><li><strong>并行性: </strong>即能同时连通多对接口，使多对主机能同时通信</li><li><strong>自学习: </strong>即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。</li></ul><a id="more"></a><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.4.png" alt></p><p><strong>优点:</strong></p><p>对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s.</p><p>③:  网络适配器又称网络接口卡，网卡</p><p><strong>网络适配器是什么?</strong></p><p>网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。</p><p><strong>网络适配器的主要作用：</strong></p><ul><li>它是主机与介质的桥梁设备</li><li>实现主机与介质之间的电信号匹配</li><li>提供数据缓冲能力</li><li>控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。)</li></ul><p>网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。</p><h2 id="二、数据链路层协议"><a href="#二、数据链路层协议" class="headerlink" title="二、数据链路层协议:"></a>二、数据链路层协议:</h2><h3 id="2-1-PPP协议-Point-to-Point-Protocal-（点到点）"><a href="#2-1-PPP协议-Point-to-Point-Protocal-（点到点）" class="headerlink" title="2.1 PPP协议:  Point-to-Point Protocal; （点到点）"></a>2.1 PPP协议:  Point-to-Point Protocal; （点到点）</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点:"></a>2.1.1 特点:</h3><p>①: 简单<br>②: 只检错,不纠错<br>③: 不使用序号,不进行流量控制</p><h3 id="2-1-2-PPP-的帧格式："><a href="#2-1-2-PPP-的帧格式：" class="headerlink" title="2.1.2 PPP 的帧格式："></a>2.1.2 PPP 的帧格式：</h3><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.3.png" alt></p><h3 id="2-2-PPPoE协议"><a href="#2-2-PPPoE协议" class="headerlink" title="2.2 PPPoE协议:"></a>2.2 PPPoE协议:</h3><p>是为宽带上网的主机使用的链路层协议</p><h3 id="2-3-CSMA-CD协议"><a href="#2-3-CSMA-CD协议" class="headerlink" title="2.3 CSMA/CD协议:"></a>2.3 CSMA/CD协议:</h3><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h2 id="三、数据链路层基本单元"><a href="#三、数据链路层基本单元" class="headerlink" title="三、数据链路层基本单元:"></a>三、数据链路层基本单元:</h2><p>帧</p><h2 id="四、数据链路层三个基本问题"><a href="#四、数据链路层三个基本问题" class="headerlink" title="四、数据链路层三个基本问题:"></a>四、数据链路层三个基本问题:</h2><h3 id="4-1-封装成帧"><a href="#4-1-封装成帧" class="headerlink" title="4.1 封装成帧:"></a>4.1 封装成帧:</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.1.png" alt></p><h3 id="4-2-透明传输"><a href="#4-2-透明传输" class="headerlink" title="4.2 透明传输:"></a>4.2 透明传输:</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.2.png" alt></p><h3 id="4-3-差错检测"><a href="#4-3-差错检测" class="headerlink" title="4.3 差错检测:"></a>4.3 差错检测:</h3><p>循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.7.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.8.png" alt></p><h2 id="五、数据链路层使用的信道"><a href="#五、数据链路层使用的信道" class="headerlink" title="五、数据链路层使用的信道:"></a>五、数据链路层使用的信道:</h2><h3 id="5-1-点对点信道"><a href="#5-1-点对点信道" class="headerlink" title="5.1 点对点信道:"></a>5.1 点对点信道:</h3><p><strong>一对一通信。</strong><br>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h3 id="5-2-广播信道"><a href="#5-2-广播信道" class="headerlink" title="5.2 广播信道:"></a>5.2 广播信道:</h3><p>①: <strong>一对多通信</strong>，一个节点发送的数据能够被广播信道上所有的节点接收到。<br>②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。<br>③: 主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用<strong>CSMA/CD 协议。</strong></p><h2 id="六、数据链路层功能："><a href="#六、数据链路层功能：" class="headerlink" title="六、数据链路层功能："></a>六、数据链路层功能：</h2><p>①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输<br>②: 组帧（Framing）<br>③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端<br>④: 流量控制（Flow control）:避免淹没接收端<br>⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧<br>⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权</p><h2 id="七、MAC-地址"><a href="#七、MAC-地址" class="headerlink" title="七、MAC 地址:"></a>七、MAC 地址:</h2><p>MAC 地址是<strong>链路层地址</strong>，长度为 6 字节（48 位），用于<strong>唯一标识网络适配器（网卡）</strong>。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="八、以太网"><a href="#八、以太网" class="headerlink" title="八、以太网:"></a>八、以太网:</h2><h3 id="8-1-以太网是一种星型拓扑结构局域网。"><a href="#8-1-以太网是一种星型拓扑结构局域网。" class="headerlink" title="8.1 以太网是一种星型拓扑结构局域网。"></a>8.1 以太网是一种星型拓扑结构局域网。</h3><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h3 id="8-2-特点"><a href="#8-2-特点" class="headerlink" title="8.2 特点:"></a>8.2 特点:</h3><p>采用的协议: CSMA/CD<br>采用无连接,半双工通信<br>对数据帧不进行编号<br>尽最大努力交付(不可靠)<br>不要求对方确认<br>发送的数据都以曼彻斯特编码<br>收到错帧就丢弃</p><h3 id="8-3-以太网帧格式："><a href="#8-3-以太网帧格式：" class="headerlink" title="8.3 以太网帧格式："></a>8.3 以太网帧格式：</h3><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.5.png" alt></p><h2 id="九、局域网"><a href="#九、局域网" class="headerlink" title="九、局域网:"></a>九、局域网:</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.6.png" alt></p><h2 id="十、10BASE-T"><a href="#十、10BASE-T" class="headerlink" title="十、10BASE-T:"></a>十、10BASE-T:</h2><p>10 代表 10Mbit/s<br>BASE : 连接线上的信号为基带信号<br>T: 双绞线</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据链路层设备&quot;&gt;&lt;a href=&quot;#一、数据链路层设备&quot; class=&quot;headerlink&quot; title=&quot;一、数据链路层设备:&quot;&gt;&lt;/a&gt;一、数据链路层设备:&lt;/h2&gt;&lt;p&gt;①: 网桥或桥接器:&lt;br&gt;②: 交换机:&lt;br&gt;　　&lt;strong&gt;实质: &lt;/strong&gt;是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器&lt;br&gt;　　&lt;strong&gt;特点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全双工:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行性: &lt;/strong&gt;即能同时连通多对接口，使多对主机能同时通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自学习: &lt;/strong&gt;即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数据链路层" scheme="https://zzwwqq.xyz/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://zzwwqq.xyz/%E7%89%A9%E7%90%86%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/物理层.html</id>
    <published>2019-03-31T07:16:47.000Z</published>
    <updated>2019-03-31T09:09:04.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传输模式"><a href="#一、传输模式" class="headerlink" title="一、传输模式:"></a>一、传输模式:</h2><p><strong>单工</strong>（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户<br><strong>半双工</strong>（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信<br><strong>全双工</strong>（full-duplex）:发送的同时也可以接收数据</p><a id="more"></a><h2 id="二、信道复用技术"><a href="#二、信道复用技术" class="headerlink" title="二、信道复用技术:"></a>二、信道复用技术:</h2><h3 id="2-1-频分复用"><a href="#2-1-频分复用" class="headerlink" title="2.1 频分复用:"></a>2.1 频分复用:</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.1.png" alt></p><h3 id="2-2-时分复用"><a href="#2-2-时分复用" class="headerlink" title="2.2 时分复用:"></a>2.2 时分复用:</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.2.png" alt></p><h3 id="2-3-波分复用"><a href="#2-3-波分复用" class="headerlink" title="2.3 波分复用:"></a>2.3 波分复用:</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="2-4-码分复用"><a href="#2-4-码分复用" class="headerlink" title="2.4 码分复用"></a>2.4 码分复用</h3><h3 id="2-5-统计时分复用"><a href="#2-5-统计时分复用" class="headerlink" title="2.5 统计时分复用:"></a>2.5 统计时分复用:</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.4.png" alt></p><h2 id="三、物理层的主要任务"><a href="#三、物理层的主要任务" class="headerlink" title="三、物理层的主要任务:"></a>三、物理层的主要任务:</h2><p>确定与传输媒体的接口有关的一些特性(机械,电气,功能,过程特性)</p><h2 id="四、物理层设备"><a href="#四、物理层设备" class="headerlink" title="四、物理层设备:"></a>四、物理层设备:</h2><p>转发器:<br>集线器: 它的每个接口,是简单的转发比特,不进行碰撞检测<br>中继器: 是一种简单的增加局域网传输距离的设备，如作为信号放大器，可使实际的网络跨越更大的距离，它工作在物理层</p><h2 id="五、物理层基本单元"><a href="#五、物理层基本单元" class="headerlink" title="五、物理层基本单元:"></a>五、物理层基本单元:</h2><p>比特</p><h2 id="六、常用编码方式"><a href="#六、常用编码方式" class="headerlink" title="六、常用编码方式:"></a>六、常用编码方式:</h2><p>不归零: 与比特流一致<br>归零: 到了高/低电平后,将回到低电平<br>曼彻斯特: 中心向下为1<br>差分曼彻斯特: 位开始无跳变为1,位中心始终跳变</p><h2 id="七、物理层规范"><a href="#七、物理层规范" class="headerlink" title="七、物理层规范:"></a>七、物理层规范:</h2><p><strong>物理层定义的是规范，不能说是协议</strong><br>例如: EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、传输模式&quot;&gt;&lt;a href=&quot;#一、传输模式&quot; class=&quot;headerlink&quot; title=&quot;一、传输模式:&quot;&gt;&lt;/a&gt;一、传输模式:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单工&lt;/strong&gt;（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户&lt;br&gt;&lt;strong&gt;半双工&lt;/strong&gt;（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信&lt;br&gt;&lt;strong&gt;全双工&lt;/strong&gt;（full-duplex）:发送的同时也可以接收数据&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="物理层" scheme="https://zzwwqq.xyz/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP</title>
    <link href="https://zzwwqq.xyz/%E5%85%B3%E4%BA%8EHTTP.html"/>
    <id>https://zzwwqq.xyz/关于HTTP.html</id>
    <published>2019-03-30T12:52:15.000Z</published>
    <updated>2019-03-30T16:07:53.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、区分URI-URL-URN"><a href="#一、区分URI-URL-URN" class="headerlink" title="一、区分URI,URL,URN:"></a>一、区分URI,URL,URN:</h2><p>URI 包含 URL 和 URN。</p><a id="more"></a><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.1.png" alt></p><h2 id="二、关于HTTP协议"><a href="#二、关于HTTP协议" class="headerlink" title="二、关于HTTP协议:"></a>二、关于HTTP协议:</h2><h3 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么?"></a>2.1 是什么?</h3><p>是一个基于(客户端/服务器)请求与响应模式的、<strong>无连接,</strong>  <strong>无状态的</strong>、<strong>应用层的协议</strong>，<strong>常基于TCP的连接方式</strong>，<strong>HTTP1.1</strong>版本中给出一种<strong>持续连接的机制</strong>，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</p><h3 id="2-2-HTTP协议的主要特点"><a href="#2-2-HTTP协议的主要特点" class="headerlink" title="2.2 HTTP协议的主要特点?"></a>2.2 HTTP协议的主要特点?</h3><p>①:   无连接：  限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>②:   无状态： HTTP协议是无状态协议,   无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>③:  传输数据类型灵活：     HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</p><p>④:  传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><h3 id="2-3-HTTP请求报文"><a href="#2-3-HTTP请求报文" class="headerlink" title="2.3 HTTP请求报文:"></a>2.3 HTTP请求报文:</h3><p>请求行,请求头,请求空行,请求体</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.2.png" alt></p><h3 id="2-4-HTTP响应报文"><a href="#2-4-HTTP响应报文" class="headerlink" title="2.4 HTTP响应报文:"></a>2.4 HTTP响应报文:</h3><p>状态行,响应头,响应空行,响应体</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.3.png" alt></p><h3 id="2-5-HTTP方法"><a href="#2-5-HTTP方法" class="headerlink" title="2.5 HTTP方法:"></a>2.5 HTTP方法:</h3><p>客户端发送的 <strong>请求报文</strong> <strong>第一行为请求行，</strong>包含了方法字段。</p><p>有九种方法: get,post,put,delete,head,patch,options,connect,trace</p><p><strong>HEAD:</strong><br>①: 作用: 获取报文首部<br>②: 和 GET 方法类似，但是不返回报文实体主体部分。<br>③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><p><strong>POST: </strong><br>作用: 传输实体主体<br>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p><strong>PUT:</strong><br>①: 作用: 上传文件<br>②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><p><strong>PATCH:</strong><br>①: 作用: 对资源进行部分修改<br>②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><p><strong>OPTIONS:</strong><br>①: 作用: 查询支持的方法<br>②: 查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><p><strong>CONNECT:</strong><br>①: 要求在与代理服务器通信时建立隧道<br>②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p><strong>TRACE:</strong><br>①: 追踪路径<br>②: 服务器会将通信路径返回给客户端。<br>③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h3 id="2-6-关于HTTP状态码"><a href="#2-6-关于HTTP状态码" class="headerlink" title="2.6 关于HTTP状态码:"></a>2.6 关于HTTP状态码:</h3><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（<strong>信息性状态码</strong>）</td><td>接收的请求正在处理<br><strong>100</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</td></tr><tr><td>2XX</td><td>Success（<strong>成功</strong>状态码）</td><td>请求正常处理完毕<br><strong>200 OK</strong></td></tr><tr><td>3XX</td><td>Redirection（<strong>重定向</strong>状态码）</td><td>需要进行附加操作以完成请求<br><strong>301</strong> ：永久性重定向<br><strong>302</strong>：临时性重定向</td></tr><tr><td>4XX</td><td>Client Error（<strong>客户端错误</strong>状态码）</td><td>服务器无法处理请求<br><strong>403 Forbidden</strong> ：请求被拒绝。<br><strong>404 Not Found</strong></td></tr><tr><td>5XX</td><td>Server Error（<strong>服务器错误</strong>状态码）</td><td>服务器处理请求出错<br><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。<br><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</td></tr></tbody></table><h3 id="2-7-连接管理"><a href="#2-7-连接管理" class="headerlink" title="2.7 : 连接管理:"></a>2.7 : 连接管理:</h3><h4 id="2-7-1-短连接与长连接"><a href="#2-7-1-短连接与长连接" class="headerlink" title="2.7.1 短连接与长连接:"></a>2.7.1 短连接与长连接:</h4><p>①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。<br>②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始<strong>默认是长连接的</strong>，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h4 id="2-7-2-流水线"><a href="#2-7-2-流水线" class="headerlink" title="2.7.2 流水线:"></a>2.7.2 流水线:</h4><p>①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<br>②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p><h4 id="2-7-3-Cookie"><a href="#2-7-3-Cookie" class="headerlink" title="2.7.3 Cookie:"></a>2.7.3 Cookie:</h4><p>①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 <strong>Cookie 来保存状态信息</strong>。</p><p>②: <strong>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>③: <strong>Cookie有什么用途?</strong></p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>④: <strong>Cookie的创建过程:</strong></p><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>⑤: <strong>Cookie的分类:</strong></p><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure><p>⑥: <strong>HttpOnly:</strong></p><ul><li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。</li><li>跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>⑦: <strong>Secure:</strong></p><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id="2-7-4-Session"><a href="#2-7-4-Session" class="headerlink" title="2.7.4 Session:"></a>2.7.4 Session:</h4><p>①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>③: <strong>使用 Session 维护用户登录状态的过程如下：</strong></p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><p>④: 浏览器禁用 Cookie:</p><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 <strong>URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</strong></p><h4 id="2-7-5-Cookie-与-Session-选择"><a href="#2-7-5-Cookie-与-Session-选择" class="headerlink" title="2.7.5 Cookie 与 Session 选择:"></a>2.7.5 Cookie 与 Session 选择:</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="2-8-常见端口"><a href="#2-8-常见端口" class="headerlink" title="2.8 常见端口:"></a>2.8 常见端口:</h3><p>Http端口80,        HTTPS端口443      DNS端口 53    FTP 端口21     SMTP端口 25</p><h2 id="三、HTTP-1-1-新特性"><a href="#三、HTTP-1-1-新特性" class="headerlink" title="三、HTTP/1.1 新特性:"></a>三、HTTP/1.1 新特性:</h2><p>①: 默认是长连接<br>②: 支持流水线<br>③: 支持同时打开多个 TCP 连接<br>④: 支持虚拟主机<br>⑤: 新增状态码 100<br>⑥: 支持分块传输编码<br>⑦: 新增缓存处理指令 max-age</p><h2 id="四、GET-和-POST-比较"><a href="#四、GET-和-POST-比较" class="headerlink" title="四、GET 和 POST 比较:"></a>四、GET 和 POST 比较:</h2><p><strong>从作用上来说: </strong><br>GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>从参数来说:</strong><br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。<br>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/<span class="number">1.1</span></span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p><strong>从缓存来说: </strong><br>如果要对响应进行缓存，需要满足以下条件：</p><p>①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。<br>②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。<br>③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。</p><p><strong>XMLHttpRequest: </strong></p><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><p>①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会<strong>先发送 Header 再发送 Data</strong>。但并不是所有浏览器会这么做，例如火狐就不会。<br>②: 而 GET 方法 <strong>Header 和 Data 会一起发送。</strong></p><h2 id="五-关于HTTPS"><a href="#五-关于HTTPS" class="headerlink" title="五: 关于HTTPS:"></a>五: 关于HTTPS:</h2><h3 id="5-1-HTTP-有以下安全性问题："><a href="#5-1-HTTP-有以下安全性问题：" class="headerlink" title="5.1 HTTP 有以下安全性问题："></a>5.1 HTTP 有以下安全性问题：</h3><p>①: 使用明文进行通信，内容可能会被窃听；<br>②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；<br>③: 无法证明报文的完整性，报文有可能遭篡改。</p><h3 id="5-2-什么是HTTPS"><a href="#5-2-什么是HTTPS" class="headerlink" title="5.2 什么是HTTPS?"></a>5.2 什么是HTTPS?</h3><p>HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.8.png" alt></p><p><strong>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong></p><h3 id="5-3-什么是SSL"><a href="#5-3-什么是SSL" class="headerlink" title="5.3 什么是SSL?"></a>5.3 什么是SSL?</h3><p>SSL（Secure Socket Layer，安全套接字层）：<br>1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><h3 id="5-4-什么是TLS"><a href="#5-4-什么是TLS" class="headerlink" title="5.4 什么是TLS?"></a>5.4 什么是TLS?</h3><p>TLS（Transport Layer Security，传输层安全）：<br>其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><strong>5.5 HTTPS的缺点: </strong></p><p>①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐<br>②: HTTPS 降低用户访问速度（多次握手）<br>③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）<br>④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密）</p><h2 id="六、关于加密"><a href="#六、关于加密" class="headerlink" title="六、关于加密:"></a>六、关于加密:</h2><h3 id="6-1-对称密钥加密-Symmetric-Key-Encryption"><a href="#6-1-对称密钥加密-Symmetric-Key-Encryption" class="headerlink" title="6.1 对称密钥加密:(Symmetric-Key Encryption)"></a>6.1 对称密钥加密:(Symmetric-Key Encryption)</h3><p>①: 有流式、分组两种，加密和解密都是使用的同一个密钥。<br>例如：DES、AES-GCM、ChaCha20-Poly1305等</p><p>优点：运算速度快；<br>缺点：无法安全地将密钥传输给通信方。</p><h3 id="6-2-非对称密钥加密"><a href="#6-2-非对称密钥加密" class="headerlink" title="6.2 非对称密钥加密:"></a>6.2 非对称密钥加密:</h3><p>①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p><p>例如：RSA、DSA、ECDSA、DH、ECDHE</p><p>②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(<strong>发消息: 公钥加密,私钥解密</strong>)<br>③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(<strong>签名: 私钥加密,公钥解密</strong>)</p><p>优点：可以更安全地将公开密钥传输给通信发送方；<br>缺点：运算速度慢。</p><h3 id="6-3-哈希算法"><a href="#6-3-哈希算法" class="headerlink" title="6.3 哈希算法:"></a>6.3 哈希算法:</h3><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p><p>例如：MD5、SHA-1、SHA-2、SHA-256 等</p><h3 id="6-4-数字签名"><a href="#6-4-数字签名" class="headerlink" title="6.4 数字签名:"></a>6.4 数字签名:</h3><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p><p>HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP</p><h3 id="6-3-HTTPS-采用的加密方式"><a href="#6-3-HTTPS-采用的加密方式" class="headerlink" title="6.3 HTTPS 采用的加密方式:"></a>6.3 HTTPS 采用的加密方式:</h3><p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输对称密钥</strong>来保证传输过程的安全性，之后使用<strong>对称密钥加密进行通信</strong>来保证通信过程的效率.</p><h2 id="七、关于认证"><a href="#七、关于认证" class="headerlink" title="七、关于认证:"></a>七、关于认证:</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p><strong>服务器</strong>的运营人员向 CA 提出<strong>公开密钥的申请</strong>，CA 在判明提出申请者的身份之后，会<strong>对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后<strong>绑定</strong>在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.4.png" alt></p><p>签名: 签名者的私钥加密,</p><p>认证: 使用签名者公钥解密</p><h2 id="八、完整性保护"><a href="#八、完整性保护" class="headerlink" title="八、完整性保护:"></a>八、完整性保护:</h2><p>①: SSL 提供报文摘要功能来进行完整性保护。<br>②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。<br>③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="九、关于代理"><a href="#九、关于代理" class="headerlink" title="九、关于代理:"></a>九、关于代理:</h2><h3 id="9-1-代理服务器接受客户端的请求，并且转发给其它服务器。"><a href="#9-1-代理服务器接受客户端的请求，并且转发给其它服务器。" class="headerlink" title="9.1 代理服务器接受客户端的请求，并且转发给其它服务器。"></a>9.1 代理服务器接受客户端的请求，并且转发给其它服务器。</h3><h3 id="9-2-使用代理的主要目的是："><a href="#9-2-使用代理的主要目的是：" class="headerlink" title="9.2 使用代理的主要目的是："></a>9.2 使用代理的主要目的是：</h3><p>①: 缓存<br>②: 负载均衡<br>③: 网络访问控制<br>④: 访问日志记录</p><h3 id="9-3-代理服务器分为正向代理和反向代理两种："><a href="#9-3-代理服务器分为正向代理和反向代理两种：" class="headerlink" title="9.3 代理服务器分为正向代理和反向代理两种："></a>9.3 代理服务器分为正向代理和反向代理两种：</h3><p><strong>举例: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.5.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.6.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.7.png" alt></p><h2 id="十、关于缓存"><a href="#十、关于缓存" class="headerlink" title="十、关于缓存:"></a>十、关于缓存:</h2><h3 id="10-1-优点"><a href="#10-1-优点" class="headerlink" title="10.1 优点:"></a>10.1 优点:</h3><p>①: 缓解服务器压力；<br>②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p><h3 id="10-2-实现方法"><a href="#10-2-实现方法" class="headerlink" title="10.2 实现方法"></a>10.2 实现方法</h3><p>①: 让代理服务器进行缓存；<br>②: 让客户端浏览器进行缓存。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、区分URI-URL-URN&quot;&gt;&lt;a href=&quot;#一、区分URI-URL-URN&quot; class=&quot;headerlink&quot; title=&quot;一、区分URI,URL,URN:&quot;&gt;&lt;/a&gt;一、区分URI,URL,URN:&lt;/h2&gt;&lt;p&gt;URI 包含 URL 和 URN。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="关于HTTP" scheme="https://zzwwqq.xyz/tags/%E5%85%B3%E4%BA%8EHTTP/"/>
    
  </entry>
  
  <entry>
    <title>java字符串</title>
    <link href="https://zzwwqq.xyz/java%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://zzwwqq.xyz/java字符串.html</id>
    <published>2019-03-29T10:51:55.000Z</published>
    <updated>2019-03-31T03:42:12.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字符串的特性"><a href="#一、字符串的特性" class="headerlink" title="一、字符串的特性:"></a>一、字符串的特性:</h2><p>String 被声明为 final，因此它不可被继承。</p><h2 id="二、不同JDK版本中String的区别"><a href="#二、不同JDK版本中String的区别" class="headerlink" title="二、不同JDK版本中String的区别:"></a>二、不同JDK版本中String的区别:</h2><p>①: 在 Java 8 中，String 内部使用 char 数组存储数据。</p><a id="more"></a><p>②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。<br>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2 id="三、String-与StringBuffer-StringBuilder的区别："><a href="#三、String-与StringBuffer-StringBuilder的区别：" class="headerlink" title="三、String 与StringBuffer,StringBuilder的区别："></a>三、String 与StringBuffer,StringBuilder的区别：</h2><h3 id="3-1-可变性"><a href="#3-1-可变性" class="headerlink" title="3.1 可变性:"></a>3.1 可变性:</h3><p>String的长度是<strong>不可变的</strong>，而StringBuffer和StringBuilder长度是<strong>可变的.</strong></p><p>也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”<br><strong>并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中.</strong></p><h3 id="3-2-线程安全"><a href="#3-2-线程安全" class="headerlink" title="3.2 线程安全:"></a>3.2 线程安全:</h3><p>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p><p><strong>StringBuffer的常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.1.png" alt></p><p><strong>String常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.4.png" alt></p><p><strong>StringBuffer和StringBuilder和String的效率比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">String text = <span class="string">""</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、字符串与其他数据类型的转换"><a href="#四、字符串与其他数据类型的转换" class="headerlink" title="四、字符串与其他数据类型的转换:"></a>四、字符串与其他数据类型的转换:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.2.png" alt></p><h3 id="4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法"><a href="#4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法" class="headerlink" title="4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)"></a>4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)</h3><p><strong>A ———&gt; B:      调用B的方法:</strong><br>①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)<br>②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法</p><h3 id="4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器"><a href="#4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器" class="headerlink" title="4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)"></a>4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)</h3><p>字符串———&gt;数组         调用字符串的方法<br>数组————&gt;字符串     调用字符串的构造器</p><p>③: 字符串——-&gt;字节数组 调用字符串的getBytes()<br>④: 字符串——-&gt;字符数组 调用字符串的toCharArray()</p><p>⑤: 字节数组——&gt;字符串  调用字符串的构造器<br>⑥: 字符数组——&gt;字符串   调用字符串的构造器</p><h2 id="五、字符串常量池（String-Pool）"><a href="#五、字符串常量池（String-Pool）" class="headerlink" title="五、字符串常量池（String Pool）:"></a>五、字符串常量池（String Pool）:</h2><p>①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在<strong>编译时期</strong>就确定。<br>还可以使用 String 的 intern() 方法在<strong>运行过程中</strong>将字符串添加到 String Pool 中。</p><p>②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="六、字符串字面量-和字符串对象"><a href="#六、字符串字面量-和字符串对象" class="headerlink" title="六、字符串字面量 和字符串对象:"></a>六、字符串字面量 和字符串对象:</h2><p>字面量指的是能够使用简单结构和符号创建对象的表达式。<br>如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。</p><h2 id="七、new-String-“abc”-创建了几个对象"><a href="#七、new-String-“abc”-创建了几个对象" class="headerlink" title="七、new String(“abc”)创建了几个对象?"></a>七、new String(“abc”)创建了几个对象?</h2><p><strong>使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。</strong></p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h2 id="八、关于”-”-和”equals”和String的intern-方法"><a href="#八、关于”-”-和”equals”和String的intern-方法" class="headerlink" title="八、关于”==” 和”equals”和String的intern()方法:"></a>八、关于”==” 和”equals”和String的intern()方法:</h2><p>①: “==”比较的是地址<br>②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.<br>所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.<br>③: String类重写了equals方法<br>④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><p><strong>关于intern():</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String s0= “kvill”; </span><br><span class="line">String s1=<span class="keyword">new</span> String(”kvill”); </span><br><span class="line">String s2=<span class="keyword">new</span> String(“kvill”); </span><br><span class="line">System.out.println( s0==s1 ); </span><br><span class="line">System.out.println( “**********” ); </span><br><span class="line">s1.intern(); </span><br><span class="line">s2=s2.intern(); <span class="comment">//把常量池中“kvill”的引用赋给s2 </span></span><br><span class="line">System.out.println( s0==s1); </span><br><span class="line">System.out.println( s0==s1.intern() ); </span><br><span class="line">System.out.println( s0==s2 );</span><br><span class="line"></span><br><span class="line">结果为： </span><br><span class="line"><span class="keyword">false</span> </span><br><span class="line">********** </span><br><span class="line"><span class="keyword">false</span> <span class="comment">//虽然执行了s1.intern(),但它的返回值没有赋给s1 </span></span><br><span class="line"><span class="keyword">true</span> <span class="comment">//说明s1.intern()返回的是常量池中”kvill”的引用 </span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>几个结论: </strong></p><ol><li><p>直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。</p></li><li><p>new出来的字符串是存放在堆里面。</p></li><li><p>对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</p><ul><li><p>表达式右边是纯字符串常量，那么存放在常量池里面。</p></li><li><p>表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;        <span class="comment">//str1存放的值是字符串常量池中字符串aaa对象的地址.</span></span><br><span class="line">String str2 = <span class="string">"bbb"</span>;</span><br><span class="line">String str3 = <span class="string">"aaabbb"</span>;</span><br><span class="line">String str4 = str1 + str2;  <span class="comment">//str4存放的是堆中字符串aaabbb对象的地址</span></span><br><span class="line">String str5 = <span class="string">"aaa"</span> + <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析:</span></span><br><span class="line">结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而</span><br><span class="line">str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。</span><br><span class="line">其实Integer这种包装类型的-<span class="number">128</span> ~ +<span class="number">127</span>也是存放在常量池里面，比如Integer i1 = <span class="number">10</span>;Integer i2 = <span class="number">10</span>; i1 == i2结果是<span class="keyword">true</span>，估计也是为了性能优化。</span><br></pre></td></tr></table></figure><h2 id="九、五个关于字符串的算法题"><a href="#九、五个关于字符串的算法题" class="headerlink" title="九、五个关于字符串的算法题:"></a>九、五个关于字符串的算法题:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="number">1</span>. 模拟一个trim方法，去除字符串两端的空格 。</span><br><span class="line"> * <span class="number">2</span>. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 </span><br><span class="line"> * <span class="number">3</span>. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。</span><br><span class="line"> * <span class="number">4</span>. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = <span class="string">"abcwercvhelloobnm"</span>。</span><br><span class="line"> * <span class="number">5</span>.对字符串中字符进行自然排序</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. 模拟trim方法，去除字符串两端的空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断字符串str前面是否有空格</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(start) == <span class="string">' '</span>) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(start);</span><br><span class="line"><span class="comment">// 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(end) == <span class="string">' '</span>) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(end);</span><br><span class="line"> <span class="comment">// 方法一：</span></span><br><span class="line"> <span class="keyword">char</span>[]a = <span class="keyword">new</span> <span class="keyword">char</span>[end-start+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++,j++) &#123;</span><br><span class="line"> System.out.print(i+<span class="string">" "</span>);</span><br><span class="line"> a[j] = str.charAt(i);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println();</span><br><span class="line"> <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line"> String str1 = <span class="keyword">new</span> String(a);</span><br><span class="line"> <span class="keyword">return</span> str1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 方法二：</span></span><br><span class="line"><span class="comment">//return str.substring(start, end + 1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverseString</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符串转换为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="keyword">return</span> myreverseArray(c, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myreverseArray</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start,j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line"><span class="keyword">char</span> temp = c[i];</span><br><span class="line">c[i] = c[j];</span><br><span class="line">c[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符数组转换为字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">String str1 = str.substring(<span class="number">0</span>,start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            str1 += c;</span><br><span class="line">&#125;</span><br><span class="line">str1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3. 获取一个字符串在另一个字符串中出现的次数.</span></span><br><span class="line"><span class="comment">// 判断str2 在 str1 中出现的次数</span></span><br><span class="line"><span class="comment">// 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">while</span> ((length = str1.indexOf(str2)) != -<span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">str1 = str1.substring(length + str2.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 获取两个字符串中最大相同字串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getMaxSubString</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">String maxStr = (str1.length() &gt; str2.length())? str1:str2;</span><br><span class="line">String minStr = (str1.length() &lt; str2.length())? str1:str2;</span><br><span class="line">        <span class="keyword">int</span> length = minStr.length();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = length - i; y &lt;= length; x++,y++) &#123;</span><br><span class="line">String str = minStr.substring(x,y);</span><br><span class="line">   <span class="keyword">if</span> (maxStr.contains(str)) &#123;</span><br><span class="line">   list.add(str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//5.对字符串中字符进行自然排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mySort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[]c = str.toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// @Test-myTrim</span></span><br><span class="line">String testString1 = <span class="string">"    abc  d    "</span>;</span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line">String testString2 = <span class="string">"              "</span>;</span><br><span class="line">        </span><br><span class="line">String str1 = StringDemo.myTrim(testString1);</span><br><span class="line">String str2 = StringDemo.myTrim(testString2);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str1 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str2 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">String str3 = str1.trim();</span><br><span class="line">String str4 = str2.trim();</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str3 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str4 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// @Test-myReverseString and myReverseArray</span></span><br><span class="line">String str5 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str6 = myReverseString(str5, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"原字符串："</span> + str5);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法一："</span> + str6);</span><br><span class="line">String str7 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str8 = reverseString2(str7, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法二："</span> + str8);</span><br><span class="line"><span class="keyword">int</span> count = getTime(<span class="string">"abkkcadkabkebfkabkskab"</span>, <span class="string">"abk"</span>);</span><br><span class="line">System.out.println(<span class="string">"出现次数为："</span> + count);</span><br><span class="line">    List&lt;String&gt; str9 = getMaxSubString(<span class="string">"abcwerathelloyuiodef"</span>, <span class="string">"abcwercvhellobnm"</span>);</span><br><span class="line">    System.out.println(str9);  </span><br><span class="line">    String str10 = <span class="string">"aediewfn"</span>;</span><br><span class="line">    String str11 = mySort(str10);</span><br><span class="line">    System.out.println(str11);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、字符串的特性&quot;&gt;&lt;a href=&quot;#一、字符串的特性&quot; class=&quot;headerlink&quot; title=&quot;一、字符串的特性:&quot;&gt;&lt;/a&gt;一、字符串的特性:&lt;/h2&gt;&lt;p&gt;String 被声明为 final，因此它不可被继承。&lt;/p&gt;
&lt;h2 id=&quot;二、不同JDK版本中String的区别&quot;&gt;&lt;a href=&quot;#二、不同JDK版本中String的区别&quot; class=&quot;headerlink&quot; title=&quot;二、不同JDK版本中String的区别:&quot;&gt;&lt;/a&gt;二、不同JDK版本中String的区别:&lt;/h2&gt;&lt;p&gt;①: 在 Java 8 中，String 内部使用 char 数组存储数据。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java字符串" scheme="https://zzwwqq.xyz/tags/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="https://zzwwqq.xyz/java%E9%9B%86%E5%90%88.html"/>
    <id>https://zzwwqq.xyz/java集合.html</id>
    <published>2019-03-29T06:49:49.000Z</published>
    <updated>2019-03-29T08:58:08.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、先来看两张图"><a href="#一、先来看两张图" class="headerlink" title="一、先来看两张图:"></a>一、先来看两张图:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.1.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.2.png" alt></p><h2 id="二、集合的分类"><a href="#二、集合的分类" class="headerlink" title="二、集合的分类:"></a>二、集合的分类:</h2><h3 id="2-1-Collection接口"><a href="#2-1-Collection接口" class="headerlink" title="2.1 Collection接口:"></a>2.1 Collection接口:</h3><p>List接口：存储有序，可重复的元素  ,遍历出来的顺序与添加<strong>顺序相同</strong></p><p>Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的<strong>位置无序</strong>))，不可重复的元素(不可</p><p>　　　　重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都</p><p>　　　　是Collection下定义的</p><h3 id="2-2-Map接口"><a href="#2-2-Map接口" class="headerlink" title="2.2 Map接口:"></a>2.2 Map接口:</h3><p><strong>注：Map接口不是Collection接口的子接口, 两者是并列关系</strong></p><h2 id="三、关于List接口"><a href="#三、关于List接口" class="headerlink" title="三、关于List接口:"></a>三、关于List接口:</h2><h3 id="3-1-List接口："><a href="#3-1-List接口：" class="headerlink" title="3.1 List接口："></a>3.1 List接口：</h3><p>存储有序，可重复的元素             遍历出来的顺序与添加顺序相同</p><h3 id="3-2-具体的实现类"><a href="#3-2-具体的实现类" class="headerlink" title="3.2 具体的实现类:"></a>3.2 具体的实现类:</h3><p>①: ArrayList(主要的实现类)<br>②: LinkedList(对于频繁的插入，删除操作   较适用)<br>③: Vector(古老的实现类，线程安全的，但效率低于ArrayList)</p><h2 id="四、关于Set接口"><a href="#四、关于Set接口" class="headerlink" title="四、关于Set接口:"></a>四、关于Set接口:</h2><h3 id="4-1-需要注意的是"><a href="#4-1-需要注意的是" class="headerlink" title="4.1 需要注意的是:"></a>4.1 需要注意的是:</h3><p>①: 通常说的” Set是无序的,  不可重复的 “  这句话中的无序是指的<strong>存储无序. </strong><br>②: 无论是HashSet,还是LinkedHashSet 存储都是无序,  且不可重复的元素((指的是元素在底层存放的位置无序))<br>③: <strong>遍历是分为有序和无序的 </strong>,   HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.  </p><h3 id="4-2-如何保证set中元素不可重复"><a href="#4-2-如何保证set中元素不可重复" class="headerlink" title="4.2 如何保证set中元素不可重复?"></a>4.2 如何保证set中元素不可重复?</h3><p><strong>要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.</strong><br>让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),<br>重写hashCode（）方法让同一个对象能算出相同的hashCode值,,   进而保证Set中元素的不可重复性,,    注意:List只用重写equals方法就可以了</p><h3 id="4-3-Set中元素是如何存储的呢？"><a href="#4-3-Set中元素是如何存储的呢？" class="headerlink" title="4.3 Set中元素是如何存储的呢？"></a>4.3 Set中元素是如何存储的呢？</h3><p><strong>使用了哈希算法</strong><br>当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复).</p><p><strong>要求</strong>：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false;    )</p><p>万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此）</p><h3 id="4-4-具体的实现类"><a href="#4-4-具体的实现类" class="headerlink" title="4.4  具体的实现类:"></a>4.4  具体的实现类:</h3><p>①: HashSet(主要的实现类)<br>②: LinkedHashSet(HashSet的子类)<br>③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口)</p><p><strong>注:  一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer  又存储String类型)</strong></p><h4 id="4-4-1-关于TreeSet"><a href="#4-4-1-关于TreeSet" class="headerlink" title="4.4.1 关于TreeSet:"></a>4.4.1 关于TreeSet:</h4><p>当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序<br>①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）<br>②定制排序：（实现Comparator接口，重写compare方法）</p><p><strong>两种排序的区别:  </strong> </p><p>前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法<br>后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法.</p><p>向TreeSet中添加元素时，<strong>首先执行元素所属类的compareTo方法</strong>比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来</p><p><strong>注: </strong>只有当<strong>compareTo</strong>比较后得两个对象不相同时，再调用执行元素所属类的<strong>hashCode方法</strong>，最后调用<strong>equals方法</strong>   <strong>compareTo()与hashCode()以及equals()三者保持一致！</strong></p><h2 id="五、关于Map接口"><a href="#五、关于Map接口" class="headerlink" title="五、关于Map接口:"></a>五、关于Map接口:</h2><h3 id="5-1-Map接口元素的存储原理"><a href="#5-1-Map接口元素的存储原理" class="headerlink" title="5.1 Map接口元素的存储原理:"></a>5.1 Map接口元素的存储原理:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.3.png" alt></p><p>Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，<strong>需要重写hashCode和equals方法, </strong>     进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复</p><p><strong>例如:</strong><br>向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(<strong>后面的会覆盖前面的</strong>,这个与HashSet不同,HashSet是后面的那个不能添加进来)。</p><h3 id="5-2-遍历Map"><a href="#5-2-遍历Map" class="headerlink" title="5.2 遍历Map:"></a>5.2 遍历Map:</h3><p>有三类，分别是遍历key，遍历value，遍历key-value对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.遍历key集</span></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.遍历value集</span></span><br><span class="line"></span><br><span class="line">Collection values = map.values();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.遍历key-value对</span></span><br><span class="line"></span><br><span class="line">Set set2 = map.entrySet();   <span class="comment">//所有entry的集合就是entrySet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj:set2)   &#123;        <span class="comment">//遍历entrySet得到entry</span></span><br><span class="line"></span><br><span class="line">Map.Entry entry = (Map.Entry)obj;   <span class="comment">//获取entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键  和  值</span></span><br><span class="line"></span><br><span class="line">   System.out.println(entry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Map的初始化"><a href="#5-3-Map的初始化" class="headerlink" title="5.3 Map的初始化:"></a>5.3 Map的初始化:</h3><p>不能初始化为:      Map&lt;String,List<score>&gt;map=null;<br>而要用new对象的方式：Map&lt;String,List<score>&gt;map=newHashMap&lt;String,List<score>&gt;();否则会报错</score></score></score></p><h3 id="5-4-从map中取值"><a href="#5-4-从map中取值" class="headerlink" title="5.4 从map中取值:"></a>5.4 从map中取值:</h3><p>正确方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一:  String str = String.valueOf(map.get(<span class="string">"键名"</span>));</span><br><span class="line">方法二:  </span><br><span class="line">String str = (String) map.get(<span class="string">"ACCEPT_CHANNEL"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != str &amp;&amp; !<span class="string">""</span>.equals(str)) &#123;</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的取值方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = map.get(<span class="string">"键名"</span>).toString;  <span class="comment">//如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常</span></span><br></pre></td></tr></table></figure><p><strong>注: Map中的Key  value可以是任何引用类型的数据</strong></p><h3 id="5-5-Map接口的具体实现类"><a href="#5-5-Map接口的具体实现类" class="headerlink" title="5.5 Map接口的具体实现类:"></a>5.5 Map接口的具体实现类:</h3><p>①: HashTable : 古老的实现类，线程安全，不建议使用<br>②: HashMap:<br>③: LinkedHashMap(是HashMap的子类)<br>④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口)</p><h4 id="5-5-1-Properties介绍"><a href="#5-5-1-Properties介绍" class="headerlink" title="5.5.1  Properties介绍:"></a>5.5.1  Properties介绍:</h4><p>Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">读取属性文件jdbc.properties: </span><br><span class="line"></span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"jdbc.properties"</span>));</span><br><span class="line"></span><br><span class="line">pros.load(fi);</span><br><span class="line"></span><br><span class="line">读取xml配置文件config.xml: </span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">InputStream configInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"config/config.xml"</span>);</span><br><span class="line"></span><br><span class="line">properties.loadFromXML(configInputStream);</span><br></pre></td></tr></table></figure><h2 id="六、关于Collections-工具类"><a href="#六、关于Collections-工具类" class="headerlink" title="六、关于Collections 工具类:"></a>六、关于Collections 工具类:</h2><p>6.1 作用:  </p><p>　　　　操作Collection以及Map</p><p>6.2 注意:<br>　　　　区分Collection与Collections</p><p>6.3 实现list的复制: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的方式：出现java.lang.indexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//List list1=new ArrayList();</span></span><br><span class="line"><span class="comment">//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1</span></span><br><span class="line"><span class="comment">//System.out.println(list1);</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//正确的方式</span></span><br><span class="line">List list2 = Arrays.asList(newObject[list.size()]);</span><br><span class="line">Collections.copy(list2,list);</span><br><span class="line">System.out.println(list2);<span class="comment">//[123,456,12,78,456]</span></span><br></pre></td></tr></table></figure><p>6.4 考虑线程安全问题:  </p><p>List 是线程不安全的, synchronizedList方法可以保证List线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过如下的方法保证list的线程安全</span></span><br><span class="line">List list3=Collections.synchronizedList(list);</span><br><span class="line">System.out.println(list3);</span><br></pre></td></tr></table></figure><p>6.5常用函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转List中元素的顺序</span><br><span class="line">shuffle(List)：对List集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序</span><br><span class="line">sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</span><br><span class="line">swap(List,<span class="keyword">int</span>,<span class="keyword">int</span>)：将指定list集合中的i处元素和j处元素进行交换</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>:<span class="comment">//将src中的内容复制到dest中</span></span></span><br></pre></td></tr></table></figure><h2 id="七、集合的遍历方法：四种"><a href="#七、集合的遍历方法：四种" class="headerlink" title="七、集合的遍历方法：四种"></a>七、集合的遍历方法：四种</h2><p>①使用Iterator迭代器</p><p>②增强型for循环</p><p>③普通for循环</p><p>④Iterator迭代器的”古老版本”Enumeration 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Enumeration 接口是Iterator迭代器的"古老版本"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumeration</span> </span>&#123;</span><br><span class="line">　　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　　　　　　Enumeration enu = <span class="keyword">new</span> StringTokenizer(<span class="string">"ab-c*-df-g"</span>, <span class="string">"-"</span>);</span><br><span class="line">　　　　　　　<span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line">　　　　　　　　　　　System.out.println(enu.nextElement());</span><br><span class="line">　　　　　　　&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;    <span class="comment">//结果: 输出MM MM  MM   AA   BB   DD </span></span><br><span class="line">    String[]str=<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"DD"</span>&#125;;</span><br><span class="line">    <span class="comment">//表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值</span></span><br><span class="line">    <span class="keyword">for</span>(String s:str)&#123;   <span class="comment">//每循环一次, s都是一个新的局部变量</span></span><br><span class="line">        s=<span class="string">"MM"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        System.out.println(str[i]);          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、关于数组"><a href="#八、关于数组" class="headerlink" title="八、关于数组:"></a>八、关于数组:</h2><p>存储对象可以考虑：①数组，②集合<br>数组存储对象的特点：Student[] stu = new Student[20];  stu[0]=new Student();…..<br>弊端：①一旦创建，其长度不可变.      ②真实的数组存放的对象的个数是不可知的</p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结:"></a>九、总结:</h2><p>①:   单类型: 　　一个TreeSet对象<strong>必须存储同一种数据类型</strong>,例如: 不能既存储Integer  又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型.</p><p>②: 一致性:　　使用TreeSet时:   compareTo()与hashCode()以及equals()三者保持一致！</p><p>③:  执行流程：　向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法</p><p>④: 顺序性:    Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)<br>Set而言: 遍历是分为有序和无序的 ,   其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、先来看两张图&quot;&gt;&lt;a href=&quot;#一、先来看两张图&quot; class=&quot;headerlink&quot; title=&quot;一、先来看两张图:&quot;&gt;&lt;/a&gt;一、先来看两张图:&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.zzwwqq.xyz/static/image
      
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java集合" scheme="https://zzwwqq.xyz/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识</title>
    <link href="https://zzwwqq.xyz/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>https://zzwwqq.xyz/java基础知识.html</id>
    <published>2019-03-29T05:29:08.000Z</published>
    <updated>2019-03-29T10:40:35.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型:"></a>一、数据类型:</h2><h3 id="1-1-基本数据类型："><a href="#1-1-基本数据类型：" class="headerlink" title="1.1 基本数据类型："></a>1.1 基本数据类型：</h3><h4 id="1-1-1-整数类型："><a href="#1-1-1-整数类型：" class="headerlink" title="1.1.1 整数类型："></a>1.1.1 整数类型：</h4><p>byte（1个字节）      -128（-2^7）——–   127 (2^7-1)<br>short（2）     -32768(-2^15)——-   32767(2^15-1)<br>int（4）            （-2)^31 ——   2^31-1<br>long(8)             （-2)^63 ——   2^63-1  </p><a id="more"></a><p><strong>整数有三种表示形式：</strong><br>　　　八进制：以0开头，如012，-027<br>　　　十进制：<br>　　　十六进制：以0x 或0X开头，如0x123,-0X12</p><h4 id="1-1-2-浮点类型："><a href="#1-1-2-浮点类型：" class="headerlink" title="1.1.2 浮点类型："></a>1.1.2 浮点类型：</h4><p>float（4）     6或7位有效数字<br>double（8）    15位有效数字<br><strong>带小数点的数默认为：双精度浮点型</strong>（double），数字后带“d  或  D”，如“2.3d”，“d  或  D”可以省略<br><strong>注意：要表示单精度浮点型（float），必须在数字后面加“f  或  F”，如“13.23f”,“f 或  F”不可省略</strong></p><h4 id="1-1-3-字符类型："><a href="#1-1-3-字符类型：" class="headerlink" title="1.1.3 字符类型："></a>1.1.3 字符类型：</h4><p>char（2）</p><h4 id="1-1-4-布尔类型boolean："><a href="#1-1-4-布尔类型boolean：" class="headerlink" title="1.1.4 布尔类型boolean："></a>1.1.4 布尔类型boolean：</h4><p>false（4）必须小写<br>true（4）必须小写</p><p>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><h3 id="1-2-引用数据类型："><a href="#1-2-引用数据类型：" class="headerlink" title="1.2 引用数据类型："></a>1.2 引用数据类型：</h3><p>①: 类(class) 如String类<br>②: 接口(interface)<br>③: 数组<br>④: 枚举（enum）</p><h3 id="1-3-包装类型"><a href="#1-3-包装类型" class="headerlink" title="1.3 包装类型:"></a>1.3 包装类型:</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-2.2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><h2 id="二、常量与变量"><a href="#二、常量与变量" class="headerlink" title="二、常量与变量"></a>二、常量与变量</h2><p>①: 常量：由final修饰的</p><p>②: 变量：<br>　　　局部变量（位于方法（一般方法，构造方法，程序入口方法）中）<br>　　　全局变量（１.实例变量（无static修饰），２.类变量也称静态变量（有static修饰））</p><h2 id="三、强制类型转换"><a href="#三、强制类型转换" class="headerlink" title="三、强制类型转换:"></a>三、强制类型转换:</h2><p>3.1 小的转换为大的，系统会自动完成强制类型转换<br>如：short i = 10;<br>　　int j;<br>　　j=i;   (系统自动完成j = (int)i )<br>3.2 大的转换为小的，<strong>必须进行手动完成</strong>强制类型转换<br>如：int i = 10;<br>　　short j;<br>　　j = (short)i;</p><h2 id="四、构造方法"><a href="#四、构造方法" class="headerlink" title="四、构造方法:"></a>四、构造方法:</h2><h4 id="4-1-特点："><a href="#4-1-特点：" class="headerlink" title="4.1 特点："></a>4.1 特点：</h4><p>①: 构造方法只能由new操作符调用，即建立对象时自动调用；<br>②: 构造方法可以重载，即在同一个类中可以有多个构造方法<br>③: 构造方法没有返回类型，甚至连void也没有<br>④: 构造方法与类同名</p><p>注: 如果没有在类中写构造方法，系统会生成一个默认的无参构造方法，并使用默认值初始化对象的属性（int变量初始化为0，boolean 变量初始化为false）,如果写了有参构造方法,那么系统不会再自动生成无参构造方法,如果此时我们要用无参构造方法,需要我们手动写无参构造方法.</p><h4 id="4-2-作用：初始化对象，如给数据成员赋值"><a href="#4-2-作用：初始化对象，如给数据成员赋值" class="headerlink" title="4.2 作用：初始化对象，如给数据成员赋值"></a>4.2 作用：初始化对象，如给数据成员赋值</h4><p><strong>注意：一旦创建了一个有参数的构造方法，系统就不会自动添加默认的无参构造方法，要想用无参构造方法，需要人为的去创建一个无参构造方法</strong></p><h2 id="五、注释"><a href="#五、注释" class="headerlink" title="五、注释:"></a>五、注释:</h2><p>①: 文件注释：在包名之上，“/*……*/”，描述文件名(java工程名)，版权信息<br>②: 类注释：“/**……*/”，描述类的作用，版本version ，日期，作者<br>③: 私有成员：“/*……*/” 或“//”；如局部变量，某一个语句的功能作用</p><p> * @param 描述方法的参数</p><p> * @return 描述返回值，对于无返回值的方法或构造方法，@return可以省略</p><p> * @throws 描述在什么情况下抛出什么类型的异常</p><p> * @author 描述作者</p><p> * @version 描述版本 </p><p> * @since 描述该类可以运行的JDK版本</p><p> * @see 参考转向，也就是相关主题</p><p> * @link 转向成员的超链接。label为链接文字。package.class#member将被自动转换为指向package.class的member文件的URL</p><p>④: 共有成员：“/**……..*/”；如构造方法</p><h2 id="六、继承（extends）"><a href="#六、继承（extends）" class="headerlink" title="六、继承（extends）"></a>六、继承（extends）</h2><h4 id="6-1-含义"><a href="#6-1-含义" class="headerlink" title="6.1 含义:"></a>6.1 含义:</h4><p>其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正<strong>每次调子类的时候都会“自动运行”它父类的构造函数</strong>，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。<br>“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”。</p><h4 id="6-2-java中子类能不能继承父类构造方法？"><a href="#6-2-java中子类能不能继承父类构造方法？" class="headerlink" title="6.2 java中子类能不能继承父类构造方法？"></a>6.2 java中子类能不能继承父类构造方法？</h4><p><strong>答案是不能*</strong><br><strong>理由：</strong>其实每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。所以父类中的构造方法是不能继承的，但是在实例化子类的时候会调用父类的构造方法</p><p><strong>注意“调用”和继承不是一个含义，实质上是“自动运行”。</strong></p><h2 id="七、关于JavaBean"><a href="#七、关于JavaBean" class="headerlink" title="七、关于JavaBean:"></a>七、关于JavaBean:</h2><p>符合如下标准的Java类：<br>①: 实现serializable接口（这个不是必须的）<br>②: 必须有一个无参的公共的构造器（public修饰）<br>③: 必须属性用private修饰，且有get，set方法</p><h2 id="八、权限修饰符："><a href="#八、权限修饰符：" class="headerlink" title="八、权限修饰符："></a>八、权限修饰符：</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-2.1.png" alt></p><h2 id="九、抽象类："><a href="#九、抽象类：" class="headerlink" title="九、抽象类："></a>九、抽象类：</h2><p>特点：必须含抽象方法，其他的和一般类一样<br>抽象方法：只有声明没有实现的方法</p><h2 id="十、接口："><a href="#十、接口：" class="headerlink" title="十、接口："></a>十、接口：</h2><h4 id="10-1-特点："><a href="#10-1-特点：" class="headerlink" title="10.1 特点："></a>10.1 特点：</h4><p><strong>只含常量和抽象方法</strong><br>①: 接口中的常量都是public static final 类型(可以省略)，这是系统默认的<br>②: 接口中的方法都是public abstract类型(可以省略)，这是系统默认的<br>③: 接口 作为一种引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的该接口中的方法<br><strong>一个类要实现接口，必须实现这个接口中的所有方法</strong></p><p><strong>注意：通过一个接口变量只能调用该接口所声明的方法</strong>。 </p><h2 id="十一、重载和重写区别"><a href="#十一、重载和重写区别" class="headerlink" title="十一、重载和重写区别:"></a>十一、重载和重写区别:</h2><p>方法重载（Overload）：一个类中有多个方法，名字相同，参数不同（如参数个数，种类，参数顺序不同），与返回值无关；<br>方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，只是方法的实现不同</p><h2 id="十二、面向对象编程的四个基本特征"><a href="#十二、面向对象编程的四个基本特征" class="headerlink" title="十二、面向对象编程的四个基本特征:"></a>十二、面向对象编程的四个基本特征:</h2><p>①：抽象:<br>②：封装：把对象的数据和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节<br>③：继承：<br>④：多态性：<br><strong>多态的定义：</strong>是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。</p><p><strong>多态的举例：</strong>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。<br>同一个事件发生在不同的对象上会产生不同的结果。</p><p><strong>多态的作用：</strong>消除类型之间的耦合关系</p><p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p><strong>重载和重写都是多态的体现.</strong></p><h2 id="十三、异常与错误"><a href="#十三、异常与错误" class="headerlink" title="十三、异常与错误:"></a>十三、异常与错误:</h2><h3 id="12-1-异常"><a href="#12-1-异常" class="headerlink" title="12.1 异常:"></a>12.1 异常:</h3><h4 id="12-1-1-编译异常："><a href="#12-1-1-编译异常：" class="headerlink" title="12.1.1 编译异常："></a>12.1.1 编译异常：</h4><p>　　　　　　　由于程序语法不合规范，编译不通过</p><h4 id="12-1-2-运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）："><a href="#12-1-2-运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）：" class="headerlink" title="12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）："></a>12.1.2 运行异常（又称非检查性异常，此类异常可捕获可不捕获处理）：</h4><p>　　　　　　　编译通过，运行时出现异常。如数组下标越界，除数为零，数字格式错误，空指针异常</p><h4 id="12-1-3-非运行时异常（又称检查性异常，此类异常必须被捕获处理）："><a href="#12-1-3-非运行时异常（又称检查性异常，此类异常必须被捕获处理）：" class="headerlink" title="12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）："></a>12.1.3 非运行时异常（又称检查性异常，此类异常必须被捕获处理）：</h4><p>　　　　　　　如类没找到，IO操作错误</p><h4 id="12-1-4-逻辑异常："><a href="#12-1-4-逻辑异常：" class="headerlink" title="12.1.4 逻辑异常："></a>12.1.4 逻辑异常：</h4><p>　　　　　　　输出的结果不符合预期的要求</p><h4 id="12-1-5-try-catch-finally只有三种组合："><a href="#12-1-5-try-catch-finally只有三种组合：" class="headerlink" title="12.1.5 try ,catch ,finally只有三种组合："></a>12.1.5 try ,catch ,finally只有三种组合：</h4><p>​                                   a. try…catch…finally</p><p>​                                   b. try…catch</p><p>​                                   c. try…finally</p><p>①: 异常发生时，如果匹配的catch语句中抛出（有throw关键字）了异常，则finally之外的语句将不能被执行</p><p>②: finally中的语句无论什么情况都会执行</p><p>③: 得到有关异常信息：getMessage()</p><p>④: 用来跟踪异常事件发生时执行堆栈的内容：printStackTrace（）</p><h4 id="12-1-6-throws-和-throw-的区别："><a href="#12-1-6-throws-和-throw-的区别：" class="headerlink" title="12.1.6 throws 和 throw 的区别："></a>12.1.6 throws 和 throw 的区别：</h4><p>throws 关键字用于方法的声明部分，说明方法可能抛出的异常类型<br>throw 关键字用来抛出异常，如果抛出了检查性异常（非运行时异常），还必须在方法头部声明方法可能抛出的异常类，该方法的调用者还必须捕获处理抛出的异常,如果抛出非检查性异常（运行时异常），该方法的调用者可捕获可不捕获异常</p><h3 id="12-2-错误（Error）："><a href="#12-2-错误（Error）：" class="headerlink" title="12.2 错误（Error）："></a>12.2 错误（Error）：</h3><p>①：虚拟机错误（Virtual Machine Error）<br>②：连接错误（LinkageError）<br>③：图形界面错误（AWTError）</p><h2 id="十四、日期与时间"><a href="#十四、日期与时间" class="headerlink" title="十四、日期与时间:"></a>十四、日期与时间:</h2><h4 id="13-1-java中主要使用三个类来处理日期和时间"><a href="#13-1-java中主要使用三个类来处理日期和时间" class="headerlink" title="13.1 java中主要使用三个类来处理日期和时间:"></a>13.1 java中主要使用三个类来处理日期和时间:</h4><p>①: java.util.Date(日期) ,            ————–是一个具体类，用来表示一个时间点，表示的是（GMT即格林尼治标准时间）从1970年1月1日00:00:00这一刻开始经历的<strong>毫秒数</strong></p><p>②: java.util.Calendar（日历） ,      ————–是一个抽象类，用来解释和处理时间，设置和获取日期数据的特定部分</p><p>③: java.text.DateFormat（日期格式化）————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat<br>月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的<strong>大小写有要求</strong></p><h4 id="13-2-具体类Date的对象调用getTime（）方法得到的是毫秒数，形如：-1506582000000"><a href="#13-2-具体类Date的对象调用getTime（）方法得到的是毫秒数，形如：-1506582000000" class="headerlink" title="13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 1506582000000"></a>13.2 具体类Date的对象调用getTime（）方法得到的是毫秒数，形如： 1506582000000</h4><h4 id="13-3-抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun-Jul-23-12-15-52-PDT-2017"><a href="#13-3-抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun-Jul-23-12-15-52-PDT-2017" class="headerlink" title="13.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017"></a>13.3 抽象类Calendar的对象调用getTime（）方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017</h4><h4 id="13-4-对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23-12-15-52"><a href="#13-4-对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23-12-15-52" class="headerlink" title="13.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52"></a>13.4 对具体类Date和抽象类Calendar的时间进行格式化后，得到形如：2017-07-23 12:15:52</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据类型&quot;&gt;&lt;a href=&quot;#一、数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型:&quot;&gt;&lt;/a&gt;一、数据类型:&lt;/h2&gt;&lt;h3 id=&quot;1-1-基本数据类型：&quot;&gt;&lt;a href=&quot;#1-1-基本数据类型：&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本数据类型：&quot;&gt;&lt;/a&gt;1.1 基本数据类型：&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-整数类型：&quot;&gt;&lt;a href=&quot;#1-1-1-整数类型：&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 整数类型：&quot;&gt;&lt;/a&gt;1.1.1 整数类型：&lt;/h4&gt;&lt;p&gt;byte（1个字节）      -128（-2^7）——–   127 (2^7-1)&lt;br&gt;short（2）     -32768(-2^15)——-   32767(2^15-1)&lt;br&gt;int（4）            （-2)^31 ——   2^31-1&lt;br&gt;long(8)             （-2)^63 ——   2^63-1  &lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java基础" scheme="https://zzwwqq.xyz/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>初识java</title>
    <link href="https://zzwwqq.xyz/%E5%88%9D%E8%AF%86java.html"/>
    <id>https://zzwwqq.xyz/初识java.html</id>
    <published>2019-03-29T05:12:29.000Z</published>
    <updated>2019-03-29T06:31:58.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、发展历史"><a href="#一、发展历史" class="headerlink" title="一、发展历史"></a>一、发展历史</h2><p>①: java语言前身是oak（橡树）语言<br>②: java于1995年诞生于sun公司<br>③: 1996第一个JDK诞生<br>④: 1999 Sun发布J2SE，J2EE ,J2ME</p><h2 id="二、语言特点"><a href="#二、语言特点" class="headerlink" title="二、语言特点"></a>二、语言特点</h2><p>①: 面向对象<br>②: 分布式多线程<br>③: 健壮性(异常处理)<br>④: 安全<br>⑤: 可移植性</p><h2 id="三、Java技术体系分四个平台"><a href="#三、Java技术体系分四个平台" class="headerlink" title="三、Java技术体系分四个平台:"></a>三、Java技术体系分四个平台:</h2><p>①: Java Card: java小程序运行在小内存设备(智能卡)上的平台.<br>②: Java ME: 移动终端(手机)<br>③: JavaSE:  桌面级(Windows下的应用程序)<br>④: JavaEE  : 以前称J2EE ,企业级</p><h2 id="四、JDK和JRE"><a href="#四、JDK和JRE" class="headerlink" title="四、JDK和JRE"></a>四、JDK和JRE</h2><p>JDK: java开发工具包,包含了<strong>JRE</strong>、<strong>编译器</strong>和其它工具（如：<strong>javaDOc、java调试器)</strong> </p><h3 id="JDK目录结构"><a href="#JDK目录结构" class="headerlink" title="JDK目录结构:"></a>JDK目录结构:</h3><p>①: bin目录：包含编译器（javac.exe（c是compile（编译）的缩写）），解释器（java.exe），帮助文档生成器（javadoc.exe），打包工具（jar.exe），小应用程序浏览工具（appletviewer.exe）</p><p>②: lib目录：包含类库文件</p><p>③: demo目录：包含各种演示例子</p><p>④: include目录：包含C语言头文件，支持java本地接口</p><p>⑤: jre目录：包含java虚拟机，java应用启动器，运行时的类包</p><p>⑥: sample目录：sun配带的帮助学习者学习的java例子</p><p>⑦: src.zip:源码压缩文件</p><p>JDK:  Java程序设计语言   +   Java 虚拟机  +  JavaAPI类库</p><p>JRE :  JavaAPI中的<strong>Java SE API </strong>+ <strong>Java虚拟机</strong></p><p>因此 JDK包含JRE</p><h2 id="五、java虚拟机是什么？"><a href="#五、java虚拟机是什么？" class="headerlink" title="五、java虚拟机是什么？"></a>五、java虚拟机是什么？</h2><p>(Java Virtual Machine) 简称JVM  Java语言写的代码是.java文件，它会被特定程序编译(javac.exe，它会被Eclipse之类的IDE调用)成字节码(bytecode)，字节码不能直接在CPU上运行，需要另一个程序读取并执行，这个部件就是java虚拟机，它像机器一样运行编译好的java字节码，就像机器直接执行机器码一样……java虚拟机的外部接口在windows下主要是jvm.dll这个文件……<br><strong>简言之：jvm是Java开发语言中，用来运行Java字节码文件的平台；提供对Java字节码的解释及运行，位于JRE中</strong><br>JRE: java运行环境,包含java虚拟机和java程序所需的核心类库(javaSE API) 。<br>如果只是想跑java程序，那么只需安装JRE，如果要写java程序，那就需要JDK了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;768px&quot; height=&quot;367px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/java/java-1.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java开篇" scheme="https://zzwwqq.xyz/tags/java%E5%BC%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机之内存分配和回收</title>
    <link href="https://zzwwqq.xyz/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6.html"/>
    <id>https://zzwwqq.xyz/java虚拟机之内存分配和回收.html</id>
    <published>2019-03-29T02:31:01.000Z</published>
    <updated>2019-03-29T03:18:05.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、内存分配策略"><a href="#一、内存分配策略" class="headerlink" title="一、内存分配策略:"></a>一、内存分配策略:</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配:"></a>1. 对象优先在 Eden 分配:</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代:"></a>2. 大对象直接进入老年代:</h3><p>①: 大对象是指<strong>需要连续内存空间</strong>的对象，最典型的大对象是那种很长的字符串以及数组。<br>②: 经常出现大对象会<strong>提前触发垃圾收集</strong>以获取足够的连续空间分配给大对象。<br>⑤: -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><a id="more"></a><h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代:"></a>3. 长期存活的对象进入老年代:</h3><p>①: 为对象定义<strong>年龄计数器</strong>，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。<br>②: -XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定:"></a>4. 动态对象年龄判定:</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在<strong>Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保:"></a>5. 空间分配担保:</h3><p>在发生 Minor GC 之前，虚拟机<strong>先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h2 id="Minor-GC-的触发条件-当-Eden-空间满时，就将触发一次-Minor-GC"><a href="#Minor-GC-的触发条件-当-Eden-空间满时，就将触发一次-Minor-GC" class="headerlink" title="Minor GC 的触发条件: 当 Eden 空间满时，就将触发一次 Minor GC"></a>Minor GC 的触发条件: 当 Eden 空间满时，就将触发一次 Minor GC</h2><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件:"></a>Full GC 的触发条件:</h2><p>①:  老年代空间不足:<br>　　解决方案：<br>　　　　　　①：尽量不要创建过大的对象以及数组<br>　　　　　　②：通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。<br>　　　　　　③：通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><p>②: 空间分配担保失败</p><p>③:  调用 System.gc():  只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><p>④：JDK 1.7 及以前的永久代空间不足<br>　　解决方案：<br>　　　　　　①：可采用的方法为增大永久代空间<br>　　　　　　②：转为使用 CMS GC。</p><h2 id="二、内存回收："><a href="#二、内存回收：" class="headerlink" title="二、内存回收："></a>二、内存回收：</h2><h3 id="2-1-GC-分为两种：Minor-GC、Full-GC-或称为-Major-GC-。"><a href="#2-1-GC-分为两种：Minor-GC、Full-GC-或称为-Major-GC-。" class="headerlink" title="2.1 GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。"></a>2.1 GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。</h3><h3 id="2-1-1-Minor-GC-是发生在新生代中的垃圾收集动作，所采用的是复制算法。"><a href="#2-1-1-Minor-GC-是发生在新生代中的垃圾收集动作，所采用的是复制算法。" class="headerlink" title="2.1.1 Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。"></a>2.1.1 Minor GC 是发生在新生代中的垃圾收集动作，所采用的是<strong>复制算法。</strong></h3><p>新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。</p><h3 id="2-1-2-Full-GC-是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。"><a href="#2-1-2-Full-GC-是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。" class="headerlink" title="2.1.2 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。"></a>2.1.2 Full GC 是发生在老年代的垃圾收集动作，所采用的是<strong>标记-清除算法。</strong></h3><p>现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p><ul><li><p>Minor GC：<strong>回收新生代</strong>，因为新生代对象存活时间很短，因此 Minor GC 会<strong>频繁执行</strong>，执行的速度一般也会比较<strong>快</strong>。</p></li><li><p>Full GC：<strong>回收老年代和新生代</strong>，老年代对象其存活时间长，因此 Full GC <strong>很少执行</strong>，执行速度会比 Minor GC <strong>慢</strong>很多。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、内存分配策略&quot;&gt;&lt;a href=&quot;#一、内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;一、内存分配策略:&quot;&gt;&lt;/a&gt;一、内存分配策略:&lt;/h2&gt;&lt;h3 id=&quot;1-对象优先在-Eden-分配&quot;&gt;&lt;a href=&quot;#1-对象优先在-Eden-分配&quot; class=&quot;headerlink&quot; title=&quot;1. 对象优先在 Eden 分配:&quot;&gt;&lt;/a&gt;1. 对象优先在 Eden 分配:&lt;/h3&gt;&lt;p&gt;大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p&gt;
&lt;h3 id=&quot;2-大对象直接进入老年代&quot;&gt;&lt;a href=&quot;#2-大对象直接进入老年代&quot; class=&quot;headerlink&quot; title=&quot;2. 大对象直接进入老年代:&quot;&gt;&lt;/a&gt;2. 大对象直接进入老年代:&lt;/h3&gt;&lt;p&gt;①: 大对象是指&lt;strong&gt;需要连续内存空间&lt;/strong&gt;的对象，最典型的大对象是那种很长的字符串以及数组。&lt;br&gt;②: 经常出现大对象会&lt;strong&gt;提前触发垃圾收集&lt;/strong&gt;以获取足够的连续空间分配给大对象。&lt;br&gt;⑤: -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://zzwwqq.xyz/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zzwwqq.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-3无重复字符的最长子串</title>
    <link href="https://zzwwqq.xyz/LeetCode-3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html"/>
    <id>https://zzwwqq.xyz/LeetCode-3无重复字符的最长子串.html</id>
    <published>2019-03-28T13:09:04.000Z</published>
    <updated>2019-03-29T03:17:55.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"kew"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><p>给了我们一个字符串，让我们求最长的无重复字符的子串，注意<strong>这里是子串，不是子序列</strong>，所以<strong>必须是连续的。</strong></p><p>我们先不考虑代码怎么实现，如果给一个例子中的例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉第一次出现的b，以此类推，最终发现最长的长度为3。</p><p>所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。</p><p>进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个<strong>滑动窗口</strong>，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。<strong>窗口的右边界就是当前遍历到的字符的位置</strong>，为了求出窗口的大小，我们需要一个<strong>变量left来指向滑动窗口的左边界，</strong>这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。</p><p>参考链接:<br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h3&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode刷题" scheme="https://zzwwqq.xyz/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://zzwwqq.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机之垃圾收集</title>
    <link href="https://zzwwqq.xyz/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html"/>
    <id>https://zzwwqq.xyz/java虚拟机之垃圾收集.html</id>
    <published>2019-03-28T10:38:28.000Z</published>
    <updated>2019-03-28T13:05:01.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、垃圾收集"><a href="#一、垃圾收集" class="headerlink" title="一、垃圾收集:"></a>一、垃圾收集:</h2><h3 id="1-1哪些区域需要垃圾收集"><a href="#1-1哪些区域需要垃圾收集" class="headerlink" title="1.1哪些区域需要垃圾收集:"></a>1.1哪些区域需要垃圾收集:</h3><p>①: <strong>垃圾收集主要是针对堆和方法区进行。</strong><br>②: 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h2 id="二、判断一个对象是否可被回收"><a href="#二、判断一个对象是否可被回收" class="headerlink" title="二、判断一个对象是否可被回收:"></a>二、判断一个对象是否可被回收:</h2><h3 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法:"></a>2.1 引用计数算法:</h3><p>为对象添加一个引用计数器，当<strong>对象增加一个引用时计数器加 1</strong>，<strong>引用失效时计数器减 1</strong>。<strong>引用计数为 0 的对象可被回收。</strong><br>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法:"></a>2.2 可达性分析算法:</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。<br>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：<br>　　①: 虚拟机栈中局部变量表中引用的对象<br>　　②: 本地方法栈中 JNI 中引用的对象<br>　　③: 方法区中类静态属性引用的对象<br>　　④: 方法区中的常量引用的对象</p><h3 id="2-3-方法区的回收"><a href="#2-3-方法区的回收" class="headerlink" title="2.3 方法区的回收"></a>2.3 方法区的回收</h3><p>①: 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>②: 主要是对<strong>常量池的回收和对类的卸载。</strong></p><p>③: 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>④: 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li><p>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</p></li><li><p>加载该类的 ClassLoader 已经被回收。</p></li><li><p>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p></li></ul><h3 id="2-4-finalize"><a href="#2-4-finalize" class="headerlink" title="2.4. finalize()"></a>2.4. finalize()</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。<br>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h2 id="三、引用类型"><a href="#三、引用类型" class="headerlink" title="三、引用类型:"></a>三、引用类型:</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，<strong>判定对象是否可被回收都与引用有关。</strong></p><h3 id="Java-提供了四种强度不同的引用类型"><a href="#Java-提供了四种强度不同的引用类型" class="headerlink" title="Java 提供了四种强度不同的引用类型:"></a>Java 提供了四种强度不同的引用类型:</h3><h3 id="3-1-强引用"><a href="#3-1-强引用" class="headerlink" title="3.1 强引用"></a>3.1 强引用</h3><p>被强引用关联的对象<strong>不会被回收。</strong><br>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="3-2-软引用"><a href="#3-2-软引用" class="headerlink" title="3.2 软引用:"></a>3.2 软引用:</h3><p>被软引用关联的对象只有在<strong>内存不够的情况下才会被回收。</strong><br>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h3 id="3-3-弱引用"><a href="#3-3-弱引用" class="headerlink" title="3.3 弱引用:"></a>3.3 弱引用:</h3><p>被弱引用关联的对象一定会被回收，也就是说它<strong>只能存活到下一次垃圾回收发生之前。</strong><br>使用 WeakReference 类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用:"></a>4. 虚引用:</h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。<br>为一个对象设置虚引用的唯一目的: 是<strong>能在这个对象被回收时收到一个系统通知。</strong><br>使用 PhantomReference 来创建虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="四、垃圾收集算法"><a href="#四、垃圾收集算法" class="headerlink" title="四、垃圾收集算法:"></a>四、垃圾收集算法:</h2><h3 id="4-1-标记-清除"><a href="#4-1-标记-清除" class="headerlink" title="4.1 标记 - 清除:"></a>4.1 标记 - 清除:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-2.2.png" alt></p><p>标记要回收的对象，然后清除。<br><strong>不足：</strong><br>标记和清除过程效率都不高；<br>会<strong>产生大量不连续的内存碎片</strong>，导致无法给大对象分配内存。</p><h3 id="4-2-标记-整理"><a href="#4-2-标记-整理" class="headerlink" title="4.2 标记 - 整理:"></a>4.2 标记 - 整理:</h3><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><strong>优点: </strong>不会产生内存碎片</p><p><strong>不足:</strong> <strong>需要移动大量对象</strong>，处理效率比较低。</p><h3 id="4-3-复制"><a href="#4-3-复制" class="headerlink" title="4.3 复制:"></a>4.3 复制:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-2.1.png" alt></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p><strong>主要不足:</strong> 是<strong>只使用了内存的一半。</strong></p><p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p><h3 id="4-4-分代收集"><a href="#4-4-分代收集" class="headerlink" title="4.4 分代收集:"></a>4.4 分代收集:</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p><strong>一般将堆分为新生代和老年代。</strong></p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><h2 id="五、垃圾收集器"><a href="#五、垃圾收集器" class="headerlink" title="五、垃圾收集器:"></a>五、垃圾收集器:</h2><p>HotSpot 虚拟机中的 7 个垃圾收集器:</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h3 id="5-1-Serial-收集器"><a href="#5-1-Serial-收集器" class="headerlink" title="5.1 Serial 收集器:"></a>5.1 Serial 收集器:</h3><p>Serial 翻译为<strong>串行</strong>，也就是说它以串行的方式执行。</p><p>它是<strong>单线程的收集器</strong>，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 <strong>Client </strong>场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。    </p><h3 id="5-2ParNew-收集器"><a href="#5-2ParNew-收集器" class="headerlink" title="5.2ParNew 收集器:"></a>5.2ParNew 收集器:</h3><p>它是 Serial 收集器的<strong>多线程</strong>版本。</p><p>它是<strong>Server</strong>场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p><h3 id="5-3-Parallel-Scavenge-收集器"><a href="#5-3-Parallel-Scavenge-收集器" class="headerlink" title="5.3 Parallel Scavenge 收集器:"></a>5.3 Parallel Scavenge 收集器:</h3><p>与 ParNew 一样是<strong>多线程</strong>收集器。</p><p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</p><h3 id="5-4-Serial-Old-收集器"><a href="#5-4-Serial-Old-收集器" class="headerlink" title="5.4 Serial Old 收集器:"></a>5.4 Serial Old 收集器:</h3><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li><p>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</p></li><li><p>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</p></li></ul><h3 id="5-5-Parallel-Old-收集器"><a href="#5-5-Parallel-Old-收集器" class="headerlink" title="5.5 Parallel Old 收集器:"></a>5.5 Parallel Old 收集器:</h3><p>是 Parallel Scavenge 收集器的老年代版本。<br>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3 id="5-6-CMS-收集器"><a href="#5-6-CMS-收集器" class="headerlink" title="5.6 CMS 收集器:"></a>5.6 CMS 收集器:</h3><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>具有以下缺点：<br>①: 吞吐量低：<br>②: 无法处理浮动垃圾: 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。<br>③: 标记 - 清除算法导致空间碎片</p><h3 id="5-7-G1-收集器"><a href="#5-7-G1-收集器" class="headerlink" title="5.7 G1 收集器:"></a>5.7 G1 收集器:</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p><strong>堆被分为新生代和老年代</strong>，其它收集器进行收集的范围都是整个新生代或者老年代，而 <strong>G1 可以直接对新生代和老年代一起回收。</strong></p><p><strong>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</strong></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>参考链接:<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、垃圾收集&quot;&gt;&lt;a href=&quot;#一、垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾收集:&quot;&gt;&lt;/a&gt;一、垃圾收集:&lt;/h2&gt;&lt;h3 id=&quot;1-1哪些区域需要垃圾收集&quot;&gt;&lt;a href=&quot;#1-1哪些区域需要垃圾收集&quot; class=&quot;
      
    
    </summary>
    
      <category term="JVM" scheme="https://zzwwqq.xyz/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zzwwqq.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机</title>
    <link href="https://zzwwqq.xyz/java%E8%99%9A%E6%8B%9F%E6%9C%BA.html"/>
    <id>https://zzwwqq.xyz/java虚拟机.html</id>
    <published>2019-03-27T09:27:04.000Z</published>
    <updated>2019-03-31T03:22:48.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JVM是什么"><a href="#一、JVM是什么" class="headerlink" title="一、JVM是什么?"></a>一、JVM是什么?</h2><p>JVM是Java Virtual Machine（Java虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><h2 id="二、JVM的作用"><a href="#二、JVM的作用" class="headerlink" title="二、JVM的作用?"></a>二、JVM的作用?</h2><p>JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码字节码，就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p><h2 id="三、从进程的角度解释JVM"><a href="#三、从进程的角度解释JVM" class="headerlink" title="三、从进程的角度解释JVM"></a>三、从进程的角度解释JVM</h2><p>我们知道，虚拟机是运行在操作系统之中的，那么什么东西才能在操作系统中运行呢？当然是进程，因为进程是操作系统中的执行单位。可以这样理解，当它在运行的时候，它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放于文件系统中），可以把它叫做程序。</p><p>对命令行比较熟悉的同学，都知道其实一个命令对应一个可执行的二进制文件，当敲下这个命令并且回车后，就会创建一个进程，加载对应的可执行文件到进程的地址空间中，并且执行其中的指令。</p><h2 id="四、Java版HelloWord程序的编译和执行形式"><a href="#四、Java版HelloWord程序的编译和执行形式" class="headerlink" title="四、Java版HelloWord程序的编译和执行形式:"></a>四、Java版HelloWord程序的编译和执行形式:</h2><p>①: 首先编写源文件HelloWord.java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②: 编译Java版的HelloWorld程序：<code>$ javac HelloWorld.java</code></p><p>③: 运行Java版的HelloWorld程序：<code>$ java -classpath . HelloWorld</code></p><p>4.1 从上面的过程可以看到， 我们在运行Java版的HelloWorld程序的时候， 敲入的命令并不是 ./HelloWorld.class 。 因为class文件并不是可以直接被操作系统识别的二进制可执行文件 。 我们敲入的是java这个命令。 这个命令说明， 我们首先启动的是一个叫做java的程序， 这个java程序在运行起来之后就是一个JVM进程实例.</p><p>4.2 上面的命令执行流程是这样的：</p><p>java命令首先启动虚拟机进程，虚拟机进程成功启动后，读取参数“HelloWorld”，把他作为初始类加载到内存，对这个类进行初始化和动态链接，然后从这个类的main方法开始执行。</p><p>也就是说我们的.class文件不是直接被系统加载后直接在cpu上执行的，而是被一个叫做虚拟机的进程托管的。首先必须虚拟机进程启动就绪，然后由虚拟机中的类加载器加载必要的class文件，包括jdk中的基础类（如String和Object等），然后由虚拟机进程解释class字节码指令，把这些字节码指令翻译成本机cpu能够识别的指令，才能在cpu上运行.</p><p>4.3 从这个层面上来看，在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。</p><h2 id="五、JVM体系结构简介"><a href="#五、JVM体系结构简介" class="headerlink" title="五、JVM体系结构简介:"></a>五、JVM体系结构简介:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.2.png" alt></p><p>根据上图表达的内容，我们编译之后的class文件是作为Java虚拟机的原料被输入到Java虚拟机的内部的，那么具体由谁来做这一部分工作呢？其实在Java虚拟机内部，有一个叫做<strong>类加载器的子系统</strong>，这个子系统用来<strong>在运行时根据需要加载类。</strong>注意上面一句话中的“根据需要”四个字。在Java虚拟机执行过程中，<strong>只有他需要一个类的时候，才会调用类加载器来加载这个类，并不会在开始运行时加载所有的类。</strong>就像一个人，只有饿的时候才去吃饭，而不是一次把一年的饭都吃到肚子里。一般来说，<strong>虚拟机加载类的时机，在第一次使用一个新的类的时候</strong>。</p><p>由虚拟机加载的类，被加载到Java虚拟机内存中之后，虚拟机会读取并执行它里面存在的字节码指令。虚拟机中执行字节码指令的部分叫做<strong>执行引擎</strong>。就像一个人，不是把饭吃下去就完事了，还要进行消化，执行引擎就相当于人的肠胃系统。在执行的过程中还会把各个class文件动态的连接起来。</p><p>Java虚拟机会进行自动内存管理。具体说来就是自动释放没有用的对象，而不需要程序员编写代码来释放分配的内存。这部分工作由垃圾收集子系统负责。</p><p>一个Java虚拟机实例在运行过程中有三个子系统来保障它的正常运行，分别是类加载器子系统， 执行引擎子系统和垃圾收集子系统。 如下图所示：</p><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.3.png" alt></p><p>虚拟机的运行，必须加载class文件，并且执行class文件中的字节码指令。它做这么多事情，必须需要自己的空间。就像人吃下去的东西首先要放在胃中。虚拟机也需要空间来存放个中数据。首先，加载的字节码，需要一个单独的内存空间来存放；一个线程的执行，也需要内存空间来维护方法的调用关系，存放方法中的数据和中间计算结果；在执行的过程中，无法避免的要创建对象，创建的对象需要一个专门的内存空间来存放。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.4.png" alt></p><h3 id="5-1-Java虚拟机-运行时数据区"><a href="#5-1-Java虚拟机-运行时数据区" class="headerlink" title="5.1 Java虚拟机 运行时数据区:"></a>5.1 Java虚拟机 运行时数据区:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.5.png" alt></p><h4 id="5-1-1程序计数器"><a href="#5-1-1程序计数器" class="headerlink" title="5.1.1程序计数器:"></a>5.1.1程序计数器:</h4><p>①: <strong>是一块较小的内存空间</strong>,  当前线程执行的字节码的行号指示器(记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。)<br>②: 指向下一条需要执行的指令<br>③: 每条线程都需要一个独立的程序计数器,彼此互不干扰(线程私有的内存)</p><h4 id="5-1-2Java虚拟机栈"><a href="#5-1-2Java虚拟机栈" class="headerlink" title="5.1.2Java虚拟机栈:"></a>5.1.2Java虚拟机栈:</h4><p>①: 线程私有的,生命周期与线程相同<br>②: 描述java方法执行的内存模型,每个方法执行时都会创建一个<strong>栈帧</strong>,用来存放<strong>局部变量表</strong>,<strong>操作数栈</strong>,<strong>常量池引用</strong>等信息.<br>③: <strong>每个方法从调用到执行完成 就对应着栈帧在虚拟机栈帧中入栈和出栈.</strong><br>④: 两种异常:<br>　　　　　　StackOverFlow异常 :     线程所请求的栈深度大于虚拟机允许的则抛出<br>　　　　　　OutOffMemoryError异常:     扩展时无法申请到足够的内存则抛出<br>⑤: 我们常说的栈 和堆  中的栈就是Java虚拟机栈,更具体来说是Java虚拟机栈中的局部变量表部分.<br>⑥: 局部变量表:<br>　　　　　　存放编译期可知的各种基本数据类型,对象引用类型<br>　　　　　　所需要的内存空间在编译期完成分配,  在方法运行期间不会改变其大小<br>　　　　　　64位长度的long  和 double 类型数据会占用2个局部变量空间(Slot) ,其余占一个.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.6.png" alt></p><p>⑦: 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：<code>java -Xss512M HackTheJava</code></p><h4 id="5-1-3本地方法栈"><a href="#5-1-3本地方法栈" class="headerlink" title="5.1.3本地方法栈:"></a>5.1.3本地方法栈:</h4><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。<br>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><p><strong>上面三个区域随线程而生,  随线程而灭; </strong></p><h4 id="5-1-4Java堆-Java-Heap-也称GC堆-Garbage-Collected-Heap"><a href="#5-1-4Java堆-Java-Heap-也称GC堆-Garbage-Collected-Heap" class="headerlink" title="5.1.4Java堆( Java Heap) :  也称GC堆(Garbage  Collected  Heap  )"></a>5.1.4Java堆( Java Heap) :  也称GC堆(Garbage  Collected  Heap  )</h4><p>①: 是Java虚拟机管理的内存中最大的一块<br>②: 被所有线程共享,的一块内存空间,  在虚拟机启动时候创建,<br>③: 唯一目的:  存放对象实例, 几乎所有的对象实例  和 数组   都在这里这里分配内存.<br>④: <strong>是垃圾收集器管理的主要区域 ,所以也称GC堆</strong><br>⑤: 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。<br><code>java -Xms1M -Xmx2M HackTheJava</code><br>⑥: 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.7.png" alt></p><p>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p><h4 id="5-1-5方法区-永久代"><a href="#5-1-5方法区-永久代" class="headerlink" title="5.1.5方法区(永久代):"></a>5.1.5方法区(永久代):</h4><p>①: 被所有线程共享,的一块内存空间<br>②: 用来存储Class的相关信息如已经被Java虚拟机<strong>加载的类信息</strong>,<strong>常量</strong>,<strong>静态变量</strong>,即时编译器编译后的代码等数据。<br>③: 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。<br>④: <strong>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载</strong>，但是一般比较难实现。<br>⑤: HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，<strong>从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</strong>。</p><h4 id="5-1-5运行时常量池"><a href="#5-1-5运行时常量池" class="headerlink" title="5.1.5运行时常量池"></a>5.1.5运行时常量池</h4><p>①: <strong>运行时常量池是方法区的一部分。</strong><br>②: .Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。<br>③: 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。<br>④: <strong>常量池(constant pool)</strong>指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 </p><p>参考链接:<br><a href="https://baike.baidu.com/item/JVM" target="_blank" rel="noopener">https://baike.baidu.com/item/JVM</a><br><a href="https://blog.csdn.net/zhangjg_blog/article/details/20380971" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/20380971</a><br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md</a><br><a href="https://blog.csdn.net/gyqjn/article/details/49848473" target="_blank" rel="noopener">https://blog.csdn.net/gyqjn/article/details/49848473</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;768px&quot; height=&quot;367px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/JVM/jvm-1.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://zzwwqq.xyz/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zzwwqq.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之策略模式.html</id>
    <published>2019-03-27T02:59:53.000Z</published>
    <updated>2019-03-27T03:43:06.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是策略模式"><a href="#一、什么是策略模式" class="headerlink" title="一、什么是策略模式?"></a>一、什么是策略模式?</h2><p>定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp;<br>让算法可在不影响客户端的情况下发生变化<br>简单来说：准备一组算法 &amp; 将每一个算法封装起来，让外部按需调用 &amp; 使得互换</p><a id="more"></a><h2 id="二、如何使用-使用步骤"><a href="#二、如何使用-使用步骤" class="headerlink" title="二、如何使用?使用步骤?"></a>二、如何使用?使用步骤?</h2><p>步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口<br>步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动<br>步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员<br>步骤4：客户端调用-让销售员进行促销活动的落地</p><h2 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点:"></a>三、优点:</h2><p>①: 策略类之间可以自由切换,由于策略类都实现同一个接口，所以使它们之间可以自由切换<br>②: 易于扩展,增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码<br>③: 符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p><h2 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点:"></a>四、缺点:</h2><p>①: 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>②: 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</p><h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景:"></a>五、应用场景:</h2><p>动态选择多种复杂行为</p><h2 id="六、实例"><a href="#六、实例" class="headerlink" title="六、实例:"></a>六、实例:</h2><p>背景：小成有一家百货公司，最近在定年度的促销活动<br>冲突：每个节日用同一个促销活动太枯燥，没吸引力<br>解决方案：针对不同节目使用不同促销活动进行促销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</span></span><br><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为春节准备的促销活动A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为中秋节准备的促销活动B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为中秋准备的促销活动A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为国庆准备的促销活动C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为国庆准备的促销活动C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context_SaleMan</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy 具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context_SaleMan</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户展示促销活动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sale_ManShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤4：客户端调用-让销售员进行促销活动的落地</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span> </span>&#123;</span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Context_SaleMan saleMan;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择并创建需要使用的策略对象</span></span><br><span class="line">        <span class="comment">// 例如现在要做春节的活动</span></span><br><span class="line">        Strategy strategyA = <span class="keyword">new</span> StrategyA();</span><br><span class="line">        System.out.println(<span class="string">"对于春节："</span>);</span><br><span class="line">        <span class="comment">// 创建环境</span></span><br><span class="line">        saleMan = <span class="keyword">new</span> Context_SaleMan(strategyA);</span><br><span class="line">        saleMan.Sale_ManShow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择并创建需要使用的策略对象</span></span><br><span class="line">        <span class="comment">// 例如现在要做中秋节的活动</span></span><br><span class="line">        Strategy strategyB = <span class="keyword">new</span> StrategyB();</span><br><span class="line">        System.out.println(<span class="string">"对于中秋节："</span>);</span><br><span class="line">        <span class="comment">// 创建环境</span></span><br><span class="line">        saleMan = <span class="keyword">new</span> Context_SaleMan(strategyB);</span><br><span class="line">        saleMan.Sale_ManShow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择并创建需要使用的策略对象</span></span><br><span class="line">        <span class="comment">// 例如现在要做国庆节的活动</span></span><br><span class="line">        Strategy strategyC = <span class="keyword">new</span> StrategyC();</span><br><span class="line">        System.out.println(<span class="string">"对于国庆节："</span>);</span><br><span class="line">        <span class="comment">// 创建环境</span></span><br><span class="line">        saleMan = <span class="keyword">new</span> Context_SaleMan(strategyC);</span><br><span class="line">        saleMan.Sale_ManShow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是策略模式&quot;&gt;&lt;a href=&quot;#一、什么是策略模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是策略模式?&quot;&gt;&lt;/a&gt;一、什么是策略模式?&lt;/h2&gt;&lt;p&gt;定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp;amp;&lt;br&gt;让算法可在不影响客户端的情况下发生变化&lt;br&gt;简单来说：准备一组算法 &amp;amp; 将每一个算法封装起来，让外部按需调用 &amp;amp; 使得互换&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之策略模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之抽象工厂模式.html</id>
    <published>2019-03-26T08:50:29.000Z</published>
    <updated>2019-03-26T09:52:37.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是抽象工厂模式"><a href="#什么是抽象工厂模式" class="headerlink" title="什么是抽象工厂模式?"></a>什么是抽象工厂模式?</h2><p>抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，<br>而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p><a id="more"></a><h2 id="抽象工厂模式与工厂方法模式最大的区别"><a href="#抽象工厂模式与工厂方法模式最大的区别" class="headerlink" title="抽象工厂模式与工厂方法模式最大的区别?"></a>抽象工厂模式与工厂方法模式最大的区别?</h2><p>抽象工厂中每个工厂可以创建多种类的产品, 而工厂方法每个工厂只能创建一类.</p><h2 id="使用步骤-根据下图来理解"><a href="#使用步骤-根据下图来理解" class="headerlink" title="使用步骤:(根据下图来理解:)"></a>使用步骤:(根据下图来理解:)</h2><p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口；<br>步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；<br>步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；<br>步骤4： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；<br>步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例</p><p><img src="http://cdn.zzwwqq.xyz/static/images/设计模式/DesignPatterns-4.1.1.png" alt></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><p>①: 降低耦合:<br>　　　　　抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，<br>　　　　　可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；<br>②: 更符合开-闭原则:<br>　　　　　新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可<br>　　　　　而简单工厂模式需要修改工厂类的判断逻辑</p><p>③: 符合单一职责原则:<br>　　　　　每个具体工厂类只负责创建对应的产品，<br>　　　　　而简单工厂中的工厂类存在复杂的switch逻辑判断<br>④: 不使用静态工厂方法，可以形成基于继承的等级结构，<br>　而简单工厂模式的工厂类使用静态工厂方法</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h2><p>①: 抽象工厂模式很难支持新种类产品的变化。<br>这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。<br>②: 对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景:"></a>应用场景:</h2><p>①: 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。<br>②: 这个系统有多个系列产品，而系统中只消费其中某一系列产品<br>③: 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>背景：<br>　　小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂所在地的客户  　　也需要模具类产品，B厂所在地的客户也需要容器类产品；<br>冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂.<br>解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建抽象工厂类，定义具体工厂的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> Product  <span class="title">ManufactureContainer</span><span class="params">()</span></span>;<span class="comment">//容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> Product  <span class="title">ManufactureMould</span><span class="params">()</span></span>;<span class="comment">//模型</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建抽象产品族类 ，定义具体产品的公共接口；</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3： 创建抽象产品类 ，定义具体产品的公共接口；</span></span><br><span class="line"><span class="comment">//容器产品抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerProduct</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模型产品抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MouldProduct</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；</span></span><br><span class="line"><span class="comment">//容器产品A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerProductA</span> <span class="keyword">extends</span> <span class="title">ContainerProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了容器产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerProductB</span> <span class="keyword">extends</span> <span class="title">ContainerProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了容器产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模具产品A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouldProductA</span> <span class="keyword">extends</span> <span class="title">MouldProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了模具产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模具产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouldProductB</span> <span class="keyword">extends</span> <span class="title">MouldProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了模具产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；</span></span><br><span class="line"><span class="comment">//A厂 - 生产模具+容器产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContainerProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureMould</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MouldProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B厂 - 生产模具+容器产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContainerProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureMould</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MouldProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory myfactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        Factory myfactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        <span class="comment">//A厂当地客户需要容器产品A</span></span><br><span class="line">        myfactoryA.ManufactureContainer().show();</span><br><span class="line">        <span class="comment">//A厂当地客户需要模具产品A</span></span><br><span class="line">        myfactoryA.ManufactureMould().show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B厂当地客户需要容器产品B</span></span><br><span class="line">        myfactoryB.ManufactureContainer().show();</span><br><span class="line">        <span class="comment">//B厂当地客户需要模具产品B</span></span><br><span class="line">        myfactoryB.ManufactureMould().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是抽象工厂模式&quot;&gt;&lt;a href=&quot;#什么是抽象工厂模式&quot; class=&quot;headerlink&quot; title=&quot;什么是抽象工厂模式?&quot;&gt;&lt;/a&gt;什么是抽象工厂模式?&lt;/h2&gt;&lt;p&gt;抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，&lt;br&gt;而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之抽象工厂模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-2两数相加</title>
    <link href="https://zzwwqq.xyz/LeetCode-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html"/>
    <id>https://zzwwqq.xyz/LeetCode-2两数相加.html</id>
    <published>2019-03-26T04:39:10.000Z</published>
    <updated>2019-03-27T04:32:30.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><a id="more"></a><p> <strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><p>建立一个新链表，然后把输入的两个链表从头往后遍历，每两个相加，添加一个新节点到新链表后面。为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后，由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点。<br>好，可以开始让两个链表相加了，这道题好就好在最低位在链表的开头，所以我们可以在遍历链表的同时按从低到高的顺序直接相加。<br>while循环的条件两个链表中只要有一个不为空行，由于链表可能为空，所以我们在取当前结点值的时候，先判断一下，若为空则取0，否则取结点值。然后把两个结点值相加，同时还要加上进位carry。然后更新carry，直接 sum/10 即可，然后以 sum%10 为值建立一个新结点，连到cur后面，然后cur移动到下一个结点。之后再更新两个结点，若存在，则指向下一个位置。while循环退出之后，最高位的进位问题要最后特殊处理一下，若carry为1，则再建一个值为1的结点，代码如下：</p><p><img src="http://cdn.zzwwqq.xyz/static/images/LeetCode/LeetCode-2.1.1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;   <span class="comment">//l1,l2相当于指向两个链表表头的指针</span></span><br><span class="line">    <span class="comment">//为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到dummy结点之后</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点</span></span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//至少有一个结点不为空</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//结点为空,那么值就设置为0,不为空取出结点所存放的值</span></span><br><span class="line">        <span class="keyword">int</span> d1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">        <span class="keyword">int</span> d2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">        <span class="comment">//两个链表中对应结点的值求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = d1 + d2 + carry;</span><br><span class="line">        carry = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//sum不会超过二十,所以最多进1位</span></span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);<span class="comment">//造一个新结点,将两个链表对应结点的两数之和,存到新链表的新结点</span></span><br><span class="line">        cur = cur.next;<span class="comment">//移动cur指针,指向下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l1 = l1.next;<span class="comment">//移动l1指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l2 = l2.next;<span class="comment">//移动l2指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//循环结束</span></span><br><span class="line">    <span class="comment">//如果最高位相加,产生进位,需要再造一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">addTwoNumbers</span> </span>&#123;</span><br><span class="line"><span class="comment">//程序入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建立第一个链表</span></span><br><span class="line">        ListNode listNode1 =  <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode listNode2 =  <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode listNode3 =  <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        listNode1.next=listNode2;</span><br><span class="line">        listNode2.next=listNode3;</span><br><span class="line">        listNode3.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立第二个链表</span></span><br><span class="line">        ListNode listNode4 =  <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode listNode5 =  <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        ListNode listNode6 =  <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        listNode4.next=listNode5;</span><br><span class="line">        listNode5.next=listNode6;</span><br><span class="line">        listNode6.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> addTwoNumbers().addTwoNumbers(listNode1,listNode4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果: ListNode&#123;val=7, next=ListNode&#123;val=0, next=ListNode&#123;val=8, next=null&#125;&#125;&#125;</span></span><br><span class="line">        System.out.println(listNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接:<br><a href="http://www.cnblogs.com/grandyang/p/4129891.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4129891.html</a><br><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h3&gt;&lt;p&gt;给出两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且它们的每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;br&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;br&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode刷题" scheme="https://zzwwqq.xyz/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://zzwwqq.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂方法模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之工厂方法模式.html</id>
    <published>2019-03-26T03:29:50.000Z</published>
    <updated>2019-03-26T04:32:53.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是工厂方法模式"><a href="#一、什么是工厂方法模式" class="headerlink" title="一、什么是工厂方法模式?"></a>一、什么是工厂方法模式?</h2><p>①: 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口(抽象方法)，而子类重写接口(抽象方法)则负责生成具体的对象。<br>③: 简言之:工厂里面造对象,对象所属类里面造产品</p><a id="more"></a><h2 id="二、如何使用-使用步骤"><a href="#二、如何使用-使用步骤" class="headerlink" title="二、如何使用?使用步骤?"></a>二、如何使用?使用步骤?</h2><p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口(抽象方法)；<br>步骤2： 创建抽象产品类 ，定义具体产品的公共接口(抽象方法)；<br>步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>步骤4： 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例(对象)的方法；<br>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</p><h2 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点:"></a>三、优点:</h2><p>①: 更符合开-闭原则:<br>　　　　　　　新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可,<br>　　　　　　　而简单工厂模式需要修改工厂类的判断逻辑<br>②: 符合单一职责原则:<br>　　　　　　　每个具体工厂类只负责创建对应的产品,<br>　　　　　　　而简单工厂中的工厂类存在复杂的switch逻辑判断,<br>　　　　　　　它不使用静态工厂方法，可以形成基于继承的等级结构。<br>　　　　　　　而简单工厂模式的工厂类使用静态工厂方法</p><h2 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点:"></a>四、缺点:</h2><p>①: 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；<br>②: 同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；<br>③: 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。<br>④: 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；<br>⑤: 一个具体工厂只能创建一种具体产品</p><h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景:"></a>五、应用场景:</h2><p>①: 当一个类不知道它所需要的对象的类时<br>②: 当一个类希望通过其子类来指定创建对象时<br>③: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>④: 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p><h2 id="六、实例"><a href="#六、实例" class="headerlink" title="六、实例:"></a>六、实例:</h2><p>背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；<br>冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；<br>解决方案：小成决定置办塑料分厂B来生产B类产品；</p><p>//步骤1： 创建抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">Manufacture</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//步骤2： 创建抽象产品类 ，定义具体产品的公共接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下:<br>//步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法,代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品,代码如下: </span></span><br><span class="line"><span class="comment">//具体产品A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；</span></span><br><span class="line"><span class="comment">//工厂A类 - 生产A类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂B类 - 生产B类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        FactoryA myfactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        myfactoryA.Manufacture().show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        FactoryB myFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        myFactoryB.Manufacture().show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="七、总结："><a href="#七、总结：" class="headerlink" title="七、总结："></a>七、总结：</h2><p>工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p><p>参考文章:<br><a href="https://www.jianshu.com/p/e55fbddc071c" target="_blank" rel="noopener">https://www.jianshu.com/p/e55fbddc071c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是工厂方法模式&quot;&gt;&lt;a href=&quot;#一、什么是工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是工厂方法模式?&quot;&gt;&lt;/a&gt;一、什么是工厂方法模式?&lt;/h2&gt;&lt;p&gt;①: 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口(抽象方法)，而子类重写接口(抽象方法)则负责生成具体的对象。&lt;br&gt;③: 简言之:工厂里面造对象,对象所属类里面造产品&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之工厂方法模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之简单工厂模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之简单工厂模式.html</id>
    <published>2019-03-26T03:06:08.000Z</published>
    <updated>2019-03-26T04:33:15.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是简单工厂模式"><a href="#一、什么是简单工厂模式" class="headerlink" title="一、什么是简单工厂模式?"></a>一、什么是简单工厂模式?</h2><p>①: 简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）</p><p>②: 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</p><a id="more"></a><h2 id="二、如何使用-使用步骤"><a href="#二、如何使用-使用步骤" class="headerlink" title="二、如何使用?使用步骤?:"></a>二、如何使用?使用步骤?:</h2><p>①: 创建抽象产品类 &amp; 定义具体产品的公共接口；<br>②: 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>③: 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；<br>④: 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例</p><h2 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点:"></a>三、优点:</h2><p>①: 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；<br>②: 把初始化实例时的工作放到工厂里进行，使代码更容易维护。<br>③: 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</p><h2 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点:"></a>四、缺点:</h2><p>①: 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；<br>②: 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。<br>③: 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</p><h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景:"></a>五、应用场景:</h2><p>①: 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；<br>②: 当工厂类负责创建的对象（具体产品）比较少时。</p><h2 id="六、实例"><a href="#六、实例" class="headerlink" title="六、实例:"></a>六、实例:</h2><p>背景：小成有一个塑料生产厂，用来做塑料加工生意<br>目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产</p><p>//步骤1. 创建抽象产品类，定义具体产品的公共接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//步骤2.创建具体产品类（继承抽象产品类），定义生产的具体产品,      代码如下:<br>//步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例,   代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出A产品!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出B产品!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductC</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出C产品!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要A产品</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Factory.Manufacture(<span class="string">"A"</span>).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有A产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要B产品</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Factory.Manufacture(<span class="string">"B"</span>).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有B产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要C产品</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Factory.Manufacture(<span class="string">"C"</span>).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有C产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要D产品</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Factory.Manufacture(<span class="string">"D"</span>).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">Manufacture</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化</span></span><br><span class="line">        <span class="keyword">switch</span>(productName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductC();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="https://www.jianshu.com/p/e55fbddc071c" target="_blank" rel="noopener">https://www.jianshu.com/p/e55fbddc071c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是简单工厂模式&quot;&gt;&lt;a href=&quot;#一、什么是简单工厂模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是简单工厂模式?&quot;&gt;&lt;/a&gt;一、什么是简单工厂模式?&lt;/h2&gt;&lt;p&gt;①: 简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）&lt;/p&gt;
&lt;p&gt;②: 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之简单工厂模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCP-三次握手和四次挥手</title>
    <link href="https://zzwwqq.xyz/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"/>
    <id>https://zzwwqq.xyz/TCP-三次握手和四次挥手.html</id>
    <published>2019-03-25T14:05:46.000Z</published>
    <updated>2019-03-31T13:51:53.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字段说明"><a href="#一、字段说明" class="headerlink" title="一、字段说明:"></a>一、字段说明:</h2><table><thead><tr><th>字段:</th><th>含义:</th></tr></thead><tbody><tr><td>SYN,seq</td><td>同步报文段</td></tr><tr><td>ACK,ack</td><td>确认报文段</td></tr><tr><td>ack</td><td>确认号</td></tr><tr><td>seq</td><td>序列号</td></tr><tr><td>SYN</td><td>同步位</td></tr><tr><td>FIN</td><td>终止位</td></tr><tr><td>ACK</td><td>确认位</td></tr></tbody></table><a id="more"></a><h2 id="二、三次握手"><a href="#二、三次握手" class="headerlink" title="二、三次握手:"></a>二、三次握手:</h2><p>第一次:  连接请求报文段:  SYN=1(请求连接)  初始序号seq=x(客户端初始序号)<br>第二次:  确认报文段(同意连接): SYN =1(请求连接) seq= y(服务器自己的初始序号)  ACK = 1(确认收到) ack = x+1(确认号)<br>第三次: 确认报文段:ACK=1(确认收到)   seq=x+1 (客户端序号) ack=y+1(确认号)  确认号ack是上一次的序号seq加1</p><p>总结: ack的值等于对方上一次发送的报文段中的seq的值加一,<br>​    seq的值等于自己上一次发送的报文段中的seq的值加一(第一次seq值任意取)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计网/计网-4.1.png" alt></p><p>简图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计网/计网-4.2.png" alt></p><ul><li>B 处于 LISTEN（监听）状态，等待来自 A 的连接请求。</li><li>A 向 B 发送连接请求报文 SYN。</li><li>B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN ACK。</li><li>A 收到 SYN ACK 后，还要向 B 发出确认报文 ACK。</li><li>B 收到 ACK 后，连接建立。</li></ul><p><strong>应该注意到，接收了 SYN 之后的所有报文都存在 ACK 字段。</strong></p><h2 id="三、三次握手的原因"><a href="#三、三次握手的原因" class="headerlink" title="三、三次握手的原因:"></a>三、三次握手的原因:</h2><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="四、四次挥手"><a href="#四、四次挥手" class="headerlink" title="四、四次挥手:"></a>四、四次挥手:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/计网/计网-4.3.png" alt></p><p>简图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计网/计网-4.4.png" alt></p><p>第一次:     连接释放报文段:  FIN=1    seq=u(u为前面已经传送过的数据的最后一个字节的序号加一)</p><p>第二次:     连接释放确认报文段:  确认只断开A—B   ACK= 1(确认收到)  ack=u+1(确认号)   seq=v(v为为前面已经传送过的数据的最后一个字节的序号加一)</p><p>第三次:     连接释放确认报文段:  断开B—-A       FIN = 1   ACK =1   ack=u+1   seq=w(seq=v后还发送了数据, w是前面已经传送过的数据的最后一个字节的序号加一)</p><p>第四次:      连接释放确认报文段 :  确认断开B—A       ACK=1  ack = w+1    seq=u+1    </p><ul><li>A 发送连接释放报文 FIN。</li><li>B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文 FIN。</li><li>A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 ACK 后释放连接。</li></ul><h2 id="五、四次挥手的原因"><a href="#五、四次挥手的原因" class="headerlink" title="五、四次挥手的原因:"></a>五、四次挥手的原因:</h2><p>客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。</p><h2 id="六、为什么还要设置一个Time-WAIT"><a href="#六、为什么还要设置一个Time-WAIT" class="headerlink" title="六、为什么还要设置一个Time-WAIT ?"></a>六、为什么还要设置一个Time-WAIT ?</h2><p>客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。</li></ul><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/tGlWTrr5KLAv1AflfeAejA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tGlWTrr5KLAv1AflfeAejA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、字段说明&quot;&gt;&lt;a href=&quot;#一、字段说明&quot; class=&quot;headerlink&quot; title=&quot;一、字段说明:&quot;&gt;&lt;/a&gt;一、字段说明:&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段:&lt;/th&gt;
&lt;th&gt;含义:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN,seq&lt;/td&gt;
&lt;td&gt;同步报文段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ACK,ack&lt;/td&gt;
&lt;td&gt;确认报文段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ack&lt;/td&gt;
&lt;td&gt;确认号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seq&lt;/td&gt;
&lt;td&gt;序列号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;同步位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;终止位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ACK&lt;/td&gt;
&lt;td&gt;确认位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP-三次握手和四次挥手" scheme="https://zzwwqq.xyz/tags/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1两数之和</title>
    <link href="https://zzwwqq.xyz/LeetCode-1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"/>
    <id>https://zzwwqq.xyz/LeetCode-1两数之和.html</id>
    <published>2019-03-25T11:24:28.000Z</published>
    <updated>2019-03-27T04:39:51.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><p>这道题给了我们一个数组，还有一个目标数target，让我们找到两个数字，使其和为target，乍一看就感觉可以用暴力搜索(遍历所有的两个数字的组合，然后算其和), 但是时间复杂度是O(n^2)。能否想个O(n)的算法来实现，一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢，我们可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，我们都知道HashMap是常数级的查找效率，这样，我们在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。代码如下：</p><p>法一: 暴力搜索(不采用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> result[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">//0 1 2</span></span><br><span class="line">           <span class="keyword">for</span> (j = i; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">               t = nums[i] + nums[j + <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span> (t == target) &#123;</span><br><span class="line">                   result[<span class="number">0</span>] = i;</span><br><span class="line">                   result[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">return</span> result;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>法二: 使用HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] sums,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sums.length;i++)&#123;</span><br><span class="line">            hashMap.put(sums[i],i);<span class="comment">//把值存到HashMap,数作为键,下标作为值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - sums[i];</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(t) &amp;&amp; hashMap.get(t) != i) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = hashMap.get(t);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//一旦找到了,就立刻终止循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//程序入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> []nums =  <span class="keyword">new</span> <span class="keyword">int</span> []&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">       <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        result = <span class="keyword">new</span> TwoSum().twoSum(nums,target);</span><br><span class="line">        <span class="comment">//打印结果: [0,1]</span></span><br><span class="line">        System.out.println(<span class="string">"["</span>+result[<span class="number">0</span>]+<span class="string">","</span>+result[<span class="number">1</span>]+<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考链接:<br><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a><br><a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4130379.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;768px&quot; height=&quot;367px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/LeetCode/LeetCode-1.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode刷题" scheme="https://zzwwqq.xyz/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://zzwwqq.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之单例模式.html</id>
    <published>2019-03-25T04:41:46.000Z</published>
    <updated>2019-03-25T05:50:44.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式?"></a>一、什么是单例模式?</h2><p>　　实现1个类只有1个实例化对象并提供一个全局访问点.</p><h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理:"></a>二、工作原理:</h2><p>　　保证在内存中只有一个对象存在.<br>　　在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的，<br>　　要是想实现一个类只有一个实例化对象，就要对类的构造方法下功夫</p><h2 id="三、如何去保证内存中只有一个对象存在"><a href="#三、如何去保证内存中只有一个对象存在" class="headerlink" title="三、如何去保证内存中只有一个对象存在?"></a>三、如何去保证内存中只有一个对象存在?</h2><p>　　①: 构造函数私有化<br>　　②: 自己创建当前类的对象<br>　　③: 对外提供公共的方法(获取已经创建好的对象)</p><h2 id="四、使用步骤"><a href="#四、使用步骤" class="headerlink" title="四、使用步骤:"></a>四、使用步骤:</h2><ol><li>创建私有变量 OurInstance,（用以记录 Singleton 的唯一实例）,内部进行实例化</li><li>把类的构造方法私有化，不让外部调用构造方法实例化(构造方法只能在本类中调用)</li><li>定义公有方法提供该类的全局唯一访问点外部通过调用newInstance()方法来返回唯一的实例</li></ol><h2 id="五、优点"><a href="#五、优点" class="headerlink" title="五、优点:"></a>五、优点:</h2><p>　　提供了对唯一实例的受控访问；<br>　　由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；<br>　　可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式；</p><h2 id="六、缺点"><a href="#六、缺点" class="headerlink" title="六、缺点:"></a>六、缺点:</h2><p>　　单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”。<br>　　如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失。</p><h2 id="七、单例模式的实现方式"><a href="#七、单例模式的实现方式" class="headerlink" title="七、单例模式的实现方式:"></a>七、单例模式的实现方式:</h2><p>可分为2大类、6种实现方式:<br>　　第一大类: 初始化单例类时 即 创建单例<br>　　　　　实现方式1: 饿汉式<br>　　　　　实现方式2: 枚举类型</p><p>　　第二大类: 按需,延迟创建单例<br>　　　　　实现方式3: 懒汉式的基础实现<br>　　　　　实现方式4: 懒汉式的改进—&gt;同步锁<br>　　　　　实现方式5: 懒汉式的改进—&gt;双重检验锁<br>　　　　　实现方式6: 静态内部类</p><h2 id="八、饿汉式和懒汉式的区别"><a href="#八、饿汉式和懒汉式的区别" class="headerlink" title="八、饿汉式和懒汉式的区别:"></a>八、饿汉式和懒汉式的区别:</h2><p>　　饿汉式: 随类的加载而创建对象<br>　　懒汉式: 上来不创建对象,当调用的时候,再创建对象,以后使用的就是同一个对象了<br>　　懒汉式: 懒加载,延迟加载</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DesignPatterns-2.2.png" alt></p><h2 id="九、实现方式详解"><a href="#九、实现方式详解" class="headerlink" title="九、实现方式详解:"></a>九、实现方式详解:</h2><h3 id="9-1-实现方式1-饿汉式"><a href="#9-1-实现方式1-饿汉式" class="headerlink" title="9.1 实现方式1: 饿汉式"></a>9.1 实现方式1: 饿汉式</h3><p>　　①: 这是 最简单的单例实现方式<br>　　②: 原理: 依赖 JVM类加载机制，保证单例只会被创建1次，即 线程安全<br>　　　　　　JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化<br>　　　　　　在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化<br>　　③: 应用场景: 除了初始化单例类时 即 创建单例外，继续延伸出来的是：单例对象 要求初始化速度快 &amp; 占用内存小<br>　　④: 具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">　　　　　　　<span class="comment">// 1. 加载该类时，单例就会自动被创建</span></span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">static</span>  Singleton ourInstance  = <span class="keyword">new</span>  Singleton();</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">              <span class="comment">// 原因：禁止他人创建实例</span></span><br><span class="line">              <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 3. 通过调用静态方法获得创建的单例</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> ourInstance;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-实现方式2-枚举类型"><a href="#9-2-实现方式2-枚举类型" class="headerlink" title="9.2 实现方式2: 枚举类型"></a>9.2 实现方式2: 枚举类型</h3><p>　　①: 原理: 根据枚举类型的下述特点，满足单例模式所需的 创建单例、线程安全、实现简洁的需求<br>　　②: 具体实现:      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">   <span class="comment">//定义1个枚举的元素，即为单例类的1个实例</span></span><br><span class="line">   INSTANCE;                  </span><br><span class="line">    <span class="comment">// 隐藏了1个空的、私有的 构造方法</span></span><br><span class="line">    <span class="comment">// private Singleton () &#123;&#125;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取单例的方式：</span></span><br><span class="line">       Singleton singleton = Singleton.INSTANCE;</span><br><span class="line">注：这是 最简洁、易用 的单例实现方式，借用《Effective Java》的话：</span><br><span class="line">单元素的枚举类型已经成为实现 Singleton的最佳方法</span><br></pre></td></tr></table></figure><h3 id="9-3实现方式3-懒汉式（基础实现）"><a href="#9-3实现方式3-懒汉式（基础实现）" class="headerlink" title="9.3实现方式3: 懒汉式（基础实现）"></a>9.3实现方式3: 懒汉式（基础实现）</h3><p>　　①: 原理: 与饿汉式 最大的区别是：单例创建的时机<br>　　　　　　饿汉式：单例创建时机不可控，即类加载时 自动创建 单例<br>　　　　　　懒汉式：单例创建时机可控，即有需要时，才 手动创建 单例<br>　　②: 具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// 1. 类加载时，先不自动创建单例</span></span><br><span class="line">                  <span class="comment">//  即，将单例的引用先赋值为 Null</span></span><br><span class="line">                      <span class="keyword">private</span> <span class="keyword">static</span>  Singleton ourInstance  = <span class="keyword">null</span>；  </span><br><span class="line">                  <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">                  <span class="comment">// 原因：禁止他人创建实例</span></span><br><span class="line">                  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 3. 需要时才手动调用 newInstance（） 创建 单例</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">                  <span class="keyword">if</span>( ourInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                      ourInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">return</span> ourInstance;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><p>　　③: 缺点: 基础实现的懒汉式是线程不安全的，具体原因如下:<br>　　　　　　可能存在多个线程并发 调用 newInstance ( ),从而重复创建单例对象</p><p>　　④:具体实例: 一个线程A执行到singleton=new Singleton( ); 但还没有获得对象(因对象初始化需要时间),此时,第2个线程也在执行,执行到if (singleton == null) 判断 (判断为真,于是继续运行,创建单例对象),最终线程A ,B 同时获得了一个单例对象, 在内存中就出现两个单例类的对象,造成单例模式失效.</p><h3 id="9-4实现方式4-懒汉式的改进—-gt-同步锁"><a href="#9-4实现方式4-懒汉式的改进—-gt-同步锁" class="headerlink" title="9.4实现方式4: 懒汉式的改进—&gt;同步锁"></a>9.4实现方式4: 懒汉式的改进—&gt;同步锁</h3><p>　　①: 原理: 使用同步锁 synchronized锁住创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建　即，getInstance（）方法块只能运行在1个线程中．若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待，而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下单例对象的唯一性．<br>　　②: 具体实现:           </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 写法1(同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">               　 <span class="comment">// 1. 类加载时，先不自动创建单例</span></span><br><span class="line">               　<span class="comment">//  即，将单例的引用先赋值为 Null</span></span><br><span class="line">                 <span class="keyword">private</span> <span class="keyword">static</span>  Singleton ourInstance  = <span class="keyword">null</span>；            </span><br><span class="line">                 <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">                  <span class="comment">// 原因：禁止他人创建实例</span></span><br><span class="line">                  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 3. 加入同步锁</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">                      <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">                      <span class="keyword">if</span> ( ourInstance == <span class="keyword">null</span> )</span><br><span class="line">                          ourInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                      <span class="keyword">return</span> ourInstance;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 写法2 (同步代码块)</span></span><br><span class="line">               <span class="comment">// 该写法的作用与上述写法作用相同，只是写法有所区别</span></span><br><span class="line">               <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">                       <span class="comment">// 加入同步锁</span></span><br><span class="line">                       <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                               instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">return</span> instance;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>　　④: 缺点: 每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能）<br>　　注: 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步</p><h3 id="9-5-实现方式5-懒汉式的改进—-gt-双重检验锁"><a href="#9-5-实现方式5-懒汉式的改进—-gt-双重检验锁" class="headerlink" title="9.5 实现方式5: 懒汉式的改进—&gt;双重检验锁"></a>9.5 实现方式5: 懒汉式的改进—&gt;双重检验锁</h3><p>　　①: 原理: 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能<br>　　②: 具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span>  Singleton ourInstance  = <span class="keyword">null</span>；</span><br><span class="line">               <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="comment">// 加入双重校验锁</span></span><br><span class="line">                  <span class="comment">// 校验锁1：第1个if</span></span><br><span class="line">                  <span class="keyword">if</span>( ourInstance == <span class="keyword">null</span>)&#123;  <span class="comment">// ①</span></span><br><span class="line">                   <span class="keyword">synchronized</span> (Singleton.class)&#123; <span class="comment">// ②</span></span><br><span class="line">                    <span class="comment">// 校验锁2：第2个 if</span></span><br><span class="line">                    <span class="keyword">if</span>( ourInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        ourInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                      <span class="keyword">return</span> ourInstance;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           <span class="comment">// 说明</span></span><br><span class="line">           <span class="comment">// 校验锁1：第1个if</span></span><br><span class="line">           <span class="comment">// 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作</span></span><br><span class="line">           <span class="comment">// 即直接跳到执行 return ourInstance</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 校验锁2：第2个 if</span></span><br><span class="line">           <span class="comment">// 作用：防止多次创建单例问题</span></span><br><span class="line">           <span class="comment">// 原理</span></span><br><span class="line">             <span class="comment">// 1. 线程A调用newInstance()方法，当运行到②位置时，此时线程B也调用了newInstance()方法,</span></span><br><span class="line">             <span class="comment">// 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕</span></span><br><span class="line">             <span class="comment">// 3. 当线程A释放同步锁时，单例已创建，即instance已非空</span></span><br><span class="line">             <span class="comment">// 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 为非空（单例已创建），因此也不会创建多余的实例</span></span><br><span class="line">     ③: 缺点: 实现复杂 = 多种判断，易出错</span><br></pre></td></tr></table></figure><h3 id="9-6-实现方式6-静态内部类"><a href="#9-6-实现方式6-静态内部类" class="headerlink" title="9.6 实现方式6: 静态内部类"></a>9.6 实现方式6: 静态内部类</h3><p>　　①: 原理: 根据 静态内部类 的特性，同时解决了按需加载、线程安全的问题，同时实现简洁<br>　　　　　　在静态内部类里创建单例，在装载该内部类时才会去创建单例<br>　　　　　　线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例<br>　　②: 具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 1. 创建静态内部类</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 在静态内部类里创建单例</span></span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">static</span>  Singleton ourInstance  = <span class="keyword">new</span> Singleton()；</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 私有构造函数</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延迟加载、按需创建</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Singleton2.ourInstance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用过程说明：</span></span><br><span class="line">              <span class="comment">// 1. 外部调用类的newInstance()</span></span><br><span class="line">              <span class="comment">// 2. 自动调用Singleton2.ourInstance</span></span><br><span class="line">               <span class="comment">// 2.1 此时单例类Singleton2得到初始化</span></span><br><span class="line">               <span class="comment">// 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例；</span></span><br><span class="line">               <span class="comment">// 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性</span></span><br><span class="line">              <span class="comment">// 3. 最终只创建1个单例</span></span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="https://www.jianshu.com/p/b8c578b07fbc" target="_blank" rel="noopener">https://www.jianshu.com/p/b8c578b07fbc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;769px&quot; height=&quot;369px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DesignPatterns-2.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之单例模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
