<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zwq</title>
  
  <subtitle>路漫漫其修远兮,吾将上下而求索!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zzwwqq.xyz/"/>
  <updated>2019-05-05T07:59:31.990Z</updated>
  <id>https://zzwwqq.xyz/</id>
  
  <author>
    <name>zwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信息系统项目管理师之论文部分</title>
    <link href="https://zzwwqq.xyz/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E4%B9%8B%E8%AE%BA%E6%96%87%E9%83%A8%E5%88%86.html"/>
    <id>https://zzwwqq.xyz/信息系统项目管理师之论文部分.html</id>
    <published>2019-04-22T04:44:31.000Z</published>
    <updated>2019-05-05T07:59:31.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十大知识领域、五大项目管理过程组、47个过程"><a href="#十大知识领域、五大项目管理过程组、47个过程" class="headerlink" title="十大知识领域、五大项目管理过程组、47个过程"></a>十大知识领域、五大项目管理过程组、47个过程</h3><p>启动过程组 2个<br>规划过程组 24个<br>执行过程组 8个<br>监控过程组 11个<br>收尾过程组 2个</p><a id="more"></a><h2 id="一、整体管理"><a href="#一、整体管理" class="headerlink" title="一、整体管理"></a>一、整体管理</h2><h3 id="1-1-可以从以下方面去写"><a href="#1-1-可以从以下方面去写" class="headerlink" title="1.1 可以从以下方面去写:"></a>1.1 可以从以下方面去写:</h3><p>①: 6个过程       (命题概率较大)</p><p>②: PDCA          (命题概率较大)</p><p>③: 5大过程组</p><p>注: PDCA是质量管理和项目管理的基本模型。PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Action(行动)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。</p><h3 id="1-2-写作思路"><a href="#1-2-写作思路" class="headerlink" title="1.2 写作思路:"></a>1.2 写作思路:</h3><table><thead><tr><th>过程</th><th>通俗解释</th><th>写作要点(举例: 根据子题目写)</th></tr></thead><tbody><tr><td>1 制定项目章程</td><td>正式批准项目的启动,为项目经理授权</td><td>不用写太多,一句话带过,如项目发起人发布了这个文件,项目启动了,我被授权了.</td></tr><tr><td>2 制定项目管理计划</td><td>和大家一起编制项目管理计划,为项目的执行奠定基础</td><td>可写计划编写的原则,工具,步骤等内容,列举项目管理计划包含了什么内容</td></tr><tr><td>3 指导和管理项目执行</td><td>按照项目管理计划来指定项目的执行</td><td>如何按照计划来指导和管理项目, 如: 根据计划做了什么安排,怎么安排等</td></tr><tr><td>4 监督和控制项目工作</td><td>做好项目的纠偏控制</td><td>如何设置监控点,如何进行监控和捕获项目信息,什么时候发现项目状态有问题,分析什么原因造成的,如何解决的.</td></tr><tr><td>5 整体变更管理</td><td>变更不可避免,当发生变更时严格按照变更流程进行项目变更管理工程.</td><td>具体举例,如何进行变更控制(6个流程)</td></tr><tr><td>6 项目收尾</td><td>项目通过验收,交付了产品,还要召开项目总结会议,进行项目总结和评估审计等工作.</td><td>写验收情况,项目总结会议的作用,内容,最后更新组织过程资产等</td></tr></tbody></table><h3 id="1-3-过程-输入-输出-工具和技术"><a href="#1-3-过程-输入-输出-工具和技术" class="headerlink" title="1.3 过程,输入,输出,工具和技术"></a>1.3 过程,输入,输出,工具和技术</h3><table><thead><tr><th>过程+输入</th><th>工具/技术</th><th>输出</th></tr></thead><tbody><tr><td><font color="red" size="5">1.3.1 制定项目章程 (启动过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目工作说明书</td><td>专家判断</td><td><strong>项目章程</strong></td></tr><tr><td>②: 商业论证</td><td>引导技术</td><td></td></tr><tr><td>③: 协议</td><td></td><td></td></tr><tr><td>④: 事业环境因素</td><td></td><td></td></tr><tr><td>⑤: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 工商议事有组织,专家引导出章程</font>(工:工作说明书,商: 商业论证,议: 协议,事: 事业环境因素,)</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.2 制定项目管理计划 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目章程</td><td>专家判断</td><td><strong>项目管理计划</strong></td></tr><tr><td>②: 其他过程的输出</td><td>引导技术</td><td></td></tr><tr><td>③: 事业环境因素</td><td></td><td></td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td>⑤: 初步项目范围说明书</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 章程输出靠业组,专家引导出计划</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.3 指导与管理项目执行 (执行过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td><strong>可交付性成果</strong></td></tr><tr><td>②: 批准的变更请求</td><td>项目管理信息系统</td><td><strong>工作绩效数据</strong></td></tr><tr><td>③: 事业环境因素</td><td>会议</td><td><strong>变更请求</strong></td></tr><tr><td>④: 组织过程资产</td><td></td><td>项目管理计划更新</td></tr><tr><td><font color="green" size="5">口诀: 计变业组会专项, 效果变更新文划</font>( 计: 项目管理计划, 业: 事业环境因素,专: 专家, 项: 项目管理信息系统,效:绩效,果:可交付性成果,变:变更请求,新:更新,文: 文件,划:计划)</td><td></td><td>项目文件更新</td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.4 监控项目工作 (监控过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>变更请求</td></tr><tr><td><strong>②: 进度预测</strong></td><td>项目管理信息系统</td><td><strong>工作绩效报告</strong></td></tr><tr><td>③: 成本预测</td><td>会议</td><td>项目管理计划更新</td></tr><tr><td>④: 确认的变更</td><td></td><td>项目文件更新</td></tr><tr><td>⑤: 工作绩效信息</td><td></td><td></td></tr><tr><td>⑥: 事业环境因素</td><td></td><td></td></tr><tr><td>⑦: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 计划进成预测后,业组确认变更信</font>(输入而言)</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.5 实施整体变更控制 (监控过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td><strong>批准的变更请求</strong></td></tr><tr><td>②: 工作绩效报告</td><td>会议</td><td><strong>变更日志</strong></td></tr><tr><td>③: 变更请求</td><td>变更控制工具</td><td>项目管理计划更新</td></tr><tr><td>④: 事业环境因素</td><td></td><td>项目文件更新</td></tr><tr><td>⑤: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 计划变更效业组,批准日志新文划</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.6 结束项目或阶段 (收尾过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>最终产品,服务或成果移交</td></tr><tr><td>②: 验收的可交付成果</td><td>分析技术</td><td>组织过程资产更新</td></tr><tr><td>③: 组织过程资产</td><td>会议</td><td>管理收尾规程</td></tr><tr><td><font color="green" size="5">口诀: 计划验收无事业,会议分析有专家</font></td><td></td><td>合同收尾规程</td></tr></tbody></table><h3 id="1-4-论文格式"><a href="#1-4-论文格式" class="headerlink" title="1.4 论文格式:"></a>1.4 论文格式:</h3><p>第一部分:</p><p>摘要部分: 300字左右</p><p>第二部分: </p><p>正文部分: 2700字左右</p><p><strong>总共3000字左右.</strong></p><h3 id="1-5-范文-举例"><a href="#1-5-范文-举例" class="headerlink" title="1.5 范文: 举例"></a>1.5 范文: 举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">论信息系统工程项目的整体管理</span><br><span class="line">摘要:</span><br><span class="line"></span><br><span class="line"><span class="number">2005</span> 年 <span class="number">3</span> 月我作为项目经理参与了某市的公安部人口管理信息系统，该项目是为了实现该市平安城市的 <span class="number">5</span> 年规</span><br><span class="line">划。它投资 <span class="number">800</span> 万元。工期为 <span class="number">1</span> 年。目标是采用统一的技术路线和架构体系构建开放的、集成的、一体化的信息化的应</span><br><span class="line">用环境.该项目主要实现了常住人口户籍办公管理、二代身份证管理、暂住人口户籍管理、租赁房屋管理等。<span class="number">2006</span> 年 </span><br><span class="line"><span class="number">3</span> 月通过了甲方的验收，获得了甲方的一致好评。本文以我的实际经验讨论了有关大型整体管理的体会，主要从制定项目</span><br><span class="line">章程、制定项目范围说明书(初步)、制定项目管理计划、指导和管理   项目执行、监督和控制项目工作、整体变更控制、</span><br><span class="line">项目收尾方面做了论述。</span><br><span class="line"></span><br><span class="line">正文:</span><br><span class="line"></span><br><span class="line">为了实现某市平安城市的 <span class="number">5</span> 年规划，某市决定开发一个公安系统的人口管理信息系统。工期为 <span class="number">1</span> 年，投资 <span class="number">800</span> 万</span><br><span class="line">元。我公司在 <span class="number">2005</span> 年 <span class="number">2</span> 月中标了该市的公安部人口管理信息系统项目，签署了建设合同。<span class="number">2006</span> 年 <span class="number">3</span> 月通过了甲方的</span><br><span class="line">验收。项目分为平台开发和项目部署 <span class="number">2</span> 个阶段。软件方面考虑到各区县地理位置分布的不集中，计算机硬件和软件存在较</span><br><span class="line">大的差异等问题，我们决定采用 J2EE 框架的 <span class="number">3</span> 层 BS 模式，解决了各种应用系统中应用的不兼容问题， 提高了该系统</span><br><span class="line">的易用性。数据库采用了 Oracle <span class="number">9</span>g 来管理各项数据。服务器操作软件采用比较通用的 Windows Server <span class="number">2003</span>。硬件方</span><br><span class="line">面采用 IBM System X 系列的服务器提高了系统的稳定性和高性能。在应用层面上我们实现了常住人口户籍办公管理、二</span><br><span class="line">代身份证管理、暂住人口户籍管理、租赁房屋管理等功能。由千该项目工期紧，工作量大，在制定项目章程的时候  决定</span><br><span class="line">了多个分项的项目经理和总经理。我作为项目总经理参与了该项目的管理。接下来我将结合实际工作从制定项目章程，制定</span><br><span class="line">项目范围说明书(初步)，制定项目管理计划，指导和管理项目执行，监督和控制项目工作，整体变更控制及项目收尾来讨</span><br><span class="line">论大型项目的整体管理。</span><br><span class="line"></span><br><span class="line">一、制定项目章程</span><br><span class="line"></span><br><span class="line">项目章程是实施项目开发的前提和确定项目开发什么产品的依据。经过公司领导的授权  我被任命为该项目的总经</span><br><span class="line">理。由千项目的规模比较大、工期较紧，我们根据合同、项目工作  说明书等过程资产确认了另外 <span class="number">3</span> 名项目经理。我作为</span><br><span class="line">总经理统一协调。</span><br><span class="line"></span><br><span class="line">二、制定项目管理计划</span><br><span class="line"></span><br><span class="line">俗话说得好，“磨刀不误砍柴工”，在实施项目开发之前，做好应有的准备工作是很有必要的。完备的计划是项目实施</span><br><span class="line">的根本前提。为此我组织召开了“项目工作计划的会议”，会议邀请了各团队的项目经理、业务专家和技术专家。</span><br><span class="line">在制定范围控制管理计划进行 WBS 分解的时候，我发现由千涉及的人员较多，个人的知识水平也参差不齐，信息尚</span><br><span class="line">不够明确。因此我们决定采用滚动波式计划。对于即将开展的活动进行详细的分析和计划，对于后期的活动尽量粗略地估</span><br><span class="line">计，避免出现大范围的变更。 在制定进度控制计划的历时估算时因为我有过许多类似项目管理的经验。因此大部分的活动</span><br><span class="line">我采用了类比估算法，从而节约了时间。此外我们还考虑了活动存在的风险情况。在与负责二代身份证管理的经理讨论的过</span><br><span class="line">程中，我们发现身份证采集的设备驱动程序来自第三方，驱动的连接是否正常直接影响到了信息采集活动的开展。因此相关</span><br><span class="line">的业务、技术专家和团队成员调整了估算方法，采用了三点估算法。该方法主要有 <span class="number">3</span> 个数据，分别是最乐观历时估算 a、</span><br><span class="line">最悲观历时估算 c、最有可能历时估算 b，而后利用 T=(a+<span class="number">4</span>b+c)取其平均值。经过个专家和开发团队成员的讨论，认为</span><br><span class="line">最乐观的时间为 <span class="number">2</span> 个工作日、最悲观的时间为 <span class="number">6</span> 个工作日、最有可能的时间为 <span class="number">4</span> 个工作日。最后该活动的历时为 <span class="number">4</span> 个</span><br><span class="line">工作日。为项目的按时完工打下了基础。</span><br><span class="line">在制定质量控制管理计划的时候我们发现客户的有些要求与相关的法律法规相冲突。为此我及时通知了客户，与客户</span><br><span class="line">进行了沟通，最后我们修改了相关质量标准，使项目的质量得到了保证。</span><br><span class="line">在制定人力资源计划的时候为了保证有充足的资源去完成项目。团队的所有项目经理、 相关业务专家和技术专家经过</span><br><span class="line">讨论决定采用自下而上的方式进行估算，对每一层下面工作所需的资源进行估算，最后将所有的资源进行汇总。比如二代身</span><br><span class="line">份证信息管理可以分解为身份证信息的采集、信息的存储、信息的修改、信息的存储。信息采集工作需要忱卡器一</span><br><span class="line">台、能够在 Java 中成功调用 DLL 动态库一个以及 Java 程序开发人员 <span class="number">2</span> 名；信息存储工作需要通用数据库存储过程一</span><br><span class="line">个、Java 程序开发人员 <span class="number">2</span> 名。暂住人口户籍管理、租赁房屋管理的分项经理这时提出也需要Java 的开发人员各 <span class="number">2</span> 名。</span><br><span class="line">我们检查公司的人力资源表后发现缺少 <span class="number">2</span> 名Java 程序员，我及时向公司领导汇报了情况，经领导同意我们又招聘了 <span class="number">2</span> 名</span><br><span class="line">程序员，完成了资源的合理分配。通过讨论我还制作了活动资源日历，保证每个活动都有后备的资源考虑。</span><br><span class="line">我们还制定了项目成本控制管理计划、沟通管理计划、采购管理计划、风险管理计划等。</span><br><span class="line"></span><br><span class="line">三、指导和管理项目执行</span><br><span class="line"></span><br><span class="line">“懂业务的不懂技术，懂技术的不懂业务”，在这种情况下项目的风险很大，一旦开发人 员没有理解业务去开发，将导致严</span><br><span class="line">重的返工，最终影响项目进度。因此在开发的时候我要求 每个开发的具体功能必须要求项目经理组织相关干系人对开发人</span><br><span class="line">员进行交底，避免返工的发 生。开发这一阶段在每完成一个里程碑式的可交付物时，我都会邀请客户来进行确认签字，</span><br><span class="line">保证了我们开发产品的有效性，减少了无谓的变更。</span><br><span class="line"></span><br><span class="line">四、监督和控制项目工作</span><br><span class="line"></span><br><span class="line">在项目执行的过程中总会遇到各种各样的问题。那么怎样才能预防和控制各种问题的发生呢？每周我会根据绩效信息</span><br><span class="line">与计划进度表进行比较，进行偏差分析，利用挣值技术计算进度偏差情况，及时采取纠正和预防措施。比如负责二代身份证</span><br><span class="line">信息管理项目的丁工还负责其他项目的系统需求分析和设计，因其他项目上的事情比较多，二代身份证管理的需求分析 和</span><br><span class="line">详细设计迟迟不能开始，已落后千计划，SV=-<span class="number">3</span>。如果再不提交将会影响到编码阶段。届时，我与丁工进行了沟通，与他协</span><br><span class="line">商决定，我负责帮他完成一部分其他项目的工作，他加班负责把马上要进行编码阶段的二代身份证信息管理的需求分析和设</span><br><span class="line">计提交出来，最终二代身份证信息管理的编码工作按计划开展。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">五、整体变更控制</span><br><span class="line"></span><br><span class="line">项目开发的过程中客户的需求经常会有变更。为了防止频繁的变更对项目进度等带来的 不利影响。项目的初期我们成</span><br><span class="line">立了由客户方、开发方和监理方组成项目控制委员会 CCB。客户或者开发方每个需要的变更都要经 CCB 的批准才能实行。</span><br><span class="line"></span><br><span class="line">六、项目收尾</span><br><span class="line"></span><br><span class="line">经过项目全体人员的共同努力，<span class="number">2006</span> 年 <span class="number">2</span> 月终千完成了压力测试，<span class="number">2006</span> 年 <span class="number">3</span> 月项目一次性通过了甲方的验收。</span><br><span class="line">回顾项目的进度管理工作的过程中，项目能成功通过验收得益千在 事前进行了充分的计划和准备工作。我觉得项目管理的</span><br><span class="line">能力和项目开发的能力是有很大的区 别的。一个成功而高效的项目开发必须要有一个能统筹管理和善千沟通的项目经理。</span><br><span class="line">特别是 作为大型项目经理，我们的主要工作就是平衡各种资源的利用，使其达到最佳的效率。怎样才能达到这个最佳。这</span><br><span class="line">个是我在今后的工作中需要长期实践和摸索的内容。虽然项目成功通过了验收没有大的事故发生，但仍然存在许多问题，主</span><br><span class="line">要有以下几点：</span><br><span class="line">(<span class="number">1</span>)在需要客户确认时，与客户的沟通方式比较单一，只是一味等待，导致某些工作落后 千计划进度，影响了整体计划。</span><br><span class="line">(<span class="number">2</span>)需求分析还不够全面，某些功能没有能够很完善地实现。</span><br><span class="line">(<span class="number">3</span>)软件测试不系统，用例准备仍不够充分，忽视了压力测试。系统实际运行后随着参保 职工和定点结算的增加，运行速</span><br><span class="line">度下降很快，达不到设计要求。虽然通过升级硬件缓解了这个问题，但造成资金的额外投入。</span><br></pre></td></tr></table></figure><h3 id="1-6-模板"><a href="#1-6-模板" class="headerlink" title="1.6 模板:"></a>1.6 模板:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">项目整体管理是项目管理的必要条件，是项目管理的有效基础，是项目管理的重要内容。为了保障项目的持续进展，</span><br><span class="line">确保项目的有序进行，保证项目能够顺利的上线，我从制定项目章程、制定初步范围说明书、制定项目管理计划、管理和指</span><br><span class="line">导项目执行、监控项目工作、整体变更控制和合同收尾等六个方面加强项目的整体管理。</span><br><span class="line"></span><br><span class="line">第一，制定项目章程。</span><br><span class="line"></span><br><span class="line">制定项目章程是项目整体管理的第一步。通过制定项目章程明确项目的整体目标，通过收益法判断整体的项目收益。</span><br><span class="line">整个项目采用项目型管理方式。正式任命我作为项目经理。假定某某省某某市的计划生育政策具有延续性，不会有大的变</span><br><span class="line">更，这样保障需求不会发生实质的变更。假定项目开发人员中的主力开发人员不会在项目开发过程离职。系统的人口信息表</span><br><span class="line">的存放数据量为<span class="number">600</span>万条，系统的响应时间不超过<span class="number">6</span>秒，系统的从需求分析到系统试运行时间为<span class="number">1</span>年，系统的并发用户为<span class="number">50</span></span><br><span class="line">个。系统的项目干系人分为四类：甲方的领导层，关心整体项目进度情况；甲方的业务人员，关心项目的具体业务的实现；</span><br><span class="line">乙方的领导层，关心项目的成本、质量及合同的收款情况；乙方的项目团队曾元，关心项目的需求、设计、编码、测试、实</span><br><span class="line">施上线。</span><br><span class="line"></span><br><span class="line">第二，制定初步范围说明书。</span><br><span class="line"></span><br><span class="line">项目初步范围说明书是项目整体管理的第二步。项目初步范围说明书是项目各个阶段提交的交付物和为提交交付物所</span><br><span class="line">做的工作。我初步制定了项目初步范围说明书包括需求分析报告、系统概要设计、系统详细设计、模块开发卷宗、测试规</span><br><span class="line">范、系统集成规范、系统验收规范、系统产品说明书、系统代码。制定了初步工作分解结构。</span><br><span class="line"></span><br><span class="line">第三、制定项目管理计划。</span><br><span class="line"></span><br><span class="line">制定项目管理计划是项目整体管理的第三步。项目管理计划包括成本管理计划、质量管理计划、时间管理计划、风险</span><br><span class="line">识别册、人力资源沟通计划等。通过制定项目管理计划，整个项目按照制定的计划预期稳步向前推进。</span><br><span class="line"></span><br><span class="line">第四，管理和指导项目执行。</span><br><span class="line"></span><br><span class="line">采用工具sourceSafe建立配置管理系统，对所有的文档及变更记录进行管理。采用OA系统作为所有项目干系人的沟通</span><br><span class="line">工具，所有的变更文档记录及相关的项目文档资料通过OA的流程管理进行处理。比如，有的程序员对J2EE比较熟悉，这次</span><br><span class="line">开发采用.NET路线，因此请对.NET精通的专家对不熟悉J2EE的程序员进行培训。要求质量管理人员按照编码规范对代码进</span><br><span class="line">行走查，不符合要求责令修改。</span><br><span class="line"></span><br><span class="line">第五，监控项目工作。</span><br><span class="line"></span><br><span class="line">监控项目工作是项目整体管理的第五个步骤。对整个项目在成本、风险、质量、进度等方面进行监控。在每个里程碑</span><br><span class="line">的节点上开面对面沟通会议，对前一阶段的工作进行审核把关，同时对出现的问题进行记录，寻找解决办法；通过每周的项</span><br><span class="line">目例会，对这一周的工作进行总结，出现的问题进行记录，及时把问题解决。通过每天的项目组成员的工作日志，记录成员</span><br><span class="line">每天的工作情况，以便于及时的把问题查找出来。通过每天的工作日志、每周的项目例会及里程碑节点的会议及时的与项目</span><br><span class="line">计划进行比对，找出偏差，及时处理。</span><br><span class="line"></span><br><span class="line">第六、整体变更控制。</span><br><span class="line"></span><br><span class="line">成立变更控制管理委员会，对整个项目的需求变更进行管理控制。变更管理委员会对申请的变更要审核、评估。批准</span><br><span class="line">后的变更要按计划执行，同时对执行后的项目进行追踪。</span><br><span class="line"></span><br><span class="line">第七，项目收尾。</span><br><span class="line"></span><br><span class="line">项目收尾包括管理收尾和合同收尾。通过项目范围说明书、合同等文档的要求，对提交给用户的可交付物进行比对。</span><br><span class="line">对已完成的可交付请求客户确认签字，对用户确定需要进一步完善的可交付物要及时的按照文档资料要求处理。最后整体验</span><br><span class="line">收。例如，按照合同要求，我们用惠普的loadrunner对系统进行了<span class="number">50</span>并发用户的压力测试，同时在开发的过程也组织了人</span><br><span class="line">力对人口的基础数据进行了录入，响应时间小于<span class="number">6</span>秒。同时提交的文档资料整体提交完毕，人员培训已经完成，系统试运行</span><br><span class="line">三个月情况良好，满足用户需求。</span><br></pre></td></tr></table></figure><h2 id="二、范围管理"><a href="#二、范围管理" class="headerlink" title="二、范围管理"></a>二、范围管理</h2><h3 id="2-1-可以从以下方面去写"><a href="#2-1-可以从以下方面去写" class="headerlink" title="2.1 可以从以下方面去写:"></a>2.1 可以从以下方面去写:</h3><p>①: 6个过程       (命题概率较大)</p><p>②: PDCA          (命题概率较大)</p><p>③: 范围结合需求</p><p>④: 问题解决的角度</p><p>注: <strong>其中 1 命题概率大，建议 6 个过程的角度必须准备</strong></p><h3 id="2-2-写作思路"><a href="#2-2-写作思路" class="headerlink" title="2.2 写作思路:"></a>2.2 写作思路:</h3><table><thead><tr><th>过程</th><th>通俗解释</th><th>写作要点</th></tr></thead><tbody><tr><td>1 范围规划</td><td>编写<strong>项目范围管理计划</strong></td><td>写我组织相关人员进行了项目范围管理计划的<strong>编制</strong>,在编制<strong>之前</strong>做了什么准备,通过什么<strong>方法</strong>进行编制,编制后的计划包含什么<strong>内容.</strong></td></tr><tr><td>2 收集需求</td><td><strong>记录</strong>并管理<strong>干系人的需要</strong>和需求过程</td><td>哪些<strong>类型</strong>的需求, <strong>输入,输出,工具技术</strong>,该过程的<strong>重要性</strong>,遇到什么<strong>问题</strong>,如何<strong>解决</strong>,需求文件,建立需求跟踪矩阵等.</td></tr><tr><td>3 范围定义</td><td>对项目和产品详细描述,并写到详细的范围说明书中,形成<strong>详细的范围说明书.</strong></td><td>举例描述,本项目的某个功能<strong>原来</strong>是怎么定义,<strong>现在</strong>是如何详细的表示,最终说明书包含什么</td></tr><tr><td>4 创建工作分解结构WBS</td><td>项目的<strong>可交付物和项目管理的工作进行分解</strong>,分解为更小更易于管理的单元.</td><td><strong>为什么要分解</strong>,是采用树形还是列表型,以什么作为<strong>第一层</strong>,分解的五个<strong>步骤</strong>是什么,遵循什么<strong>原则</strong></td></tr><tr><td>5 范围确认</td><td><strong>阶段性的接受</strong>项目的可交付物,对不可接受的说明理由,重新整改.</td><td>具体通过什么<strong>方式</strong>进行范围确认,哪些进行了确认,哪些没有,是什么<strong>原因</strong>,怎样整改.</td></tr><tr><td>6 范围控制</td><td><strong>管理好变更</strong>,避免出现<strong>范围蔓延</strong></td><td>写范围管理的<strong>重要性</strong>,<strong>如何</strong>进行范围控制的,如何防止<strong>范围蔓延</strong></td></tr></tbody></table><h3 id="2-3-过程-输入-输出-工具和技术"><a href="#2-3-过程-输入-输出-工具和技术" class="headerlink" title="2.3 过程,输入,输出,工具和技术"></a>2.3 过程,输入,输出,工具和技术</h3><table><thead><tr><th>过程+输入</th><th>工具/技术</th><th>输出</th></tr></thead><tbody><tr><td><font color="red" size="5">2.3.1 范围规划 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>范围管理计划</td></tr><tr><td>②: 项目章程</td><td>会议</td><td>需求管理计划</td></tr><tr><td>③: 事业环境因素</td><td>模板,表格,标准</td><td></td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td>⑤: 初步项目范围说明书</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 章程计划找业组, 专家会议两计划</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.2 收集需求 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 范围管理计划</td><td>访谈</td><td>需求文件</td></tr><tr><td>②: 需求管理计划</td><td>问卷</td><td>需求跟踪矩阵</td></tr><tr><td>③: 干系人管理计划</td><td>观察</td><td></td></tr><tr><td>④: 项目章程</td><td>标杆</td><td></td></tr><tr><td>⑤: 干系人登记册</td><td>原型</td><td></td></tr><tr><td><font color="green" size="5">口诀: 范需人划章程册, 需求文件矩阵出</font>(划: 管理计划),</td><td>文件分析</td><td></td></tr><tr><td></td><td>系统交互图</td><td></td></tr><tr><td></td><td>焦点小组</td><td></td></tr><tr><td></td><td>引导式研讨会</td><td></td></tr><tr><td></td><td>群体创新技术</td><td></td></tr><tr><td></td><td>群体决策技术</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.3 范围定义 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 范围管理和计划</td><td>专家判断</td><td>项目范围说明书(详细)</td></tr><tr><td>②: 项目章程</td><td>产品分析</td><td>项目管理计划更新</td></tr><tr><td>③: 需求文件</td><td>可选方案识别</td><td></td></tr><tr><td>④: 组织过程资产</td><td>引导式研讨会</td><td></td></tr><tr><td><font color="green" size="5">口诀: 范划章程需文组, 文件更新出范书</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.4 创建工作分解结构WBS (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 范围管理计划</td><td>分解技术</td><td>范围基准</td></tr><tr><td>②: 详细项目范围说明书</td><td>专家判断</td><td>项目管理计划更新</td></tr><tr><td>③: 需求文件</td><td>WBS分解结构模板</td><td>WBS和WBS字典</td></tr><tr><td>④: 事业环境因素</td><td></td><td></td></tr><tr><td>⑤: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 范划范书需业组,文件更新出基准</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.5 范围确认 (监控过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>检查</td><td>验收的可交付性成果</td></tr><tr><td>②: 需求文件</td><td>群体决策</td><td>变更请求</td></tr><tr><td>③: 需求跟踪矩阵</td><td></td><td>工作绩效信息</td></tr><tr><td>④: 核实的可交付性成果</td><td></td><td>项目文件更新</td></tr><tr><td>⑤: 工作绩效数据</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 计划需文效成果,文件变更绩效出</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.6 范围控制</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>偏差分析</td><td>工作绩效信息</td></tr><tr><td>②: 需求文件</td><td>变更控制系统</td><td>变更请求</td></tr><tr><td>③: 需求跟踪矩阵</td><td>配置管理系统</td><td>项目管理计划更新</td></tr><tr><td>④: 工作绩效数据</td><td>重新规划</td><td>项目文件更新</td></tr><tr><td>⑤: 组织过程资产</td><td></td><td>组织过程资产更新</td></tr><tr><td><font color="green" size="5"> 口诀: 计划需文效矩组,计组文件齐更新 </font></td><td></td></tr></tbody></table><h3 id="2-4-范文"><a href="#2-4-范文" class="headerlink" title="2.4 范文:"></a>2.4 范文:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">论信息系统工程项目的范围管理</span><br><span class="line">摘要:</span><br><span class="line"><span class="number">2009</span> 年 <span class="number">5</span> 月，我作为项目经理，参与了××物流公司条形码项目。该项目是为了提升××物流公司日常业务运作中货物</span><br><span class="line">流转交换的准确性和及时性，解决该公司现有业务运作中的货物差错率高、装卸效率低、记录颗粒度粗等问题，进而提升整</span><br><span class="line">体运营服务质量，实现×× 物流公司由低端运输向高端公路快运转型的战略目标。</span><br><span class="line">作为该公司的重点战略项目，项目总投资 <span class="number">2000</span> 万元，项目工期为 <span class="number">2</span> 年，系统主要实现了以下功能：CD对货物流转</span><br><span class="line">交换过程中的每一个环节的扫描，实现货物运输全过程跟踪处理功能；＠基千计划与实际扫描结果的比对，实现装卸差错及</span><br><span class="line">时发现、及时解决；＠货物异常处理；＠提送货任务的指派与管理。</span><br><span class="line"><span class="number">2011</span> 年 <span class="number">6</span> 月，该项目通过了客户的验收，顾得了甲方的好评，成为公路运输行业实施条码技术的成功案例；得到业</span><br><span class="line">内的一致认可。本文结合作者的实际经验讨论了项目的范围管理，主要从制定范围计划、定义范围、创建 WBS，以及核实</span><br><span class="line">范围、控制范围这几个方面进行论述。</span><br><span class="line"></span><br><span class="line">正文:</span><br><span class="line"><span class="number">2009</span> 年 <span class="number">5</span> 月，我参与了××物流公司条形码项目建设，该项目应××物流公司由低端运输向高端公路快运转型的战略而</span><br><span class="line">立项，是 <span class="number">2009</span> 年该公司的重点项目。项目建设周期为 <span class="number">2</span>年，由 <span class="number">2009</span> 年 <span class="number">5</span> 月开始，到 <span class="number">2011</span> 年 <span class="number">6</span> 月验收结束，项目</span><br><span class="line">总投资为人民币 <span class="number">2000</span> 万元。其目标是建立一套高效实用的条码系统，全面提高流转交换的准确性和及时性，降低差错，</span><br><span class="line">提升运营服务质量，实现由低端运输向高端公路快运转型的战略目标。</span><br><span class="line">系统采用 C/S 架构，服务端应用采用 J2EE+Oracle 的模式开发，服务器使用 HP 的 <span class="number">580</span>G7， 操作系统为Redhat </span><br><span class="line">企业版 Linux <span class="number">5.4</span>，数据库使用 Oracle <span class="number">11</span>g R2 并做 RAC，中间件采用 IBM 的 WebSphere 并做集群，终端应用基千 </span><br><span class="line">Microsoft 的Windows CE 平台，采用 C#语言开发， 运行千 PDA 上。项目采用矩阵型组织结构，从各职能部门抽调主</span><br><span class="line">干成员，组成专门的项目团队。我被任命为该项目的项目经理，负责项目的管理工作，直接向项目总监汇报。下面我将结合</span><br><span class="line">本项目从制定范围管理计划、定义范围、创建工作分解结构、核实范围、控制范围这几个方面对项目的范围管理进行介绍。</span><br><span class="line">一、制定范围计划</span><br><span class="line">作为一名合格的项目管理者，做任何事之前都应该先做好计划。好的计划，是成功实施项目的基础。有些人为做项目</span><br><span class="line">范围计划花费了太多时间，不如把它们用千执行工作，项目将会更快更好地完成，我认为这是一个错误的想法，通过省略范</span><br><span class="line">围计划制定，虽然能短暂时间内节省一定的时间，但在长期来看，常常会因缺乏管理计划指导而使得范围定义不清、范围蔓</span><br><span class="line">延，以致无法完成项目。</span><br><span class="line">因此，在该项目中，我非常重视范围计划的制定，在正式做计划之前，我先查找了公司组织过程资产，找出制定范围管理计</span><br><span class="line">划的模板，再结合以往项目的经验，制定出一份初步的计划，然后召集项目团队成员讨论，对计划进行修改和完善，在全体</span><br><span class="line">参与下，最终完成一份详细的、科学的范围管理计划，用千指导项目如何定义、分解以及核实和控制范围。</span><br><span class="line"></span><br><span class="line">二、定义范围</span><br><span class="line">一个成功的项目，应该做且只做成功完成项目所需的全部工作。为了保证这一点，就需要在项目前期定义一个明确的</span><br><span class="line">项目范围。在项目的早期阶段，我带领团队，到了客户现场收集需求，我组织了客户的运营部门、服务质量部门、IT 部门</span><br><span class="line">以及我的需求团队，召开需求讨论会，共同商讨项目范围。在收集需求的时候，客户有时候需求描述得不是很清楚，造成了</span><br><span class="line">双方对需求理解有歧义，甚至有时候客户对千其需求自己都不清楚，只有一个模糊的概念； 针对这种情况，我采用原型法</span><br><span class="line">将收集到的需求，做成模型供客户参考确认，以此消除彼此的歧义，充分挖掘用户的需求，并基千团队自身的经验以及专业</span><br><span class="line">水平，对客户的需求进行引导、细化，将其模糊的概念形象化，粗糙的需求具体化。</span><br><span class="line">基于需求文件，我召集项目的主要干系人进行开会讨论，同时邀请了系统的最终用户代表（包括甲方的业务员，装卸</span><br><span class="line">工、调度等）对系统功能做评价，通过用户的角度，去发现和改进系统的功能，以此最终形成了完整的项目范围说明书，主</span><br><span class="line">要包含：CD条码项目的产品范围描述（包括取派件管理、装卸管理、异常管理等）；＠项目的主要可交付成果（用户文</span><br><span class="line">档、应用系统、源代码等）；＠产品验收标准（系统运行稳定、功能满足业务需求、相关文档齐全等）；＠项目的除外责任</span><br><span class="line">（该项目涉及的仓库环境改造，强电、弱电改造不包含在该项目范围中）；＠项目制约因素（之前的预算和系统设计仅针对</span><br><span class="line">定日达产品进行，如果扩展到零担，必须追加投入、延长项目时间）；＠项目假设条件（假设项目涉及的场站改造、人员素</span><br><span class="line">质提高可以配合条码项目进行持续改进，假设甲方的业务系统满足条码项目上线后给其增加的负载）；＠项目的目标、总预</span><br><span class="line">算、资源，以及主要里程碑等。</span><br><span class="line"></span><br><span class="line">三、创建 WBS</span><br><span class="line">基于项目范围说明书，我和我的团队开始对项目范围进行分解，以形成该项目的 WBS。在分解过程中，我按照以下原</span><br><span class="line">则进行分解。在各层次上保持项目的完整性，我将该项目涉及的需求调研、系统设计、开发、测试等完整的模块都一一列</span><br><span class="line">出，避免遗漏必要的组成部分。一个工作单元只从属千某个上层单元。对千该项目中的数据库设计，我就只将其归入系统设</span><br><span class="line">计单元中，在其他单元不再重复出现，避免了交叉从属。相同层次的工作单元应有相同性质。对千系统设计单元下的数据库</span><br><span class="line">设计、接口设计、系统设计等设计内工作，它们从属性上来讲， 都属千设计，因此我将其一并归入系统设计单元下。工作</span><br><span class="line">单元应能分开不同的责任者和不同的工作内容。对千该项目中每个工作包，我都指定唯一的负责人和其负责的工作内容，便</span><br><span class="line">千项目管理进行计划和控制的管理。对千该项目的每个工作包，我都对其进行编号，并与组织结构图和成本控制点深度融</span><br><span class="line">合，便千项目的日后管理。应包括项目管理工作，包括分包出去的工作。对千该项目，我将项目管理和外包的 AP 部署也</span><br><span class="line">一并纳入 WBS 中，并逐层分解。WBS 的最低层次的工作单元是工作包；对千该项目中工作单元，我参照 <span class="number">8</span>/<span class="number">80</span> 小时原则</span><br><span class="line">细化成具体的工作包，并指定具体的负责人。同时制作 WBS 词典，对工作包做具体描述。</span><br><span class="line"></span><br><span class="line">四、核实范围</span><br><span class="line"></span><br><span class="line">范围确认并不是件容易的事情，在与客户的沟通上，我们希望客户尽快确认以便尽快开展后续的开发阶段工作，而客</span><br><span class="line">户则可能认为自己什么也没看到，怎么确认呢？针对这种情况， 我在提交文档给客户的相关干系人后，重点对客户的 IT </span><br><span class="line">人员进行沟通培训，详细介绍系统的设计，然后用他们的声音去向客户的业务部门做出介绍，这样既有益千专业人员之间的</span><br><span class="line">技术沟通，也有益千客户业务部门对系统范围的认可与信任。同时，在与客户的业务部门沟通时，我重点强调，虽然范围确</span><br><span class="line">认是正式的，但这并不意味着项目的范围就是铁板一块，不能再修改了，只要走标准的变更流程，且审批通过的，都是可以</span><br><span class="line">进行变更的。这样就消除了客户的顾虑，便千快速、高效地完成范围确认。</span><br><span class="line"></span><br><span class="line">五、控制范围</span><br><span class="line"></span><br><span class="line">控制范围就是监督项目的范围状态，管理范围基础变更的过程。因此在项目中，我定期组织召开项目状态审查会，审查项目</span><br><span class="line">的范围，通过对照范围基础，找出范围偏差，并做分析，严格杜绝一切的范围蔓延以及锁金。</span><br><span class="line">例如，在一次状态审查会上，我发现项目的功能模块中，系统管理以及库存管理模块多了登录日志以及盘库两块功</span><br><span class="line">能，我查了一下系统变更日志，未找到有类似的变更记录，千是我参照责任分配矩阵，分别找到这两个模块开发的负责人询</span><br><span class="line">问原因，A 成员告诉我，他增加登录日志这个功能，是因为客户在一次电话中，向他提过希望在系统管理模块中加一个登</span><br><span class="line">录日志的功能，B 成员则是因为在开发库存管理模块时，发现整个库存管理没有库存盘点的功能，他认为做库存管理，肯</span><br><span class="line">定需要用到盘点功能，而且这是个亮点，所以他私自增加了这一功能。针对这两种情况，我首先向这两名成员强调了范围基</span><br><span class="line">准以及变更流程的重要性；其次， 针对这两项多出来的功能，我要求相关人员提交正式的变更申请，走正常的变更控制流</span><br><span class="line">程。从事项目管理工作的我深知，项目范围不是一经定义，就一成不变的，项目干系人出千项目利益以及各种情况考虑，总</span><br><span class="line">会有一些需求变更，管理这些变更，需要在项目规划时，就制定好变更控制流程以及成立一个专门的需求变更控制委员会</span><br><span class="line">（CCB）。</span><br><span class="line">因此，我和我的团队在项目早期就制定了一套标准的变更流程：CD提交变更申请；＠评估变更；＠报 CCB 审批；＠</span><br><span class="line">实施变更并调整基准；＠将变更信息通知相关干系人；＠对变更的结果进行追踪与审核。有了这些流程以及 CCB 的</span><br><span class="line">控制，项目的需求变更得以良性发展，变更带来更多的是项目利益以及效率的提升。</span><br><span class="line">经过我和我的团队不懈努力，该项目最终千 <span class="number">2011</span> 年 <span class="number">5</span> 月试运行成功，并在同年 <span class="number">6</span> 月通过了客户验收小组的验收，</span><br><span class="line">得到了甲方的好评，使得××物流公司运营的货物差错率降低了<span class="number">50</span>%，客户投诉率降低了 <span class="number">20</span>%，理赔损失降低了 <span class="number">20</span>%，提升</span><br><span class="line">了该公司的整体运营服务水平、客户满意度及公司形象，为××物流公司由低端运输向高端公路快运转型提供强有力的保</span><br><span class="line">障。项目最终能成功完成，得益千我在项目中有效的范围管理，采用科学的范围管理方法、工具和技术，为项目的范围管理</span><br><span class="line">带来了事半功倍的效果。同时，在该项目的实施过程中，也出现了一些问题，本人觉得处理得不是很好，主要在千项目中的</span><br><span class="line">冲突管理以及项目风险识别方面还存在不足，后续我将加强这两个方面的学历与知识积累，不断提升自身项目管理水平，为</span><br><span class="line">中国物流行业的信息化发展添砖加瓦</span><br></pre></td></tr></table></figure><h3 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">项目范围管理是项目管理的核心部分，是项目管理的必要条件，是项目管理持续发展的基础，是项目管理有效进行的前提。</span><br><span class="line">我从范围规划、范围定义、工作分解结构、范围确认、范围控制等五个方面开展了项目范围管理的工作。</span><br><span class="line"></span><br><span class="line">第一，范围规划。</span><br><span class="line">范围规划是项目范围管理的第一个环节。范围规划确保范围定义、工作分解结构、范围确认和范围控制如何开展。</span><br><span class="line"></span><br><span class="line">第二，范围定义。</span><br><span class="line">范围定义是制定项目范围说明书的过程，项目范围说明书是确定整个项目工作中的可交付物及提交可交付物所做的工作。本</span><br><span class="line">项目采用快速原型结合面向对象开发的方法。先根据甲方沟通，确定甲方的重要项目干系人分类。一类是甲方的领导层确定</span><br><span class="line">系统要达到的整体目标，另一类是甲方的业务人员，他们的要求是系统的具体功能。我方人员通过与各类项目干系人进行沟</span><br><span class="line">通，通过制作界面原型与甲方不断确认，把需求确定下来，把范围确定下来。</span><br><span class="line"></span><br><span class="line">第三，创建工作分解结构。</span><br><span class="line">创建工作分解结构项目范围管理的重要环节。通过工作分解结构把项目的整体工作分解成工作包。通过滚动式规划，把近期</span><br><span class="line">的工作分解较为详细，远期的工作分解较为初略。根据工作分解结构，初步整个项目分解成业务需求、用户需求、功能需</span><br><span class="line">求、概要设计、详细设计、系统编码、单元测试、整体测试、集成测试、安全测试、压力测试、系统培训、系统试运行。</span><br><span class="line"></span><br><span class="line">第四，范围确认。</span><br><span class="line">范围确认是我方与甲方对项目说明书确认的一个过程，对于系统开发过程中所提交的文档、资料、软件等可交付物及为这些</span><br><span class="line">交付物所做的工作的确认。整个范围确认是贯穿整个过程的始终。我方和用户方商定，所有的提交的可交付物，用户必须制</span><br><span class="line">定项目联系人签字盖章，如果拒绝提交，也要提出书面说明。</span><br><span class="line"></span><br><span class="line">第五，范围控制。</span><br><span class="line">范围控制是保证整个项目有效实施的重要内容。我方与用户方成立变更控制委员会。对用户方提出的范围变更请求必须提交</span><br><span class="line">书面申请，由变更控制委员会进行审核，审核通过后执行，并对执行的结果进行跟踪。建立sourcesafe软件配置管理系</span><br><span class="line">统。把所有的文档用配置管理系统管理起来，对整个项目的管理及范围变更有非常清晰的认识。</span><br></pre></td></tr></table></figure><h2 id="三、进度管理"><a href="#三、进度管理" class="headerlink" title="三、进度管理"></a>三、进度管理</h2><h3 id="3-1-可以从以下方面去写"><a href="#3-1-可以从以下方面去写" class="headerlink" title="3.1 可以从以下方面去写:"></a>3.1 可以从以下方面去写:</h3><p>①: 7个过程       (命题概率较大)</p><p>②: PDCA          (命题概率较大)</p><h3 id="3-2-写作思路"><a href="#3-2-写作思路" class="headerlink" title="3.2 写作思路:"></a>3.2 写作思路:</h3><table><thead><tr><th>过程</th><th>通俗解释</th><th>写作要点(举例: 根据子题目写)</th></tr></thead><tbody><tr><td>1 制定进度管理计划</td><td>写一个叫做进度管理计划的文档</td><td>我组织相关人员进行了进度管理计划的编制工作，在进行编制前做了什么准备,通过什么方法进行了编制，编制后的计划包含什么内容等，计划的重要性等等</td></tr><tr><td>2 定义活动</td><td>看项目里面到底有多少活动需要完成，识别出来并记录下来</td><td>活动定义和 WBS 的关系，举例写下结合本项目有哪些活动？</td></tr><tr><td>3 排列活动顺序</td><td>明确各活动之间的顺序等相互的依赖关系，并记录下来</td><td>举例描述下活动的逻辑关系</td></tr><tr><td>4 估算活动资源</td><td>估算下每个活动到底需要多少材料、人员、设备等等资源</td><td>某某活动需要什么资源，需要多少资源，什么时候需要等等。是通过什么方式进行估算的等内容</td></tr><tr><td>5 估算活动持续时间</td><td>估算下完成某活动所需要的持续时间</td><td>什么方法对本项目中的一些活动进行了历时估算，是多少时间等。</td></tr><tr><td>6 制定进度计划</td><td>分析这些活动的顺序、历时、资源需求和相关的一些进度约束等内容来编制项目的进度计划</td><td>通过什么方法进行进度计划的制定的</td></tr><tr><td>7 进度控制</td><td>监控项目的具体状态， 如果发现有偏差，我们需要进行纠偏</td><td>进度控制的重要性、工作内容，举例挣值分析，发现项目进度怎么样了，分析为什么，进行纠偏</td></tr></tbody></table><h3 id="3-3-过程-输入-输出-工具和技术"><a href="#3-3-过程-输入-输出-工具和技术" class="headerlink" title="3.3 过程,输入,输出,工具和技术"></a>3.3 过程,输入,输出,工具和技术</h3><table><thead><tr><th>过程+输入</th><th>工具/技术</th><th>输出</th></tr></thead><tbody><tr><td><font color="red" size="5">3.3.1 规划进度管理</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>进度管理计划</td></tr><tr><td>②: 项目章程</td><td>分析技术</td><td></td></tr><tr><td>③: 事业环境因素</td><td>会议</td><td></td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 章程计划找业组,分家会上进管子</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.2 定义活动</font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>分解</td><td>活动清单</td></tr><tr><td>②: 范围基准</td><td>滚动式规则</td><td>活动属性</td></tr><tr><td>③: 事业环境因素</td><td>专家判断</td><td>里程碑清单</td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组进管炒基范,分家滚出清属里</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.3 排列活动顺序</font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>紧前关系绘图法PDM</td><td>项目进度网络图</td></tr><tr><td>②: 活动清单</td><td>确定依赖关系</td><td>项目文件更新</td></tr><tr><td>③: 活动属性</td><td>提前与滞后</td><td></td></tr><tr><td>④: 里程碑清单</td><td></td><td></td></tr><tr><td>⑤: 项目范围管理书</td><td></td><td></td></tr><tr><td>⑥: 事业环境因素</td><td></td><td></td></tr><tr><td>⑦: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 范进业组清属里, 前后紧赖网新文</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.4 估算活动资源 </font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>自下而上估算</td><td>资源分解结构</td></tr><tr><td>②: 活动清单</td><td>备选方案分析</td><td>活动资源需求</td></tr><tr><td>③: 活动属性</td><td>项目管理软件</td><td>项目文件更新</td></tr><tr><td>④: 资源日历</td><td>发布的估算数据</td><td></td></tr><tr><td>⑤: 风险登记册</td><td>专家判断</td><td></td></tr><tr><td>⑥: 活动成本估算</td><td></td><td></td></tr><tr><td>⑦:  事业环境因素</td><td></td><td></td></tr><tr><td>⑧: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组进管估成本,清属资历有风险</font></td><td>自选软件算专家</td><td>分解需求新文件</td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.5 估算活动持续时间 </font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>专家判断</td><td>活动持续时间估算</td></tr><tr><td>②: 活动清单</td><td>类比估算</td><td>项目文件更新</td></tr><tr><td>③: 活动属性</td><td>参数估算</td><td></td></tr><tr><td>④: 活动资源需求</td><td>三点估算</td><td></td></tr><tr><td>⑤: 资源日历</td><td>群体决策技术</td><td></td></tr><tr><td>⑥: 项目范围说明书</td><td>储备分析</td><td></td></tr><tr><td>⑦: 风险登记册</td><td></td><td></td></tr><tr><td>⑧: 资源分解结构</td><td></td><td></td></tr><tr><td>⑨: 事业环境因素</td><td></td><td></td></tr><tr><td>⑩: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组资需分日进,清属范书有风险</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.6 制定进度计划 </font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>进度网络分析</td><td>进度基准</td></tr><tr><td>②: 活动清单</td><td>关键路径法</td><td>项目进度计划</td></tr><tr><td>③: 活动属性</td><td>关键链法</td><td>进度数据</td></tr><tr><td>④: 项目进度网络图</td><td>资源优化技术</td><td>项目日历</td></tr><tr><td>⑤: 活动资源需求</td><td>建模压缩技术</td><td>项目管理计划更新</td></tr><tr><td>⑥: 资源日历</td><td>提前与滞后</td><td>项目文件更新</td></tr><tr><td>⑦: 活动持续时间估算</td><td>进度压缩</td><td></td></tr><tr><td>⑧: 项目范围说明书</td><td>进度计划编制</td><td></td></tr><tr><td>⑨: 风险登记册</td><td></td><td></td></tr><tr><td>⑩: 项目人员分配</td><td></td><td></td></tr><tr><td>⑩: 资源分解结构</td><td></td><td></td></tr><tr><td>⑩: 事业环境因素</td><td></td><td></td></tr><tr><td>⑩: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组资需分日进,清属范书有风险,人员进</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.7 控制进度计划 </font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>绩效审查</td><td>工作绩效信息</td></tr><tr><td>②: 进度管理计划</td><td>项目管理软件</td><td>进度预测</td></tr><tr><td>③: 工作绩效数据</td><td>资源优化技术</td><td>变更请求</td></tr><tr><td>④: 项目日历</td><td>建模技术</td><td>项目管理计划更新</td></tr><tr><td>⑤: 进度数据</td><td>提前与滞后</td><td>项目文件更新</td></tr><tr><td>⑥: 组织过程资产</td><td>进度压缩</td><td>组织过程资产更新</td></tr><tr><td></td><td>进度计划编制工具</td><td></td></tr><tr><td><font color="green" size="5">口诀: 两数两划组日历</font></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-4-范文-举例"><a href="#3-4-范文-举例" class="headerlink" title="3.4 范文: 举例"></a>3.4 范文: 举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">论项目进度管理</span><br><span class="line">【摘要】</span><br><span class="line"><span class="number">2008</span> 年 <span class="number">10</span> 月，XX 发展股份有限公司作为系统集成项目的总包商承接了 XX 市人力资源和社会保障局所委托的XX</span><br><span class="line">市基本臣疗保险门诊实时结算信息系统建设项目，我作为项目经理负责全程管理该项目，该项目的主要业务目标是建设</span><br><span class="line">覆盖全市 <span class="number">1800</span> 家臣保定点臣疗机构的门诊实时结算系统;在实施该项目过程中，项目在时间管理方面具有以下特点:项</span><br><span class="line">目业务功能复杂，涉及到 XX 市 <span class="number">1800</span> 家臣保定点臣疗机构和 <span class="number">1300</span> 万臣保参保人，同时该项目工期较长历时一年</span><br><span class="line">多，涉及的项目干系人众多，并目_项目属千 <span class="number">2009</span> 年 XX 市政府折子土程，要求必须在 <span class="number">2009</span> 年底完成。因而该项目</span><br><span class="line">的时间管理是项目成功的关键。</span><br><span class="line">在充分分析了该项目特点的基础上，在时间管理方面我对项目的所有活动通过活动分解进行了定义，使用前导图的方法</span><br><span class="line">对项目活动进行了排序，经过对项目活动的资源估算、项目活动历时估算并制订了项目进度计划，形成了项目进度甘特</span><br><span class="line">图，在项目执行过程中依据项目甘特图，进行项目绩效测量，根据绩效测量的结果以及通过项目进度变更控制系统对项</span><br><span class="line">目进度进行了很好的控制。在项目的各个里程碑阶段都很好地在确保项目质量和成本的基础上， 按照项目时间进度计</span><br><span class="line">划完成了项目。最终，在 <span class="number">2009</span> 年底由 XX 市政府正式宣布系统一次性上线成功。</span><br><span class="line">该项目在时间管理过程中还存在一些不足，例如在活动历时估算时我们还应该更多的安排预留时间，为项目风险做好时</span><br><span class="line">间方面的准备;在制订顷目进度计划时，我们还应该更多考</span><br><span class="line">虑资源平衡方面的问题，使项目资源得到更充分的利用;在进度控制阶段，我们在各个里程碑评审过程中还应该增加用</span><br><span class="line">户参与，与用户更好地进行项目进度沟通。争取在今后的项目管理过程中百尺竿头、更进一步。</span><br><span class="line"></span><br><span class="line">【正文】</span><br><span class="line"><span class="number">2008</span> 年 <span class="number">10</span> 月，XX 发展股份有限公司作为系统集成总承包商承接了 XX 市人力资源和社会保障局所委托的 XX 市基</span><br><span class="line">本臣疗保险门诊实时结算项目，我作为项目经理负责全程项日管理，并参与了业务需求讨论和系统分析等工作。该项目</span><br><span class="line">覆盖了全市 <span class="number">18</span> 个区县、<span class="number">1800</span> 家臣保定点臣疗机构和 <span class="number">1300</span> 万参保人。在参保人门诊就臣费用结算时，使用社保片实</span><br><span class="line">时计算臣保基金和个人支付金额，参保个人只需负担个人支付金额即可完成结算过程，将门诊费用报销支付时间由几个</span><br><span class="line">月缩短为儿秒钟，极大地方便了参保人。该项目从 <span class="number">2008</span> 年 <span class="number">10</span> 月开工，到<span class="number">2009</span> 年 <span class="number">12</span> 月验收结束，历时一年多，</span><br><span class="line">项目涉及 XX 市和 <span class="number">18</span> 区县人社局、<span class="number">1800</span> 家定点臣疗机构，项目干系人众多，项目业务需求内容繁多。由千项目属千 </span><br><span class="line">XX 市政府折子工程，项目时间进度要求必须在 <span class="number">2009</span> 年底完成，项目管理过程中的时间管理尤为重要，是项目是否成</span><br><span class="line">功的重要评价标准。在具体管理过程中，我根据项目实际情况，遵循时间管理的主要方法， 对项目活动进行了定义、</span><br><span class="line">排序，资源估算、历时估算并制订了项目进度计划，在项目执行过程中，通过项目进度变更控制系统对项目进度进行很</span><br><span class="line">好的控制，最终在既定的时间完成了所有项目工作，取得了良好的效果。<span class="number">2009</span> 年底由 XX 市政府正式宣布一次性上线</span><br><span class="line">成功，目前运行情况良好。</span><br><span class="line"></span><br><span class="line">一、活动定义</span><br><span class="line">首先，我们根据项目范围说明书以及项目的 WBS 对项目的所有活动进行了定义。我们将项目先进行了阶段定义，包括</span><br><span class="line">项目的需求获取、需求分析、系统设计、系统开发、系统测试、用户测试、系统试点、系统正式上线阶段，然后，我根</span><br><span class="line">据项目进展的不同阶段，采用滚动规划方法，将项目涉及到的所有活动逐步进行了定义。对千近期需要完成的工作在工</span><br><span class="line">作分解结构最下层详细规划，远期需要完成的工作则表现在工作分解结构相对高的层次上。通过滚动规划方式随着项目</span><br><span class="line">工作的开展，项目活动也逐层逐步清晰。</span><br><span class="line"></span><br><span class="line">二、活动排序</span><br><span class="line">根据活动定义，我将所有活动进行了排序，通过前导图的方法，将所有活动之间的依赖关系整理形成项目网络图。在此</span><br><span class="line">阶段中最重要的就是明确各个活动之间的依赖关系，例如在系统测试试阶段，我们通过与用户沟通，最终明确先进行我</span><br><span class="line">们公司内部的自测工作，然后由用户代表在公司的实验室环境下进行用户测试，最后再选择两家试点臣院在臣院实地环</span><br><span class="line">境下进行现场测试;而对千公司内部测试阶段，我们将臣院端系统与区县经办机构端的系统进行同步闭环测试。</span><br><span class="line"></span><br><span class="line">三、活动的资源估算</span><br><span class="line">为了做好所有项目活动在所需资源上面的准备工作，我们还对项目活动的资源进行了估算，通过自下而上的估算方法我</span><br><span class="line">们整理了整个项目所需要的相关资源。例如在测试阶段，我们针对所需要测试的系统数量、每个系统的测试人员数量，</span><br><span class="line">以及试点测试臣院的数量，我们估算了所需要测试用忱卡机具以及测试卡的数量，在系统测试之前要求机具和卡片提供</span><br><span class="line">商必须按时提供测试用的设各以保证测试工作的顺利进行。</span><br><span class="line"></span><br><span class="line">四、活动的历时估算</span><br><span class="line">对千活动历时估算我们使用了活动历时二点估算法，由千在系统开发过程中业务算法相对比较复杂，具体开发过程中可</span><br><span class="line">能会遇到很多不确定因素，为此，我要求项目人员估算了最乐观、最悲观以及最可能的时间的开发时间，使用三点估算</span><br><span class="line">法计算公式计算出项目活动的历时估算。例如对千系统测试工作，无法很准确地估算测试 bug 的修改时间，为此我要</span><br><span class="line">求测试人员进行了三点估算，最乐观的时间为 <span class="number">3</span> 周，最悲观的时间为 <span class="number">8</span> 周，最可能的时间为 G 周，通过三点估算公</span><br><span class="line">式计算出估算时间为 <span class="number">5.9</span> 周。通过使用三点估算法设置统计权重，运用统计规律降低了项目历时的不确定性。</span><br><span class="line"></span><br><span class="line">五、制订进度计划</span><br><span class="line">在前期时间管理工作的基础上，我制订了项目进度计划，通过项目甘特图全面反映了项目进度状况。在制订进度计划过</span><br><span class="line">程中，使用了关键路径法，根据各项目活动之间的依赖关系以及项目活动所使用的资源情况，我们分析并寻找了项目的</span><br><span class="line">关键活动，并形成了项目的关键路径。通过平衡与协调项目资源使用情况，最终制订了项目计划甘特图。为了使项目干</span><br><span class="line">系人都了解和掌握项目进度计划，我们还将项目计划甘特图印刷成册，形成了项目手册，下发给项目参与各方，得到了</span><br><span class="line">用户方以及项目监理方的好评。</span><br><span class="line"></span><br><span class="line">六、进度控制</span><br><span class="line">在项目执行过程中，每周各子项目组根据项目进展报告进行挣值分析，并形成项目跟踪甘特图，并与项目计划甘特图进</span><br><span class="line">行比对，如果发现有滞后现象则安排项目组进行赶工。每两周项目整体进行绩效测量通过挣值分析以及项目跟踪甘特图</span><br><span class="line">进行绩效评估。如果出现进度变更，则通过项目组以及公司两级进度变更控制系统进行变更评审。对千项目工作重大的</span><br><span class="line">变更则由项目监理公司主持召开项目监理会，与用户方和监理方共同沟通项目进度变更情况，对千批准的变更申请，在</span><br><span class="line">监理会后形成项目进度变更报告，发送项目相关各方。</span><br><span class="line">【结束语】</span><br><span class="line">在门诊实时结算项目管理过程中，我全面应用了项目时间管理的方法，使得该项目在时间管理方面较好地达到了预期目</span><br><span class="line">的，确保了 <span class="number">2009</span> 年底系统上线。鉴千我们在项目初期通过项目工作分解进行了活动定义，使用了前导图法对项目活动</span><br><span class="line">进行了排序，并使用了自下而上的估算方法对项目活动进行了资源估算，使用了项目历时三点估算法降低了历时估算的</span><br><span class="line">不确定性，最终形成项目进度计划，并在项目执行过程中很好地运用了绩效测量以及项目组与公司两级进度控制系统，</span><br><span class="line">对项目进度进行了控制，并且在项目监理方的组织下与用户进行了有效的沟通，最终确保了在 <span class="number">2009</span> 年底完成了项目所</span><br><span class="line">有工作，并由 XX 市政府正式宣布一次性上线成功。</span><br><span class="line">通过总结，对千项目在时一间管理方面我认为还存在一些不足:</span><br><span class="line">第一，在项目活动历时一估算时还应该更多的安排预留时间，为项目风险做好时间方面的准备。</span><br><span class="line">第二，在制订进度计划方面还应该更多考虑资源平衡方面的问题，使项目在确保时间进度不变的情况下更好地减少成</span><br><span class="line">本。</span><br><span class="line">第三，在项目执行过程中，各个里程碑评审过程还应该加强用户参与，在项目进度方面增加与用户的沟通。如果对千以</span><br><span class="line">上方面能够进行更好的总结与提高，在今后的项目管理过程中时间管理的水平将得到不断提高，真正达</span><br><span class="line">到“百尺竿头、更进一步”的目标。</span><br></pre></td></tr></table></figure><h3 id="3-5-模板"><a href="#3-5-模板" class="headerlink" title="3.5 模板"></a>3.5 模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">项目时间管理是项目管理的一个非常重要的环节，是项目管理的必要条件之一，是保障项目的有序的进行的基础，确保项目</span><br><span class="line">的持续发展的前提。因此，我从活动定义、活动排序、活动资源评估、活动历时评估、制定进度表和进度控制等六个方面对</span><br><span class="line">项目时间管理进行了把握。</span><br><span class="line"></span><br><span class="line">第一，活动定义。</span><br><span class="line">根据项目范围说明书、项目管理计划、组织过程资产等资料，我对整个项目进行活动定义。通过四个步骤控制账户、规划定</span><br><span class="line">义、工作包、活动对整个项目进行分解。通过滚动式规划对近期发生的工作进行详细分解，把分解活动放在工作分解结构的</span><br><span class="line">最下层。把远期发生的工作暂时放在工作分解结构的上层。根据整个项目情况，工作包分解成需求分析、概要设计、详细设</span><br><span class="line">计、系统编码、系统测试、系统培训、系统试运行、系统上线。然后在把每个工作包在进行详细分解成活动。例如系统测试</span><br><span class="line">分解成单元测试、整体测试、集成测试、安全测试、压力测试。定义好后列出活动清单及活动属性。</span><br><span class="line"></span><br><span class="line">第二，活动排序。</span><br><span class="line">活动排序是时间管理的第二个步骤。根据活动清单用前导图的方法对活动进行排序。例如系统编码工作中，某程序员负责基</span><br><span class="line">础信息采集的子系统的编码，他所进行的工作分解后，按照活动顺序依次为行政区采集的编码，户人口信息的采集编码、户</span><br><span class="line">成员基础信息采集编码、已婚育龄妇女基础信息的采集编码、已婚育龄妇女指纹接口对接的编码、手术人员基础信息的采集</span><br><span class="line">编码、新生儿基础信息的采集编码。</span><br><span class="line"></span><br><span class="line">第三，活动资源估算。</span><br><span class="line">活动资源估算是每个活动占用的资源进行估算。根据活动的资源估算汇总成工作包所占的资源估算。例如，编码的活动定义</span><br><span class="line">和排序完成以后，根据活动的数量及难易程度，判断开发这些活动所需的高级程序员以及普通程序员的人数，某某省某某市</span><br><span class="line">人口计划和生育系统需要<span class="number">4</span>个高级程序员和<span class="number">2</span>个普通程序员。</span><br><span class="line"></span><br><span class="line">第四，活动历时估算。</span><br><span class="line">活动历时估算是估算每个活动所占用的时间。根据活动开发的工作量的大小判断活动的时间。根据过去开发项目的经验，我</span><br><span class="line">对这次项目开发进行了估算。例如权限管理和用户管理功能因过去有开发项目的源代码，因此编码及单元测试的时间估算为</span><br><span class="line"><span class="number">2</span>天。</span><br><span class="line"></span><br><span class="line">第五，制定进度表。</span><br><span class="line">制定进度表是项目时间管理中关键的一环，因此根据前导图，通过关键路径法制定出真个个开发过程的时间。需求分析<span class="number">1</span>个</span><br><span class="line">月、系统设计<span class="number">1</span>个月、系统编码<span class="number">6</span>个月、系统测试<span class="number">1</span>个月、系统培训<span class="number">1</span>个月、系统试运行<span class="number">3</span>个月。因此从系统需求分析到系统正</span><br><span class="line">式上线的周期大概为<span class="number">1</span>年零<span class="number">1</span>个月。</span><br><span class="line"></span><br><span class="line">第六，进度控制。</span><br><span class="line">进度控制对于项目时间管理来说是非常重要的环节。根据项目实际开发的时间与进度表的时间的偏差进行计算，判断项目时</span><br><span class="line">间进展情况。在开发的过程中，由于统计报表管理中人口计划生育国统七张表的统计口径根据政策发生了变更，然后活动重</span><br><span class="line">新进行了定义排序估算，根据新的时间，开发周期将会超期。为此，我们利用赶工的方法，加班加点把统计报表子系统在预</span><br><span class="line">计的周期内完成。</span><br></pre></td></tr></table></figure><h2 id="四、成本管理"><a href="#四、成本管理" class="headerlink" title="四、成本管理"></a>四、成本管理</h2><h2 id="五、质量管理"><a href="#五、质量管理" class="headerlink" title="五、质量管理"></a>五、质量管理</h2><h2 id="六、人力资源管理"><a href="#六、人力资源管理" class="headerlink" title="六、人力资源管理"></a>六、人力资源管理</h2><h2 id="七、沟通管理"><a href="#七、沟通管理" class="headerlink" title="七、沟通管理"></a>七、沟通管理</h2><h2 id="八、风险管理"><a href="#八、风险管理" class="headerlink" title="八、风险管理"></a>八、风险管理</h2><h2 id="九、采购管理"><a href="#九、采购管理" class="headerlink" title="九、采购管理"></a>九、采购管理</h2><h2 id="十、干系人管理"><a href="#十、干系人管理" class="headerlink" title="十、干系人管理"></a>十、干系人管理</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;十大知识领域、五大项目管理过程组、47个过程&quot;&gt;&lt;a href=&quot;#十大知识领域、五大项目管理过程组、47个过程&quot; class=&quot;headerlink&quot; title=&quot;十大知识领域、五大项目管理过程组、47个过程&quot;&gt;&lt;/a&gt;十大知识领域、五大项目管理过程组、47个过程&lt;/h3&gt;&lt;p&gt;启动过程组 2个&lt;br&gt;规划过程组 24个&lt;br&gt;执行过程组 8个&lt;br&gt;监控过程组 11个&lt;br&gt;收尾过程组 2个&lt;/p&gt;
    
    </summary>
    
      <category term="考证" scheme="https://zzwwqq.xyz/categories/%E8%80%83%E8%AF%81/"/>
    
    
      <category term="信息系统项目管理师" scheme="https://zzwwqq.xyz/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
      <category term="论文" scheme="https://zzwwqq.xyz/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zzwwqq.xyz/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://zzwwqq.xyz/信息系统项目管理师常考知识点.html</id>
    <published>2019-04-13T03:31:36.513Z</published>
    <updated>2019-05-21T16:29:22.174Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java网络编程之TCP-UDP</title>
    <link href="https://zzwwqq.xyz/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP.html"/>
    <id>https://zzwwqq.xyz/java网络编程之TCP-UDP/java网络编程之TCP-UDP.html</id>
    <published>2019-04-13T01:49:05.000Z</published>
    <updated>2019-04-13T03:22:20.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网络编程基础"><a href="#一、网络编程基础" class="headerlink" title="一、网络编程基础"></a>一、网络编程基础</h2><h3 id="1-1-网络编程有两个主要的问题"><a href="#1-1-网络编程有两个主要的问题" class="headerlink" title="1.1 网络编程有两个主要的问题:"></a>1.1 网络编程有两个主要的问题:</h3><p>①: 如何准确定位网络上的一台或多台主机<br>②: 定位后如何可靠高效的传输数据</p><a id="more"></a><p>在TCP/IP中,IP层主要负责网络主机的定位,数据传输的路由,由IP地址可以唯一的确定网络上的一台主机.<br>而TCP层提供面向应用的数据传输机制,这是网络编程的主要对象.</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2  基本概念:"></a>1.2  基本概念:</h3><p><strong>端口号:</strong>  网络通信时同一机器上的不同进程的标识（其中0~1023为系统保留的端口号）,<strong>端口范围: 0~65535</strong><br><strong>套接字:</strong>  <strong>IP : 端口号</strong><br><strong>资源名: </strong>是资源的完整地址,包括主机名,端口号,文件名,如<a href="http://www.sun.com" target="_blank" rel="noopener">http://www.sun.com</a> （协议名://主机名）<a href="http://home.netscape.com/home/welcome.html（协议名：/机器名+文件名）" target="_blank" rel="noopener">http://home.netscape.com/home/welcome.html（协议名：//机器名+文件名）</a><br><strong>协议名：</strong>指明获取资源时所使用的传输协议。  如http，ftp,gopher,file</p><h3 id="1-3-关于UDP"><a href="#1-3-关于UDP" class="headerlink" title="1.3 关于UDP:"></a>1.3 关于UDP:</h3><p>UDP: <strong>无连接</strong>的协议,<strong>每个数据报都是一个独立的信息</strong>,<strong>包括完整的源地址或目的地址</strong>,它在网络上任何可能路径传往目的地<br>,<strong>不可靠性</strong>(发送方发送的数据报不一定以相同次序到达接收方),<strong>传输效率高</strong>,<strong>有大小限制</strong>(每个数据报大小不超过64KB),.</p><h3 id="1-4-获取网络信息和资源"><a href="#1-4-获取网络信息和资源" class="headerlink" title="1.4 获取网络信息和资源:"></a>1.4 获取网络信息和资源:</h3><h4 id="1-4-1-非常重要的一个类-InetAddress-IP地址的封装类"><a href="#1-4-1-非常重要的一个类-InetAddress-IP地址的封装类" class="headerlink" title="1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)"></a>1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)</h4><p>java.net中很多类使用到了它,如ServerSocket, Socket , DatagramSocket等</p><h4 id="1-4-2-常用方法"><a href="#1-4-2-常用方法" class="headerlink" title="1.4.2 常用方法:"></a>1.4.2 常用方法:</h4><p><strong>获取本机主机名:</strong> InetAddress.getLocalHost().getHostName()<br><strong>获取本机IP:</strong>  InetAddress.getLocalHost().getHostAddress()<br><strong>获取本机端口: </strong>serverSocket = new ServerSocket(6666); serverSocket.getLocalPort();</p><p><strong>服务器端获取客户端IP: </strong>Socket socket = serverSocket.accept(); socket.getInetAddress().getHostAddress();<br><strong>服务器获取客户端端口: </strong>String.valueOf(socket.getPort())</p><h2 id="二、基于TCP的网络通信"><a href="#二、基于TCP的网络通信" class="headerlink" title="二、基于TCP的网络通信:"></a>二、基于TCP的网络通信:</h2><h3 id="2-1-通过套接字建立连接的过程"><a href="#2-1-通过套接字建立连接的过程" class="headerlink" title="2.1 通过套接字建立连接的过程:"></a>2.1 通过套接字建立连接的过程:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.1.png" alt></p><h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例:"></a>2.2 实例:</h3><p><strong>客户端:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Client();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Socket sock;</span><br><span class="line">    <span class="comment">//界面上显示的组件</span></span><br><span class="line">    JTextField txtMsgServerIP = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JTextField txtMsgServerPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    JButton btnConnect = <span class="keyword">new</span> JButton(<span class="string">"连接服务器"</span>);</span><br><span class="line">    JButton btnDisConnect = <span class="keyword">new</span> JButton(<span class="string">"断开连接"</span>);</span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据输入输出流</span></span><br><span class="line">    DataOutputStream out;</span><br><span class="line">    DataInputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> canWaite = <span class="keyword">true</span>;</span><br><span class="line">    CWaiter waiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器中完成初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//容器</span></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始状态时"连接服务器"按钮可点击</span></span><br><span class="line">        btnConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//初始状态时"断开连接"按钮不可点击</span></span><br><span class="line">        btnDisConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时文本域不可编辑,只能用于显示通话信息</span></span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时发送消息的编辑框不可输入</span></span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时发送按钮不可点</span></span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建面板</span></span><br><span class="line">        JPanel jp =  <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER));</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器IP"</span>));</span><br><span class="line">        jp_f1.add(txtMsgServerIP);</span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器端口号"</span>));</span><br><span class="line">        jp_f1.add(txtMsgServerPort);</span><br><span class="line"></span><br><span class="line">        jp_f2.add(btnConnect);</span><br><span class="line">        jp_f2.add(btnDisConnect);</span><br><span class="line"></span><br><span class="line">        jp.add(jp_f1);</span><br><span class="line">        jp.add(jp_f2);</span><br><span class="line">        <span class="comment">//创建面板,并把组件添加到面板</span></span><br><span class="line">        JScrollPane jsp =  <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp2 = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组件添加到面板</span></span><br><span class="line"></span><br><span class="line">        jp2.add(txtMsgSend);</span><br><span class="line">        jp2.add(btnSend);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//面板添加到容器</span></span><br><span class="line">        container.add(jp,<span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp,<span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp2,<span class="string">"South"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口标题</span></span><br><span class="line">        setTitle(<span class="string">"客户端"</span>);</span><br><span class="line">        <span class="comment">//窗口大小</span></span><br><span class="line">        setSize(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//是否可见</span></span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给组件添加监听器</span></span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnConnect.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnDisConnect.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加窗口监听器</span></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//窗口关闭事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    disconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String ServerIP,Integer ServerPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建套接字,用于连接服务器</span></span><br><span class="line">            sock = <span class="keyword">new</span> Socket(ServerIP,ServerPort);</span><br><span class="line">            <span class="comment">//由套接字获取输入输出流</span></span><br><span class="line">            InputStream is = sock.getInputStream();</span><br><span class="line">            OutputStream os = sock.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由输入输出流获取数据输入输出流</span></span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(is);</span><br><span class="line">            out = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向输出流(向服务器端)写数据</span></span><br><span class="line">            out.writeUTF(<span class="string">"客户进来"</span>);</span><br><span class="line">            <span class="comment">//客户端的文本域中显示连接信息</span></span><br><span class="line">            txtMsgArea.append(<span class="string">"连接成功\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//连接服务器按钮 设置为不可点击(因为现在已经连接了服务器,避免重复连接,所以按钮设置为不可点击)</span></span><br><span class="line">            btnConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//断开连接按钮 设置为 可点击</span></span><br><span class="line">            btnDisConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//发送信息按钮 设置为 可点击</span></span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//发送信息的编辑框 设置为可输入</span></span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动线程</span></span><br><span class="line">            waiter = <span class="keyword">new</span> CWaiter();</span><br><span class="line">            waiter.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"连接服务器失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端发送消息到服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发送的消息不为空</span></span><br><span class="line">       <span class="keyword">if</span>(!txtMsgSend.getText().equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//通过输出流向服务器发消息</span></span><br><span class="line">               out.writeUTF(txtMsgSend.getText());</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"发送消息失败!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"不能发送空消息!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置组件权限</span></span><br><span class="line">        btnConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        btnDisConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向服务器发消息,内容为disconnect,表示要断开连接</span></span><br><span class="line">            out.writeUTF(<span class="string">"disconnect"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            canWaite = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭输入输出流</span></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//关闭套接字</span></span><br><span class="line">                    sock.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果点击了发送按钮,就调用sendMsg函数,发送消息到服务器</span></span><br><span class="line">        <span class="keyword">if</span>(e.getSource() == btnSend || e.getSource() == txtMsgSend)&#123;</span><br><span class="line">            sendMsg();</span><br><span class="line">            txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == btnConnect)&#123; <span class="comment">//如果点击了连接按钮,就调用connect函数</span></span><br><span class="line">            <span class="comment">//都不为空</span></span><br><span class="line">            <span class="keyword">if</span>(!(txtMsgServerIP.getText().equals(<span class="string">""</span>) || txtMsgServerPort.getText().equals(<span class="string">""</span>)))&#123;</span><br><span class="line">                canWaite = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> ServerPort = Integer.parseInt(txtMsgServerPort.getText());</span><br><span class="line">                <span class="keyword">if</span>(!(ServerPort &gt; <span class="number">0</span>  &amp;&amp; ServerPort &lt; <span class="number">65535</span>)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"端口值必须在0~65535之间!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                connect(txtMsgServerIP.getText(),Integer.parseInt(txtMsgServerPort.getText()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//不都为空</span></span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"服务器IP或端口号不能为空!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == btnDisConnect)&#123;</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于接收信息的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CWaiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>(canWaite) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//从输入流中读取服务器返回的数据</span></span><br><span class="line">                    msg = in.readUTF();</span><br><span class="line">                    <span class="keyword">if</span>(msg.equals(<span class="string">"serverStop"</span>))&#123;</span><br><span class="line">                        txtMsgArea.append(<span class="string">"服务器停止!\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    txtMsgArea.append(<span class="string">"服务器说: "</span>+ msg + <span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            txtMsgArea.append(<span class="string">"客户离开\n"</span>);</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.2.png" alt></p><p><strong>服务器端: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义界面组件</span></span><br><span class="line">    JTextField txtServerPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">    JButton btnStart = <span class="keyword">new</span> JButton(<span class="string">"启动服务器"</span>);</span><br><span class="line">    JButton btnStop = <span class="keyword">new</span> JButton(<span class="string">"停止服务器"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端套接字</span></span><br><span class="line">    ServerSocket serverSocket;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="comment">//数据流</span></span><br><span class="line">    DataOutputStream out;</span><br><span class="line">    DataInputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制线程的逻辑变量</span></span><br><span class="line">    <span class="keyword">boolean</span> canWaiter = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canAccepter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    Accepter accepter;</span><br><span class="line">    SWaiter waiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器中完成界面初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        btnStart.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        btnStop.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网格布局</span></span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//流式布局</span></span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER));</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器端口号"</span>));</span><br><span class="line">        jp_f1.add(txtServerPort);</span><br><span class="line">        jp_f2.add(btnStart);</span><br><span class="line">        jp_f2.add(btnStop);</span><br><span class="line"></span><br><span class="line">        jp.add(jp_f1);</span><br><span class="line">        jp.add(jp_f2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp2 = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        jp2.add(txtMsgSend);</span><br><span class="line">        jp2.add(btnSend);</span><br><span class="line"></span><br><span class="line">        container.add(jp, <span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp, <span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp2, <span class="string">"South"</span>);</span><br><span class="line"></span><br><span class="line">        setTitle(<span class="string">"服务器"</span>);</span><br><span class="line">        setSize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        btnStart.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStop.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                stopServer();</span><br><span class="line">                dispose();</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(Integer txtServerPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(txtServerPort);</span><br><span class="line">            btnStart.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            btnStop.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            accepter = <span class="keyword">new</span> Accepter();</span><br><span class="line">            accepter.start();</span><br><span class="line">            <span class="comment">//System.out.println(InetAddress.getLocalHost().getHostName());</span></span><br><span class="line">            <span class="comment">//System.out.println(InetAddress.getLocalHost().getHostAddress());</span></span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器已成功启动...\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器主机名为: "</span> + InetAddress.getLocalHost().getHostName()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器IP地址为: "</span> + InetAddress.getLocalHost().getHostAddress()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器端口号为: "</span> + serverSocket.getLocalPort()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"启动服务器失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息到客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!txtMsgSend.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//向客户端写数据</span></span><br><span class="line">                out.writeUTF(txtMsgSend.getText());</span><br><span class="line">                txtMsgArea.append(<span class="string">"服务器说: "</span> + txtMsgSend.getText() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"发送消息失败!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"不能发送消息!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置组件的权限</span></span><br><span class="line">        btnStop.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnStart.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//停止等待客户端请求的线程</span></span><br><span class="line">        canAccepter = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向输出流写数据,通知客户端服务器已停止.</span></span><br><span class="line">            out.writeUTF(<span class="string">"serverStop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭服务器端套接字</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//断开连接</span></span><br><span class="line">                disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向输出流写数据,通知客户端服务器已停止.</span></span><br><span class="line">            out.writeUTF(<span class="string">"serverStop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//停止接收信息的线程</span></span><br><span class="line">            canWaiter = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭流</span></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//关闭套接字</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据套接字获得输入输出流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由输入输出流 建立数据输入输出流</span></span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(is);</span><br><span class="line">            out = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从输入流读取客户端写入的数据,并显示</span></span><br><span class="line">            String msg = in.readUTF();</span><br><span class="line">            txtMsgArea.append(msg + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置组件的权限</span></span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line">            canWaiter = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//建立 和 启动线程</span></span><br><span class="line">            waiter = <span class="keyword">new</span> SWaiter();</span><br><span class="line">            waiter.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件(如按钮被点击)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == btnSend || e.getSource() == txtMsgSend) &#123;</span><br><span class="line">            sendMsg();</span><br><span class="line">            <span class="comment">//发送完消息后清空输入框,以便下一次输入</span></span><br><span class="line">            txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">            <span class="comment">//定位焦点到输入框,以便下一次输入</span></span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == btnStart) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(txtServerPort.getText().equals(<span class="string">""</span>)))&#123;</span><br><span class="line">                <span class="keyword">int</span> ServerPort = Integer.parseInt(txtServerPort.getText());</span><br><span class="line">                <span class="keyword">if</span>(!(ServerPort &gt; <span class="number">0</span>  &amp;&amp; ServerPort &lt; <span class="number">65535</span>)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"端口值必须在0~65535之间!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                canAccepter = <span class="keyword">true</span>;</span><br><span class="line">                canWaiter = <span class="keyword">true</span>;</span><br><span class="line">                startServer(ServerPort);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == btnStop) &#123;</span><br><span class="line">            stopServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收客户端请求的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Accepter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (canAccepter) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                    acceptConnect();</span><br><span class="line">                    <span class="comment">//在服务器端窗口显示客户端的IP地址和端口格式为  "/192.168.56.1:9606"</span></span><br><span class="line">                    <span class="comment">//txtMsgArea.append(socket.getRemoteSocketAddress().toString()+"\n");</span></span><br><span class="line">                    <span class="comment">//在服务器端窗口显示客户端的IP地址</span></span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户端IP地址: "</span>+socket.getInetAddress().getHostAddress()+<span class="string">"\n"</span>);</span><br><span class="line">                    <span class="comment">//服务器端窗口显示客户端端口</span></span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户端端口号: "</span>+ String.valueOf(socket.getPort())+<span class="string">"\n"</span>);</span><br><span class="line">                    txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭服务器套接字</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待消息的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SWaiter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (canWaiter) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    msg = in.readUTF();</span><br><span class="line">                    <span class="keyword">if</span> (msg.equals(<span class="string">"disconnect"</span>)) &#123;</span><br><span class="line">                        txtMsgArea.append(<span class="string">"客户离开!\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户说: "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            txtMsgArea.append(<span class="string">"断开连接\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行图: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.3.png" alt></p><p><strong>客户端与服务器通信:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.4.png" alt></p><h2 id="三、基于UDP的网络通信"><a href="#三、基于UDP的网络通信" class="headerlink" title="三、基于UDP的网络通信:"></a>三、基于UDP的网络通信:</h2><h3 id="3-1-实例"><a href="#3-1-实例" class="headerlink" title="3.1 实例:"></a>3.1 实例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostComputer</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HostComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文本域</span></span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    <span class="comment">//输入框</span></span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//对方地址</span></span><br><span class="line">    JTextField txtToAddress = <span class="keyword">new</span> JTextField(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//对方端口</span></span><br><span class="line">    JTextField txtToPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//本地端口</span></span><br><span class="line">    JTextField txtLocalPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//按钮</span></span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">    JButton btnStart = <span class="keyword">new</span> JButton(<span class="string">"开始"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">byte</span>[]buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    InetAddress toAddress;</span><br><span class="line">    <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">int</span> toPort;</span><br><span class="line">    <span class="comment">//本地端口</span></span><br><span class="line">    <span class="keyword">int</span> localPort;</span><br><span class="line">    <span class="comment">//数据报套接字</span></span><br><span class="line">    DatagramSocket socket;</span><br><span class="line">    <span class="comment">//控制线程的逻辑变量</span></span><br><span class="line">    <span class="keyword">boolean</span> canWaiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置组件权限</span></span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        JPanel jp_G = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"对方地址"</span>));</span><br><span class="line">        jp_f1.add(txtToAddress);</span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"对方端口"</span>));</span><br><span class="line">        jp_f1.add(txtToPort);</span><br><span class="line"></span><br><span class="line">        jp_f2.add(<span class="keyword">new</span> JLabel(<span class="string">"本地端口"</span>));</span><br><span class="line">        jp_f2.add(txtLocalPort);</span><br><span class="line">        jp_f2.add(btnStart);</span><br><span class="line"></span><br><span class="line">        jp_G.add(jp_f1);</span><br><span class="line">        jp_G.add(jp_f2);</span><br><span class="line"></span><br><span class="line">        jp.add(txtMsgSend);</span><br><span class="line">        jp.add(btnSend);</span><br><span class="line"></span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStart.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        container.add(jp_G,<span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp,<span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp,<span class="string">"South"</span>);</span><br><span class="line">        setTitle(<span class="string">"基于数据报的UDP通信"</span>);</span><br><span class="line">        setSize(<span class="number">500</span>,<span class="number">300</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   stop();</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e1)&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               dispose();</span><br><span class="line">               System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            toAddress = InetAddress.getByName(txtToAddress.getText());</span><br><span class="line">            toPort = Integer.parseInt(txtToPort.getText());</span><br><span class="line">            localPort = Integer.parseInt(txtLocalPort.getText());</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(localPort);</span><br><span class="line">            canWaiter = <span class="keyword">true</span>;</span><br><span class="line">            (<span class="keyword">new</span> Waiter()).start();</span><br><span class="line">            <span class="comment">//设置组件权限</span></span><br><span class="line">            txtToAddress.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtToPort.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtLocalPort.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            btnStart.setText(<span class="string">"停止"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"启动失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置按钮权限</span></span><br><span class="line">       txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">       txtLocalPort.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       txtToPort.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       txtToAddress.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//txtMsgArea.setEditable(false);</span></span><br><span class="line">       btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       canWaiter = <span class="keyword">false</span>;</span><br><span class="line">       toAddress = <span class="keyword">null</span>;</span><br><span class="line">       socket.close();</span><br><span class="line">       btnStart.setText(<span class="string">"开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!txtMsgSend.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = txtMsgSend.getText().getBytes();</span><br><span class="line">            DatagramPacket packet =  <span class="keyword">new</span> DatagramPacket(b,b.length,toAddress,toPort);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                txtMsgArea.append(<span class="string">"发送的数据: "</span>+txtMsgSend.getText()+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgArea.append(<span class="string">"发送到"</span>+toAddress+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgArea.append(<span class="string">"数据长度为: "</span>+packet.getLength()+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">                txtMsgSend.requestFocus();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"不能发送空消息!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(canWaiter)&#123;</span><br><span class="line">           DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               socket.receive(packet);</span><br><span class="line">               String received = <span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">               txtMsgArea.append(<span class="string">"收到的数据: "</span>+received+<span class="string">"\n"</span>);</span><br><span class="line">               txtMsgArea.append(<span class="string">"数据来自于: "</span>+packet.getAddress()+<span class="string">"\n"</span>);</span><br><span class="line">               txtMsgArea.append(<span class="string">"数据长度为: "</span>+packet.getLength()+<span class="string">"\n"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.getSource() == txtMsgSend || e.getSource() == btnSend)&#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getActionCommand().equals(<span class="string">"开始"</span>))&#123;</span><br><span class="line">            start();</span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getActionCommand().equals(<span class="string">"停止"</span>))&#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行两次,出现两个窗口,在这两个窗口进行通信**</strong></p><p><strong>运行图: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.5.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、网络编程基础&quot;&gt;&lt;a href=&quot;#一、网络编程基础&quot; class=&quot;headerlink&quot; title=&quot;一、网络编程基础&quot;&gt;&lt;/a&gt;一、网络编程基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-网络编程有两个主要的问题&quot;&gt;&lt;a href=&quot;#1-1-网络编程有两个主要的问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 网络编程有两个主要的问题:&quot;&gt;&lt;/a&gt;1.1 网络编程有两个主要的问题:&lt;/h3&gt;&lt;p&gt;①: 如何准确定位网络上的一台或多台主机&lt;br&gt;②: 定位后如何可靠高效的传输数据&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="Java网络编程" scheme="https://zzwwqq.xyz/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android之UI</title>
    <link href="https://zzwwqq.xyz/Android%E4%B9%8BUI.html"/>
    <id>https://zzwwqq.xyz/Android之UI.html</id>
    <published>2019-04-09T04:28:34.000Z</published>
    <updated>2019-04-13T03:14:53.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、如何编写程序界面"><a href="#一、如何编写程序界面" class="headerlink" title="一、如何编写程序界面:"></a>一、如何编写程序界面:</h2><p>Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局.</p><h2 id="二、常见控件的使用方法"><a href="#二、常见控件的使用方法" class="headerlink" title="二、常见控件的使用方法"></a>二、常见控件的使用方法</h2><h3 id="2-1-TextView"><a href="#2-1-TextView" class="headerlink" title="2.1 TextView"></a>2.1 TextView</h3><p>主要用于在界面上显示一段文本信息,设置颜色,文本居中</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line"><span class="comment">//给当前控件定义了一个唯一标识符</span></span><br><span class="line">android:id=<span class="string">"@+id/text_view"</span></span><br><span class="line">         <span class="comment">//所有的控件都具有这两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="comment">//文本居中对齐    </span></span><br><span class="line">         android:gravity=<span class="string">"center"</span></span><br><span class="line">        <span class="comment">//设置字体大小     </span></span><br><span class="line">android:textSize=<span class="string">"24sp"</span></span><br><span class="line">        <span class="comment">//设置字体颜色</span></span><br><span class="line">android:textColor=<span class="string">"#00ff00"</span>   </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">android:text=<span class="string">"This is TextView"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">//match_parent 由父布局来决定当前控件的大小</span></span><br><span class="line"><span class="comment">//wrap_content 由控件内容决定当前控件的大小</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Button"><a href="#2-2-Button" class="headerlink" title="2.2 Button:"></a>2.2 Button:</h3><p>activity_main.xml 中添加代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">....</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>在 MainActivity 中为 Button 的点击事件注册一个监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//  在此处添加逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-EditText"><a href="#2-3-EditText" class="headerlink" title="2.3 EditText"></a>2.3 EditText</h3><p>它允许用户在控件里输入和编辑内容</p><p>修改 布局文件activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">...&gt;</span><br><span class="line">....</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/edit_text"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">       <span class="comment">//输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失     </span></span><br><span class="line">       android:hint=<span class="string">"Type something here"</span>   </span><br><span class="line">       <span class="comment">//通过 android:maxLines 指定了 EditText 的最大行数为两行，这样当输入的内容超过两行时，文本就会向</span></span><br><span class="line">       <span class="comment">//上滚动，而 EditText则不会再继续拉伸</span></span><br><span class="line">       android:maxLines=<span class="string">"2"</span>    </span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过点击按钮来获取EditText 中输入的内容。修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                String inputText = editText.getText().toString();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, inputText,</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ImageView"><a href="#2-4-ImageView" class="headerlink" title="2.4 ImageView"></a>2.4 ImageView</h3><p>修改 activity_main.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">....</span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=<span class="string">"@+id/image_view"</span></span><br><span class="line">         <span class="comment">//将 ImageView 的宽和高都设定为wrap_content，这样保证不管图片的尺寸是多少都可以完整地展示出来</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">          <span class="comment">//使用 android:src 属性给 ImageView指定了一张图片</span></span><br><span class="line">android:src=<span class="string">"@drawable/ic_launcher"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过代码动态地更改 ImageView 中的图片。这里我准备了另外一张图片，jelly_bean.png，将它复制到 res/drawable-hdpi 目录下，然后修改 MainActivity 的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> ImageView imageView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        imageView = (ImageView) findViewById(R.id.image_view);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="comment">//调用 ImageView 的 setImageResource()方法将显示的图片改成 jelly_bean</span></span><br><span class="line">                imageView.setImageResource(R.drawable.jelly_bean);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-ProgressBar"><a href="#2-5-ProgressBar" class="headerlink" title="2.5 ProgressBar"></a>2.5 ProgressBar</h3><p>用于在界面上显示一个进度条</p><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">... &gt;</span><br><span class="line">...</span><br><span class="line">&lt;ProgressBar</span><br><span class="line">android:id=<span class="string">"@+id/progress_bar"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="comment">//指定成水平进度条  </span></span><br><span class="line">         style=<span class="string">"?android:attr/progressBarStyleHorizontal"</span></span><br><span class="line">         <span class="comment">//给进度条设置一个最大值,然后在MainActivity类中动态地更改进度条的进度</span></span><br><span class="line">android:max=<span class="string">"100"</span></span><br><span class="line">     /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>Android控件的可见属性。可以通过android:visibility进行指定，可选值有三种，visible、invisible 和 gone。<br>visible 表示控件是可见的，这个值是默认值<br>invisible 表示控件不可见，但是它仍然占据着原来的位置和大小<br>gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。<br>还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 三种值。</p><p>点击一下按钮让进度条消失，再点击一下按钮让进度条出现的这种效果。修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">private</span> ProgressBar progressBar;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">        progressBar = (ProgressBar) findViewById(R.id.progress_bar);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="keyword">if</span> (progressBar.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    progressBar.setVisibility(View.VISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    progressBar.setVisibility(View.GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 activity_main.xml 中添加 android:max 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="keyword">int</span> progress = progressBar.getProgress();</span><br><span class="line">                progress = progress + <span class="number">10</span>;</span><br><span class="line">                progressBar.setProgress(progress);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-AlertDialog"><a href="#2-6-AlertDialog" class="headerlink" title="2.6 AlertDialog"></a>2.6 AlertDialog</h3><p>在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上,用于提示一些非常重要的内容或者警告信息</p><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="comment">//通过 AlertDialog.Builder 创建出一个 AlertDialog 的实例</span></span><br><span class="line">                AlertDialog.Builder dialog = <span class="keyword">new</span> AlertDialog.Builder</span><br><span class="line">                    (MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                dialog.setTitle(<span class="string">"This is Dialog"</span>);</span><br><span class="line">                dialog.setMessage(<span class="string">"Something important."</span>);</span><br><span class="line">                dialog.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//调用 setPositiveButton()方法为对话框设置确定按钮的点击事件</span></span><br><span class="line">                dialog.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.</span><br><span class="line">                       OnClickListener() &#123;</span><br><span class="line">                              <span class="meta">@Override</span></span><br><span class="line">                              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                              &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                <span class="comment">//调用 setNegativeButton()方法设置取消按钮的点击事件</span></span><br><span class="line">                dialog.setNegativeButton(<span class="string">"Cancel"</span>, <span class="keyword">new</span> DialogInterface.</span><br><span class="line">                       OnClickListener() &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                               &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                <span class="comment">//调用 show()方法将对话框显示出来</span></span><br><span class="line">                dialog.show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-ProgressDialog"><a href="#2-7-ProgressDialog" class="headerlink" title="2.7 ProgressDialog"></a>2.7 ProgressDialog</h3><p>在对话框中显示一个进度条,表示当前操作比较耗时，让用户耐心地等待</p><p>修改 MainActivity 中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                ProgressDialog progressDialog = <span class="keyword">new</span> ProgressDialog(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                progressDialog.setTitle(<span class="string">"This is ProgressDialog"</span>);</span><br><span class="line">                progressDialog.setMessage(<span class="string">"Loading..."</span>);</span><br><span class="line"><span class="comment">/*注意如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的   dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                progressDialog.setCancelable(<span class="keyword">true</span>);</span><br><span class="line">                progressDialog.show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、详解四种基本布局"><a href="#三、详解四种基本布局" class="headerlink" title="三、详解四种基本布局"></a>三、详解四种基本布局</h2><p>布局是一种可用于放置很多控件的容器,布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套</p><p>新建一个UILayoutTest项目，并让 ADT 自动帮我们创建好活动，活动名和布局名都使用默认值</p><h3 id="3-1-LinearLayout"><a href="#3-1-LinearLayout" class="headerlink" title="3.1 LinearLayout:"></a>3.1 LinearLayout:</h3><p>称作线性布局，是一种非常常用的布局,它所包含的控件在线性方向上依次排列</p><h4 id="3-1-1-通过-android-orientation-属性指定排列方向-vertical为垂直对齐-horizontal为水平对齐"><a href="#3-1-1-通过-android-orientation-属性指定排列方向-vertical为垂直对齐-horizontal为水平对齐" class="headerlink" title="3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐"></a>3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐</h4><p>修改activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">         <span class="comment">//指定了排列方向是 vertical(垂直方向), orientation(方向；定向；适应；情况介绍)</span></span><br><span class="line">android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">            &lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span> /&gt;              </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><strong>垂直对齐:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.1.png" alt></p><p>android:gravity 是用于指定文字在控件中的对齐方式</p><p>android:layout_gravity 是用于指定控件在布局中的对齐方式</p><p><strong>需要注意，当LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水<br>平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式,同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效.</strong></p><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">         ....</span><br><span class="line">         <span class="comment">/*LinearLayout 的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向(即只能指定上,中,下,而不能指定左右)，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_vertical*/</span></span><br><span class="line">android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Button</span><br><span class="line">....</span><br><span class="line">android:layout_gravity=<span class="string">"top"</span></span><br><span class="line">android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">            &lt;Button</span><br><span class="line">....</span><br><span class="line">android:layout_gravity=<span class="string">"center_vertical"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span> /&gt;              </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.3.png" alt></p><h4 id="3-1-2-android-layout-weight。这个属性允许我们使用比例的方式来指定控件的大小"><a href="#3-1-2-android-layout-weight。这个属性允许我们使用比例的方式来指定控件的大小" class="headerlink" title="3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小"></a>3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小</h4><p>编写一个消息发送界面，需要一个文本编辑框和一个发送按钮</p><p>修改activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    ....</span><br><span class="line">   android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/input_message"</span></span><br><span class="line">        <span class="comment">/*这里竟然将 EditText 和 Button 的宽度都指定成了 0，这样文本编辑框和按钮还能显示出来吗？不用担</span></span><br><span class="line"><span class="comment">         心，由于我们使用了 android:layout_weight 属性，此时控件的宽度,就不应该再android:layout_width </span></span><br><span class="line"><span class="comment">         来决定，这里指定成 0 是一种比较规范的写法 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">android:hint=<span class="string">"Type something"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/send"</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">         <span class="comment">/* EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示EditText 和 </span></span><br><span class="line"><span class="comment">         Button 将在水平方向平分宽度*/</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">android:text=<span class="string">"Send"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">/*为什么将 android:layout_weight 属性的值同时指定为 1 就会平分屏幕宽度呢？</span></span><br><span class="line"><span class="comment">系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，</span></span><br><span class="line"><span class="comment">然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。</span></span><br><span class="line"><span class="comment">因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的</span></span><br><span class="line"><span class="comment">layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。*/</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.4.png" alt></p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回</span></span><br><span class="line"><span class="comment">wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏</span></span><br><span class="line"><span class="comment">幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且</span></span><br><span class="line"><span class="comment">看起来也更加舒服*/</span></span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....</span><br><span class="line">android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/input_message"</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">...</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/send"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">....</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.5.png" alt></p><h3 id="3-2-RelativeLayout"><a href="#3-2-RelativeLayout" class="headerlink" title="3.2 RelativeLayout"></a>3.2 RelativeLayout</h3><p>通过相对定位的方式让控件出现在布局的任何位置</p><h4 id="3-2-1-每个控件相对于父布局进行定位"><a href="#3-2-1-每个控件相对于父布局进行定位" class="headerlink" title="3.2.1 每个控件相对于父布局进行定位"></a>3.2.1 每个控件相对于父布局进行定位</h4><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">.... &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">         <span class="comment">//Button 1和父布局的左上角对齐</span></span><br><span class="line">android:layout_alignParentLeft=<span class="string">"true"</span></span><br><span class="line">android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">.../&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_alignParentRight=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">        ... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_centerInParent=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button4"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentLeft=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button5"</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//Button 5 和父布局的右下角对齐</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentRight=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.6.png" alt></p><h4 id="3-2-2-控件相对于控件进行定位"><a href="#3-2-2-控件相对于控件进行定位" class="headerlink" title="3.2.2 控件相对于控件进行定位"></a>3.2.2 控件相对于控件进行定位</h4><p>修改 activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">"true"</span></span><br><span class="line">        android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">       ....</span><br><span class="line">        <span class="comment">//android:layout_above属性让一个控件位于另一个控件的上方</span></span><br><span class="line">        <span class="comment">//@id/button3，表示让该控件位于 Button 3 的上方</span></span><br><span class="line">        android:layout_above=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_above=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button4"</span></span><br><span class="line">       ....</span><br><span class="line">        android:layout_below=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button5"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_below=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br><span class="line"><span class="comment">/*另外一组相对于控件进行定位的属性</span></span><br><span class="line"><span class="comment">  如android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.7.png" alt></p><h3 id="3-3-FrameLayout"><a href="#3-3-FrameLayout" class="headerlink" title="3.3 FrameLayout"></a>3.3 FrameLayout</h3><p>没有任何的定位方式，所有的控件都会摆放在布局的左上角,它的应用场景并不多</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line"><span class="comment">//按钮</span></span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        ....</span><br><span class="line">        /&gt;</span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">        android:id=<span class="string">"@+id/image_view"</span></span><br><span class="line">        ....</span><br><span class="line">        android:src=<span class="string">"@drawable/ic_launcher"</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.8.png" alt></p><h3 id="3-4-TableLayout"><a href="#3-4-TableLayout" class="headerlink" title="3.4 TableLayout"></a>3.4 TableLayout</h3><p>使用表格的方式来排列控件</p><p>设计一个登录界面，用户输入账号密码后登录</p><p>activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    <span class="comment">// TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行</span></span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line"><span class="comment">//在 TableRow中每加入一个控件，就表示在该行中加入了一列</span></span><br><span class="line"><span class="comment">//TableRow 中的控件是不能指定宽度的</span></span><br><span class="line">&lt;TextView</span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Account:"</span> /&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/account"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:hint=<span class="string">"Input your account"</span> /&gt;</span><br><span class="line">&lt;/TableRow&gt;</span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:text=<span class="string">"Password:"</span> /&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/password"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:inputType=<span class="string">"textPassword"</span> /&gt;</span><br><span class="line">&lt;/TableRow&gt;</span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">            android:id=<span class="string">"@+id/login"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="comment">//对单元格进行合并</span></span><br><span class="line">            android:layout_span=<span class="string">"2"</span></span><br><span class="line">            android:text=<span class="string">"Login"</span> /&gt;</span><br><span class="line">    &lt;/TableRow&gt;</span><br><span class="line">&lt;/TableLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.9.png" alt></p><p>android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列<br>进行拉伸，以达到自动适应屏幕宽度的作用</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="comment">// android:stretchColumns 的值指定为 1，表示如果表格不能完全占满屏幕宽度，就将第二列进行拉伸</span></span><br><span class="line">    <span class="comment">//指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列</span></span><br><span class="line">android:stretchColumns=<span class="string">"1"</span></span><br><span class="line">&gt;</span><br><span class="line">....</span><br><span class="line">&lt;/TableLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="四、创建自定义控件"><a href="#四、创建自定义控件" class="headerlink" title="四、创建自定义控件"></a>四、创建自定义控件</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.10.png" alt></p><p>所有控件都是直接或间接继承自 View,<br>所有布局都是直接或间接继承自 ViewGroup </p><p>创建一个 UICustomViews 项目:</p><h3 id="4-1-引入布局"><a href="#4-1-引入布局" class="headerlink" title="4.1 引入布局"></a>4.1 引入布局</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android:background 用于为布局或控件指定一个背景</span></span><br></pre></td></tr></table></figure><p>修改activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//引入标题栏布局    </span></span><br><span class="line">&lt;include layout=<span class="string">"@layout/title"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>别忘了在 MainActivity 中将系统自带的标题栏隐藏掉</p><p>修改MainActivity类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-创建自定义控件"><a href="#4-2-创建自定义控件" class="headerlink" title="4.2 创建自定义控件"></a>4.2 创建自定义控件</h3><p>引入布局确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码,这种情况最好是使用自定义控件的方式来解决</p><p>新建 TitleLayout类 继承自 LinearLayout，让它成为我们自定义的标题栏控件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在布局中引入 TitleLayout</span></span><br><span class="line"><span class="comment">控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借</span></span><br><span class="line"><span class="comment">助 LayoutInflater 来实现了,LayoutInflater 的 from()方法可以构建出一个 LayoutInflater</span></span><br><span class="line"><span class="comment">对象，然后调用 inflate()方法就可以动态加载一个布局文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//第一个参数是要加载的布局文件的 id,第二个参数是给加载好的布局再添加一个父布局,这里我们想要指定为 TitleLayout，于是直接传入 this</span></span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在自定义控件已经创建好了，然后在布局文件中添加这个自定义控件</p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候我们需要指明控件的完整类名，包名在这里是不可以省略的</span></span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;com.example.uicustomviews.TitleLayout</span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>&gt;</span><br><span class="line">&lt;/com.example.uicustomviews.TitleLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>为标题栏中的按钮注册点击事件</p><p>修改 TitleLayout中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// findViewById()方法得到按钮的实例</span></span><br><span class="line">        Button titleBack = (Button) findViewById(R.id.title_back);</span><br><span class="line">        Button titleEdit = (Button) findViewById(R.id.title_edit);</span><br><span class="line">        <span class="comment">//分别调用 setOnClickListener()方法给两个按钮注册了点击事件</span></span><br><span class="line">        titleBack.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                ((Activity) getContext()).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        titleEdit.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getContext(), <span class="string">"You clicked Edit button"</span>,</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、最常用最难用控件ListView"><a href="#五、最常用最难用控件ListView" class="headerlink" title="五、最常用最难用控件ListView"></a>五、最常用最难用控件ListView</h2><p>ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕</p><h3 id="5-1-ListView-的简单用法"><a href="#5-1-ListView-的简单用法" class="headerlink" title="5.1 ListView 的简单用法"></a>5.1 ListView 的简单用法</h3><p>首先新建一个 ListViewTest 项目,都默认</p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    &lt;ListView</span><br><span class="line">android:id=<span class="string">"@+id/list_view"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    &lt;/ListView&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String[] data = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Watermelon"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Pineapple"</span>, <span class="string">"Strawberry"</span>,<span class="string">"Cherry"</span>, <span class="string">"Mango"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成</span></span><br><span class="line">        <span class="comment">//android.R.layout.simple_list_item_1 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本</span></span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(MainActivity.<span class="keyword">this</span>,                           android.R.layout.simple_list_item_1,data);</span><br><span class="line">ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">       <span class="comment">// setAdapter()方法，将构建好的适配器对象传递进去,这样 ListView和数据之间的关联就建立完成了</span></span><br><span class="line">listView.setAdapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.15.png" alt></p><h3 id="5-2-定制-ListView-的界面"><a href="#5-2-定制-ListView-的界面" class="headerlink" title="5.2 定制 ListView 的界面"></a>5.2 定制 ListView 的界面</h3><p>新建类 Fruit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> imageId;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name, <span class="keyword">int</span> imageId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.imageId = imageId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImageId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 目录下新建fruit_item.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">        <span class="comment">// ImageView 用于显示水果的图片</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=<span class="string">"@+id/fruit_image"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span> /&gt;</span><br><span class="line">            <span class="comment">//TextView用于显示水果的名称</span></span><br><span class="line">&lt;TextView</span><br><span class="line">        android:id=<span class="string">"@+id/fruit_name"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">"10dip"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建类 FruitAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context, <span class="keyword">int</span> textViewResourceId, List&lt;Fruit&gt; objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, textViewResourceId, objects);</span><br><span class="line">resourceId = textViewResourceId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// getItem()方法得到当前项的 Fruit 实例</span></span><br><span class="line">Fruit fruit = getItem(position); <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line"><span class="comment">//LayoutInflater 来为这个子项加载我们传入的布局，</span></span><br><span class="line">View view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// findViewById()方法分别获取到 ImageView 和 TextView 的实例</span></span><br><span class="line">ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line"><span class="comment">// setImageResource()和 setText()方法来设置显示的图片和文字</span></span><br><span class="line">fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">fruitName.setText(fruit.getName());</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Watermelon"</span>,</span><br><span class="line">                             <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Pineapple"</span>, <span class="string">"Strawberry"</span>, <span class="string">"Cherry"</span>, <span class="string">"Mango"</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initFruits(); <span class="comment">//  初始化水果数据</span></span><br><span class="line">        FruitAdapter adapter = <span class="keyword">new</span> FruitAdapter(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                                                R.layout.fruit_item, fruitList);</span><br><span class="line">        ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFruits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Fruit(<span class="string">"Apple"</span>, R.drawable.apple_pic);</span><br><span class="line">        fruitList.add(apple);</span><br><span class="line">        Fruit banana = <span class="keyword">new</span> Fruit(<span class="string">"Banana"</span>, R.drawable.banana_pic);</span><br><span class="line">        fruitList.add(banana);</span><br><span class="line">        Fruit orange = <span class="keyword">new</span> Fruit(<span class="string">"Orange"</span>, R.drawable.orange_pic);</span><br><span class="line">        fruitList.add(orange);</span><br><span class="line">        Fruit watermelon = <span class="keyword">new</span> Fruit(<span class="string">"Watermelon"</span>, R.drawable.watermelon_pic);</span><br><span class="line">        fruitList.add(watermelon);</span><br><span class="line">        Fruit pear = <span class="keyword">new</span> Fruit(<span class="string">"Pear"</span>, R.drawable.pear_pic);</span><br><span class="line">        fruitList.add(pear);</span><br><span class="line">        Fruit grape = <span class="keyword">new</span> Fruit(<span class="string">"Grape"</span>, R.drawable.grape_pic);</span><br><span class="line">        fruitList.add(grape);</span><br><span class="line">        Fruit pineapple = <span class="keyword">new</span> Fruit(<span class="string">"Pineapple"</span>, R.drawable.pineapple_pic);</span><br><span class="line">        fruitList.add(pineapple);</span><br><span class="line">        Fruit strawberry = <span class="keyword">new</span> Fruit(<span class="string">"Strawberry"</span>, R.drawable.strawberry_pic);</span><br><span class="line">        fruitList.add(strawberry);</span><br><span class="line">        Fruit cherry = <span class="keyword">new</span> Fruit(<span class="string">"Cherry"</span>, R.drawable.cherry_pic);</span><br><span class="line">        fruitList.add(cherry);</span><br><span class="line">        Fruit mango = <span class="keyword">new</span> Fruit(<span class="string">"Mango"</span>, R.drawable.mango_pic);</span><br><span class="line">        fruitList.add(mango);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-提升-ListView-的运行效率"><a href="#5-3-提升-ListView-的运行效率" class="headerlink" title="5.3 提升 ListView 的运行效率"></a>5.3 提升 ListView 的运行效率</h3><p>修改 FruitAdapter中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getView()方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view;</span><br><span class="line">       <span class="comment">//如果 convertView 为空，则使用LayoutInflater 去加载布局，如果不为空则直接对 convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候也可以表现出更好的性能。</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView;</span><br><span class="line">        &#125;</span><br><span class="line">        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">        fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        fruitName.setText(fruit.getName());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然现在已经不会再重复去加载布局，但是每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个 ViewHolder来对这部分性能进行优化</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以继续优化</p><p>修改 FruitAdapter 中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view;</span><br><span class="line">        ViewHolder viewHolder;</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">            viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">            viewHolder.fruitImage = (ImageView) view.findViewById</span><br><span class="line">                (R.id.fruit_image);</span><br><span class="line">            viewHolder.fruitName = (TextView) view.findViewById</span><br><span class="line">                (R.id.fruit_name);</span><br><span class="line">            view.setTag(viewHolder); <span class="comment">//  将ViewHolder 存储在View 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView;</span><br><span class="line">            viewHolder = (ViewHolder) view.getTag(); <span class="comment">//  重新获取ViewHolder</span></span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        viewHolder.fruitName.setText(fruit.getName());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ViewHolder，用于对控件的实例进行缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        ImageView fruitImage;</span><br><span class="line">        TextView fruitName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 convertView为空的时候:</span></span><br><span class="line"><span class="comment">创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View的 setTag()方法，将 ViewHolder 对象存储在 View 中。</span></span><br><span class="line"><span class="comment">当 convertView 不为空的时候:</span></span><br><span class="line"><span class="comment">则调用View的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="5-4-ListView-的点击事件"><a href="#5-4-ListView-的点击事件" class="headerlink" title="5.4 ListView 的点击事件"></a>5.4 ListView 的点击事件</h3><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"> <span class="comment">//通过 position 参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来</span></span><br><span class="line">        listView.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">                Fruit fruit = fruitList.get(position);</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, fruit.getName(),</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、单位和尺寸"><a href="#六、单位和尺寸" class="headerlink" title="六、单位和尺寸"></a>六、单位和尺寸</h2><p>布局文件中指定宽高的固定大小有以下常用单位可供选择：px、pt、dp 和 sp</p><p>px 是像素的意思，即屏幕中可以显示的最小元素单元</p><p>pt 是磅数的意思，1 磅等于 1/72 英寸，一般 pt 都会作为字体的单位来使用</p><p>新建好一个 UISizeTest 项目</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button"</span></span><br><span class="line"><span class="comment">// android:layout_width 属性将按钮的宽指定为 200px</span></span><br><span class="line">android:layout_width=<span class="string">"200px"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.16.png" alt></p><p>接着创建一个 240*320 像素的低分辨率模拟器，在这个模拟器上重新运行程序</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.17.png" alt></p><p>dp 是密度无关像素的意思，也被称作 dip，和 px 相比，它在不同密度的屏幕中的显示比例将保持一致。</p><p>sp 是可伸缩像素的意思，它采用了和 dp 同样的设计理念，解决了文字大小的适配问题</p><p>什么叫密度？Android 中的密度就是屏幕每英寸所包含的像素数，通常以 dpi为单位</p><p>比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果它的分辨率是 320<em>480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640</em>960，那这个屏幕的密度就是 320dpi</p><p><strong>如何得知当前屏幕的密度值?</strong></p><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">float</span> xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line">        <span class="keyword">float</span> ydpi = getResources().getDisplayMetrics().ydpi;</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"xdpi is "</span> + xdpi);</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"ydpi is "</span> + ydpi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Android 的规定，在 160dpi 的屏幕上，1dp 等于 1px，而在 320dpi 的屏幕上，1dp就等于 2px。因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的显示比例保持一致</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        android:layout_width=<span class="string">"200dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:text=<span class="string">"Button"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="七、编写界面的最佳实践"><a href="#七、编写界面的最佳实践" class="headerlink" title="七、编写界面的最佳实践:"></a>七、编写界面的最佳实践:</h2><p>创建一个 UIBestPractice 项目</p><h3 id="7-1-制作-Nine-Patch-图片"><a href="#7-1-制作-Nine-Patch-图片" class="headerlink" title="7.1 制作 Nine-Patch 图片"></a>7.1 制作 Nine-Patch 图片</h3><p><strong>Nine-Patch 图片,它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸而哪些区域不可以。</strong></p><p>准备一张普通的气泡样式的png图片 message_left.png (google上直接搜索message_left.png就可找到)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.19.png" alt></p><p>将这张图片设置为一个 LinearLayout 的背景图片,修改 activity_main.xml </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:background=<span class="string">"@drawable/message_left"</span> &gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.20.png" alt></p><p>可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差.</p><p>这时我们就可以使用 Nine-Patch 图片来进行改善</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.21.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.22.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.23.png" alt></p><p>在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。绘制完成后效果如图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.24.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.25.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.26.png" alt></p><p><strong>注意：制作完成后，应该将原始文件删除，否则AS会分不清楚而报错。</strong></p><p>重新运行程序</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.27.png" alt></p><p>这样当图片需要拉伸的时候，就可以只拉伸指定的区域，程序在外观上也是有了很大的改进</p><h3 id="7-2-编写精美的聊天界面"><a href="#7-2-编写精美的聊天界面" class="headerlink" title="7.2 编写精美的聊天界面"></a>7.2 编写精美的聊天界面</h3><p>再制作一张message_right.9.png作为发出消息的背景图</p><p>修改 activity_main.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:background=<span class="string">"#d8e0e8"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line"><span class="comment">// ListView 用于显示聊天的消息内容</span></span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=<span class="string">"@+id/msg_list_view"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_weight=<span class="string">"1"</span></span><br><span class="line"><span class="comment">// android:divider属性，它可以指定 ListView分隔线的颜色，这里#0000 表示将分隔线设为透明色</span></span><br><span class="line">        android:divider=<span class="string">"#0000"</span> &gt;</span><br><span class="line">    &lt;/ListView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span> &gt;</span><br><span class="line"><span class="comment">//EditText用于输入消息</span></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/input_text"</span></span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_weight=<span class="string">"1"</span></span><br><span class="line">            android:hint=<span class="string">"Type somthing here"</span></span><br><span class="line">            android:maxLines=<span class="string">"2"</span> /&gt;</span><br><span class="line"><span class="comment">// Button 用于发送消息</span></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=<span class="string">"@+id/send"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:text=<span class="string">"Send"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>定义消息的实体类，新建 Msg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TYPE_RECEIVED 表示这是一条收到的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_RECEIVED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//TYPE_SENT 表示这是一条发出的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SENT = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//content 表示消息的内容</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line">    <span class="comment">//type 表示消息的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Msg</span><span class="params">(String content, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.content = content;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 ListView子项的布局，新建 msg_item.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:padding=<span class="string">"10dp"</span> &gt;</span><br><span class="line"><span class="comment">//让收到的消息居左对齐</span></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">"@+id/left_layout"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"left"</span></span><br><span class="line">        android:background=<span class="string">"@drawable/message_left"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">"@+id/left_msg"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">            android:layout_margin=<span class="string">"10dp"</span></span><br><span class="line">            android:textColor=<span class="string">"#fff"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">//发出的消息居右对齐</span></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">"@+id/right_layout"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"right"</span></span><br><span class="line">        android:background=<span class="string">"@drawable/message_right"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">"@+id/right_msg"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">            android:layout_margin=<span class="string">"10dp"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>创建 ListView 的适配器类，让它继承自 ArrayAdapter，并将泛型指定为 Msg类。新建类 MsgAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Msg</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MsgAdapter</span><span class="params">(Context context, <span class="keyword">int</span> textViewResourceId, List&lt;Msg&gt; objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, textViewResourceId, objects);</span><br><span class="line">resourceId = textViewResourceId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">Msg msg = getItem(position);</span><br><span class="line">View view;</span><br><span class="line">ViewHolder viewHolder;</span><br><span class="line"><span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">viewHolder.leftLayout = (LinearLayout) view.findViewById(R.id.left_layout);</span><br><span class="line">viewHolder.rightLayout = (LinearLayout) view.findViewById(R.id.right_layout);</span><br><span class="line">viewHolder.leftMsg = (TextView) view.findViewById(R.id.left_msg);</span><br><span class="line">viewHolder.rightMsg = (TextView) view.findViewById(R.id.right_msg);</span><br><span class="line">view.setTag(viewHolder);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">view = convertView;</span><br><span class="line">viewHolder = (ViewHolder) view.getTag();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.getType() == Msg.TYPE_RECEIVED) &#123;</span><br><span class="line"><span class="comment">// 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏</span></span><br><span class="line">viewHolder.leftLayout.setVisibility(View.VISIBLE);</span><br><span class="line">viewHolder.rightLayout.setVisibility(View.GONE);</span><br><span class="line">viewHolder.leftMsg.setText(msg.getContent());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.getType() == Msg.TYPE_SENT) &#123;</span><br><span class="line"><span class="comment">// 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏</span></span><br><span class="line">viewHolder.rightLayout.setVisibility(View.VISIBLE);</span><br><span class="line">viewHolder.leftLayout.setVisibility(View.GONE);</span><br><span class="line">viewHolder.rightMsg.setText(msg.getContent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">LinearLayout leftLayout;</span><br><span class="line">LinearLayout rightLayout;</span><br><span class="line">TextView leftMsg;</span><br><span class="line">TextView rightMsg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码，来为 ListView初始化一些数据，并给发送按钮加入事件响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListView msgListView;</span><br><span class="line"><span class="keyword">private</span> EditText inputText;</span><br><span class="line"><span class="keyword">private</span> Button send;</span><br><span class="line"><span class="keyword">private</span> MsgAdapter adapter;</span><br><span class="line"><span class="keyword">private</span> List&lt;Msg&gt; msgList = <span class="keyword">new</span> ArrayList&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">initMsgs(); <span class="comment">// 初始化消息数据</span></span><br><span class="line">adapter = <span class="keyword">new</span> MsgAdapter(MainActivity.<span class="keyword">this</span>, R.layout.msg_item, msgList);</span><br><span class="line">inputText = (EditText) findViewById(R.id.input_text);</span><br><span class="line">send = (Button) findViewById(R.id.send);</span><br><span class="line">msgListView = (ListView) findViewById(R.id.msg_list_view);</span><br><span class="line">msgListView.setAdapter(adapter);</span><br><span class="line">send.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">//获取 EditText 中的内容</span></span><br><span class="line">String content = inputText.getText().toString();</span><br><span class="line">                <span class="comment">//如果内容不为空则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="string">""</span>.equals(content)) &#123;</span><br><span class="line">Msg msg = <span class="keyword">new</span> Msg(content, Msg.TYPE_SENT);</span><br><span class="line">msgList.add(msg);</span><br><span class="line">                    <span class="comment">//调用了适配器的 notifyDataSetChanged()方法，用于通知列表的数据发生了变化</span></span><br><span class="line">adapter.notifyDataSetChanged(); <span class="comment">// 当有新消息时，刷新ListView中的显示</span></span><br><span class="line">                     <span class="comment">// 将ListView定位到最后一行,以保证一定可以看得到最后发出的一条消息 </span></span><br><span class="line">msgListView.setSelection(msgList.size()); </span><br><span class="line">inputText.setText(<span class="string">""</span>); <span class="comment">// 清空输入框中的内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMsgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化几条数据用于在 ListView 中显示</span></span><br><span class="line">Msg msg1 = <span class="keyword">new</span> Msg(<span class="string">"Hello guy."</span>, Msg.TYPE_RECEIVED);</span><br><span class="line">msgList.add(msg1);</span><br><span class="line">Msg msg2 = <span class="keyword">new</span> Msg(<span class="string">"Hello. Who is that?"</span>, Msg.TYPE_SENT);</span><br><span class="line">msgList.add(msg2);</span><br><span class="line">Msg msg3 = <span class="keyword">new</span> Msg(<span class="string">"This is Tom. Nice talking to you. "</span>, Msg.TYPE_RECEIVED);</span><br><span class="line">msgList.add(msg3);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.29.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、如何编写程序界面&quot;&gt;&lt;a href=&quot;#一、如何编写程序界面&quot; class=&quot;headerlink&quot; title=&quot;一、如何编写程序界面:&quot;&gt;&lt;/a&gt;一、如何编写程序界面:&lt;/h2&gt;&lt;p&gt;Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局.&lt;/p&gt;
&lt;h2 id=&quot;二、常见控件的使用方法&quot;&gt;&lt;a href=&quot;#二、常见控件的使用方法&quot; class=&quot;headerlink&quot; title=&quot;二、常见控件的使用方法&quot;&gt;&lt;/a&gt;二、常见控件的使用方法&lt;/h2&gt;&lt;h3 id=&quot;2-1-TextView&quot;&gt;&lt;a href=&quot;#2-1-TextView&quot; class=&quot;headerlink&quot; title=&quot;2.1 TextView&quot;&gt;&lt;/a&gt;2.1 TextView&lt;/h3&gt;&lt;p&gt;主要用于在界面上显示一段文本信息,设置颜色,文本居中&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="Android之UI" scheme="https://zzwwqq.xyz/tags/Android%E4%B9%8BUI/"/>
    
  </entry>
  
  <entry>
    <title>java字符串</title>
    <link href="https://zzwwqq.xyz/java%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://zzwwqq.xyz/java字符串.html</id>
    <published>2019-04-08T10:51:55.000Z</published>
    <updated>2019-04-09T13:33:18.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字符串的特性"><a href="#一、字符串的特性" class="headerlink" title="一、字符串的特性:"></a>一、字符串的特性:</h2><p>String 被声明为 final，因此它不可被继承。</p><h2 id="二、不同JDK版本中String的区别"><a href="#二、不同JDK版本中String的区别" class="headerlink" title="二、不同JDK版本中String的区别:"></a>二、不同JDK版本中String的区别:</h2><p>①: 在 Java 8 中，String 内部使用 char 数组存储数据。</p><a id="more"></a><p>②: 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。<br>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2 id="三、String-与StringBuffer-StringBuilder的区别："><a href="#三、String-与StringBuffer-StringBuilder的区别：" class="headerlink" title="三、String 与StringBuffer,StringBuilder的区别："></a>三、String 与StringBuffer,StringBuilder的区别：</h2><h3 id="3-1-可变性"><a href="#3-1-可变性" class="headerlink" title="3.1 可变性:"></a>3.1 可变性:</h3><p>String的长度是<strong>不可变的</strong>，而StringBuffer和StringBuilder长度是<strong>可变的.</strong></p><p>也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”<br><strong>并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中.</strong></p><h3 id="3-2-线程安全"><a href="#3-2-线程安全" class="headerlink" title="3.2 线程安全:"></a>3.2 线程安全:</h3><p>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p><p><strong>StringBuffer的常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.1.png" alt></p><p><strong>String常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.4.png" alt></p><p><strong>StringBuffer和StringBuilder和String的效率比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">String text = <span class="string">""</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、字符串与其他数据类型的转换"><a href="#四、字符串与其他数据类型的转换" class="headerlink" title="四、字符串与其他数据类型的转换:"></a>四、字符串与其他数据类型的转换:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.2.png" alt></p><h3 id="4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法"><a href="#4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法" class="headerlink" title="4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)"></a>4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)</h3><p><strong>A ———&gt; B:      调用B的方法:</strong><br>①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)<br>②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法</p><h3 id="4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器"><a href="#4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器" class="headerlink" title="4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)"></a>4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)</h3><p>字符串———&gt;数组         调用字符串的方法<br>数组————&gt;字符串     调用字符串的构造器</p><p>③: 字符串——-&gt;字节数组 调用字符串的getBytes()<br>④: 字符串——-&gt;字符数组 调用字符串的toCharArray()</p><p>⑤: 字节数组——&gt;字符串  调用字符串的构造器<br>⑥: 字符数组——&gt;字符串   调用字符串的构造器</p><h2 id="五、字符串常量池（String-Pool）"><a href="#五、字符串常量池（String-Pool）" class="headerlink" title="五、字符串常量池（String Pool）:"></a>五、字符串常量池（String Pool）:</h2><p>①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在<strong>编译时期</strong>就确定。<br>还可以使用 String 的 intern() 方法在<strong>运行过程中</strong>将字符串添加到 String Pool 中。</p><p>②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="六、字符串字面量-和字符串对象"><a href="#六、字符串字面量-和字符串对象" class="headerlink" title="六、字符串字面量 和字符串对象:"></a>六、字符串字面量 和字符串对象:</h2><p>字面量指的是能够使用简单结构和符号创建对象的表达式。<br>如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。</p><h2 id="七、new-String-“abc”-创建了几个对象"><a href="#七、new-String-“abc”-创建了几个对象" class="headerlink" title="七、new String(“abc”)创建了几个对象?"></a>七、new String(“abc”)创建了几个对象?</h2><p><strong>使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。</strong></p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h2 id="八、关于”-”-和”equals”和String的intern-方法"><a href="#八、关于”-”-和”equals”和String的intern-方法" class="headerlink" title="八、关于”==” 和”equals”和String的intern()方法:"></a>八、关于”==” 和”equals”和String的intern()方法:</h2><p>①: “==”比较的是地址<br>②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.<br>所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.<br>③: String类重写了equals方法<br>④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><p><strong>关于intern():</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String s0= “kvill”; </span><br><span class="line">String s1=<span class="keyword">new</span> String(”kvill”); </span><br><span class="line">String s2=<span class="keyword">new</span> String(“kvill”); </span><br><span class="line">System.out.println( s0==s1 ); </span><br><span class="line">System.out.println( “**********” ); </span><br><span class="line">s1.intern(); </span><br><span class="line">s2=s2.intern(); <span class="comment">//把常量池中“kvill”的引用赋给s2 </span></span><br><span class="line">System.out.println( s0==s1); </span><br><span class="line">System.out.println( s0==s1.intern() ); </span><br><span class="line">System.out.println( s0==s2 );</span><br><span class="line"></span><br><span class="line">结果为： </span><br><span class="line"><span class="keyword">false</span> </span><br><span class="line">********** </span><br><span class="line"><span class="keyword">false</span> <span class="comment">//虽然执行了s1.intern(),但它的返回值没有赋给s1 </span></span><br><span class="line"><span class="keyword">true</span> <span class="comment">//说明s1.intern()返回的是常量池中”kvill”的引用 </span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>几个结论: </strong></p><ol><li><p>直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。</p></li><li><p>new出来的字符串是存放在堆里面。</p></li><li><p>对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</p><ul><li><p>表达式右边是纯字符串常量，那么存放在常量池里面。</p></li><li><p>表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;        <span class="comment">//str1存放的值是字符串常量池中字符串aaa对象的地址.</span></span><br><span class="line">String str2 = <span class="string">"bbb"</span>;</span><br><span class="line">String str3 = <span class="string">"aaabbb"</span>;</span><br><span class="line">String str4 = str1 + str2;  <span class="comment">//str4存放的是堆中字符串aaabbb对象的地址</span></span><br><span class="line">String str5 = <span class="string">"aaa"</span> + <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析:</span></span><br><span class="line">结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而</span><br><span class="line">str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。</span><br><span class="line">其实Integer这种包装类型的-<span class="number">128</span> ~ +<span class="number">127</span>也是存放在常量池里面，比如Integer i1 = <span class="number">10</span>;Integer i2 = <span class="number">10</span>; i1 == i2结果是<span class="keyword">true</span>，估计也是为了性能优化。</span><br></pre></td></tr></table></figure><h2 id="九、五个关于字符串的算法题"><a href="#九、五个关于字符串的算法题" class="headerlink" title="九、五个关于字符串的算法题:"></a>九、五个关于字符串的算法题:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="number">1</span>. 模拟一个trim方法，去除字符串两端的空格 。</span><br><span class="line"> * <span class="number">2</span>. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 </span><br><span class="line"> * <span class="number">3</span>. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。</span><br><span class="line"> * <span class="number">4</span>. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = <span class="string">"abcwercvhelloobnm"</span>。</span><br><span class="line"> * <span class="number">5</span>.对字符串中字符进行自然排序</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. 模拟trim方法，去除字符串两端的空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断字符串str前面是否有空格</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(start) == <span class="string">' '</span>) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(start);</span><br><span class="line"><span class="comment">// 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(end) == <span class="string">' '</span>) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(end);</span><br><span class="line"> <span class="comment">// 方法一：</span></span><br><span class="line"> <span class="keyword">char</span>[]a = <span class="keyword">new</span> <span class="keyword">char</span>[end-start+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++,j++) &#123;</span><br><span class="line"> System.out.print(i+<span class="string">" "</span>);</span><br><span class="line"> a[j] = str.charAt(i);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println();</span><br><span class="line"> <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line"> String str1 = <span class="keyword">new</span> String(a);</span><br><span class="line"> <span class="keyword">return</span> str1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 方法二：</span></span><br><span class="line"><span class="comment">//return str.substring(start, end + 1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverseString</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符串转换为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="keyword">return</span> myreverseArray(c, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myreverseArray</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start,j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line"><span class="keyword">char</span> temp = c[i];</span><br><span class="line">c[i] = c[j];</span><br><span class="line">c[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符数组转换为字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">String str1 = str.substring(<span class="number">0</span>,start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            str1 += c;</span><br><span class="line">&#125;</span><br><span class="line">str1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3. 获取一个字符串在另一个字符串中出现的次数.</span></span><br><span class="line"><span class="comment">// 判断str2 在 str1 中出现的次数</span></span><br><span class="line"><span class="comment">// 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">while</span> ((length = str1.indexOf(str2)) != -<span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">str1 = str1.substring(length + str2.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 获取两个字符串中最大相同字串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getMaxSubString</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">String maxStr = (str1.length() &gt; str2.length())? str1:str2;</span><br><span class="line">String minStr = (str1.length() &lt; str2.length())? str1:str2;</span><br><span class="line">        <span class="keyword">int</span> length = minStr.length();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = length - i; y &lt;= length; x++,y++) &#123;</span><br><span class="line">String str = minStr.substring(x,y);</span><br><span class="line">   <span class="keyword">if</span> (maxStr.contains(str)) &#123;</span><br><span class="line">   list.add(str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//5.对字符串中字符进行自然排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mySort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[]c = str.toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// @Test-myTrim</span></span><br><span class="line">String testString1 = <span class="string">"    abc  d    "</span>;</span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line">String testString2 = <span class="string">"              "</span>;</span><br><span class="line">        </span><br><span class="line">String str1 = StringDemo.myTrim(testString1);</span><br><span class="line">String str2 = StringDemo.myTrim(testString2);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str1 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str2 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">String str3 = str1.trim();</span><br><span class="line">String str4 = str2.trim();</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str3 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str4 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// @Test-myReverseString and myReverseArray</span></span><br><span class="line">String str5 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str6 = myReverseString(str5, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"原字符串："</span> + str5);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法一："</span> + str6);</span><br><span class="line">String str7 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str8 = reverseString2(str7, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法二："</span> + str8);</span><br><span class="line"><span class="keyword">int</span> count = getTime(<span class="string">"abkkcadkabkebfkabkskab"</span>, <span class="string">"abk"</span>);</span><br><span class="line">System.out.println(<span class="string">"出现次数为："</span> + count);</span><br><span class="line">    List&lt;String&gt; str9 = getMaxSubString(<span class="string">"abcwerathelloyuiodef"</span>, <span class="string">"abcwercvhellobnm"</span>);</span><br><span class="line">    System.out.println(str9);  </span><br><span class="line">    String str10 = <span class="string">"aediewfn"</span>;</span><br><span class="line">    String str11 = mySort(str10);</span><br><span class="line">    System.out.println(str11);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、字符串的特性&quot;&gt;&lt;a href=&quot;#一、字符串的特性&quot; class=&quot;headerlink&quot; title=&quot;一、字符串的特性:&quot;&gt;&lt;/a&gt;一、字符串的特性:&lt;/h2&gt;&lt;p&gt;String 被声明为 final，因此它不可被继承。&lt;/p&gt;
&lt;h2 id=&quot;二、不同JDK版本中String的区别&quot;&gt;&lt;a href=&quot;#二、不同JDK版本中String的区别&quot; class=&quot;headerlink&quot; title=&quot;二、不同JDK版本中String的区别:&quot;&gt;&lt;/a&gt;二、不同JDK版本中String的区别:&lt;/h2&gt;&lt;p&gt;①: 在 Java 8 中，String 内部使用 char 数组存储数据。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java字符串" scheme="https://zzwwqq.xyz/tags/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://zzwwqq.xyz/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/数据链路层.html</id>
    <published>2019-04-07T07:37:34.000Z</published>
    <updated>2019-04-09T13:33:42.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据链路层设备"><a href="#一、数据链路层设备" class="headerlink" title="一、数据链路层设备:"></a>一、数据链路层设备:</h2><p>①: 网桥或桥接器:<br>②: 交换机:<br>　　<strong>实质: </strong>是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器<br>　　<strong>特点:</strong></p><ul><li><strong>全双工:</strong></li><li><strong>并行性: </strong>即能同时连通多对接口，使多对主机能同时通信</li><li><strong>自学习: </strong>即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。</li></ul><a id="more"></a><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.4.png" alt></p><p><strong>优点:</strong></p><p>对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s.</p><p>③:  网络适配器又称网络接口卡，网卡</p><p><strong>网络适配器是什么?</strong></p><p>网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。</p><p><strong>网络适配器的主要作用：</strong></p><ul><li>它是主机与介质的桥梁设备</li><li>实现主机与介质之间的电信号匹配</li><li>提供数据缓冲能力</li><li>控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。)</li></ul><p>网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。</p><h2 id="二、数据链路层协议"><a href="#二、数据链路层协议" class="headerlink" title="二、数据链路层协议:"></a>二、数据链路层协议:</h2><h3 id="2-1-PPP协议-Point-to-Point-Protocal-（点到点）"><a href="#2-1-PPP协议-Point-to-Point-Protocal-（点到点）" class="headerlink" title="2.1 PPP协议:  Point-to-Point Protocal; （点到点）"></a>2.1 PPP协议:  Point-to-Point Protocal; （点到点）</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点:"></a>2.1.1 特点:</h3><p>①: 简单<br>②: 只检错,不纠错<br>③: 不使用序号,不进行流量控制</p><h3 id="2-1-2-PPP-的帧格式："><a href="#2-1-2-PPP-的帧格式：" class="headerlink" title="2.1.2 PPP 的帧格式："></a>2.1.2 PPP 的帧格式：</h3><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.3.png" alt></p><h3 id="2-2-PPPoE协议"><a href="#2-2-PPPoE协议" class="headerlink" title="2.2 PPPoE协议:"></a>2.2 PPPoE协议:</h3><p>是为宽带上网的主机使用的链路层协议</p><h3 id="2-3-CSMA-CD协议"><a href="#2-3-CSMA-CD协议" class="headerlink" title="2.3 CSMA/CD协议:"></a>2.3 CSMA/CD协议:</h3><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h3 id="2-4-IEEE-802-3-2协议"><a href="#2-4-IEEE-802-3-2协议" class="headerlink" title="2.4 IEEE 802.3/.2协议"></a>2.4 IEEE 802.3/.2协议</h3><h3 id="2-5-ATM协议"><a href="#2-5-ATM协议" class="headerlink" title="2.5 ATM协议"></a>2.5 ATM协议</h3><h3 id="2-6-HDLC协议"><a href="#2-6-HDLC协议" class="headerlink" title="2.6 HDLC协议"></a>2.6 HDLC协议</h3><h2 id="三、数据链路层基本单元"><a href="#三、数据链路层基本单元" class="headerlink" title="三、数据链路层基本单元:"></a>三、数据链路层基本单元:</h2><p>帧</p><h2 id="四、数据链路层三个基本问题"><a href="#四、数据链路层三个基本问题" class="headerlink" title="四、数据链路层三个基本问题:"></a>四、数据链路层三个基本问题:</h2><h3 id="4-1-封装成帧"><a href="#4-1-封装成帧" class="headerlink" title="4.1 封装成帧:"></a>4.1 封装成帧:</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.1.png" alt></p><h3 id="4-2-透明传输"><a href="#4-2-透明传输" class="headerlink" title="4.2 透明传输:"></a>4.2 透明传输:</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.2.png" alt></p><h3 id="4-3-差错检测"><a href="#4-3-差错检测" class="headerlink" title="4.3 差错检测:"></a>4.3 差错检测:</h3><p>循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.7.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.8.png" alt></p><h2 id="五、数据链路层使用的信道"><a href="#五、数据链路层使用的信道" class="headerlink" title="五、数据链路层使用的信道:"></a>五、数据链路层使用的信道:</h2><h3 id="5-1-点对点信道"><a href="#5-1-点对点信道" class="headerlink" title="5.1 点对点信道:"></a>5.1 点对点信道:</h3><p><strong>一对一通信。</strong><br>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h3 id="5-2-广播信道"><a href="#5-2-广播信道" class="headerlink" title="5.2 广播信道:"></a>5.2 广播信道:</h3><p>①: <strong>一对多通信</strong>，一个节点发送的数据能够被广播信道上所有的节点接收到。<br>②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。<br>③: 主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用<strong>CSMA/CD 协议。</strong></p><h2 id="六、数据链路层功能："><a href="#六、数据链路层功能：" class="headerlink" title="六、数据链路层功能："></a>六、数据链路层功能：</h2><p>①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输<br>②: 组帧（Framing）<br>③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端<br>④: 流量控制（Flow control）:避免淹没接收端<br>⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧<br>⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权</p><h2 id="七、数据链路层任务"><a href="#七、数据链路层任务" class="headerlink" title="七、数据链路层任务:"></a>七、数据链路层任务:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.9.png" alt></p><h2 id="八、MAC-地址"><a href="#八、MAC-地址" class="headerlink" title="八、MAC 地址:"></a>八、MAC 地址:</h2><p>MAC 地址是<strong>链路层地址</strong>，长度为 6 字节（48 位），用于<strong>唯一标识网络适配器（网卡）</strong>。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="九、以太网"><a href="#九、以太网" class="headerlink" title="九、以太网:"></a>九、以太网:</h2><h3 id="9-1-以太网是一种星型拓扑结构局域网。"><a href="#9-1-以太网是一种星型拓扑结构局域网。" class="headerlink" title="9.1 以太网是一种星型拓扑结构局域网。"></a>9.1 以太网是一种星型拓扑结构局域网。</h3><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h3 id="9-2-特点"><a href="#9-2-特点" class="headerlink" title="9.2 特点:"></a>9.2 特点:</h3><p>采用的协议: CSMA/CD<br>采用无连接,半双工通信<br>对数据帧不进行编号<br>尽最大努力交付(不可靠)<br>不要求对方确认<br>发送的数据都以曼彻斯特编码<br>收到错帧就丢弃</p><h3 id="9-3-以太网帧格式："><a href="#9-3-以太网帧格式：" class="headerlink" title="9.3 以太网帧格式："></a>9.3 以太网帧格式：</h3><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.5.png" alt></p><h2 id="十、局域网"><a href="#十、局域网" class="headerlink" title="十、局域网:"></a>十、局域网:</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.6.png" alt></p><h2 id="十一、10BASE-T"><a href="#十一、10BASE-T" class="headerlink" title="十一、10BASE-T:"></a>十一、10BASE-T:</h2><p>10 代表 10Mbit/s<br>BASE : 连接线上的信号为基带信号<br>T: 双绞线</p><h2 id="十二、数据链路层功能"><a href="#十二、数据链路层功能" class="headerlink" title="十二、数据链路层功能:"></a>十二、数据链路层功能:</h2><p>将网络层接收到的数据分割成特定的可被物理层传输的帧</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据链路层设备&quot;&gt;&lt;a href=&quot;#一、数据链路层设备&quot; class=&quot;headerlink&quot; title=&quot;一、数据链路层设备:&quot;&gt;&lt;/a&gt;一、数据链路层设备:&lt;/h2&gt;&lt;p&gt;①: 网桥或桥接器:&lt;br&gt;②: 交换机:&lt;br&gt;　　&lt;strong&gt;实质: &lt;/strong&gt;是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器&lt;br&gt;　　&lt;strong&gt;特点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全双工:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行性: &lt;/strong&gt;即能同时连通多对接口，使多对主机能同时通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自学习: &lt;/strong&gt;即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数据链路层" scheme="https://zzwwqq.xyz/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Markdown用法</title>
    <link href="https://zzwwqq.xyz/Markdown%E7%94%A8%E6%B3%95.html"/>
    <id>https://zzwwqq.xyz/Markdown用法.html</id>
    <published>2019-04-06T12:23:12.000Z</published>
    <updated>2019-04-23T07:18:11.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常用操作"><a href="#一、常用操作" class="headerlink" title="一、常用操作:"></a>一、常用操作:</h2><h3 id="1-1-代码块"><a href="#1-1-代码块" class="headerlink" title="1.1 代码块:"></a>1.1 代码块:</h3><p><strong>①: 添加代码块 :</strong><br><strong>一行代码时: (也称行内代码)</strong> 使用一对单引号(ESC键下面的单引号键),代码放在这对单引号之间</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.4.png" alt>    </p><p>效果图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.3.png" alt>    </p><p><strong>多行代码:</strong> 连按三个单引号(ESC键下面的单引号键) ,然后回车.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.5.png" alt>   </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.6.png" alt> </p><p>效果图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.2.png" alt>     </p><p><strong>②: 代码快速排版: </strong></p><p>先把光标定位到代码块中，此时右下角会让你输入代码格式（如Java，C，C#等）,比选择Java， 然后Ctrl+ A选中所有代码,  最后  <code>Shift + tab</code></p><p>拍版前:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.7.png" alt>  </p><p> 排版后:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.8.png" alt>  </p><h3 id="1-2-插入图片"><a href="#1-2-插入图片" class="headerlink" title="1.2 插入图片"></a>1.2 插入图片</h3><p>插入互联网上图片:</p><p><code>![这里写图片描述](这里写地址)</code></p><p><code>![这里写图片描述](http://img3.douban.com/mpic/s1108264.jpg)</code></p><h3 id="1-3-超链接"><a href="#1-3-超链接" class="headerlink" title="1.3 超链接"></a>1.3 超链接</h3><p>链接文字都是用 [方括号] 来标记,在方块括号后面紧接着圆括号并插入网址链接即可</p><p><code>[This link](http://example.net/)</code></p><h3 id="1-4-分割线："><a href="#1-4-分割线：" class="headerlink" title="1.4 分割线："></a>1.4 分割线：</h3><p>在一行中输入三个连续的减号:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.9.png" alt></p><p>效果图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.10.png" alt></p><h3 id="1-5-换行"><a href="#1-5-换行" class="headerlink" title="1.5 换行"></a>1.5 换行</h3><p>方法1: 连续两个以上空格,  然后   回车</p><p>方法2：使用html语言换行标签：<code>&lt;br&gt;</code></p><h3 id="1-6-首行缩进："><a href="#1-6-首行缩进：" class="headerlink" title="1.6 首行缩进："></a>1.6 首行缩进：</h3><p>首行缩进两个字符：(每个表示一个空格，连续使用两个即可）</p><ul><li><code>&amp;ensp;</code> 半角的空格</li><li><code>&amp;emsp;</code> 全角的空格</li></ul><h3 id="1-7-字体-字体颜色-字体大小"><a href="#1-7-字体-字体颜色-字体大小" class="headerlink" title="1.7 字体,字体颜色,字体大小"></a>1.7 字体,字体颜色,字体大小</h3><p>使用内嵌HTML的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是浅蓝色,黑体,7号字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>我是红色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3</span><br></pre></td></tr></table></figure><h3 id="1-8-背景色"><a href="#1-8-背景色" class="headerlink" title="1.8 背景色"></a>1.8 背景色</h3><p>Markdown本身不支持背景色设置，需要采用内置html的方式实现</p><p>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">green</span>&gt;</span>背景色是：green<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图:</p><table><tr><td bgcolor="green">背景色是：green</td></tr></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;768px&quot; height=&quot;367px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://zzwwqq.xyz/categories/Markdown/"/>
    
    
      <category term="Markdown用法指南" scheme="https://zzwwqq.xyz/tags/Markdown%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>初识Android</title>
    <link href="https://zzwwqq.xyz/%E5%88%9D%E8%AF%86Android.html"/>
    <id>https://zzwwqq.xyz/初识Android.html</id>
    <published>2019-04-05T11:35:08.000Z</published>
    <updated>2019-04-09T13:31:06.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Android系统四大组件"><a href="#一、Android系统四大组件" class="headerlink" title="一、Android系统四大组件:"></a>一、Android系统四大组件:</h2><h3 id="1-1-活动（Activity）"><a href="#1-1-活动（Activity）" class="headerlink" title="1.1 活动（Activity）:"></a>1.1 活动（Activity）:</h3><p>凡是在应用中你看得到的东西，都是放在活动中的。</p><h3 id="1-2-服务（Service）"><a href="#1-2-服务（Service）" class="headerlink" title="1.2 服务（Service）:"></a>1.2 服务（Service）:</h3><p>你无法看到它，但它会一直在后台默默地运行</p><h3 id="1-3-广播接收器（Broadcast-Receiver）"><a href="#1-3-广播接收器（Broadcast-Receiver）" class="headerlink" title="1.3 广播接收器（Broadcast Receiver）:"></a>1.3 广播接收器（Broadcast Receiver）:</h3><p>接收来自各处的广播消息，比如电话、短信等</p><h3 id="1-4-内容提供器（ContentProvider）"><a href="#1-4-内容提供器（ContentProvider）" class="headerlink" title="1.4 内容提供器（ContentProvider）:"></a>1.4 内容提供器（ContentProvider）:</h3><p>为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现</p><h2 id="二、创建并运行HelloWorld程序"><a href="#二、创建并运行HelloWorld程序" class="headerlink" title="二、创建并运行HelloWorld程序:"></a>二、创建并运行HelloWorld程序:</h2><h3 id="2-1-创建程序"><a href="#2-1-创建程序" class="headerlink" title="2.1 创建程序"></a>2.1 创建程序</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.1.png" alt></p><p>Application Name 代表应用名称，此应用安装到手机之后会在手机上显示该名称:<br>Project Name 代表项目名称，在项目创建完成后该名称会显示在 Eclipse 中<br>Minimum Required SDK 是指程序最低兼容的版本<br>Target SDK 是指你在该目标版本上已经做过了充分的测试，系统不会再帮你在这个版本上做向前兼容的操作了<br>Compile With是指程序将使用哪个版本的 SDK 进行编译<br>最后一个 Theme是指程序 UI 所使用的主题，我个人比较喜欢选择 None</p><h4 id="2-1-1-创建活动"><a href="#2-1-1-创建活动" class="headerlink" title="2.1.1 创建活动:"></a>2.1.1 创建活动:</h4><p>选择一个你想创建的活动类型，这里我们就选择 Blank Activity 了</p><h3 id="2-2-启动模拟器"><a href="#2-2-启动模拟器" class="headerlink" title="2.2 启动模拟器:"></a>2.2 启动模拟器:</h3><p>点击 Eclipse 导航栏中的 Window→Open Perspective→DDMS<br>如果你的 Devices 窗口中有一个设备显示是 Online 的，那就说明目前一切正常，你的模拟器是在线的</p><h3 id="2-3-执行程序代码"><a href="#2-3-执行程序代码" class="headerlink" title="2.3 执行程序代码:"></a>2.3 执行程序代码:</h3><p>右击 HelloWorld 项目→Run As→Android Application</p><h2 id="三、程序的目录结构"><a href="#三、程序的目录结构" class="headerlink" title="三、程序的目录结构:"></a>三、程序的目录结构:</h2><h3 id="3-1-gen"><a href="#3-1-gen" class="headerlink" title="3.1 gen"></a>3.1 gen</h3><p>自动生成的，主要有一个 R.java 文件,你在项目中添加的任何资源都会在其中生成一个相应的资源 id,<strong>永远不要手动去修改它。</strong></p><h3 id="3-2-bin"><a href="#3-2-bin" class="headerlink" title="3.2 bin"></a>3.2 bin</h3><p>存放<strong>编译时自动产生</strong>的文件, 目录下有HelloWorld.apk，把这个文件拷到手机上就可以直接安装了</p><h3 id="3-3-libs"><a href="#3-3-libs" class="headerlink" title="3.3 libs"></a>3.3 libs</h3><p>存放第三方 Jar包, 会被<strong>自动添加</strong>到构建路径里去</p><h3 id="3-4-assets"><a href="#3-4-assets" class="headerlink" title="3.4 assets"></a>3.4 assets</h3><p>存放一些<strong>随程序打包的文件</strong>,所有<strong>网页相关的文件</strong>也都存放在这个目录下</p><h3 id="3-5-res-resources即资源目录"><a href="#3-5-res-resources即资源目录" class="headerlink" title="3.5 res: (resources即资源目录)"></a>3.5 res: (resources即资源目录)</h3><p>图片、布局、字符串等资源都要存放在这个目录下<br>图片放在 drawable 目录下<br>布局放在 layout 目录下<br>字符串放在 values 目录下</p><h3 id="3-6-AndroidManifest-xml"><a href="#3-6-AndroidManifest-xml" class="headerlink" title="3.6 AndroidManifest.xml"></a>3.6 AndroidManifest.xml</h3><p>整个 Android 项目的配置文件，四大组件都需要在这个文件里注册,还可以添加权限声明,版本兼容修改</p><h3 id="3-7-project-properties"><a href="#3-7-project-properties" class="headerlink" title="3.7 project.properties"></a>3.7 project.properties</h3><p>指定编译程序时所使用的 SDK 版本</p><h2 id="四、程序的运行流程分析"><a href="#四、程序的运行流程分析" class="headerlink" title="四、程序的运行流程分析:"></a>四、程序的运行流程分析:</h2><h3 id="4-1-AndroidManifest-xml-文件"><a href="#4-1-AndroidManifest-xml-文件" class="headerlink" title="4.1 AndroidManifest.xml 文件:"></a>4.1 AndroidManifest.xml 文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 HelloWorldActivity 这个活动进行注册,没有在 AndroidManifest.xml 里面注册的活动是不能使用的。</span></span><br><span class="line">&lt;activity</span><br><span class="line">　　　android:name=<span class="string">"com.test.helloworld.HelloWorldActivity"</span></span><br><span class="line">　　　android:label=<span class="string">"@string/app_name"</span> &gt;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//主活动，在手机上点击应用图标，首先启动的就是这个活动。</span></span><br><span class="line">　　　&lt;intent-filter&gt;</span><br><span class="line">　　　　　&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">　　　　　&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">　　　&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-再来看src-HelloWorldActivity-java文件"><a href="#4-2-再来看src-HelloWorldActivity-java文件" class="headerlink" title="4.2 再来看src/HelloWorldActivity.java文件"></a>4.2 再来看src/HelloWorldActivity.java文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 调用了setContentView()方法，给当前的活动引入了一个 hello_world_layout 布局</span></span><br><span class="line">        setContentView(R.layout.hello_world_layout);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Activity</strong> 是 Android 系统提供的一个活动基类，项目中<strong>所有的活动都必须要继承它才能拥有活动的特性</strong></p><p><strong>onCreate()方法</strong>是一个<strong>活动被创建时必定要执行的方法</strong></p><p>Android程序的设计讲究逻辑和视图分离,在<strong>布局文件中编写界面</strong>，然后<strong>在活动中引入进来。</strong></p><h3 id="4-3-看-res-layout-hello-world-layout-xml-布局文件"><a href="#4-3-看-res-layout-hello-world-layout-xml-布局文件" class="headerlink" title="4.3 看 res/layout/hello_world_layout.xml 布局文件:"></a>4.3 看 res/layout/hello_world_layout.xml 布局文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">.......</span><br><span class="line">&lt;TextView</span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">......</span><br><span class="line">android:text=<span class="string">"@string/hello_world"</span> /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><strong>TextView</strong>，这是 Android 系统提供的一个控件，用于在<strong>布局中显示文字的</strong><br>hello_world_layout.xml布局文件中就是通过引用了 hello_world这个键，才找到了相应的值</p><h3 id="4-4-查看res-values-strings-xml-文件"><a href="#4-4-查看res-values-strings-xml-文件" class="headerlink" title="4.4 查看res/values/strings.xml 文件:"></a>4.4 查看res/values/strings.xml 文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;string name="app_name"&gt;Hello World&lt;/string&gt;</span><br><span class="line">....</span><br><span class="line">&lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p>一 般 是 把 字 符 串 定 义 在res/values/strings.xml 里，然后可以在布局文件或代码中引用<br>Hello world!字符串就是定义在这个文件里的<br>可以在这里通过修改 app_name 对应的值，来改变此应用程序的名称,在哪儿引用了app_name 这个键呢？在AndroidManifest.xml查找.</p><h2 id="五、关于资源目录res"><a href="#五、关于资源目录res" class="headerlink" title="五、关于资源目录res:"></a>五、关于资源目录res:</h2><p>drawable开头的文件夹都是用来放图片的<br>values开头的文件夹都是用来放字符串<br>layout 文件夹是用来放布局文件<br>menu 文件夹是用来放菜单文件</p><p>之所以有这么多 drawable开头的文件夹，是为了让程序能够兼容更多的设备, 最好能够给同一张图片提供几个不同分辨率的副本<br><strong>只有一份图片时,所有图片都放在 drawable-hdpi下即可</strong></p><h2 id="六、如何引用资源"><a href="#六、如何引用资源" class="headerlink" title="六、如何引用资源?"></a>六、如何引用资源?</h2><p> strings.xml 中的 Hello world!字符串，有两种方式引用它：</p><p>①: 代码中通过 <code>R.string.hello_world</code> 可以获得该字符串的引用；<br>②: 在 XML 中通过<code>@string/hello_world</code>可以获得该字符串的引用。</p><p>string 部分是可以替换的,如果是<strong>引用的图片资源就可以替换成 drawable,</strong>如果是引用的布局文件就可以替换成 layout,以此类推</p><h2 id="七、日志"><a href="#七、日志" class="headerlink" title="七、日志:"></a>七、日志:</h2><h3 id="7-1-打印日志"><a href="#7-1-打印日志" class="headerlink" title="7.1 打印日志:"></a>7.1 打印日志:</h3><p>打开 HelloWorldActivity，在 onCreate()方法中添加一行打印日志的语句，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">Log.d(<span class="string">"HelloWorldActivity"</span>, <span class="string">"onCreate execute"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Log.d 第一个参数是 tag，一般传入当前的类名，主要用于对打印信息进行过滤。<br>第二个参数是 msg，即想要打印的具体的内容。</p><h3 id="7-2-日志过滤器"><a href="#7-2-日志过滤器" class="headerlink" title="7.2 日志过滤器:"></a>7.2 日志过滤器:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.3.png" alt></p><p>给过滤器起名叫 data，并且让它对名为 data 的 Tag进行过滤</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.4.png" alt></p><p>在 onCreate()方法中把打印日志的语句改成 Log.d(“data”,”onCreate execute”)，然后再次运行程序，你就会在 data 过滤器下看到这行日志了。</p><h3 id="7-3-日志级别"><a href="#7-3-日志级别" class="headerlink" title="7.3 日志级别:"></a>7.3 日志级别:</h3><p>选中debug级别，这时只有使用 debug 及以上级别方法打印的日志才会显示出来<br>如果你把LogCat 中的级别选中为 info、warn 或者 error 时，我们在 onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是 Log.d()方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Android系统四大组件&quot;&gt;&lt;a href=&quot;#一、Android系统四大组件&quot; class=&quot;headerlink&quot; title=&quot;一、Android系统四大组件:&quot;&gt;&lt;/a&gt;一、Android系统四大组件:&lt;/h2&gt;&lt;h3 id=&quot;1-1-活动（Acti
      
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="初识Android" scheme="https://zzwwqq.xyz/tags/%E5%88%9D%E8%AF%86Android/"/>
    
  </entry>
  
  <entry>
    <title>PV操作</title>
    <link href="https://zzwwqq.xyz/PV%E6%93%8D%E4%BD%9C%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html"/>
    <id>https://zzwwqq.xyz/PV操作经典实例.html</id>
    <published>2019-04-04T07:58:18.000Z</published>
    <updated>2019-04-09T13:29:56.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是PV操作"><a href="#一、什么是PV操作" class="headerlink" title="一、什么是PV操作?"></a>一、什么是PV操作?</h2><p>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：<br>P（S）：<br>①将信号量S的值减1，即S=S-1；<br>②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。<br><a id="more"></a></p><p>V（S）：<br>①将信号量S的值加1，即S=S+1；</p><h2 id="二、PV操作的意义："><a href="#二、PV操作的意义：" class="headerlink" title="二、PV操作的意义："></a>二、PV操作的意义：</h2><p>我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。</p><h2 id="三、什么是信号量？"><a href="#三、什么是信号量？" class="headerlink" title="三、什么是信号量？"></a>三、什么是信号量？</h2><p>信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。<br><strong>信号量的值与相应资源的使用情况有关: </strong><br>①: 当信号量的值大于0时，表示当前可用资源的数量<br>②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数<br><strong>注意，信号量的值仅能由PV操作来改变。</strong></p><h2 id="四、使用PV操作注意事项："><a href="#四、使用PV操作注意事项：" class="headerlink" title="四、使用PV操作注意事项："></a>四、使用PV操作注意事项：</h2><p>①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。<br>②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。<br>③: 互斥信号量的初值一般为1。</p><h2 id="五、PV操作实例"><a href="#五、PV操作实例" class="headerlink" title="五、PV操作实例:"></a>五、PV操作实例:</h2><h2 id="5-1-例题1-吃苹果问题"><a href="#5-1-例题1-吃苹果问题" class="headerlink" title="5.1 例题1: 吃苹果问题:"></a>5.1 例题1: 吃苹果问题:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.1.png" alt></p><p><strong>解题过程:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty=<span class="number">2</span>； <span class="comment">//定义empty对应盘子的剩余放水果的位置个数初值为2(      空缓冲区个数       ) </span></span><br><span class="line">    semaphore apple=<span class="number">0</span>； <span class="comment">//定义信号量apple对应盘子里的苹果数量初值为0 </span></span><br><span class="line">    semaphore orange=<span class="number">0</span>； <span class="comment">//定义信号量orange对于盘子里的橘子数量初值为0 </span></span><br><span class="line">    semaphore mutex=<span class="number">1</span>： <span class="comment">//定义信号量mutex来保护盘子被互斥地访问 </span></span><br><span class="line">    father()&#123; <span class="comment">//爸爸进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(empty)； <span class="comment">//盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放苹果</span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            在盘子里放一个苹果 </span><br><span class="line">            V(mutex)； </span><br><span class="line">            V(apple)；<span class="comment">//盘中苹果数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mother()&#123; <span class="comment">//妈妈进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">        P(empty)； <span class="comment">//盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放橘子</span></span><br><span class="line">            P(mutex)； <span class="comment">//互斥变量减一，如果&lt;0，则说明有进程在临界区。则当前进程必须等待。</span></span><br><span class="line">            在盘子里放一个橘子</span><br><span class="line">            V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。</span><br><span class="line">            V(orange)； <span class="comment">//盘中橘子数加一</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">son()&#123; <span class="comment">//用这段程序产生两个儿子进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">        P(orange)； <span class="comment">//盘中橘子个数减一，如果结果&gt;=0时,说明盘中有橘子，可以取 </span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            从盘子里拿一个橘子</span><br><span class="line">            V(mutex)； </span><br><span class="line">            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123; <span class="comment">//用这段程序产生两个女儿进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span> )  &#123; </span><br><span class="line">        P(apple)；   <span class="comment">//盘中苹果个数减一，如果结果&gt;=0时,说明盘中有苹果，可以取</span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            从盘子里拿出一个苹果 </span><br><span class="line">            V(mutex)；</span><br><span class="line">            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-和尚打水"><a href="#5-2-和尚打水" class="headerlink" title="5.2 : 和尚打水:"></a>5.2 : 和尚打水:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.2.png" alt></p><p><strong>分析:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.3.png" alt></p><p><strong>解题过程:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Semaphore   mutexA = <span class="number">1</span>;    <span class="comment">//保护井被互斥地访问 </span></span><br><span class="line">Semaphore   mutexB = <span class="number">1</span>;    <span class="comment">//保护缸被互斥地访问 </span></span><br><span class="line">Semaphore   Count = <span class="number">3</span>；    <span class="comment">//桶总数为3</span></span><br><span class="line">Semaphore   full = <span class="number">0</span>;      <span class="comment">//控制出水，刚开始，缸是空的，能取出0桶水</span></span><br><span class="line">Semaphore   empty = <span class="number">10</span> ;   <span class="comment">//控制入水，刚开始，缸是空的，能倒入10桶水</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小和尚打水：</span></span><br><span class="line">Progress（小和尚）&#123;</span><br><span class="line">          <span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">                   P（empty）  <span class="comment">//判断缸是否满了（结果如果&gt;=0,未满），决定是否需要打水</span></span><br><span class="line">                   P（count）  <span class="comment">//拿桶（判断是否有空闲的桶，结果如果&gt;=0,有桶）</span></span><br><span class="line">                   P（mutexA）&#123;   <span class="comment">//对井互斥访问</span></span><br><span class="line">                    从井中打水；</span><br><span class="line">                    V（mutexA）    <span class="comment">//互斥</span></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                    P（mutexB）&#123;   <span class="comment">//对缸互斥访问</span></span><br><span class="line">                    向缸中倒水；</span><br><span class="line">                    V（mutexB）    <span class="comment">//互斥</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   V（count）<span class="comment">//还桶，空闲桶的数量加一</span></span><br><span class="line">                   V（full）   <span class="comment">//缸中水的数量加一，（通知老和尚取水）</span></span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老和尚取水：</span></span><br><span class="line">progress（老和尚）&#123;</span><br><span class="line">             <span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">                      P（full） <span class="comment">//判断缸中是否有水，（结果如果&gt;=0,说明缸中有水，可取水）</span></span><br><span class="line">                      P（count）<span class="comment">//拿桶</span></span><br><span class="line">                      P（mutexB) <span class="comment">//互斥</span></span><br><span class="line">                      从缸中取水；</span><br><span class="line">                      V（mutexB）<span class="comment">//互斥</span></span><br><span class="line">                      V(count)   <span class="comment">//还桶</span></span><br><span class="line">                      V（empty）<span class="comment">//缸中还能容纳的水数量加一，（通知小和尚打水）</span></span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是PV操作&quot;&gt;&lt;a href=&quot;#一、什么是PV操作&quot; class=&quot;headerlink&quot; title=&quot;一、什么是PV操作?&quot;&gt;&lt;/a&gt;一、什么是PV操作?&lt;/h2&gt;&lt;p&gt;PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：&lt;br&gt;P（S）：&lt;br&gt;①将信号量S的值减1，即S=S-1；&lt;br&gt;②如果S&amp;gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="PV操作" scheme="https://zzwwqq.xyz/tags/PV%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://zzwwqq.xyz/%E6%AD%BB%E9%94%81.html"/>
    <id>https://zzwwqq.xyz/死锁.html</id>
    <published>2019-04-03T07:10:16.000Z</published>
    <updated>2019-04-03T08:40:59.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是死锁"><a href="#一、什么是死锁" class="headerlink" title="一、什么是死锁:"></a>一、什么是死锁:</h2><p>是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种<strong>互相等待</strong>的现象,若无<strong>外力</strong>作用,它们都将无法推进下去.</p><h2 id="二、产生死锁的原因"><a href="#二、产生死锁的原因" class="headerlink" title="二、产生死锁的原因:"></a>二、产生死锁的原因:</h2><a id="more"></a><p>①: 因为系统资源不足<br>②: 进程运行推进顺序不合适<br>③: 资源分配不当等</p><h2 id="三、产生死锁的必要条件"><a href="#三、产生死锁的必要条件" class="headerlink" title="三、产生死锁的必要条件:"></a>三、产生死锁的必要条件:</h2><p>①: 互斥：一个资源每次只能被一个进程使用<br>②: 占有和等待(请求与保持)：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>③:  不剥夺: 进程已获得的资源，在使用完之前，不能强行被抢占,它只能被占有它的进程显式地释放。<br>④: 环路等待: 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p><p><strong>注: 只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong></p><h2 id="四、处理死锁的方法"><a href="#四、处理死锁的方法" class="headerlink" title="四、处理死锁的方法:"></a>四、处理死锁的方法:</h2><p>主要有以下四种方法：</p><h3 id="4-1-鸵鸟策略"><a href="#4-1-鸵鸟策略" class="headerlink" title="4.1 鸵鸟策略"></a>4.1 鸵鸟策略</h3><p><strong>4.1.1 原理: </strong><br>把头埋在沙子里，假装根本没发生问题, 也就是忽略死锁<br><strong>4.1.2 什么时候用?</strong><br>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><h3 id="4-2-死锁检测与死锁恢复"><a href="#4-2-死锁检测与死锁恢复" class="headerlink" title="4.2 死锁检测与死锁恢复"></a>4.2 死锁检测与死锁恢复</h3><p><strong>4.2.1 原理: </strong><br>不试图阻止死锁，而是当<strong>检测到死锁发生时</strong>，<strong>再采取措施</strong>进行恢复。<br><strong>4.2.2 死锁检测:</strong><br><strong>4.2.2.1 每种类型一个资源的死锁检测:</strong><br>通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>4.2.2.2 每种类型多个资源的死锁检测:</strong><br>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。<br>①: 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。<br>②: 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。<br>③: 如果没有这样一个进程，算法终止。</p><h3 id="4-2-3-死锁恢复"><a href="#4-2-3-死锁恢复" class="headerlink" title="4.2.3 死锁恢复:"></a>4.2.3 死锁恢复:</h3><p>①: 利用抢占恢复<br>②: 利用回滚恢复<br>③:     通过杀死进程恢复</p><h3 id="4-3-死锁预防"><a href="#4-3-死锁预防" class="headerlink" title="4.3 死锁预防"></a>4.3 死锁预防</h3><h3 id="4-3-1-原理"><a href="#4-3-1-原理" class="headerlink" title="4.3.1 原理:"></a>4.3.1 原理:</h3><p>在程序<strong>运行之前</strong>预防发生死锁</p><h3 id="4-3-2-采取方法"><a href="#4-3-2-采取方法" class="headerlink" title="4.3.2 采取方法:"></a>4.3.2 采取方法:</h3><p>破坏死锁的四个必要条件<br><strong>①: 破坏互斥：</strong><br><strong>②: 破坏占有和等待(请求与保持):</strong><br>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p><strong>③: 破坏不剥夺:</strong><br><strong>④: 破坏环路等待:</strong><br>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="4-4-死锁避免"><a href="#4-4-死锁避免" class="headerlink" title="4.4 死锁避免"></a>4.4 死锁避免</h3><p>在程序<strong>运行时</strong>避免发生死锁</p><h2 id="五、银行家算法"><a href="#五、银行家算法" class="headerlink" title="五、银行家算法:"></a>五、银行家算法:</h2><p><strong>例题: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-3.1.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-3.2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是死锁&quot;&gt;&lt;a href=&quot;#一、什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;一、什么是死锁:&quot;&gt;&lt;/a&gt;一、什么是死锁:&lt;/h2&gt;&lt;p&gt;是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种&lt;strong&gt;互相等待&lt;/strong&gt;的现象,若无&lt;strong&gt;外力&lt;/strong&gt;作用,它们都将无法推进下去.&lt;/p&gt;
&lt;h2 id=&quot;二、产生死锁的原因&quot;&gt;&lt;a href=&quot;#二、产生死锁的原因&quot; class=&quot;headerlink&quot; title=&quot;二、产生死锁的原因:&quot;&gt;&lt;/a&gt;二、产生死锁的原因:&lt;/h2&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="https://zzwwqq.xyz/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Android之活动</title>
    <link href="https://zzwwqq.xyz/Android%E4%B9%8B%E6%B4%BB%E5%8A%A8.html"/>
    <id>https://zzwwqq.xyz/Android之活动.html</id>
    <published>2019-04-02T13:31:03.000Z</published>
    <updated>2019-04-03T08:25:55.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、活动的基本用法"><a href="#一、活动的基本用法" class="headerlink" title="一、活动的基本用法:"></a>一、活动的基本用法:</h2><p>项目名可以叫做 ActivityTest ,为了手动创建活动 <strong>不再勾选 Create Activity</strong></p><h3 id="1-1-手动创建活动"><a href="#1-1-手动创建活动" class="headerlink" title="1.1 手动创建活动:"></a>1.1 手动创建活动:</h3><p>src 目录下先添加一个包,使用的默认包名com.example.activitytest<br>新建FirstActivity 类继承自 Activity<br>任何活动都应该重写 Activity 的 onCreate()方法</p><h3 id="1-2-创建布局"><a href="#1-2-创建布局" class="headerlink" title="1.2 创建布局"></a>1.2 创建布局</h3><p>每一个活动对应一个布局，布局就是用来显示界面内容<br>在res/layout 目录下新建 名为first_layout.xml的文件(菜单中点击Android XMLFile),根元素就默认选择为 LinearLayout</p><p><strong>添加一个按钮:</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_1"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>XML 中引用一个 id，就使用@id/id_name 这种语法<br>XML 中定义一个 id，则要使用@+id/id_name 这种语法<br>android:layout_width 指定了当前元素的宽度，match_parent表示让当前元素和父元素一样宽。<br>android:layout_height 指定了高度， wrap_content，表示当前元素的高度只要能刚好包含里面的内容就行。<br>android:text 指定了元素中显示的文字内容</p><h3 id="1-3-在活动中加载这个布局"><a href="#1-3-在活动中加载这个布局" class="headerlink" title="1.3 在活动中加载这个布局:"></a>1.3 在活动中加载这个布局:</h3><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            setContentView(R.layout.first_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id，因此我们刚才创建的 first_layout.xml 布局的 id 现在应该是已经添加到 R 文件中了。<br><strong>在代码中引用布局文件:  R.layout.first_layout </strong><br><strong>注意: </strong>这里我们使用的 R，是com.example.activitytest 包下的 R 文件<br>Android SDK 还会自动提供一个 android 包下的 R 文件，千万别使用错了。</p><h3 id="1-4-在-AndroidManifest-文件中注册"><a href="#1-4-在-AndroidManifest-文件中注册" class="headerlink" title="1.4 在 AndroidManifest 文件中注册:"></a>1.4 在 AndroidManifest 文件中注册:</h3><p>所有的活动都要在 AndroidManifest.xml 中进行注册才能生效    </p><p>在AndroidManifest.xml 来给 FirstActivity 注册:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"com.example.activitytest"</span> &gt;</span><br><span class="line">....</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">....</span><br><span class="line">&lt;activity</span><br><span class="line"><span class="comment">/*.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity 的</span></span><br><span class="line"><span class="comment">缩写由于最外层的&lt;manifest&gt;标签中已经通过 package 属性指定了程序的包名是</span></span><br><span class="line"><span class="comment">             com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">             android:label=<span class="string">"This is FirstActivity"</span> &gt;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果你想让 FirstActivity 作为我们这个程序的主活动，即点击桌面应用程序图标时首先打开的就是这</span></span><br><span class="line"><span class="comment">             个活动，那就一定要加入下面这两句声明。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他的应用在内部进行调用的，如支付宝快捷支付服务。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>活动的注册声明要放在<code>&lt;application&gt;</code>标签内, 通过<code>&lt;activity&gt;</code>标签来对活动进行注册的<br>android:name 来指定具体注册哪一个活动<br>android:label指定活动中标题栏的内容</p><h3 id="1-5-隐藏标题栏"><a href="#1-5-隐藏标题栏" class="headerlink" title="1.5 隐藏标题栏"></a>1.5 隐藏标题栏</h3><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注意这句代码一定要在 setContentView()之前执行，不然会报错</span></span><br><span class="line">    requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-在活动中使用-Toast"><a href="#1-6-在活动中使用-Toast" class="headerlink" title="1.6 在活动中使用 Toast:"></a>1.6 在活动中使用 Toast:</h3><p>toast是什么?<br>界面弹出短小的信息通知给用户，这些信息会在一段时间后自动消失</p><p>首先需要定义一个弹出 Toast 的触发点,    如点击按钮的时候弹出一个 Toast </p><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// findViewById()方法获取在布局文件中定义的元素，传入 R.id.button_1，来得到按钮的实例</span></span><br><span class="line">        Button button1 = (Button) findViewById(R.id.button_1);<span class="comment">//findViewById返回的是一个 View 对象</span></span><br><span class="line">        <span class="comment">//注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法</span></span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* makeText()创建出一个 Toast对象, show()是将 Toast 显示出来</span></span><br><span class="line"><span class="comment">            第一个参数是 Context，也就是 Toast 要求的上下文，活动本身就是一个 Context 对象</span></span><br><span class="line"><span class="comment">            第二个参数是Toast显示的文本内容</span></span><br><span class="line"><span class="comment">            第三个参数是Toast显示的时长</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Toast.makeText(FirstActivity.<span class="keyword">this</span>, <span class="string">"You clicked Button 1"</span>,</span><br><span class="line">                           Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-在活动中使用-Menu"><a href="#1-7-在活动中使用-Menu" class="headerlink" title="1.7 在活动中使用 Menu"></a>1.7 在活动中使用 Menu</h3><p>在 res 目录下新建一个 menu 文件夹<br>新建一个 main.xml 文件(点击Android XML File)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line"><span class="comment">//&lt;item&gt;标签就是用来创建具体的某一个菜单项</span></span><br><span class="line">    &lt;item</span><br><span class="line">         <span class="comment">//给这个菜单项指定一个唯一标识符，</span></span><br><span class="line">android:id=<span class="string">"@+id/add_item"</span></span><br><span class="line">         <span class="comment">//给这个菜单项指定一个名称</span></span><br><span class="line">android:title=<span class="string">"Add"</span>/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><p>然后打开 FirstActivity类，重写 onCreateOptionsMenu()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* inflate()方法就可以给当前活动创建菜单</span></span><br><span class="line"><span class="comment">    第一个参数:通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main</span></span><br><span class="line"><span class="comment">    第二个参数:用于指定我们的菜单项将添加到哪一个 Menu对象当中，这里直接使用 onCreateOptionsMenu()方法中传</span></span><br><span class="line"><span class="comment">    入的 menu参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="comment">//返回 true，表示允许创建的菜单显示出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义菜单响应事件"><a href="#定义菜单响应事件" class="headerlink" title="定义菜单响应事件:"></a>定义菜单响应事件:</h3><p> FirstActivity 中重写 onOptionsItemSelected()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// item.getItemId()来判断我们点击的是哪一个菜单项</span></span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Add"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Remove"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-销毁一个活动"><a href="#1-8-销毁一个活动" class="headerlink" title="1.8 销毁一个活动:"></a>1.8 销毁一个活动:</h3><p>Activity 类提供了一个 finish()方法:</p><p>打开 FirstActivity类,onCreate方法中, 修改按钮监听器中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一样的。</span></span><br></pre></td></tr></table></figure><h2 id="二、使用-Intent-在活动之间穿梭"><a href="#二、使用-Intent-在活动之间穿梭" class="headerlink" title="二、使用 Intent 在活动之间穿梭:"></a>二、使用 Intent 在活动之间穿梭:</h2><h3 id="2-1-使用显式-Intent"><a href="#2-1-使用显式-Intent" class="headerlink" title="2.1 使用显式 Intent:"></a>2.1 使用显式 Intent:</h3><p>Intent的“意图”非常明显，因此我们称之为显式 Intent</p><p>在 ActivityTest 项目中再创建一个活动。新建一个 second_layout.xml 布局文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//定义了一个按钮，按钮上显示 Button 2</span></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_2"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建活动 SecondActivity 继承自Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 AndroidManifest.xml 中为 SecondActivity 进行注册。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">   ...&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">android:label=<span class="string">"This is FirstActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"><span class="comment">// SecondActivity 不是主活动，因此不需要配置&lt;intent-filter&gt;标签里的内容</span></span><br><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure><p><strong>Intent 一般可被用于启动活动、启动服务、以及发送广播等场景</strong><br>Intent 是 各组件之间进行<strong>交互</strong>的一种重要方式，它可以<strong>指明</strong>当前组件想要<strong>执行的动作</strong>，还可以在不同组件之间<strong>传递数据</strong></p><p>Intent(Context packageContext, Class&lt;?&gt; cls):<br>这个构造函数接收两个参数，第一个参数: 启动活动的上下文，第二个参数 指定想要启动的目标活动</p><p>Activity 类中 startActivity()方法，用于启动活动的，它接收一个Intent参数</p><p>修改 FirstActivity 中按钮的点击事件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在FirstActivity活动的基础上打开 SecondActivity活动,startActivity()方法来执行这个Intent</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-使用隐式-Intent"><a href="#2-2-使用隐式-Intent" class="headerlink" title="2.2 使用隐式 Intent:"></a>2.2 使用隐式 Intent:</h3><p><strong>不明确指出</strong>我们想要启动哪一个活动，而是指定了一系列更为抽象的 action和 category等信息,<strong>由系统去分析Intent</strong>，并找出合适的活动(响应隐式 Intent的活动)去启动</p><p> AndroidManifest.xml添加如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    <span class="comment">//指明当前活动可以响应 ACTION_START这个 action</span></span><br><span class="line">&lt;action android:name=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span><br><span class="line">         <span class="comment">// 精确地指明当前的活动能够响应的 Intent 中还可能带有的 category  </span></span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"><span class="comment">//只有&lt;action&gt;和&lt;category&gt;中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。</span></span><br></pre></td></tr></table></figure><p>修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用了Intent 的另一个构造函数,传入action的字符串,表明要启动能够响应ACTION_START这个action的活动</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注: &lt;action&gt;和&lt;category&gt;同时匹配上才能响应,而这里没有指定category,这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中</span></span><br></pre></td></tr></table></figure><p><strong>每个 Intent 中只能指定一个 action，但却能指定多个 category</strong></p><p>修改 FirstActivity 中按钮的点击事件,增加一个category</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        <span class="comment">// addCategory()方法来添加一个 category</span></span><br><span class="line">        intent.addCategory(<span class="string">"com.example.activitytest.MY_CATEGORY"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中 SecondActivity的<code>&lt;intent-filter&gt;</code>中再添加一个 category 的声明:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">....</span><br><span class="line">&lt;category android:name=<span class="string">"com.example.activitytest.MY_CATEGORY"</span>/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-更多隐式-Intent-的用法"><a href="#2-3-更多隐式-Intent-的用法" class="headerlink" title="2.3 更多隐式 Intent 的用法"></a>2.3 更多隐式 Intent 的用法</h3><p>修改 FirstActivity 中按钮点击事件的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器来打开这个网页就行了</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Intent.ACTION_VIEW，这是一个 Android 系统内置的动作</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        <span class="comment">// Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以在<code>&lt;intent-filter&gt;</code>标签中再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容:</p><p>android:scheme<br>用于指定数据的协议部分，如上例中的 http 部分</p><p><strong>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data完全一致时，当前活动才能够响应该 Intent。</strong><br>如上面浏览器示例中，其实只需要<strong>指定 android:scheme 为 http，就可以响应所有的 http 协议的 Intent 了</strong>。</p><h3 id="2-4-自己建立一个活动，让它也能响应打开网页的Intent"><a href="#2-4-自己建立一个活动，让它也能响应打开网页的Intent" class="headerlink" title="2.4 自己建立一个活动，让它也能响应打开网页的Intent"></a>2.4 自己建立一个活动，让它也能响应打开网页的Intent</h3><p>新建 third_layout.xml 布局文件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_3"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 3"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建活动 ThirdActivity 类继承自 Activity<br>将布局添加到活动中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.third_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 AndroidManifest.xml 中为 ThirdActivity 进行注册</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".ThirdActivity"</span> &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">     &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">          <span class="comment">//数据的协议必须是 http协议</span></span><br><span class="line">          &lt;data android:scheme=<span class="string">"http"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p><strong>调用系统拨号界面</strong></p><p>除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示<br>拨打电话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL);</span><br><span class="line">        <span class="comment">// data部分指定了协议是 tel，号码是 10086</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-5-向下一个活动传递数据"><a href="#2-5-向下一个活动传递数据" class="headerlink" title="2.5 向下一个活动传递数据:"></a>2.5 向下一个活动传递数据:</h3><p> Intent 还可以在启动活动的时候传递数据, </p><p>putExtra()的重载，可把想要传递的数据暂存在 Intent 中，启动另一个活动后，只需把这些数据从Intent 中取出就可</p><p>SecondActivity 类中,修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity中</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String data = <span class="string">"Hello SecondActivity"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">//第一个参数是键,用于后面从 Intent中取值，第二个参数才是真正要传递的数据。</span></span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>, data);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// getIntent()方法获取到用于启动 SecondActivity 的 Intent</span></span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        <span class="comment">//如果传递的是布尔型数据，则使用 getBooleanExtra()方法</span></span><br><span class="line">        <span class="comment">//getStringExtra()方法，传入相应的键值，就可以得到传递的数据了</span></span><br><span class="line">        String data = intent.getStringExtra(<span class="string">"extra_data"</span>);</span><br><span class="line">        Log.d(<span class="string">"SecondActivity"</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-返回数据给上一个活动"><a href="#2-6-返回数据给上一个活动" class="headerlink" title="2.6 返回数据给上一个活动:"></a>2.6 返回数据给上一个活动:</h3><p>Activity 中 <strong>startActivityForResult()</strong>方法也是用于<strong>启动活动</strong>的，但这个方法期望在活动<strong>销毁的时</strong>候能够<strong>返回一个结果给上一个活动</strong>。</p><p>修改 FirstActivity 中按钮的点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">//第一个参数还是 Intent,第二个参数是请求码，用于在之后的回调中判断数据的来源,请求码只要是一个唯一值就可以了</span></span><br><span class="line">        startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SecondActivity 中给按钮注册点击事件并在点击事件中添加返回数据的逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">        Button button2 = (Button) findViewById(R.id.button_2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">                intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">                <span class="comment">//setResult()专门用于向上一个活动返回数据的</span></span><br><span class="line">                <span class="comment">//第一个参数用于向上一个活动返回处理结果,第二个参数则是把带有数据的 Intent 传递回去</span></span><br><span class="line">                setResult(RESULT_OK, intent);</span><br><span class="line">                <span class="comment">//销毁当前活动</span></span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数 requestCode，启动活动时传入的请求码,</span></span><br><span class="line"><span class="comment">//第二个参数 resultCode，返回数据时传入的处理结果</span></span><br><span class="line"><span class="comment">//第三个参数 data，即携带着返回数据的 Intent</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到 onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作</p><p>如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下Back 键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通过重写 onBackPressed()方法来解决这个问题，代码如下所示：</p><p>SecondActivity 类中修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的话，当用户按下 Back 键，就会去执行 onBackPressed()方法中的代码，我们在这里添加返回数据的逻辑就行了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">    setResult(RESULT_OK, intent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-活动的生命周期"><a href="#2-7-活动的生命周期" class="headerlink" title="2.7 活动的生命周期:"></a>2.7 活动的生命周期:</h3><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.5.png" alt></p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期中最多可能会有四种状态。<br>运行状态:位于返回栈的栈顶时<br>暂停状态:不再处于栈顶位置，但仍然可见<br>停止状态:不再处于栈顶位置，并且完全不可见<br>销毁状态:从返回栈中移除后就变成了销毁状态</p><h3 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h3><p>Activity 类中定义了七个回调方法:</p><p>onCreate():<br>每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</p><p>onStart():<br>在活动由不可见变为可见的时候调用</p><p>onResume():<br>在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</p><p>onPause():<br>准备去启动或者恢复另一个活动的时候调用</p><p>onStop():<br>在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。</p><p>onDestroy():<br>活动被销毁之前调用</p><p>onRestart():<br>活动由停止状态变为运行状态之前调用</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.6.png" alt></p><h3 id="2-6-活动被回收了怎么办"><a href="#2-6-活动被回收了怎么办" class="headerlink" title="2.6 活动被回收了怎么办"></a>2.6 活动被回收了怎么办</h3><p>Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p><p>onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法<br>用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据，<br>以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，<br>第二个参数是真正要保存的内容。<br>在 MainActivity 中添加如下代码就可以将临时数据进行保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">String tempData = <span class="string">"Something you just typed"</span>;</span><br><span class="line">outState.putString(<span class="string">"data_key"</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我<br>们一直使用的 onCreate()方法其实也有一个 Bundle类型的参数。这个参数在一般情况下都是<br>null，但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参<br>数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。<br>修改 MainActivity 的 onCreate()方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String tempData = savedInstanceState.getString(<span class="string">"data_key"</span>);</span><br><span class="line">        Log.d(TAG, tempData);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-活动的启动模式"><a href="#2-7-活动的启动模式" class="headerlink" title="2.7 活动的启动模式"></a>2.7 活动的启动模式</h3><p>启动模式一共有四种，分别是 standard、singleTop、singleTask 和 singleInstance​    </p><p>AndroidManifest.xml 中通 过给<code>&lt;activity&gt;</code> 标签 指定android:launchMode属性来选择启动模式</p><p>standard</p><p>活动默认的启动模式,系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</p><p>singleTop</p><p>在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</p><p>修改 AndroidManifest.xml 中 FirstActivity 的启动模式，<br>如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">android:launchMode=<span class="string">"singleTop"</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>singleTask</p><p>很好地解决重复创建栈顶活动的问题</p><p>singleInstance</p><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、活动的基本用法&quot;&gt;&lt;a href=&quot;#一、活动的基本用法&quot; class=&quot;headerlink&quot; title=&quot;一、活动的基本用法:&quot;&gt;&lt;/a&gt;一、活动的基本用法:&lt;/h2&gt;&lt;p&gt;项目名可以叫做 ActivityTest ,为了手动创建活动 &lt;strong&gt;不
      
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="Android之活动" scheme="https://zzwwqq.xyz/tags/Android%E4%B9%8B%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之适配器模式.html</id>
    <published>2019-04-02T08:44:27.000Z</published>
    <updated>2019-04-02T09:10:19.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是适配器模式"><a href="#一、什么是适配器模式" class="headerlink" title="一、什么是适配器模式?"></a>一、什么是适配器模式?</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br>举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><a id="more"></a><h2 id="二、-分类"><a href="#二、-分类" class="headerlink" title="二、 分类:"></a>二、 分类:</h2><h3 id="2-1-类的适配器模式"><a href="#2-1-类的适配器模式" class="headerlink" title="2.1 类的适配器模式:"></a>2.1 类的适配器模式:</h3><p><strong>使用步骤:</strong><br>步骤1： 创建Target接口<br>步骤2： 创建源类（Adaptee）<br>步骤3： 创建适配器类Adapter (适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。)<br>步骤4： 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</p><h3 id="2-2-对象的适配器模式"><a href="#2-2-对象的适配器模式" class="headerlink" title="2.2 对象的适配器模式:"></a>2.2 对象的适配器模式:</h3><p><strong>原理:</strong><br>与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。<br><strong>步骤:</strong><br>①: 创建Target接口<br>②: 创建源类（Adaptee）<br>③: 创建适配器类（Adapter）（不适用继承而是委派）<br>④: 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</p><h3 id="2-3-对象的适配器模式与类的适配器模式比较"><a href="#2-3-对象的适配器模式与类的适配器模式比较" class="headerlink" title="2.3 对象的适配器模式与类的适配器模式比较:"></a>2.3 对象的适配器模式与类的适配器模式比较:</h3><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。</p><h3 id="2-4-什么时候用类的适配器模式"><a href="#2-4-什么时候用类的适配器模式" class="headerlink" title="2.4 什么时候用类的适配器模式?"></a>2.4 什么时候用类的适配器模式?</h3><p> ①: 仅仅希望使用方便时<br>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。<br>对于对象适配器，需要额外的引用来间接得到Adaptee。<br>②: 需要重新定义Adaptee的部分行为<br>对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。<br>对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</p><h3 id="2-5-什么时候用对象的适配器模式"><a href="#2-5-什么时候用对象的适配器模式" class="headerlink" title="2.5 什么时候用对象的适配器模式?"></a>2.5 什么时候用对象的适配器模式?</h3><p>①: 灵活使用时<br>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。<br>②: 需要同时配源类和其子类<br>对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了；</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结:"></a>2.6 总结:</h3><p>建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。</p><h2 id="三、主要作用"><a href="#三、主要作用" class="headerlink" title="三、主要作用:"></a>三、主要作用:</h2><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><h2 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点:"></a>三、优点:</h2><p>①: 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。<br>②: 解耦性:    将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码<br>③: 符合开放-关闭原则:  同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类<br>④: 更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。<br>⑤: 透明、简单:  客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接, 过多的使用适配器，会让系统非常零乱，不易整体进行把握</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景:"></a>四、应用场景:</h2><p>系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><h2 id="五、实例"><a href="#五、实例" class="headerlink" title="五、实例:"></a>五、实例:</h2><p>背景：小成买了一个进口的电视机<br>冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容<br>解决方案：设置一个适配器将插头输出的220V转变成110V</p><p><strong>使用类的适配器模式解题:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将220V转换输出110V（原有插头（Adaptee）没有的）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建源类（Adaptee）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerPort220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原有的插口只能输出220V</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OutPut_220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）</span></span><br><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter220V</span> <span class="keyword">extends</span> <span class="title">PowerPort220V</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//期待的插头要求调用Convert_110v()，但原有插头没有</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.OutPut_220V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="comment">//通过Adapter类从而调用所需要的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用户拿着进口机器插上适配器（调用Convert_110v()方法）</span></span><br><span class="line">        <span class="comment">//再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V）</span></span><br><span class="line">        <span class="comment">//适配器只是个外壳，对外提供110V，但本质还是220V进行供电</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter220V();</span><br><span class="line">        target.Convert_110V();</span><br><span class="line">        ImportMachine importMachine =  <span class="keyword">new</span> ImportMachine();</span><br><span class="line">        importMachine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进口机器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImportMachine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进口机器正常工作!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的适配器模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//源类Adapteree没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建源类（Adaptee） ；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapteree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）</span></span><br><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adapteree</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的</span></span><br><span class="line"><span class="comment">//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的适配器模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapteree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapteree adapteree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接关联被适配类Adapteree</span></span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adapteree adapteree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapteree = adapteree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里是使用委托的方式完成特殊功能</span></span><br><span class="line">        <span class="keyword">this</span>.adapteree.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adapteree());</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是适配器模式&quot;&gt;&lt;a href=&quot;#一、什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是适配器模式?&quot;&gt;&lt;/a&gt;一、什么是适配器模式?&lt;/h2&gt;&lt;p&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。&lt;br&gt;这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。&lt;br&gt;举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之适配器模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="https://zzwwqq.xyz/%E5%BA%94%E7%94%A8%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/应用层.html</id>
    <published>2019-04-02T03:06:32.000Z</published>
    <updated>2019-04-08T08:03:06.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、应用层协议"><a href="#一、应用层协议" class="headerlink" title="一、应用层协议:"></a>一、应用层协议:</h2><p>应用层的许多协议是基于客户服务器方式的</p><h3 id="1-1-DNS"><a href="#1-1-DNS" class="headerlink" title="1.1 DNS:"></a>1.1 DNS:</h3><p><strong>1.1.1 是什么? </strong><br>DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。<br><a id="more"></a></p><p><strong>1.1.2 作用:</strong><br>用于域名解析服务,将域名(机器名) 转换为 IP地址<br><strong>1.1.3 原理: </strong><br>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。<br>客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。<br><strong>1.1.4 特点:</strong><br><strong>基于UDP服务</strong>，该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。<strong>端口号53</strong><br>DNS 可以使用 UDP 或者 TCP 进行传输，大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性<br><strong>1.1.5 在两种情况下会使用 TCP 进行传输：</strong></p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h3 id="1-2-HTTP"><a href="#1-2-HTTP" class="headerlink" title="1.2 : HTTP:"></a>1.2 : HTTP:</h3><p><strong>1.2.1 是什么? </strong><br>这是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页<br><strong>1.2.2 特点: </strong><br>本身是<strong>无连接，无状态的</strong>,使用<strong>TCP</strong>连接进行可靠的传送</p><h3 id="1-3-FTP"><a href="#1-3-FTP" class="headerlink" title="1.3 : FTP:"></a>1.3 : FTP:</h3><p><strong>1.3.1 是什么? </strong><br>文件传输协议<br><strong>1.3.2 特点: </strong><br>提供交互式的访问 ,基于<strong>客户服务器模式</strong>，<strong>面向连接 </strong>,<strong>使用TCP</strong>可靠的运输服务 ,使用<strong>21端口</strong><br><strong>1.3.3 主要功能:</strong><br>减少/消除不同操作系统下文件的不兼容性 </p><p><strong>1.3.4 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</strong></p><ul><li>控制连接：服务器打开<strong>端口号 21</strong>等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。<strong>端口号20</strong></li></ul><p><strong>1.3.5 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</strong></p><ul><li><strong>主动模式：</strong>服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.3.png" alt></p><ul><li><strong>被动模式：</strong>客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.4.png" alt></p><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h3 id="1-4-简单文件传送协议TFTP"><a href="#1-4-简单文件传送协议TFTP" class="headerlink" title="1.4 : 简单文件传送协议TFTP:"></a>1.4 : 简单文件传送协议TFTP:</h3><p><strong>1.4.1 特点: </strong><br>客户服务器模式 ,使用UDP数据报 ,只支持文件传输，不支持交互 ,TFTP代码占内存小 </p><h3 id="1-5-TELNET"><a href="#1-5-TELNET" class="headerlink" title="1.5 : TELNET:"></a>1.5 : TELNET:</h3><p><strong>1.5.1 作用:</strong><br>用于远程登陆<br><strong>1.5.2 特点:</strong><br>客户服务器模式  <strong>使用23端口</strong>，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务,TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h3 id="1-6-简单网络管理协议（SNMP）"><a href="#1-6-简单网络管理协议（SNMP）" class="headerlink" title="1.6 : 简单网络管理协议（SNMP）:"></a>1.6 : 简单网络管理协议（SNMP）:</h3><p><strong>1.6.1 SNMP模型的4个组件：</strong><br>被管理结点、管理站、管理信息、管理协议<br><strong>1.6.2 SNMP代理：</strong><br>运行SNMP管理进程的被管理结点<br>对象：描述设备的变量<br>管理信息库（MIB）：保存所有对象的数据结构 </p><h3 id="1-7-DHCP"><a href="#1-7-DHCP" class="headerlink" title="1.7 : DHCP:"></a>1.7 : DHCP:</h3><p><strong>1.7.1 什么是DHCP?</strong></p><p>动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。<br>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。<br><strong>1.7.2 DHCP 工作过程如下：</strong></p><p>①: 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<br>②: DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。<br>③: 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。<br>④: DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.5.png" alt></p><h3 id="1-8-电子邮件协议"><a href="#1-8-电子邮件协议" class="headerlink" title="1.8 :电子邮件协议:"></a>1.8 :电子邮件协议:</h3><p>一个电子邮件系统由三部分组成：<br>用户代理、邮件服务器以及邮件协议。<br>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h3 id="1-8-1-SMTP"><a href="#1-8-1-SMTP" class="headerlink" title="1.8.1 : SMTP:"></a>1.8.1 : SMTP:</h3><p><strong>1.8.1.1 是什么? </strong><br>简单邮件传输协议<br><strong>1.8.1.2 作用: </strong><br>用于发送邮件。<br><strong>1.8.1.3 特点: </strong><br>Client/Server模式，面向连接 ,服务器开放的是<strong>25号端口。</strong>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。<br><strong>1.8.1.4 基本功能：</strong><br>写信、传送、报告传送情况、显示信件、接收方处理信件 </p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.7.png" alt></p><h3 id="1-8-2-POP3"><a href="#1-8-2-POP3" class="headerlink" title="1.8.2 : POP3:"></a>1.8.2 : POP3:</h3><p><strong>1.8.2.1 是什么? </strong><br>它是和SMTP对应<br><strong>1.8.2.2 作用: </strong><br>用于接收邮件<br><strong>1.8.2.3 特点: </strong><br>①: 只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。<br>②：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”。POP3协议所用的是<strong>110端口。</strong></p><h3 id="1-8-3-IMAP"><a href="#1-8-3-IMAP" class="headerlink" title="1.8.3 : IMAP:"></a>1.8.3 : IMAP:</h3><p><strong>1.8.3.1 作用: </strong><br>读取邮件<br><strong>1.8.3.2 特点: </strong><br>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.6.png" alt></p><h2 id="二、关于域名"><a href="#二、关于域名" class="headerlink" title="二、关于域名:"></a>二、关于域名:</h2><h3 id="2-1-域名规范"><a href="#2-1-域名规范" class="headerlink" title="2.1 域名规范:"></a>2.1 域名规范:</h3><p><strong>DNS规定:</strong><br>①: 域名中标号必须是英文或数字<br>②: 不区分大小写<br>③: 除连字符外不能用其他标点<br>④: 级别最低的域名写在最左边<br>⑤: 域名总长度不超过255个字符. </p><h3 id="2-2-域名分类"><a href="#2-2-域名分类" class="headerlink" title="2.2 域名分类:"></a>2.2 域名分类:</h3><p>顶级域名(TLD: TOP Level Domain):<br>①: 国家顶级域名:<br>　　　　　　　　cn代表中国 ,US代表美国<br>②:通用顶级域名:<br>　　　　　　　　com(公司,企业)<br>　　　　　　　　net(网络服务机构)<br>　　　　　　　　edu(教育机构)</p><p>mail.cctv.com: 其中com为一级域名(即顶级域名), cctv是二级域名,mail是三级域名.<br>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><h3 id="2-3-域名管理"><a href="#2-3-域名管理" class="headerlink" title="2.3 域名管理:"></a>2.3 域名管理:</h3><p>①: 在国家顶级域名下注册的二级域名均由该国家自由确定.<br>②: 各级域名由其上一级域名管理机构管理<br>③: 最高的顶级域名由ICANN管理<br><strong>注: 域名中的点与点分十进制IP地址中的点无一一对应的关系</strong></p><h3 id="2-4-为什么机器在处理IP数据报时要使用IP地址-而不用域名-机器名"><a href="#2-4-为什么机器在处理IP数据报时要使用IP地址-而不用域名-机器名" class="headerlink" title="2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?"></a>2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?</h3><p><strong>原因: </strong>IP地址长度固定(32位)而域名长度不固定,机器处理起来困难.</p><h2 id="三、关于域名服务器"><a href="#三、关于域名服务器" class="headerlink" title="三、关于域名服务器:"></a>三、关于域名服务器:</h2><p>一个域名服务器所负责管理的范围叫做<strong>区</strong>,每个区 设置相应的权限域名服务器<br>为了减轻根域名服务器的压力,域名服务器中广泛使用<strong>高速缓存.</strong></p><h3 id="3-1-域名服务器分类"><a href="#3-1-域名服务器分类" class="headerlink" title="3.1 域名服务器分类:"></a>3.1 域名服务器分类:</h3><p><strong>①: 根域名服务器: </strong><br>所有根域名服务器都知道所有顶级域名服务器的域名和IP地址<br><strong>②: 顶级域名服务器: </strong><br>管理在该顶级域名服务器下注册的所有二级域名,当收到查询请求,就给出查询结果,或者下一步应当找的域名服务器地址<br><strong>③: 权限域名服务器: </strong><br>负责一个区的域名服务器,当它不能给出最后的查询结果时,就告诉客户下一步应当查找哪个权限域名服务器<br><strong>④: 本地域名服务器: </strong><br>离用户较近,一般不超过几个路由器的距离</p><p><strong>迭代查询: </strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.1.png" alt></p><p><strong>递归查询:</strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.2.png" alt></p><h2 id="四、常用端口"><a href="#四、常用端口" class="headerlink" title="四、常用端口:"></a>四、常用端口:</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用</td><td>应用层协议</td><td>端口号</td><td>传输层协议</td><td>备注</td></tr><tr><td>域名解析</td><td><strong>DNS</strong></td><td>53</td><td>UDP/TCP</td><td>长度超过 512 字节时使用 TCP</td></tr><tr><td>动态主机配置协议</td><td>DHCP</td><td>67/68</td><td>UDP</td><td></td></tr><tr><td>简单网络管理协议</td><td>SNMP</td><td>161/162</td><td>UDP</td><td></td></tr><tr><td>文件传送协议</td><td><strong>FTP</strong></td><td>20/21</td><td>TCP</td><td>控制连接 21，数据连接 20</td></tr><tr><td>远程终端协议</td><td><strong>TELNET</strong></td><td>23</td><td>TCP</td><td></td></tr><tr><td>超文本传送协议</td><td>HTTP</td><td>80</td><td>TCP</td><td></td></tr><tr><td></td><td><strong>HTTPS</strong></td><td><strong>443</strong></td><td></td><td></td></tr><tr><td>简单邮件传送协议</td><td><strong>SMTP</strong></td><td>25</td><td>TCP</td><td></td></tr><tr><td>邮件读取协议</td><td><strong>POP3</strong></td><td>110</td><td>TCP</td><td></td></tr><tr><td>网际报文存取协议</td><td><strong>IMAP</strong></td><td>143</td><td>TCP</td></tr></tbody></table><h2 id="五、Web-页面请求过程"><a href="#五、Web-页面请求过程" class="headerlink" title="五、Web 页面请求过程:"></a>五、Web 页面请求过程:</h2><h3 id="5-1-DHCP-配置主机信息"><a href="#5-1-DHCP-配置主机信息" class="headerlink" title="5.1 DHCP 配置主机信息:"></a>5.1 DHCP 配置主机信息:</h3><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。<br>①: <strong>主机生成一个 DHCP 请求报文</strong>，并将这个报文<strong>放入</strong>具有目的端口 67 和源端口 68 的 <strong>UDP 报文段</strong>中。<br>②: 该报文段则被放入在一个具有<strong>广播 IP</strong> 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 <strong>IP 数据报</strong>中。<br>③: 该数据报则被放置在<strong>MAC 帧</strong>中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。<br>④: 连接在交换机的 DHCP 服务器收到广播帧之后，<strong>不断地向上分解</strong>得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。<br>⑤: 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。<br>⑥: 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p><h3 id="5-2-ARP-解析-MAC-地址"><a href="#5-2-ARP-解析-MAC-地址" class="headerlink" title="5.2 ARP 解析 MAC 地址"></a>5.2 ARP 解析 MAC 地址</h3><p>①: 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。<br>②: 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。<br>③: 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中<br>④: 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。<br>⑤: DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。<br>⑥: 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。<br>⑦: 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p><h3 id="5-3-DNS-解析域名"><a href="#5-3-DNS-解析域名" class="headerlink" title="5.3 DNS 解析域名:"></a>5.3 DNS 解析域名:</h3><p>①: 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。<br>②: 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。<br>③: 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。<br>④: 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。<br>⑤: 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p><h3 id="5-4-HTTP-请求页面"><a href="#5-4-HTTP-请求页面" class="headerlink" title="5.4  HTTP 请求页面:"></a>5.4  HTTP 请求页面:</h3><p>①: 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。<br>②: 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。<br>③: HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。<br>④: 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。<br>⑤: HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。<br>⑥: 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p><h2 id="六、应用层功能"><a href="#六、应用层功能" class="headerlink" title="六、应用层功能:"></a>六、应用层功能:</h2><p>负责对软件提供接口以使程序能使用网络服务</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、应用层协议&quot;&gt;&lt;a href=&quot;#一、应用层协议&quot; class=&quot;headerlink&quot; title=&quot;一、应用层协议:&quot;&gt;&lt;/a&gt;一、应用层协议:&lt;/h2&gt;&lt;p&gt;应用层的许多协议是基于客户服务器方式的&lt;/p&gt;
&lt;h3 id=&quot;1-1-DNS&quot;&gt;&lt;a href=&quot;#1-1-DNS&quot; class=&quot;headerlink&quot; title=&quot;1.1 DNS:&quot;&gt;&lt;/a&gt;1.1 DNS:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.1.1 是什么? &lt;/strong&gt;&lt;br&gt;DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="应用层" scheme="https://zzwwqq.xyz/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="https://zzwwqq.xyz/%E4%BC%A0%E8%BE%93%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/传输层.html</id>
    <published>2019-04-01T13:08:40.000Z</published>
    <updated>2019-04-08T08:05:33.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传输层协议"><a href="#一、传输层协议" class="headerlink" title="一、传输层协议:"></a>一、传输层协议:</h2><p>TCP协议,UDP协议,SPX协议</p><h3 id="10-1-关于TCP协议"><a href="#10-1-关于TCP协议" class="headerlink" title="10.1 关于TCP协议:"></a>10.1 关于TCP协议:</h3><p><strong>特点:</strong><br>①: 面向连接<br>②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点</p><p><strong>使用场合: </strong>一般用于传输数据量少,且对可靠性要求高的场合.</p><a id="more"></a><p><strong>注: 这2个端点并不是主机,也不是主机的IP地址,不是应用进程,也不是运输层协议端口, 而是指 套接字 </strong><br>③: 提供可靠交付服务: 无差错 ,  不丢失  ,   不重复  ,  按序到达<br>④: 全双工<br>⑤: 拥塞控制,流量控制<br>⑥: 检错, 分用复用<br>⑦: 面向字节流: (把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)<br>套接字socket = IP地址  ：端口号</p><h3 id="10-2-使用TCP协议的各种应用层协议："><a href="#10-2-使用TCP协议的各种应用层协议：" class="headerlink" title="10.2 使用TCP协议的各种应用层协议："></a>10.2 使用TCP协议的各种应用层协议：</h3><p>SMTP: 简单邮件传送协议<br>TELNET: 远程终端协议<br>HTTP: 超文本传输协议<br>FTP: 文件传送协议</p><h3 id="10-3-TCP首部格式"><a href="#10-3-TCP首部格式" class="headerlink" title="10.3 TCP首部格式:"></a>10.3 TCP首部格式:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.2.png" alt></p><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="10-4-关于UDP协议"><a href="#10-4-关于UDP协议" class="headerlink" title="10.4 关于UDP协议:"></a>10.4 关于UDP协议:</h3><p><strong>特点:</strong></p><p>①: 无连接: 发数据前不需要建立连接(即不需要使用套接字(即 IP: 端口号)来建立连接)<br>②: 交互通信: 一对多,一对一,多对一,多对多等<br>③: 尽最大努力交付(不可靠)<br>④: 首部开销小,8字节  而TCP是20字节<br>⑤: 无拥塞控制<br>⑥: 检错, 分用复用<br>⑦: 面向报文: UDP一次交付一个完整报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)</p><h3 id="10-5-UDP首部格式"><a href="#10-5-UDP首部格式" class="headerlink" title="10.5 UDP首部格式:"></a>10.5 UDP首部格式:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.1.png" alt></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><p><strong>使用场合: </strong>一般用于传输数据量大,且对可靠性要求不是很高,但要求速度快的场合.</p><h2 id="二、传输层数据单元"><a href="#二、传输层数据单元" class="headerlink" title="二、传输层数据单元:"></a>二、传输层数据单元:</h2><p>数据段</p><h2 id="三、关于端口"><a href="#三、关于端口" class="headerlink" title="三、关于端口:"></a>三、关于端口:</h2><p>运输层用16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口</p><h2 id="四、传输层功能"><a href="#四、传输层功能" class="headerlink" title="四、传输层功能:"></a>四、传输层功能:</h2><p>①: 负责源-目的（端-端）（进程间）完整报文传输<br>②: 分段与重组<br>③: SAP寻址: 确保将完整报文提交给正确进程，如端口号<br>④: 连接控制<br>⑤: 流量控制<br>⑥: 差错控制<br>⑦: 确保数据可靠,顺序,无错地从A点传输到B点</p><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="五、TCP-可靠传输"><a href="#五、TCP-可靠传输" class="headerlink" title="五、TCP 可靠传输:"></a>五、TCP 可靠传输:</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.3.png" alt></p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.4.png" alt></p><p>其中 RTTd 为偏差的加权平均值。</p><h2 id="六、TCP-滑动窗口"><a href="#六、TCP-滑动窗口" class="headerlink" title="六、TCP 滑动窗口:"></a>六、TCP 滑动窗口:</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.5.png" alt></p><h2 id="七、TCP-流量控制"><a href="#七、TCP-流量控制" class="headerlink" title="七、TCP 流量控制:"></a>七、TCP 流量控制:</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="八、TCP-拥塞控制"><a href="#八、TCP-拥塞控制" class="headerlink" title="八、TCP 拥塞控制:"></a>八、TCP 拥塞控制:</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br>拥塞窗口的大小取决于网络的拥塞程度<br>判断网络拥塞的依据是出现了超时.<br>发送方的发送窗口 =  拥塞窗口.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.8.png" alt></p><p><strong>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</strong></p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.6.png" alt></p><h3 id="8-1-慢开始与拥塞避免"><a href="#8-1-慢开始与拥塞避免" class="headerlink" title="8.1 慢开始与拥塞避免"></a>8.1 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="8-2-快重传与快恢复"><a href="#8-2-快重传与快恢复" class="headerlink" title="8.2. 快重传与快恢复"></a>8.2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.7.png" alt></p><p><strong>拥塞控制的具体流程: </strong></p><p>①: 初始拥塞窗口 cwnd  =  1</p><p>②: 发送方每收到一个确认就使cwnd = cwnd + 1;如果按照传输轮次考虑就是指数增长: 第一轮: cwnd =  1, 第二轮: cwnd =  2, 第三轮: cwnd =  4, …….第N轮: cwnd =  2^N</p><p>cwnd &lt; ssthresh 时,使用慢开始</p><p>cwnd = ssthresh 时,既可以使用慢开始,也可以使用拥塞避免算法</p><p>cwnd &gt;= ssthresh 时,使用拥塞避免算法</p><p>③: 网络超时时: 使ssthresh = cwnd / 2<br>然后令 cwnd = 1 </p><p>然后进入慢开始阶段,步骤同上<br>④: 直到连续接收到三个重复确认,启动快重传(立即重传) </p><p>⑤: 启动快恢复算法 ssthresh = cwnd / 2</p><p>和cwnd=ssthresh</p><p>拥塞避免: 拥塞窗口控制为按照线性增长(每个传输轮次结束时,cwnd就增加1)</p><p><strong>快重传优点: </strong></p><p>可以使整个网络的吞吐量提高20%<br>尽早让发送方知道发生了个别报文段的丢失</p><p>规定: 发送方只要一连收到3个重复确认,就知道接收方确实未收到某个报文,应当立即重传(即快重传),这样就不会出现超时,发送方也就不会误认为出现了网络拥塞.</p><p><strong>快恢复: </strong><br>调整ssthresh = cwnd / 2<br>同时设置cwnd = ssthresh;<br>然后执行拥塞避免.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、传输层协议&quot;&gt;&lt;a href=&quot;#一、传输层协议&quot; class=&quot;headerlink&quot; title=&quot;一、传输层协议:&quot;&gt;&lt;/a&gt;一、传输层协议:&lt;/h2&gt;&lt;p&gt;TCP协议,UDP协议,SPX协议&lt;/p&gt;
&lt;h3 id=&quot;10-1-关于TCP协议&quot;&gt;&lt;a href=&quot;#10-1-关于TCP协议&quot; class=&quot;headerlink&quot; title=&quot;10.1 关于TCP协议:&quot;&gt;&lt;/a&gt;10.1 关于TCP协议:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt;&lt;br&gt;①: 面向连接&lt;br&gt;②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场合: &lt;/strong&gt;一般用于传输数据量少,且对可靠性要求高的场合.&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="传输层" scheme="https://zzwwqq.xyz/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>交换机的基本配置</title>
    <link href="https://zzwwqq.xyz/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html"/>
    <id>https://zzwwqq.xyz/交换机的基本配置.html</id>
    <published>2019-04-01T11:05:44.000Z</published>
    <updated>2019-04-01T11:24:00.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、交换机的基本配置与管理："><a href="#一、交换机的基本配置与管理：" class="headerlink" title="一、交换机的基本配置与管理："></a>一、交换机的基本配置与管理：</h2><h3 id="10-1-交换机的管理方式："><a href="#10-1-交换机的管理方式：" class="headerlink" title="10.1 交换机的管理方式："></a>10.1 交换机的管理方式：</h3><p>基本分为两种: 带内管理和带外管理。<br><strong>带外管理: </strong>通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置<br><strong>带内管理: </strong>通过远程Telnet，拨号等方式属于带内管理<br><a id="more"></a></p><h2 id="二、交换机的命令行操作模式分类："><a href="#二、交换机的命令行操作模式分类：" class="headerlink" title="二、交换机的命令行操作模式分类："></a>二、交换机的命令行操作模式分类：</h2><p>①: 用户模式:  <code>Switch&gt;</code><br>②: 特权模式: <code>Switch#</code><br>③: 全局配置模式: <code>Switch(config)#</code><br>④: 端口模式: <code>Switch(config-if)#</code></p><h2 id="三、交换机命令行"><a href="#三、交换机命令行" class="headerlink" title="三、交换机命令行:"></a>三、交换机命令行:</h2><p>进入特权模式: <code>en</code><br>命令自动补齐: <code>Tab</code><br>进入全局配置模式: <code>configure terminal</code><br>命令简写：<code>conf  t</code><br>进入交换机端口视图模式: <code>int f 0/1</code><br>返回上一级操作模式: <code>exit</code><br>从全局以下级别直接返回到特权模式: <code>end</code><br>帮助信息: <code>？，co?  ,copy ?</code><br>修改交换机名称: <code>hostname  X</code><br>配置交换机端口参数: <code>speed，duplex</code><br>查看交换机版本信息: <code>show  version</code><br>查看当前生效的配置信息: <code>show run</code></p><h2 id="四、换机的Telnet远程登录配置"><a href="#四、换机的Telnet远程登录配置" class="headerlink" title="四、换机的Telnet远程登录配置:"></a>四、换机的Telnet远程登录配置:</h2><ol><li>新建packet tracer 拓扑图</li><li>配置交换机管理IP地址</li></ol><p>　　　　switch&gt; <code>enable 回车</code></p><p>　　　　switch#<code>configuration terminal 回车</code></p><p>　　　　switch（config）#<code>interface vlan 1 回车</code></p><p>　　　　默认情况下交换机所有端口都处于VLAN1中</p><p>　　　　switch(config-if) <code>ip address xxxx.xxxx.xxxx.xxxx  回车</code></p><p>　　　　switch(config-if) <code>no shutdown  回车</code></p><p>　　　　开启interface vlan 1的工作状态</p><p>　　　　switch(config-if)# <code>exit</code></p><p>　　　　返回上一级</p><ol start="3"><li>配置用户登录密码</li></ol><p>　　　　Switch(config)# <code>enable password xxxx</code></p><p>　　　　设置进入特权模式的密码</p><p>　　　　Switch(config)# <code>line vty 0 4</code></p><p>　　　　Switch(config-line)# <code>password xxxxxxx</code></p><p>　　　　设置远程登录密码</p><p>　　　　Switch(config-line)# <code>end</code></p><p>　　　　Switch# <code>show run</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、交换机的基本配置与管理：&quot;&gt;&lt;a href=&quot;#一、交换机的基本配置与管理：&quot; class=&quot;headerlink&quot; title=&quot;一、交换机的基本配置与管理：&quot;&gt;&lt;/a&gt;一、交换机的基本配置与管理：&lt;/h2&gt;&lt;h3 id=&quot;10-1-交换机的管理方式：&quot;&gt;&lt;a href=&quot;#10-1-交换机的管理方式：&quot; class=&quot;headerlink&quot; title=&quot;10.1 交换机的管理方式：&quot;&gt;&lt;/a&gt;10.1 交换机的管理方式：&lt;/h3&gt;&lt;p&gt;基本分为两种: 带内管理和带外管理。&lt;br&gt;&lt;strong&gt;带外管理: &lt;/strong&gt;通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置&lt;br&gt;&lt;strong&gt;带内管理: &lt;/strong&gt;通过远程Telnet，拨号等方式属于带内管理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="交换机的配置" scheme="https://zzwwqq.xyz/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://zzwwqq.xyz/%E7%BD%91%E7%BB%9C%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/网络层.html</id>
    <published>2019-04-01T05:36:50.000Z</published>
    <updated>2019-04-08T07:56:38.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网络层协议"><a href="#一、网络层协议" class="headerlink" title="一、网络层协议:"></a>一、网络层协议:</h2><h3 id="1-1-什么是协议（protocol）"><a href="#1-1-什么是协议（protocol）" class="headerlink" title="1.1 什么是协议（protocol）?"></a>1.1 什么是协议（protocol）?</h3><p>通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”.</p><h3 id="1-2-什么是实体（entity）"><a href="#1-2-什么是实体（entity）" class="headerlink" title="1.2 什么是实体（entity）?"></a>1.2 什么是实体（entity）?</h3><p>表示任何可发送或接收消息的硬件或软件进程<br><a id="more"></a></p><h3 id="1-3-通信协议的三要素："><a href="#1-3-通信协议的三要素：" class="headerlink" title="1.3 通信协议的三要素："></a>1.3 通信协议的三要素：</h3><p>语法,语义,时序<br><strong>语义 :</strong><br>语义是指对协议中各协议元素的含义的解释，例如：在HDLC协议中，标志Flag(7EH)表示报文的开始和结束；在BSC协议中，SOH(01H)表示报文的开始，STX(02H)表示报文正文的开始，ETX(03H)表示报文正文的结束。<br><strong>语法 :</strong><br>语法是指协议元素与数据的组合格式，也就是 报文格式，如下图所示：<br><strong>时序 :</strong><br>时序是指在通信过程中，通信双方操作的执行顺序与规则，如本节开头的图示。<br><strong>总的来说，语法是语义的载体，而时序又是对语义的有序组织。正是基于这种关系，计算机在通信时才得以保持高度默契。</strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.1.png" alt></p><h3 id="1-4-通信模型"><a href="#1-4-通信模型" class="headerlink" title="1.4 通信模型:"></a>1.4 通信模型:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.2.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.3.png" alt></p><p>我们在网络中的任何一个系统都是按照上图中的层次结构模型来组织的，该模型具有以下特点：<br>①: 同一网络中，任意两个端系统必须具有相同的层次；<br>②: 每层使用其下层提供的服务，并向其上层提供服务；<br>③: 通信只在对等层间进行，当然这里所指的通信是间接的、逻辑的、虚拟的，非对等层之间不能互相“通信”；<br>④: 实际的物理通信只在最底层完成；<br>⑤: Pn代表第n层的协议，即第n层对等实体间通信时必须遵循的规则或约定。</p><h3 id="1-5-网络层有哪些协议"><a href="#1-5-网络层有哪些协议" class="headerlink" title="1.5 网络层有哪些协议?"></a>1.5 网络层有哪些协议?</h3><p><strong>①: IP协议: </strong>这种<strong>不可靠的、无连接的</strong>传送机制称为Internet协议(网际协议)<br>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protcol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><p><strong>IP协议三个定义：</strong></p><p>IP定义了在TCP/IP互联网上数据传送的基本单元和数据格式。<br>IP软件完成路由选择功能，选择数据传送的路径。<br>IP包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</p><p><strong>②: ICMP协议: </strong><br>网际控制报文协议<br>作用：用于在IP主机、路由器之间传递控制消息,更有效的转发IP数据报和提高交付成功的机会,<br>应用: ICMP的一个重要应用就是分组网间探测PING（Package Internet Grouper）用来测试两台主机的连通性,,Ping是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP<br>详解见下文</p><p><strong>③: IGMP:</strong><br>网际组管理协议</p><p><strong>④: ARP协议:</strong><br>地址解析协议<br>自动把IP地址解析为数据链路层所需要的硬件地址(MAC地址)<br><strong>IP —–&gt;MAC 地址</strong><br><strong>工作原理:</strong></p><ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li><li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据,如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></li></ol><p><strong>广播发送ARP请求，单播发送ARP响应。</strong></p><p><strong>⑤: RARP协议:</strong><br>逆地址解析协议, 与ARP相反:<br><strong>MAC地址——&gt;IP地址</strong><br><strong>作用: </strong> 是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。<br><strong>工作流程：</strong>在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP 地址装入响应报文中发回给请求者。<br>因为需要广播请求报文，因此<strong>RARP只能用于具有广播能力的网络。</strong></p><p><strong>⑥: RIP协议:</strong><br>内部网关协议<br>基于距离向量的路由选择协议, 距离是指跳数，直接相连的路由器跳数为 1,跳数最多为 15(即允许一条路径最多包含15个路由器)，超过 15 表示不可达。<br>可见<strong>RIP只适用于小型互联网</strong></p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p><strong>距离向量算法：</strong></p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p><strong>优点:</strong><br>实现简单，开销小。<br><strong>缺点:</strong><br>①: RIP 能使用的最大距离为 15，限制了网络的规模。<br>②: 并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。<br>③: 路由器间交换的信息是完整的路由表,随着网络规模的增大,开销也增大.</p><p><strong>⑦: OSPF协议: </strong></p><p>开放最短路径优先 OSPF，是为了<strong>克服 RIP 的缺点</strong>而开发出来的。<br>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。<br>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示,  而RIP只包含距离,和下一跳路由器地址.</li><li>只有当链路状态发生变化时，路由器才会发送信息, 而 RIP不管有无变化,总是定期更新.</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，<strong>OSPF 的更新过程收敛的很快</strong>。</p><p><strong>⑧: BGP：外部网关协议</strong>:</p><p>BGP（Border Gateway Protocol，边界网关协议）</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.23.png" alt></p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。<br>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</p><h3 id="1-6-网络层特点"><a href="#1-6-网络层特点" class="headerlink" title="1.6 网络层特点:"></a>1.6 网络层特点:</h3><p>向上只提供 :<br>①:  无连接的<br>②: 尽最大努力交付<br>③: 不提供服务质量的保证(不保证分组交付的时限,所传送的分组有可能出错丢失,重复失序)<br>⑤: 进程间通信可靠性由传输层负责</p><h2 id="二、网络层设备"><a href="#二、网络层设备" class="headerlink" title="二、网络层设备:"></a>二、网络层设备:</h2><p>①: 路由器</p><h2 id="三、网络层基本单元"><a href="#三、网络层基本单元" class="headerlink" title="三、网络层基本单元:"></a>三、网络层基本单元:</h2><h3 id="3-1-什么是协议数据单元"><a href="#3-1-什么是协议数据单元" class="headerlink" title="3.1 什么是协议数据单元?"></a>3.1 什么是协议数据单元?</h3><p>协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。 </p><h3 id="3-2-每一层协议数据单元分别是什么"><a href="#3-2-每一层协议数据单元分别是什么" class="headerlink" title="3.2 每一层协议数据单元分别是什么?"></a>3.2 每一层协议数据单元分别是什么?</h3><p>从下层到上层:<br>物理层的 PDU是数据位,又称<strong>比特</strong>（bit），<br>数据链路层的 PDU是数据帧,又称<strong>帧</strong>（frame），<br>网络层的PDU是数据包又称<strong>IP数据报</strong>（packet/datagram），<br>传输层的 PDU是<strong>数据段</strong>（segment），在报文中加一个运输层的头<br>其他更高层次(即会话层,表现层,应用层)的PDU是<strong>报文</strong>（message）。</p><p>从下层往上层是拆封.<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.4.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.5.1.png" alt></p><h2 id="四、网络层功能"><a href="#四、网络层功能" class="headerlink" title="四、网络层功能:"></a>四、网络层功能:</h2><p>①: 负责源主机到目的主机数据分组（Packet）交付(可能穿越多个网络)逻辑寻址（Logical  addressing ）<br>②: 全局唯一的逻辑地址，确保数据分组被送到目的主机，如IP地址<br>③: 路由（Routing）:<br>路由器（或网关）互连网络，并路由分组至最终目的主机<br>路径选择<br>④: 分组转发<br>⑤: 网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>⑥: 将网络地址(例如IP地址)翻译为对应的物理地址(例如,网卡地址),并决定如何将数据从发送方路由到接收方</p><h3 id="4-1-核心功能"><a href="#4-1-核心功能" class="headerlink" title="4.1 核心功能:"></a>4.1 核心功能:</h3><p>分组转发 与 路由选择（forwarding)</p><h3 id="4-1-什么是转发"><a href="#4-1-什么是转发" class="headerlink" title="4.1 什么是转发?"></a>4.1 什么是转发?</h3><p>将分组从路由器的输入端口转移到合适的输出端口<br>转发表确定在本路由器如何转发分组</p><h3 id="4-2-转发表是怎么得到的呢？"><a href="#4-2-转发表是怎么得到的呢？" class="headerlink" title="4.2 转发表是怎么得到的呢？"></a>4.2 转发表是怎么得到的呢？</h3><p>路由算法（协议）确定通过网络的端到端路径</p><h3 id="4-3-什么叫路由呢？"><a href="#4-3-什么叫路由呢？" class="headerlink" title="4.3 什么叫路由呢？"></a>4.3 什么叫路由呢？</h3><p>路由（routing）：确定分组从源到目的经过的路径</p><h2 id="五、网络层任务"><a href="#五、网络层任务" class="headerlink" title="五、网络层任务:"></a>五、网络层任务:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.6.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.8.png" alt></p><h2 id="六、为什么需要数据封装"><a href="#六、为什么需要数据封装" class="headerlink" title="六、为什么需要数据封装?"></a>六、为什么需要数据封装?</h2><p>增加控制信息—构造协议数据单元（PDU—protocol  Data  Unit）<br>控制信息主要包括：<br>地址：标志发送端/接收端<br>差错检测编码（error-detecting code）：用于差错检测或纠正<br>协议控制（Protocol  control）：实现协议功能的附加信息，如优先级（priority），服务质量（QoS）和安全控制等<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.7.png" alt></p><h2 id="七、IP-数据报格式"><a href="#七、IP-数据报格式" class="headerlink" title="七、IP 数据报格式:"></a>七、IP 数据报格式:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.9.png" alt></p><p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p><p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p><p><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</p><p><strong>总长度</strong> : 包括首部长度和数据部分长度</p><p><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p><p><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p><p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.10.png" alt></p><h2 id="八、地址解析协议-ARP"><a href="#八、地址解析协议-ARP" class="headerlink" title="八、地址解析协议 ARP:"></a>八、地址解析协议 ARP:</h2><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.11.png" alt></p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.12.png" alt></p><h2 id="九、网际控制报文协议-ICMP"><a href="#九、网际控制报文协议-ICMP" class="headerlink" title="九、网际控制报文协议 ICMP:"></a>九、网际控制报文协议 ICMP:</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.13.png" alt></p><p>ICMP 报文分为差错报告报文和询问报文。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.14.png" alt></p><h3 id="9-1-ICMP协议的应用"><a href="#9-1-ICMP协议的应用" class="headerlink" title="9.1 ICMP协议的应用:"></a>9.1 ICMP协议的应用:</h3><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>Ping 是 ICMP 的一个重要应用，主要用来<strong>测试两台主机之间的连通性</strong>。<br><strong>Ping 的原理: </strong></p><p>是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute:"></a>Traceroute:</h4><p>用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。<br><strong>Traceroute的工作原理: </strong></p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="十、IP-地址编址方式"><a href="#十、IP-地址编址方式" class="headerlink" title="十、IP 地址编址方式:"></a>十、IP 地址编址方式:</h2><h3 id="10-1-IP-地址的编址方式经历了三个历史阶段："><a href="#10-1-IP-地址的编址方式经历了三个历史阶段：" class="headerlink" title="10.1 IP 地址的编址方式经历了三个历史阶段："></a>10.1 IP 地址的编址方式经历了三个历史阶段：</h3><p>①: 分类<br>②: 子网划分<br>③: 无分类</p><p><strong>分类: </strong><br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>网络号:用于识别主机所在的网络；<br>主机号: 用于识别该网络中的主机<br>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.15.png" alt></p><p><strong>IP地址分为五类，</strong>A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。</p><table><thead><tr><th>IP地址类别:</th><th>高八位</th><th>占总IP地址数的比例:</th></tr></thead><tbody><tr><td>A类：前一位固定为0</td><td>第一个八位的范围是0-127<br>目的: 保证了最小为0,最大为127  即255(全一)-128(最高位为1,其他为0)=127</td><td>(127-0+1）/ 256=50%</td></tr><tr><td>B类：前两位固定为10</td><td>第一个八位的范围是：128-191<br>前两位固定为10的目的是：为了让前八位表示的数最小为128</td><td>(191-128+1) / 256=25%</td></tr><tr><td>C类：前三位固定为110</td><td>第一个八位的范围是：192-223<br>前两位固定为110的目的是：保证最小192</td><td>(223-192+1) / 256=12.5%</td></tr><tr><td>D类：前四位固定为1110     不分网络地址和主机地址</td><td>第一个八位的范围是：224-239</td><td>(239-224+1) / 256=6.25%</td></tr><tr><td>E类：前四位固定为1111   不区分网络地址和主机地址</td><td>第一个八位的范围是：240-255</td><td>(255-240+1) / 256=6.25%</td></tr></tbody></table><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.19.png" alt>　</p><p><strong>A类地址:</strong><br>1）A类地址第1字节为网络地址，其它3个字节为主机地址。它的第1个字节的第一位固定为0，因此只有7位可供使用.<br>可指派的网络号为126个（即2^7-2=126），<br><strong>减2 的原因：</strong><br>第一：   IP地址中的<strong>全0表示“这个（或者本）</strong>”，<strong>全1表示所有的</strong>。      网络号字段全0   的IP地址是个保留地址， 意思是本网络<br>第二：   网络号为127（即01111111）保留作为本地软件环回测试（loop back test）本主机的进程之间的通信之用。<br>2）A类地址可指派网络号范围：1—126<br>3）<strong>A类地址中的私有地址和保留地址：</strong><br>① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址),且<br>范围是（10.0.0.0—10.255.255.255）<br>② 127.X.X.X是保留地址，用做循环测试用的。<br>A类地址主机号占三个字节，因此每个A类网络中最大主机数： 2^24-2=16777214<br><strong>这里减2 的原因：</strong>   全0的主机号字段，  表示该IP地址 是”本主机“所连结到的单个网络地址，（例如： 一主机的IP地址为5.6.7.8 ，则该主机所在的网络地址就是5.0.0.0）， 而全1表示”所有的“  ，因此主机号全1表示该网络上的所有主机，<br>4）IP地址空间共2^32 个地址，整个A类地址2^31,占整个IP地址空间的50%. </p><p>关于全0全1 还可以再举两个例子：<br>例如：  B类地址： 128.7.255.255 表示在网络128.7.0.0 上的所有主机，  而A类地址0.0.0.35 则表示  在这个网络上主机号为35 的主机；</p><p><strong>B类地址:</strong></p><p>B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。它的第1个字节的前两位固定为10，只剩下16-2=14位可以分配， </p><p>因为网络号字段后面的14位无论取什么值， 也不可能出现使整个2字节的网络号字段成为全0或全1， 所以这里就不存在网络总数减2的问题。</p><p>但是实际上B类网络地址的128.0.0.0 是不指派的，而可以指派的B类最小网络地址是128.1.0.0   ，   因此B类地址可指派的网络数为  2^14-1=16383.</p><p>B 类地址的每个网络上的最大主机数2^16-2=65534<br>这里减2 的原因：   要扣除主机号全0全1的。  （全0表示该IP地址 是”本主机“所连结到的单个网络地址，全1 作为广播地址）<br>整个B类地址空间2^30, 占整个IP地址空间的25%.</p><p>2） B类地址可指派网络号范围：128.1—191.255。  </p><p>3） B类地址的私有地址和保留地址</p><p>① 172.16.0.0—172.31.255.255是私有地址</p><p>② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</p><p>191.255.255.255是广播地址，不能分配。</p><p><strong>C类地址</strong></p><p>1）C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110,   还有21位可以分配，C类网络地址192.0.0.0也是不分配的， 可以指派的C类最小网络地址192.0.1.0，因此C类  地址可指派的网络总数 ， 2^21-1=2097151 ,   每一个C类网络地址的最大主机数2^8-2=254, 整个C类地址空间2^29 个地址，占整个IP地址空间的12.5%。</p><p>2）C类地址网络号范围：192.0.1—223.255.255。</p><p>3） C类地址中的私有地址：</p><p>192.168.X.X是私有地址。（192.168.0.0—192.168.255.255)</p><h3 id="10-2-特殊IP地址："><a href="#10-2-特殊IP地址：" class="headerlink" title="10.2 特殊IP地址："></a>10.2 特殊IP地址：</h3><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.16.png" alt>　</p><h3 id="10-3-私有（Private）IP地址"><a href="#10-3-私有（Private）IP地址" class="headerlink" title="10.3 私有（Private）IP地址:"></a>10.3 私有（Private）IP地址:</h3><p><strong>实体IP:</strong><br>在网络的世界里，为了要辨识每一部计算机的位置，因此有了计算机 IP 位址的定义。一个 IP 就好似一个门牌！例如，你要去微软的网站的话，就要去『 64.4.11.42 』这个 IP 位置！这些可以直接在网际网络上沟通的 IP 就被称为『实体 IP 』了。</p><p><strong>虚拟IP:</strong><br>不过，众所皆知的，IP 位址仅为 xxx.xxx.xxx.xxx 的资料型态，其中， xxx 为 1-255 间的整数，由于计算机的成长速度太快，实体的 IP 已经有点不足了，好在早在规划 IP 时就已经预留了三个网段的 IP 做为内部网域的虚拟 IP 之用。这三个预留的 IP 分别为：<br>除去主机段全零/全一:</p><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.17.png" alt></p><p>由于是虚拟 IP ，所以当您使用这些地址的时候﹐当然是有所限制的，限制如下：<br>私有位址的路由信息不能对外散播<br>使用私有位址作为来源或目的地址的封包﹐不能透过Internet来转送<br>关于私有位址的参考纪录（如DNS）﹐只能限于内部网络使用</p><p>由于虚拟 IP 的计算机并不能直接连上 Internet ，因此需要特别的功能才能上网。不过，这给我们架设IP网络提供了很大的方便﹐比如﹕您的公司还没有连上Internet﹐但这不保证将来不会。使用公共IP的话﹐如果没经过注册﹐在以后真正连上网络的时候﹐就很可能和别人冲突了。也正如前面所分析的﹐到时候再重新规划IP的话﹐将是件非常头痛的问题。这时候﹐我们可以先利用私有位址来架设网络﹐等到真要连上internet的时候﹐我们可以使用IP转换协定﹐如 NAT (Network Addresss Translation)等技术﹐配合新注册的IP就可以了。</p><h3 id="10-4-组播地址"><a href="#10-4-组播地址" class="headerlink" title="10.4 组播地址"></a>10.4 组播地址</h3><p>注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机， 224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP（Internet路由发现协议，使用组播功能）功能，那么你的主机路由表中应该有这样一条路由: 169.254.x.x</p><p>如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Windows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</p><h3 id="10-5-受限广播地址"><a href="#10-5-受限广播地址" class="headerlink" title="10.5 受限广播地址"></a>10.5 受限广播地址</h3><p>广播通信是<strong>一个主机对所有主机</strong>的通信方式。若一个IP地址的2进制数全为1，也就是255.255.255.255，则这个地址用于定义整个互联网。如果设备想使IP数据报被整个Internet所接收，就发送这个目的地址全为1的广播包，但这样会给整个互联网带来灾难性的负担。因此网络上的所有路由器都阻止具有这种类型的分组被转发出去，使这样的广播仅限于本地网段。</p><h3 id="10-6-直接广播地址"><a href="#10-6-直接广播地址" class="headerlink" title="10.6 直接广播地址"></a>10.6 直接广播地址</h3><p>一个网络中的最后一个地址为直接广播地址，也就是HostID全为1的地址。主机使用这种地址把一个IP数据报发送到本地网段的所有设备上，路由器会转发这种数据报到特定网络上的所有主机。<br><strong>注意：这个地址在IP数据报中只能作为目的地址。另外，直接广播地址使一个网段中可分配给设备的地址数减少了1个。</strong></p><h3 id="10-7-源IP地址"><a href="#10-7-源IP地址" class="headerlink" title="10.7 源IP地址:"></a>10.7 源IP地址:</h3><p>若IP地址全为0，也就是0.0.0.0，则这个IP地址在IP数据报中只能用作源IP地址，这发生在当设备启动时但又不知道自己的IP地址情况下。在使用DHCP分配IP地址的网络环境中，这样的地址是很常见的。用户主机为了获得一个可用的IP地址，就给DHCP服务器发送IP分组，并用这样的地址作为源地址，目的地址为255.255.255.255（因为主机这时还不知道DHCP服务器的IP地址）。</p><h3 id="10-8-环回地址"><a href="#10-8-环回地址" class="headerlink" title="10.8 环回地址:"></a>10.8 环回地址:</h3><p>127网段的所有地址都称为环回地址，主要用来测试网络协议是否工作正常的作用。比如使用ping.<br>127.0.0.1就可以测试本地TCP/IP协议是否已正确安装。另外一个用途是当客户进程用环回地址发送报文给位于同一台机器上的服务器进程，比如在浏览器里输入127.1.2.3，这样可以在排除网络路由的情况下用来测试IIS是否正常启动。</p><h3 id="10-9-NetID为0的地址"><a href="#10-9-NetID为0的地址" class="headerlink" title="10.9 NetID为0的地址:"></a>10.9 NetID为0的地址:</h3><p>当某个主机向同一网段上的其他主机发送报文时就可以使用这样的地址，分组也不会被路由器转发。比如12.12.12.0/24这个网络中的一台主机12.12.12.2/24在与同一网络中的另一台主机12.12.12.8/24通信时，目的地址可以是0.0.0.8。</p><h3 id="10-10-关于子网掩码"><a href="#10-10-关于子网掩码" class="headerlink" title="10.10: 关于子网掩码:"></a>10.10: 关于子网掩码:</h3><p>为了标识IP地址的网络部分和主机部分，要和地址掩码（Address Mask）结合，掩码跟IP地址一样也是32 bits，用点分十进制表示。IP地址网络部分对应的掩码部分全为“1”，主机部分对应的掩码全为“0”。</p><p>缺省状态下，如果没有进行子网划分，A类网络的子网掩码为255.0.0.0，B类网络的子网掩码为255.255.0.0，C类网络的子网掩码为255.255.255.0。利用子网，网络地址的使用会更加有效。</p><p>有了子网掩码后，IP地址的标识方法如下：<br>例：192.168.1.1 255.255.255.0或者标识成192.168.1.1/24（掩码中“1”的个数）</p><p><strong>子网划分</strong></p><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><p><strong>无分类</strong></p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="十一、虚拟专用网-VPN"><a href="#十一、虚拟专用网-VPN" class="headerlink" title="十一、虚拟专用网 VPN"></a>十一、虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255  共有2的24次方个地址</li><li>172.16.0.0 ~ 172.31.255.255  共有2的20次方个地址</li><li>192.168.0.0 ~ 192.168.255.255  共有2的16次方个地址</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.18.png" alt></p><h2 id="十二、网络地址转换-NAT"><a href="#十二、网络地址转换-NAT" class="headerlink" title="十二、网络地址转换 NAT:"></a>十二、网络地址转换 NAT:</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p>　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.20.png" alt></p><h2 id="十三、路由器的结构"><a href="#十三、路由器的结构" class="headerlink" title="十三、路由器的结构:"></a>十三、路由器的结构:</h2><h3 id="13-1-路由器的功能："><a href="#13-1-路由器的功能：" class="headerlink" title="13.1 路由器的功能："></a>13.1 路由器的功能：</h3><p>路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p>　　　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.21.png" alt></p><h3 id="13-2-路由器分组转发流程"><a href="#13-2-路由器分组转发流程" class="headerlink" title="13.2 路由器分组转发流程:"></a>13.2 路由器分组转发流程:</h3><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p>　　<img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-5.22.png" alt></p><h3 id="13-3-路由选择协议"><a href="#13-3-路由选择协议" class="headerlink" title="13.3 路由选择协议:"></a>13.3 路由选择协议:</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。<br>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。<br>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><p>参考链接:<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、网络层协议&quot;&gt;&lt;a href=&quot;#一、网络层协议&quot; class=&quot;headerlink&quot; title=&quot;一、网络层协议:&quot;&gt;&lt;/a&gt;一、网络层协议:&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是协议（protocol）&quot;&gt;&lt;a href=&quot;#1-1-什么是协议（protocol）&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是协议（protocol）?&quot;&gt;&lt;/a&gt;1.1 什么是协议（protocol）?&lt;/h3&gt;&lt;p&gt;通信协议定义了 网络实体间发送报文和接收报文的格式、顺序以及当传送和接收消息时应采取的行动(规则), 是控制两个对等实体进行通信的规则的集合，协议是“水平的”.&lt;/p&gt;
&lt;h3 id=&quot;1-2-什么是实体（entity）&quot;&gt;&lt;a href=&quot;#1-2-什么是实体（entity）&quot; class=&quot;headerlink&quot; title=&quot;1.2 什么是实体（entity）?&quot;&gt;&lt;/a&gt;1.2 什么是实体（entity）?&lt;/h3&gt;&lt;p&gt;表示任何可发送或接收消息的硬件或软件进程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络层" scheme="https://zzwwqq.xyz/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="https://zzwwqq.xyz/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://zzwwqq.xyz/进程与线程.html</id>
    <published>2019-03-31T12:38:19.000Z</published>
    <updated>2019-04-03T07:46:54.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关于进程"><a href="#一、关于进程" class="headerlink" title="一、关于进程:"></a>一、关于进程:</h2><h3 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1 什么是进程?"></a>1.1 什么是进程?</h3><p>进程是具有独立功能的<strong>程序在某个数据集合上的一次运行活动</strong>，也是操作系统进行<strong>资源分配和保护的基本单位。</strong>有挂起状态</p><h3 id="1-2-进程的组成部分"><a href="#1-2-进程的组成部分" class="headerlink" title="1.2 进程的组成部分:"></a>1.2 进程的组成部分:</h3><a id="more"></a><p><strong>进程由四个部分组成:</strong></p><p>①: 程序块<br>②: 数据块: 程序和数据刻画的是静态特征<br>③: 进程控制块 (Process Control Block, PCB) :  每个进程只有一个进程控制块Process  Control  Block (进程描述符),  包含管理进程所需的全部信息.<br>④: 核心栈:  进程运行过程中产生中断或者执行系统调用时又要运行操作系统内核函数  , 核心栈就是存放内核函数在工作时产生的信息</p><p><strong>PCB包含三类信息: </strong><br>①: 标识信息:   数值型进程号0~32767  是进程存在的唯一标识<br>②: 现场信息:   包括通用寄存器,  控制寄存器, 栈指针,  程序状态字   进程让出处理器时,必须将此时的现场信息保存到PCB<br>③: 控制信息:   用于管理和调度进程</p><h3 id="1-3-进程状态的切换"><a href="#1-3-进程状态的切换" class="headerlink" title="1.3 进程状态的切换:"></a>1.3 进程状态的切换:</h3><p><strong>进程的三种基本状态:</strong></p><ul><li><p>运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着</p></li><li><p>阻塞状态：等待资源;   由于进程等待某种条件（如等待I/O操作的完成，或等待另一个进程发来消息(即进程同步)），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行</p></li><li><p>就绪状态：等待被调度 ; 进程已获得除CPU外的所需资源，由于其他进程占用CPU而暂时无法运行的一种状态</p></li></ul><p><strong>注意: </strong><br>①: <strong>只有就绪态和运行态可以相互转换，其它的都是单向转换。</strong><br>就绪状态的进程通过<strong>调度算法</strong>从而获得 CPU 时间，转为运行状态；<br>而运行状态的进程，在分配给它的<strong>CPU 时间片用完</strong>之后就会转为就绪状态，等待下一次调度。<br>②: <strong>阻塞状态是缺少需要的资源</strong>从而由运行状态转换而来，但是<strong>该资源不包括 CPU 时间，</strong>缺少 CPU 时间会从运行态转换为就绪态。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-1.1.1.png" alt></p><h3 id="1-4-进程的特点"><a href="#1-4-进程的特点" class="headerlink" title="1.4 进程的特点:"></a>1.4 进程的特点:</h3><p>动态性:  程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。<br>共享性: 多个不同的进程,可以执行相同的程序, 进程和程序不是一 一对应的<br>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进<br>独立性: 每个进程是操作系统中的一个独立的实体,  有独立的虚存空间,程序计数器,内部状态<br>并发性:  在单处理器系统中可并发执行,  多处理器环境中并行执行.</p><h3 id="1-5-进程的挂起"><a href="#1-5-进程的挂起" class="headerlink" title="1.5 进程的挂起:"></a>1.5 进程的挂起:</h3><p><strong>目的:</strong> 平滑系统负荷<br><strong>什么时候挂起?</strong>  当系统资源尤其是内存资源已经不能满足进程运行的要求时,必须把某些进程挂起.<br><strong>特点:</strong>  将不参与低级调度, 直到它们被对换到内存,  该进程不能立即执行<br><strong>如何结束挂起状态? </strong>  只能由操作系统或者父进程发出</p><h3 id="1-6-进程挂起和激活"><a href="#1-6-进程挂起和激活" class="headerlink" title="1.6 进程挂起和激活:"></a>1.6 进程挂起和激活:</h3><p>挂 起 原 语 既 可 以 由 进 程 自 己 也 可 以 由 其 他 进 程 调 用,      激 活 原 语 只 能 由 其 他 进 程 调 用 </p><h3 id="1-7-进程阻塞和唤醒"><a href="#1-7-进程阻塞和唤醒" class="headerlink" title="1.7 进程阻塞和唤醒:"></a>1.7 进程阻塞和唤醒:</h3><p>阻塞: 进程让出处理器,转而等待一个事件,如等待资源,等待IO操作完成, 等待事件发生.<br>进程通常调用阻塞原语来阻塞自己,    因此阻塞是自主行为<br>唤醒: 等待事件完成时会产生中断,激活操作系统,在操作系统控制下,与其相关的另一个进程调用唤醒原语将阻塞进程唤醒.</p><h2 id="二、关于线程"><a href="#二、关于线程" class="headerlink" title="二、关于线程:"></a>二、关于线程:</h2><h3 id="1-1-什么是线程"><a href="#1-1-什么是线程" class="headerlink" title="1.1 什么是线程?"></a>1.1 什么是线程?</h3><p>是进程中能并发执行的实体,   是进程的组成部分,有时被称为轻量级进程(Lightweight Process，LWP）, 是处理器调度和分派的基本单位, 是一条执行路径,有独立的程序计数器   无挂起状态 </p><h3 id="1-2-线程的重要特征"><a href="#1-2-线程的重要特征" class="headerlink" title="1.2 线程的重要特征:"></a>1.2 线程的重要特征:</h3><p>①: 一个进程中可以有多个线程，它们共享进程资源。<br>②: 线程是轻量级的进程<br>③: 线程是由进程创建的(寄生在进程)<br>④: 线程没有独立的地址空间(内存空间)<br>⑤: 线程是系统独立调度和分配的基本单位<br>⑥: 可并发执行<br>⑦: 线程是一种轻型实体<br>线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。<strong>TCB包括以下信息：</strong></p><ul><li>线程状态</li><li>存放每个线程的局部变量主存区</li><li>访问同一个进程中的主存和其它资源</li><li>当线程不运行时，被保存的现场资源</li></ul><h3 id="1-3-创建线程的不同方式"><a href="#1-3-创建线程的不同方式" class="headerlink" title="1.3 创建线程的不同方式:"></a>1.3 创建线程的不同方式:</h3><p><strong>有4种方式可以用来创建线程：</strong><br>①继承Thread类<br>②实现Runnable接口<br>③应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。<br>④还有一种方式是实现Callable接口</p><h3 id="1-4-进程状态的切换"><a href="#1-4-进程状态的切换" class="headerlink" title="1.4 进程状态的切换:"></a>1.4 进程状态的切换:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-1.2.png" alt></p><p>新建( new )：新创建了一个线程对象。</p><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。</p><p><strong>阻塞的情况分三种：</strong></p><p>(一). 等待阻塞：</p><p>运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p><p>(二). 同步阻塞：</p><p>运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p><p>(三). 其他阻塞: </p><p>运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            </p><p>当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><h3 id="1-4-优点"><a href="#1-4-优点" class="headerlink" title="1.4 优点:"></a>1.4 优点:</h3><p>快速切换 : 同一个进程中的多线程只需要改变堆栈和寄存器, 地址空间不变<br>通信容易: 不必经过内核, 可自由访问全局数据,自动共享进程的内存和文件<br>减少管理开销: 线程的创建和撤销工作比进程少很多,并且无需再分配存储空间,和各种资源<br>并发程度提高:</p><h2 id="三、进程与线程的区别"><a href="#三、进程与线程的区别" class="headerlink" title="三、进程与线程的区别:"></a>三、进程与线程的区别:</h2><h3 id="3-1-就资源而言"><a href="#3-1-就资源而言" class="headerlink" title="3.1 就资源而言:"></a>3.1 就资源而言:</h3><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><h3 id="3-2-就调度而言"><a href="#3-2-就调度而言" class="headerlink" title="3.2 就调度而言:"></a>3.2 就调度而言:</h3><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><h3 id="3-3-就系统开销而言"><a href="#3-3-就系统开销而言" class="headerlink" title="3.3 就系统开销而言:"></a>3.3 就系统开销而言:</h3><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h3 id="3-4-就通信而言"><a href="#3-4-就通信而言" class="headerlink" title="3.4 就通信而言:"></a>3.4 就通信而言:</h3><p>线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。但是进程通信需要借助 IPC。</p><h3 id="3-5-就组成而言"><a href="#3-5-就组成而言" class="headerlink" title="3.5 就组成而言:"></a>3.5 就组成而言:</h3><p>进程可分为两部分:  资源集合  和  线程集合<br>进程封装管理信息,线程封装执行信息</p><h2 id="四、进程的调度算法"><a href="#四、进程的调度算法" class="headerlink" title="四、进程的调度算法:"></a>四、进程的调度算法:</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="4-1-批处理系统"><a href="#4-1-批处理系统" class="headerlink" title="4.1 批处理系统"></a>4.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证<strong>吞吐量和周转时间</strong>（从提交到终止的时间）。</p><p><strong>①: 先来先服务 first-come first-serverd（FCFS）</strong><br>按照请求的顺序进行调度。<br>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>②: 短作业优先 shortest job first（SJF）</strong><br>按估计运行时间最短的顺序进行调度。<br>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>③: 最短剩余时间优先 shortest remaining time next（SRTN）</strong><br>按估计剩余时间最短的顺序进行调度。</p><h3 id="4-2-交互式系统"><a href="#4-2-交互式系统" class="headerlink" title="4.2 交互式系统:"></a>4.2 交互式系统:</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。<br><strong>④: 时间片轮转</strong><br>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p><strong>时间片轮转算法的效率和时间片的大小有很大关系：</strong></p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><strong>⑤: 优先级调度</strong></p><p>为每个进程分配一个优先级，按优先级进行调度。<br>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p>⑥: <strong>多级反馈队列</strong></p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此<strong>只有上一个队列没有进程在排队，才能调度当前队列上的进程。</strong></p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><h3 id="4-3-实时系统"><a href="#4-3-实时系统" class="headerlink" title="4.3 实时系统"></a>4.3 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="五、进程同步"><a href="#五、进程同步" class="headerlink" title="五、进程同步:"></a>五、进程同步:</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区:"></a>临界区:</h3><p>对临界资源进行访问的那段代码称为临界区。<br>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥:"></a>同步与互斥:</h3><p>同步：多个进程按一定顺序执行；<br>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量:"></a>信号量:</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 P 和 V 操作。</p><ul><li><strong>P</strong>: 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>V</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P 操作。</li></ul><p>P, V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p><strong>如果信号量的取值只能为 0 或者 1</strong>，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用信号量实现生产者-消费者问题</strong> </p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p><strong>注意，不能先对缓冲区进行加锁，再测试信号量。</strong>也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、关于管程"><a href="#六、关于管程" class="headerlink" title="六、关于管程:"></a>六、关于管程:</h2><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。<br><strong>c 语言不支持管程</strong></p><p><strong>管程有一个重要特性：</strong><br>在一个时刻只能有一个进程使用管程。<br>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。<br>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。<br>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。<br>signal() 操作用于唤醒被阻塞的进程。</p><h2 id="七、进程的通信"><a href="#七、进程的通信" class="headerlink" title="七、进程的通信:"></a>七、进程的通信:</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：<br>进程同步：控制多个进程按一定顺序执行；<br>进程通信：进程间传输信息</p><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="八、关于管道"><a href="#八、关于管道" class="headerlink" title="八、关于管道:"></a>八、关于管道:</h2><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><p>它具有以下限制：</p><ul><li><p>只支持半双工通信（单向交替传输）；</p></li><li><p>只能在父子进程中使用。</p></li></ul><h2 id="九、同步方法和同步代码块的区别是什么？"><a href="#九、同步方法和同步代码块的区别是什么？" class="headerlink" title="九、同步方法和同步代码块的区别是什么？"></a>九、同步方法和同步代码块的区别是什么？</h2><p>①: 同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；<br>②: 同步方法使用关键字 synchronized修饰方法，<br>而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、关于进程&quot;&gt;&lt;a href=&quot;#一、关于进程&quot; class=&quot;headerlink&quot; title=&quot;一、关于进程:&quot;&gt;&lt;/a&gt;一、关于进程:&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是进程&quot;&gt;&lt;a href=&quot;#1-1-什么是进程&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是进程?&quot;&gt;&lt;/a&gt;1.1 什么是进程?&lt;/h3&gt;&lt;p&gt;进程是具有独立功能的&lt;strong&gt;程序在某个数据集合上的一次运行活动&lt;/strong&gt;，也是操作系统进行&lt;strong&gt;资源分配和保护的基本单位。&lt;/strong&gt;有挂起状态&lt;/p&gt;
&lt;h3 id=&quot;1-2-进程的组成部分&quot;&gt;&lt;a href=&quot;#1-2-进程的组成部分&quot; class=&quot;headerlink&quot; title=&quot;1.2 进程的组成部分:&quot;&gt;&lt;/a&gt;1.2 进程的组成部分:&lt;/h3&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程管理" scheme="https://zzwwqq.xyz/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://zzwwqq.xyz/%E7%89%A9%E7%90%86%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/物理层.html</id>
    <published>2019-03-31T07:16:47.000Z</published>
    <updated>2019-04-01T07:13:35.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传输模式"><a href="#一、传输模式" class="headerlink" title="一、传输模式:"></a>一、传输模式:</h2><p><strong>单工</strong>（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户<br><strong>半双工</strong>（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信<br><strong>全双工</strong>（full-duplex）:发送的同时也可以接收数据</p><a id="more"></a><h2 id="二、信道复用技术"><a href="#二、信道复用技术" class="headerlink" title="二、信道复用技术:"></a>二、信道复用技术:</h2><h3 id="2-1-频分复用"><a href="#2-1-频分复用" class="headerlink" title="2.1 频分复用:"></a>2.1 频分复用:</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.1.png" alt></p><h3 id="2-2-时分复用"><a href="#2-2-时分复用" class="headerlink" title="2.2 时分复用:"></a>2.2 时分复用:</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.2.png" alt></p><h3 id="2-3-波分复用"><a href="#2-3-波分复用" class="headerlink" title="2.3 波分复用:"></a>2.3 波分复用:</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="2-4-码分复用"><a href="#2-4-码分复用" class="headerlink" title="2.4 码分复用:"></a>2.4 码分复用:</h3><p>广泛应用于无线链路共享（如蜂窝网，卫星通信等）<br>每个用户分配一个唯一的m bit 码片序列，其中0用-1表示，1用+1表示<br>各用户使用相同频率载波，利用各自的码片序列编码数据<br>各用户码片序列相互正交<br>码片序列与编码信号的内积</p><h3 id="2-5-统计时分复用"><a href="#2-5-统计时分复用" class="headerlink" title="2.5 统计时分复用:"></a>2.5 统计时分复用:</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-2.4.png" alt></p><h2 id="三、物理层的主要任务"><a href="#三、物理层的主要任务" class="headerlink" title="三、物理层的主要任务:"></a>三、物理层的主要任务:</h2><p>确定与传输媒体的接口有关的一些特性(机械,电气,功能,过程特性)</p><h2 id="四、物理层设备"><a href="#四、物理层设备" class="headerlink" title="四、物理层设备:"></a>四、物理层设备:</h2><p>转发器:<br>集线器: 它的每个接口,是简单的转发比特,不进行碰撞检测<br>中继器: 是一种简单的增加局域网传输距离的设备，如作为信号放大器，可使实际的网络跨越更大的距离，它工作在物理层</p><h2 id="五、物理层基本单元"><a href="#五、物理层基本单元" class="headerlink" title="五、物理层基本单元:"></a>五、物理层基本单元:</h2><p>比特</p><h2 id="六、常用编码方式"><a href="#六、常用编码方式" class="headerlink" title="六、常用编码方式:"></a>六、常用编码方式:</h2><p>不归零: 与比特流一致<br>归零: 到了高/低电平后,将回到低电平<br>曼彻斯特: 中心向下为1<br>差分曼彻斯特: 位开始无跳变为1,位中心始终跳变</p><h2 id="七、物理层规范"><a href="#七、物理层规范" class="headerlink" title="七、物理层规范:"></a>七、物理层规范:</h2><p><strong>物理层定义的是规范，不能说是协议</strong><br>例如: EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、传输模式&quot;&gt;&lt;a href=&quot;#一、传输模式&quot; class=&quot;headerlink&quot; title=&quot;一、传输模式:&quot;&gt;&lt;/a&gt;一、传输模式:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单工&lt;/strong&gt;（Simplex）:只能单向通信（只能有A发送到B，B不能发送到A）：比如电视台发送电视信号给用户&lt;br&gt;&lt;strong&gt;半双工&lt;/strong&gt;（half-duplex）: 可以双向通信，但只能交替进行（即A发送给B的时候B不能发送给A，等A发送完后，B才能发送给A；发送和接收不能同时进行）；比如 对讲机 通信&lt;br&gt;&lt;strong&gt;全双工&lt;/strong&gt;（full-duplex）:发送的同时也可以接收数据&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="物理层" scheme="https://zzwwqq.xyz/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP</title>
    <link href="https://zzwwqq.xyz/%E5%85%B3%E4%BA%8EHTTP.html"/>
    <id>https://zzwwqq.xyz/关于HTTP.html</id>
    <published>2019-03-30T12:52:15.000Z</published>
    <updated>2019-03-30T16:07:53.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、区分URI-URL-URN"><a href="#一、区分URI-URL-URN" class="headerlink" title="一、区分URI,URL,URN:"></a>一、区分URI,URL,URN:</h2><p>URI 包含 URL 和 URN。</p><a id="more"></a><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.1.png" alt></p><h2 id="二、关于HTTP协议"><a href="#二、关于HTTP协议" class="headerlink" title="二、关于HTTP协议:"></a>二、关于HTTP协议:</h2><h3 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么?"></a>2.1 是什么?</h3><p>是一个基于(客户端/服务器)请求与响应模式的、<strong>无连接,</strong>  <strong>无状态的</strong>、<strong>应用层的协议</strong>，<strong>常基于TCP的连接方式</strong>，<strong>HTTP1.1</strong>版本中给出一种<strong>持续连接的机制</strong>，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</p><h3 id="2-2-HTTP协议的主要特点"><a href="#2-2-HTTP协议的主要特点" class="headerlink" title="2.2 HTTP协议的主要特点?"></a>2.2 HTTP协议的主要特点?</h3><p>①:   无连接：  限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>②:   无状态： HTTP协议是无状态协议,   无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>③:  传输数据类型灵活：     HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</p><p>④:  传输方式简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><h3 id="2-3-HTTP请求报文"><a href="#2-3-HTTP请求报文" class="headerlink" title="2.3 HTTP请求报文:"></a>2.3 HTTP请求报文:</h3><p>请求行,请求头,请求空行,请求体</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.2.png" alt></p><h3 id="2-4-HTTP响应报文"><a href="#2-4-HTTP响应报文" class="headerlink" title="2.4 HTTP响应报文:"></a>2.4 HTTP响应报文:</h3><p>状态行,响应头,响应空行,响应体</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.3.png" alt></p><h3 id="2-5-HTTP方法"><a href="#2-5-HTTP方法" class="headerlink" title="2.5 HTTP方法:"></a>2.5 HTTP方法:</h3><p>客户端发送的 <strong>请求报文</strong> <strong>第一行为请求行，</strong>包含了方法字段。</p><p>有九种方法: get,post,put,delete,head,patch,options,connect,trace</p><p><strong>HEAD:</strong><br>①: 作用: 获取报文首部<br>②: 和 GET 方法类似，但是不返回报文实体主体部分。<br>③: 主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><p><strong>POST: </strong><br>作用: 传输实体主体<br>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p><strong>PUT:</strong><br>①: 作用: 上传文件<br>②: 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><p><strong>PATCH:</strong><br>①: 作用: 对资源进行部分修改<br>②: PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><p><strong>OPTIONS:</strong><br>①: 作用: 查询支持的方法<br>②: 查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><p><strong>CONNECT:</strong><br>①: 要求在与代理服务器通信时建立隧道<br>②: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p><strong>TRACE:</strong><br>①: 追踪路径<br>②: 服务器会将通信路径返回给客户端。<br>③: 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h3 id="2-6-关于HTTP状态码"><a href="#2-6-关于HTTP状态码" class="headerlink" title="2.6 关于HTTP状态码:"></a>2.6 关于HTTP状态码:</h3><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（<strong>信息性状态码</strong>）</td><td>接收的请求正在处理<br><strong>100</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</td></tr><tr><td>2XX</td><td>Success（<strong>成功</strong>状态码）</td><td>请求正常处理完毕<br><strong>200 OK</strong></td></tr><tr><td>3XX</td><td>Redirection（<strong>重定向</strong>状态码）</td><td>需要进行附加操作以完成请求<br><strong>301</strong> ：永久性重定向<br><strong>302</strong>：临时性重定向</td></tr><tr><td>4XX</td><td>Client Error（<strong>客户端错误</strong>状态码）</td><td>服务器无法处理请求<br><strong>403 Forbidden</strong> ：请求被拒绝。<br><strong>404 Not Found</strong></td></tr><tr><td>5XX</td><td>Server Error（<strong>服务器错误</strong>状态码）</td><td>服务器处理请求出错<br><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。<br><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</td></tr></tbody></table><h3 id="2-7-连接管理"><a href="#2-7-连接管理" class="headerlink" title="2.7 : 连接管理:"></a>2.7 : 连接管理:</h3><h4 id="2-7-1-短连接与长连接"><a href="#2-7-1-短连接与长连接" class="headerlink" title="2.7.1 短连接与长连接:"></a>2.7.1 短连接与长连接:</h4><p>①: 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。<br>②: 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始<strong>默认是长连接的</strong>，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h4 id="2-7-2-流水线"><a href="#2-7-2-流水线" class="headerlink" title="2.7.2 流水线:"></a>2.7.2 流水线:</h4><p>①: 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<br>②: 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p><h4 id="2-7-3-Cookie"><a href="#2-7-3-Cookie" class="headerlink" title="2.7.3 Cookie:"></a>2.7.3 Cookie:</h4><p>①: HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 <strong>Cookie 来保存状态信息</strong>。</p><p>②: <strong>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>③: <strong>Cookie有什么用途?</strong></p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>④: <strong>Cookie的创建过程:</strong></p><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>⑤: <strong>Cookie的分类:</strong></p><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure><p>⑥: <strong>HttpOnly:</strong></p><ul><li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。</li><li>跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 访问非 HttpOnly 标记的 Cookie,从而窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>⑦: <strong>Secure:</strong></p><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id="2-7-4-Session"><a href="#2-7-4-Session" class="headerlink" title="2.7.4 Session:"></a>2.7.4 Session:</h4><p>①: 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>②: Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>③: <strong>使用 Session 维护用户登录状态的过程如下：</strong></p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><p>④: 浏览器禁用 Cookie:</p><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 <strong>URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</strong></p><h4 id="2-7-5-Cookie-与-Session-选择"><a href="#2-7-5-Cookie-与-Session-选择" class="headerlink" title="2.7.5 Cookie 与 Session 选择:"></a>2.7.5 Cookie 与 Session 选择:</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="2-8-常见端口"><a href="#2-8-常见端口" class="headerlink" title="2.8 常见端口:"></a>2.8 常见端口:</h3><p>Http端口80,        HTTPS端口443      DNS端口 53    FTP 端口21     SMTP端口 25</p><h2 id="三、HTTP-1-1-新特性"><a href="#三、HTTP-1-1-新特性" class="headerlink" title="三、HTTP/1.1 新特性:"></a>三、HTTP/1.1 新特性:</h2><p>①: 默认是长连接<br>②: 支持流水线<br>③: 支持同时打开多个 TCP 连接<br>④: 支持虚拟主机<br>⑤: 新增状态码 100<br>⑥: 支持分块传输编码<br>⑦: 新增缓存处理指令 max-age</p><h2 id="四、GET-和-POST-比较"><a href="#四、GET-和-POST-比较" class="headerlink" title="四、GET 和 POST 比较:"></a>四、GET 和 POST 比较:</h2><p><strong>从作用上来说: </strong><br>GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>从参数来说:</strong><br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。<br>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/<span class="number">1.1</span></span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p><strong>从缓存来说: </strong><br>如果要对响应进行缓存，需要满足以下条件：</p><p>①: 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，POST 在多数情况下不可缓存的。<br>②: 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。<br>③: 响应报文的 Cache-Control 首部字段没有指定不进行缓存。</p><p><strong>XMLHttpRequest: </strong></p><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><p>①: 在使用 XMLHttpRequest 的 POST 方法时，浏览器会<strong>先发送 Header 再发送 Data</strong>。但并不是所有浏览器会这么做，例如火狐就不会。<br>②: 而 GET 方法 <strong>Header 和 Data 会一起发送。</strong></p><h2 id="五-关于HTTPS"><a href="#五-关于HTTPS" class="headerlink" title="五: 关于HTTPS:"></a>五: 关于HTTPS:</h2><h3 id="5-1-HTTP-有以下安全性问题："><a href="#5-1-HTTP-有以下安全性问题：" class="headerlink" title="5.1 HTTP 有以下安全性问题："></a>5.1 HTTP 有以下安全性问题：</h3><p>①: 使用明文进行通信，内容可能会被窃听；<br>②: 不验证通信方的身份，通信方的身份有可能遭遇伪装；<br>③: 无法证明报文的完整性，报文有可能遭篡改。</p><h3 id="5-2-什么是HTTPS"><a href="#5-2-什么是HTTPS" class="headerlink" title="5.2 什么是HTTPS?"></a>5.2 什么是HTTPS?</h3><p>HTTPS （HyperText Transfer Protocol over Secure SocketLayer）并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL，用于安全的 HTTP 数据传输。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.8.png" alt></p><p><strong>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong></p><h3 id="5-3-什么是SSL"><a href="#5-3-什么是SSL" class="headerlink" title="5.3 什么是SSL?"></a>5.3 什么是SSL?</h3><p>SSL（Secure Socket Layer，安全套接字层）：<br>1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><h3 id="5-4-什么是TLS"><a href="#5-4-什么是TLS" class="headerlink" title="5.4 什么是TLS?"></a>5.4 什么是TLS?</h3><p>TLS（Transport Layer Security，传输层安全）：<br>其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><strong>5.5 HTTPS的缺点: </strong></p><p>①: SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐<br>②: HTTPS 降低用户访问速度（多次握手）<br>③: 网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）<br>④: HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密）</p><h2 id="六、关于加密"><a href="#六、关于加密" class="headerlink" title="六、关于加密:"></a>六、关于加密:</h2><h3 id="6-1-对称密钥加密-Symmetric-Key-Encryption"><a href="#6-1-对称密钥加密-Symmetric-Key-Encryption" class="headerlink" title="6.1 对称密钥加密:(Symmetric-Key Encryption)"></a>6.1 对称密钥加密:(Symmetric-Key Encryption)</h3><p>①: 有流式、分组两种，加密和解密都是使用的同一个密钥。<br>例如：DES、AES-GCM、ChaCha20-Poly1305等</p><p>优点：运算速度快；<br>缺点：无法安全地将密钥传输给通信方。</p><h3 id="6-2-非对称密钥加密"><a href="#6-2-非对称密钥加密" class="headerlink" title="6.2 非对称密钥加密:"></a>6.2 非对称密钥加密:</h3><p>①: 又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥, 分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p><p>例如：RSA、DSA、ECDSA、DH、ECDHE</p><p>②: 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。(<strong>发消息: 公钥加密,私钥解密</strong>)<br>③: 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。(<strong>签名: 私钥加密,公钥解密</strong>)</p><p>优点：可以更安全地将公开密钥传输给通信发送方；<br>缺点：运算速度慢。</p><h3 id="6-3-哈希算法"><a href="#6-3-哈希算法" class="headerlink" title="6.3 哈希算法:"></a>6.3 哈希算法:</h3><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p><p>例如：MD5、SHA-1、SHA-2、SHA-256 等</p><h3 id="6-4-数字签名"><a href="#6-4-数字签名" class="headerlink" title="6.4 数字签名:"></a>6.4 数字签名:</h3><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p><p>HTTPS=数据加密+身份认证+完整性验证(信息是否篡改)+HTTP</p><h3 id="6-3-HTTPS-采用的加密方式"><a href="#6-3-HTTPS-采用的加密方式" class="headerlink" title="6.3 HTTPS 采用的加密方式:"></a>6.3 HTTPS 采用的加密方式:</h3><p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输对称密钥</strong>来保证传输过程的安全性，之后使用<strong>对称密钥加密进行通信</strong>来保证通信过程的效率.</p><h2 id="七、关于认证"><a href="#七、关于认证" class="headerlink" title="七、关于认证:"></a>七、关于认证:</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p><strong>服务器</strong>的运营人员向 CA 提出<strong>公开密钥的申请</strong>，CA 在判明提出申请者的身份之后，会<strong>对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后<strong>绑定</strong>在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.4.png" alt></p><p>签名: 签名者的私钥加密,</p><p>认证: 使用签名者公钥解密</p><h2 id="八、完整性保护"><a href="#八、完整性保护" class="headerlink" title="八、完整性保护:"></a>八、完整性保护:</h2><p>①: SSL 提供报文摘要功能来进行完整性保护。<br>②: HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。<br>③: HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="九、关于代理"><a href="#九、关于代理" class="headerlink" title="九、关于代理:"></a>九、关于代理:</h2><h3 id="9-1-代理服务器接受客户端的请求，并且转发给其它服务器。"><a href="#9-1-代理服务器接受客户端的请求，并且转发给其它服务器。" class="headerlink" title="9.1 代理服务器接受客户端的请求，并且转发给其它服务器。"></a>9.1 代理服务器接受客户端的请求，并且转发给其它服务器。</h3><h3 id="9-2-使用代理的主要目的是："><a href="#9-2-使用代理的主要目的是：" class="headerlink" title="9.2 使用代理的主要目的是："></a>9.2 使用代理的主要目的是：</h3><p>①: 缓存<br>②: 负载均衡<br>③: 网络访问控制<br>④: 访问日志记录</p><h3 id="9-3-代理服务器分为正向代理和反向代理两种："><a href="#9-3-代理服务器分为正向代理和反向代理两种：" class="headerlink" title="9.3 代理服务器分为正向代理和反向代理两种："></a>9.3 代理服务器分为正向代理和反向代理两种：</h3><p><strong>举例: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.5.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.6.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-5.7.png" alt></p><h2 id="十、关于缓存"><a href="#十、关于缓存" class="headerlink" title="十、关于缓存:"></a>十、关于缓存:</h2><h3 id="10-1-优点"><a href="#10-1-优点" class="headerlink" title="10.1 优点:"></a>10.1 优点:</h3><p>①: 缓解服务器压力；<br>②: 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p><h3 id="10-2-实现方法"><a href="#10-2-实现方法" class="headerlink" title="10.2 实现方法"></a>10.2 实现方法</h3><p>①: 让代理服务器进行缓存；<br>②: 让客户端浏览器进行缓存。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、区分URI-URL-URN&quot;&gt;&lt;a href=&quot;#一、区分URI-URL-URN&quot; class=&quot;headerlink&quot; title=&quot;一、区分URI,URL,URN:&quot;&gt;&lt;/a&gt;一、区分URI,URL,URN:&lt;/h2&gt;&lt;p&gt;URI 包含 URL 和 URN。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="关于HTTP" scheme="https://zzwwqq.xyz/tags/%E5%85%B3%E4%BA%8EHTTP/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="https://zzwwqq.xyz/java%E9%9B%86%E5%90%88.html"/>
    <id>https://zzwwqq.xyz/java集合.html</id>
    <published>2019-03-29T06:49:49.000Z</published>
    <updated>2019-03-29T08:58:08.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、先来看两张图"><a href="#一、先来看两张图" class="headerlink" title="一、先来看两张图:"></a>一、先来看两张图:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.1.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.2.png" alt></p><h2 id="二、集合的分类"><a href="#二、集合的分类" class="headerlink" title="二、集合的分类:"></a>二、集合的分类:</h2><h3 id="2-1-Collection接口"><a href="#2-1-Collection接口" class="headerlink" title="2.1 Collection接口:"></a>2.1 Collection接口:</h3><p>List接口：存储有序，可重复的元素  ,遍历出来的顺序与添加<strong>顺序相同</strong></p><p>Set接口：存储无序(存储的元素是无序的(指的是元素在底层存放的<strong>位置无序</strong>))，不可重复的元素(不可</p><p>　　　　重复性:当向Set中添加相同的元素的时候，后面的这个不能添加进去), Set中常用的方法都</p><p>　　　　是Collection下定义的</p><h3 id="2-2-Map接口"><a href="#2-2-Map接口" class="headerlink" title="2.2 Map接口:"></a>2.2 Map接口:</h3><p><strong>注：Map接口不是Collection接口的子接口, 两者是并列关系</strong></p><h2 id="三、关于List接口"><a href="#三、关于List接口" class="headerlink" title="三、关于List接口:"></a>三、关于List接口:</h2><h3 id="3-1-List接口："><a href="#3-1-List接口：" class="headerlink" title="3.1 List接口："></a>3.1 List接口：</h3><p>存储有序，可重复的元素             遍历出来的顺序与添加顺序相同</p><h3 id="3-2-具体的实现类"><a href="#3-2-具体的实现类" class="headerlink" title="3.2 具体的实现类:"></a>3.2 具体的实现类:</h3><p>①: ArrayList(主要的实现类)<br>②: LinkedList(对于频繁的插入，删除操作   较适用)<br>③: Vector(古老的实现类，线程安全的，但效率低于ArrayList)</p><h2 id="四、关于Set接口"><a href="#四、关于Set接口" class="headerlink" title="四、关于Set接口:"></a>四、关于Set接口:</h2><h3 id="4-1-需要注意的是"><a href="#4-1-需要注意的是" class="headerlink" title="4.1 需要注意的是:"></a>4.1 需要注意的是:</h3><p>①: 通常说的” Set是无序的,  不可重复的 “  这句话中的无序是指的<strong>存储无序. </strong><br>②: 无论是HashSet,还是LinkedHashSet 存储都是无序,  且不可重复的元素((指的是元素在底层存放的位置无序))<br>③: <strong>遍历是分为有序和无序的 </strong>,   HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.  </p><h3 id="4-2-如何保证set中元素不可重复"><a href="#4-2-如何保证set中元素不可重复" class="headerlink" title="4.2 如何保证set中元素不可重复?"></a>4.2 如何保证set中元素不可重复?</h3><p><strong>要求添加进Set中的元素所在的类，一定要重写equals（）和hashCode（）方法.</strong><br>让equals方法比较的是值而不是比较地址(Object类是任何类的父类,equals方法是Object类中的方法),<br>重写hashCode（）方法让同一个对象能算出相同的hashCode值,,   进而保证Set中元素的不可重复性,,    注意:List只用重写equals方法就可以了</p><h3 id="4-3-Set中元素是如何存储的呢？"><a href="#4-3-Set中元素是如何存储的呢？" class="headerlink" title="4.3 Set中元素是如何存储的呢？"></a>4.3 Set中元素是如何存储的呢？</h3><p><strong>使用了哈希算法</strong><br>当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的哈希值，此哈希值决定了此对象在Set中的存储位置(通过这样保证无序)。若此位置之前没有对象存储，则这个对象直接存储到此位置，若此位置已有对象存储,再通过equals方法比较这两个对象是否相同，如果相同返回true，则后一个对象就不能添加进来(通过这样保证不可重复).</p><p><strong>要求</strong>：hashCode()方法要与equals()方法一致(也就是说: 同一个类的两个对象,如果属性都相同,那么算出来的两个对象的hashCode值应该相同,且equals方法返回值应该为true; 如果属性不相同,那么算出来的两个对象的hashCode值应该不相同,且equals方法返回值应该为false;    )</p><p>万一 一个类的两个对象属性不同却算出相同的hashCode值,且equals方法返回false，那么都存储到同一个位置（不建议如此）</p><h3 id="4-4-具体的实现类"><a href="#4-4-具体的实现类" class="headerlink" title="4.4  具体的实现类:"></a>4.4  具体的实现类:</h3><p>①: HashSet(主要的实现类)<br>②: LinkedHashSet(HashSet的子类)<br>③: TreeSet(是SortedSet接口的实现类,而SortedSet接口是Set的子接口)</p><p><strong>注:  一个TreeSet对象必须存储同一种数据类型( 例如:不能既存储Integer  又存储String类型)</strong></p><h4 id="4-4-1-关于TreeSet"><a href="#4-4-1-关于TreeSet" class="headerlink" title="4.4.1 关于TreeSet:"></a>4.4.1 关于TreeSet:</h4><p>当向TreeSet中添加自定义类的对象时，有两种排序方法：①自然排序②定制排序<br>①自然排序：（实现comparable接口，并重写compareTo方法）（从小到大，从大到小排序）<br>②定制排序：（实现Comparator接口，重写compare方法）</p><p><strong>两种排序的区别:  </strong> </p><p>前者要求在自定义类中实现java.lang.Comparable接口并重写其compareTo(Objecto)方法<br>后者可以在方法中创建一个实现了Comparator接口的类对象(匿名内部类),并重写compare方法.</p><p>向TreeSet中添加元素时，<strong>首先执行元素所属类的compareTo方法</strong>比较元素，一旦返回0，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来</p><p><strong>注: </strong>只有当<strong>compareTo</strong>比较后得两个对象不相同时，再调用执行元素所属类的<strong>hashCode方法</strong>，最后调用<strong>equals方法</strong>   <strong>compareTo()与hashCode()以及equals()三者保持一致！</strong></p><h2 id="五、关于Map接口"><a href="#五、关于Map接口" class="headerlink" title="五、关于Map接口:"></a>五、关于Map接口:</h2><h3 id="5-1-Map接口元素的存储原理"><a href="#5-1-Map接口元素的存储原理" class="headerlink" title="5.1 Map接口元素的存储原理:"></a>5.1 Map接口元素的存储原理:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-3.3.png" alt></p><p>Map接口中的key是用set存放的，不许重复，也就是说同一个Map对象所对应的类，<strong>需要重写hashCode和equals方法, </strong>     进而保证Set中元素的不可重复性, value是用Collection来存放的可以重复</p><p><strong>例如:</strong><br>向HashMap中添加元素时，会调用key所在类的equals()方法，判断两个key是否相同，若相同 ,则只能添加进后添加的那个元素(<strong>后面的会覆盖前面的</strong>,这个与HashSet不同,HashSet是后面的那个不能添加进来)。</p><h3 id="5-2-遍历Map"><a href="#5-2-遍历Map" class="headerlink" title="5.2 遍历Map:"></a>5.2 遍历Map:</h3><p>有三类，分别是遍历key，遍历value，遍历key-value对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.遍历key集</span></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.遍历value集</span></span><br><span class="line"></span><br><span class="line">Collection values = map.values();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.遍历key-value对</span></span><br><span class="line"></span><br><span class="line">Set set2 = map.entrySet();   <span class="comment">//所有entry的集合就是entrySet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj:set2)   &#123;        <span class="comment">//遍历entrySet得到entry</span></span><br><span class="line"></span><br><span class="line">Map.Entry entry = (Map.Entry)obj;   <span class="comment">//获取entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(entry.getKey()+"------&gt;"+entry.getValue()); //分别获取entry中的键  和  值</span></span><br><span class="line"></span><br><span class="line">   System.out.println(entry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Map的初始化"><a href="#5-3-Map的初始化" class="headerlink" title="5.3 Map的初始化:"></a>5.3 Map的初始化:</h3><p>不能初始化为:      Map&lt;String,List<score>&gt;map=null;<br>而要用new对象的方式：Map&lt;String,List<score>&gt;map=newHashMap&lt;String,List<score>&gt;();否则会报错</score></score></score></p><h3 id="5-4-从map中取值"><a href="#5-4-从map中取值" class="headerlink" title="5.4 从map中取值:"></a>5.4 从map中取值:</h3><p>正确方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一:  String str = String.valueOf(map.get(<span class="string">"键名"</span>));</span><br><span class="line">方法二:  </span><br><span class="line">String str = (String) map.get(<span class="string">"ACCEPT_CHANNEL"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != str &amp;&amp; !<span class="string">""</span>.equals(str)) &#123;</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的取值方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = map.get(<span class="string">"键名"</span>).toString;  <span class="comment">//如果键对应的值不存在即为null,那么再调用tostring()方法时,就会抛出空指针异常</span></span><br></pre></td></tr></table></figure><p><strong>注: Map中的Key  value可以是任何引用类型的数据</strong></p><h3 id="5-5-Map接口的具体实现类"><a href="#5-5-Map接口的具体实现类" class="headerlink" title="5.5 Map接口的具体实现类:"></a>5.5 Map接口的具体实现类:</h3><p>①: HashTable : 古老的实现类，线程安全，不建议使用<br>②: HashMap:<br>③: LinkedHashMap(是HashMap的子类)<br>④: TreeMap:(实现了SortedMap接口,而SortedMap接口是Map的子接口)</p><h4 id="5-5-1-Properties介绍"><a href="#5-5-1-Properties介绍" class="headerlink" title="5.5.1  Properties介绍:"></a>5.5.1  Properties介绍:</h4><p>Properties：是Hashtable的子类，常用来处理属性文件。键和值都为String类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">读取属性文件jdbc.properties: </span><br><span class="line"></span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"jdbc.properties"</span>));</span><br><span class="line"></span><br><span class="line">pros.load(fi);</span><br><span class="line"></span><br><span class="line">读取xml配置文件config.xml: </span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">InputStream configInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"config/config.xml"</span>);</span><br><span class="line"></span><br><span class="line">properties.loadFromXML(configInputStream);</span><br></pre></td></tr></table></figure><h2 id="六、关于Collections-工具类"><a href="#六、关于Collections-工具类" class="headerlink" title="六、关于Collections 工具类:"></a>六、关于Collections 工具类:</h2><p>6.1 作用:  </p><p>　　　　操作Collection以及Map</p><p>6.2 注意:<br>　　　　区分Collection与Collections</p><p>6.3 实现list的复制: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的方式：出现java.lang.indexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//List list1=new ArrayList();</span></span><br><span class="line"><span class="comment">//Collections.copy(list1,list);//list1长度为0，list长度为5，所以无法将list复制到list1</span></span><br><span class="line"><span class="comment">//System.out.println(list1);</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//正确的方式</span></span><br><span class="line">List list2 = Arrays.asList(newObject[list.size()]);</span><br><span class="line">Collections.copy(list2,list);</span><br><span class="line">System.out.println(list2);<span class="comment">//[123,456,12,78,456]</span></span><br></pre></td></tr></table></figure><p>6.4 考虑线程安全问题:  </p><p>List 是线程不安全的, synchronizedList方法可以保证List线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过如下的方法保证list的线程安全</span></span><br><span class="line">List list3=Collections.synchronizedList(list);</span><br><span class="line">System.out.println(list3);</span><br></pre></td></tr></table></figure><p>6.5常用函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转List中元素的顺序</span><br><span class="line">shuffle(List)：对List集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定的List集合元素按照升序排序</span><br><span class="line">sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</span><br><span class="line">swap(List,<span class="keyword">int</span>,<span class="keyword">int</span>)：将指定list集合中的i处元素和j处元素进行交换</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>:<span class="comment">//将src中的内容复制到dest中</span></span></span><br></pre></td></tr></table></figure><h2 id="七、集合的遍历方法：四种"><a href="#七、集合的遍历方法：四种" class="headerlink" title="七、集合的遍历方法：四种"></a>七、集合的遍历方法：四种</h2><p>①使用Iterator迭代器</p><p>②增强型for循环</p><p>③普通for循环</p><p>④Iterator迭代器的”古老版本”Enumeration 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Enumeration 接口是Iterator迭代器的"古老版本"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumeration</span> </span>&#123;</span><br><span class="line">　　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　　　　　　Enumeration enu = <span class="keyword">new</span> StringTokenizer(<span class="string">"ab-c*-df-g"</span>, <span class="string">"-"</span>);</span><br><span class="line">　　　　　　　<span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line">　　　　　　　　　　　System.out.println(enu.nextElement());</span><br><span class="line">　　　　　　　&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;    <span class="comment">//结果: 输出MM MM  MM   AA   BB   DD </span></span><br><span class="line">    String[]str=<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"DD"</span>&#125;;</span><br><span class="line">    <span class="comment">//表示每次从str中取出一个元素赋给局部变量s，所以s值的修改，并不影响str中的值</span></span><br><span class="line">    <span class="keyword">for</span>(String s:str)&#123;   <span class="comment">//每循环一次, s都是一个新的局部变量</span></span><br><span class="line">        s=<span class="string">"MM"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        System.out.println(str[i]);          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、关于数组"><a href="#八、关于数组" class="headerlink" title="八、关于数组:"></a>八、关于数组:</h2><p>存储对象可以考虑：①数组，②集合<br>数组存储对象的特点：Student[] stu = new Student[20];  stu[0]=new Student();…..<br>弊端：①一旦创建，其长度不可变.      ②真实的数组存放的对象的个数是不可知的</p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结:"></a>九、总结:</h2><p>①:   单类型: 　　一个TreeSet对象<strong>必须存储同一种数据类型</strong>,例如: 不能既存储Integer  又存储String类型, 而HashSet和LinkedHashSet可同时存多种数据类型.</p><p>②: 一致性:　　使用TreeSet时:   compareTo()与hashCode()以及equals()三者保持一致！</p><p>③:  执行流程：　向TreeSet中添加元素时，首先执行元素所属类的compareTo方法比较元素，一旦返回0(表示相同)，虽然仅是两个对象的此属性组相同，但是程序会认为这两个对象相同，进而后一个对象不能添加进来 .只有当compareTo比较后得两个对象不相同时，再调用执行元素所属类的hashCode方法，最后调用equals方法</p><p>④: 顺序性:    Set而言:元素在底层存放的位置无序(即存储无序),List而言: 元素存储在连续的地址空间(即存储有序)<br>Set而言: 遍历是分为有序和无序的 ,   其中HashSet遍历是无序的,不是按照添加的顺序遍历, 而LinkedHashSet遍历是有序的,按照添加的顺序遍历.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、先来看两张图&quot;&gt;&lt;a href=&quot;#一、先来看两张图&quot; class=&quot;headerlink&quot; title=&quot;一、先来看两张图:&quot;&gt;&lt;/a&gt;一、先来看两张图:&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.zzwwqq.xyz/static/image
      
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java集合" scheme="https://zzwwqq.xyz/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
