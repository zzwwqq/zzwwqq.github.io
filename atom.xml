<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zwq</title>
  
  <subtitle>路漫漫其修远兮,吾将上下而求索!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zzwwqq.xyz/"/>
  <updated>2019-06-03T10:42:29.171Z</updated>
  <id>https://zzwwqq.xyz/</id>
  
  <author>
    <name>zwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jQuery必知必会</title>
    <link href="https://zzwwqq.xyz/jQuery%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html"/>
    <id>https://zzwwqq.xyz/jQuery必知必会.html</id>
    <published>2019-06-03T04:01:23.000Z</published>
    <updated>2019-06-03T10:42:29.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、jQuery简介"><a href="#一、jQuery简介" class="headerlink" title="一、jQuery简介:"></a>一、jQuery简介:</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍:"></a>1.1 介绍:</h3><p>jQuery 是一个 JavaScript 框架。</p><p>jQuery 极大地简化了 JavaScript 编程。</p><p>特点: jQuery是一个轻量级的”写的少，做的多”的JavaScript库。</p><h3 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h3><p>jQuery库包含以下功能：</p><ul><li>HTML 元素选取</li><li>HTML 元素操作</li><li>CSS 操作</li><li>HTML 事件函数</li><li>JavaScript 特效和动画</li><li>HTML DOM 遍历和修改</li><li>AJAX</li><li>Utilities</li></ul><p><strong>提示：</strong> 除此之外，Jquery还提供了大量的插件。</p><h3 id="1-3-如何用–-gt-第一步"><a href="#1-3-如何用–-gt-第一步" class="headerlink" title="1.3 如何用–&gt;第一步?"></a>1.3 如何用–&gt;第一步?</h3><p>要想在jsp中使用jQuery首先需要在JSP页面中引入jQuery文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一: 下载jQuery文件到本地,然后存到项目目录下  [下载路径:](http://jquery.com/download/)</span></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=<span class="string">"/本地目录/jquery-1.10.2.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/方式二: 直接引用网络路径(例如:引用百度的cdn)</span></span><br><span class="line"><span class="regexp">&lt;head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/apps.bdimg.com/</span>libs/jquery/<span class="number">2.1</span><span class="number">.4</span>/jquery.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//注: 没有在 &lt;script&gt; 标签中使用 type="</span>text/javascript<span class="string">" 的原因是: 在 HTML5 中，不必那样做了。</span></span><br><span class="line"><span class="string">//JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！</span></span><br></pre></td></tr></table></figure><h3 id="1-4-jQuery-语法"><a href="#1-4-jQuery-语法" class="headerlink" title="1.4 jQuery 语法"></a>1.4 jQuery 语法</h3><p>通过 jQuery，您可以选取（查询，query） HTML 元素，并对它们执行”操作”（actions）。</p><p><strong>基础语法：</strong>  <strong>$(selector).action()</strong></p><ul><li>美元符号定义 jQuery</li><li>选择符（selector）”查询”和”查找” HTML 元素</li><li>jQuery 的 action() 执行对元素的操作</li></ul><p>实例:</p><ul><li>$(this).hide() - 隐藏当前元素</li><li>$(“p”).hide() - 隐藏所有 \<p> 元素</p></li><li>$(“p.test”).hide() - 隐藏所有 class=”test” 的 \<p> 元素</p></li><li>$(“#test”).hide() - 隐藏所有 id=”test” 的元素</li></ul><h3 id="1-5-事件之文档加载完毕"><a href="#1-5-事件之文档加载完毕" class="headerlink" title="1.5 事件之文档加载完毕"></a>1.5 事件之文档加载完毕</h3><p>如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：</p><ul><li>试图隐藏一个不存在的元素</li><li>获得未完全加载的图像的大小</li></ul><p>为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作,<br>可以这样: <strong>两种方法: </strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery 入口函数:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一: </span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二:  较简洁---&gt;推荐使用</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>补充: JavaScript 入口函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery 入口函数与 JavaScript 入口函数的区别：</p><ul><li>jQuery 的入口函数是在 html <strong>所有标签(DOM)</strong>都加载之后，就会去执行。</li><li>JavaScript 的 window.onload 事件是等到<strong>所有内容</strong>，<strong>包括外部图片</strong>之类的文件加载完后，才会执行。</li></ul><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nuzzudt9j30nk0aq0tj.jpg" alt></p><h3 id="1-6-jQuery-选择器"><a href="#1-6-jQuery-选择器" class="headerlink" title="1.6 jQuery 选择器"></a>1.6 jQuery 选择器</h3><p><strong>jQuery 中所有选择器都以美元符号开头：$( )</strong></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyio94j5j30j70doqb2.jpg" alt></p><h4 id="1-6-1-选择器分类"><a href="#1-6-1-选择器分类" class="headerlink" title="1.6.1 选择器分类:"></a>1.6.1 选择器分类:</h4><p>①: 基本选择器: </p><ul><li>ID选择器( #id选择器 )—&gt;语法: 举例  $(“#test”)</li><li>类选择器(.class 选择器)—&gt;语法: 举例  $(“.test”)</li><li>元素选择器—-&gt;语法: 举例  $(“div”)</li><li>通配选择器—&gt;语法: 举例  $(“*“)</li><li>选择器分组</li><li>交集选择器—-&gt; 语法：选择器1<strong>.</strong>选择器2<strong>.</strong>选择器N{}——<strong>例子：p.hello{}是元素选择器和类选择器构成———(交点)</strong></li><li>并集选择器—-&gt;语法：选择器1<strong>,</strong>选择器2<strong>,</strong>选择器N{}—–<strong>例子：div,p,#box,.hello{}是元素,id和类选择器构成——-(逗比)</strong></li></ul><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyjmxdgxj30jt0b3teb.jpg" alt></p><p>②: 层级选择器: </p><ul><li>后代元素选择器:       语法：祖先元素   后代元素{ }   ———————————————– (后空翻）                                           </li><li>兄弟元素选择器  <ul><li>选取后一个兄弟元素                  语法: 前一个 <strong>+</strong> 后一个————————————————(嘉玲兄)</li><li>选取后边所有的兄弟元素            语法:   前一个 <strong>~</strong> 后一个————————————————-(浪全兄)</li></ul></li><li>子元素元素选择器:                            语法：父元素 <strong>&gt;</strong> 子元素 {}———————————————–    （父大于子）</li></ul><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyjf8axhj30i00bvdpp.jpg" alt></p><p>③: 属性选择器</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o55oyracj30h0071mxc.jpg" alt></p><p>④: 表单选择器 :——-&gt; <strong>语法:  $(:名称)</strong></p><p><strong>注: 与过滤选择器区别是:  ==:前面没有内容==</strong></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nzz1xqclj30i2054n0t.jpg" alt></p><p><strong>⑤: 过滤选择器</strong>  ——–&gt; <strong>语法:  $(选择器 :过滤器)</strong></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyju6yqyj30l808iwlb.jpg" alt></p><ul><li>基本过滤选择器</li><li><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nzsm1d6bj30ck07c0u6.jpg" alt></li><li>内容过滤选择器</li><li><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyk8bpxmj30jw0a3gr0.jpg" alt></li><li>属性过滤选择器</li><li>子元素过滤选择器</li><li>可见性过滤选择器</li><li><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nykhi0g5j30ix0a20z8.jpg" alt></li><li>表单对象属性过滤选择器</li><li><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nw6l4wsjj30bg01ymx3.jpg" alt></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择器使用实例: </span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"#id"</span>, <span class="string">".class"</span>)  复合选择器    <span class="comment">//-------------&gt;记忆方法: 豆腐</span></span><br><span class="line">$(div p span)       层级选择器 <span class="comment">//div下的p元素中的span元素------&gt;记忆方法: 后空翻</span></span><br><span class="line">$(div&gt;p)            父子选择器 <span class="comment">//div下的所有p元素----&gt;  记忆方法: 父大于子</span></span><br><span class="line">$(div+p)            相邻元素选择器 <span class="comment">//div后面的p元素(仅一个p)-----&gt;记忆方法: 嘉玲兄</span></span><br><span class="line">$(div~p)            兄弟选择器  <span class="comment">//div后面的所有p元素(同级别)-----&gt;记忆方法:浪全兄</span></span><br><span class="line">$(.p:last)          类选择器 加 过滤选择器  第一个和最后一个（first 或者 last）</span><br><span class="line">$(<span class="string">"#mytable td:odd"</span>)      层级选择 加 过滤选择器 奇偶（odd 或者 even）</span><br><span class="line">$(<span class="string">"div p:eq(2)"</span>)    索引选择器 div下的第三个p元素（索引是从<span class="number">0</span>开始）</span><br><span class="line">$(<span class="string">"a[href='www.baidu.com']"</span>)  属性选择器</span><br><span class="line">$(<span class="string">"p:contains(test)"</span>)        <span class="comment">// 内容过滤选择器，包含text内容的p元素</span></span><br><span class="line">$(<span class="string">":emtyp"</span>)        <span class="comment">//内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent 相反</span></span><br><span class="line">$(<span class="string">":hidden"</span>)       <span class="comment">//所有隐藏元素 visible </span></span><br><span class="line">$(<span class="string">"input:enabled"</span>) <span class="comment">//选取所有启用的表单元素</span></span><br><span class="line">$(<span class="string">":disabled"</span>)     <span class="comment">//所有不可用的元素</span></span><br><span class="line">$(<span class="string">"input:checked"</span>) <span class="comment">//获取所有选中的复选框单选按钮等</span></span><br><span class="line">$(<span class="string">"select option:selected"</span>) <span class="comment">//获取选中的选项元素</span></span><br></pre></td></tr></table></figure><h3 id="1-6-2-关于-和-这两个符号的理解"><a href="#1-6-2-关于-和-这两个符号的理解" class="headerlink" title="1.6.2 关于    : 和 [   ] 这两个符号的理解"></a>1.6.2 关于    : 和 [   ] 这两个符号的理解</h3><p>： 即为 jQuery 的过滤选择器，语法类似于 css 中的伪类选择器；可以理解为种类的意思，如：<strong>p:first</strong>，<strong>p</strong> 的种类为第一个。</p><p>[   ] 很自然的可以理解为属性的意思，如：<strong>[href]</strong> 选取带有 <strong>href</strong> 属性的元素。</p><h3 id="1-6-3-“button”-与-“-button”-区别"><a href="#1-6-3-“button”-与-“-button”-区别" class="headerlink" title="1.6.3 \$(“button”) 与   $(“:button”)区别:"></a>1.6.3 \$(“button”) 与   $(“:button”)区别:</h3><p>前者为基本选择器中的元素选择器, 只能获取 \<button> 元素。</button></p><p>后者为表单选择器: 可以选取所有 type=”button” 的 \<input> 元素 和\<button> 元素</button></p><h3 id="1-7-jQuery事件"><a href="#1-7-jQuery事件" class="headerlink" title="1.7 jQuery事件"></a>1.7 jQuery事件</h3><h4 id="1-7-1-常用的-jQuery-事件方法"><a href="#1-7-1-常用的-jQuery-事件方法" class="headerlink" title="### 1.7.1 常用的 jQuery 事件方法"></a>### 1.7.1 常用的 jQuery 事件方法</h4><p>①: $(document).ready()</p><p>②: click()  和  dblclick()——当双击元素时，会发生 dblclick 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).dblclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>③: mouseenter() 和 mouseleave() 及 mousedown()  mouseup()—–当在元素上松开鼠标按钮时，会发生 mouseup 事件。</p><p>④: hover()</p><p>⑤: focus()   和    blur()—-当元素失去焦点时，发生 blur 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"input"</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>,<span class="string">"#ffffff"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>⑥: bind(),unbind()</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nycufb0pj30g201bgmp.jpg" alt></p><p>⑦: submit()</p><h3 id="1-8-获取内容和属性"><a href="#1-8-获取内容和属性" class="headerlink" title="1.8 获取内容和属性"></a>1.8 获取内容和属性</h3><p>jQuery 中非常重要的部分，就是操作 DOM 的能力。</p><p><strong>DOM = Document Object Model（文档对象模型）</strong>,DOM 定义访问 HTML 和 XML 文档的标准</p><h4 id="1-8-1-获得内容-text-、html-以及-val"><a href="#1-8-1-获得内容-text-、html-以及-val" class="headerlink" title="1.8.1 获得内容 - text()、html() 以及 val()"></a>1.8.1 获得内容 - text()、html() 以及 val()</h4><p>三个简单实用的用于 DOM 操作的 jQuery 方法：</p><ul><li>text() - 设置或返回<strong>所选元素的文本内容</strong></li><li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li><li>val() - 设置或返回<strong>表单字段的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Text: "</span> + $(<span class="string">"#test"</span>).text());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-8-2-获取属性-attr"><a href="#1-8-2-获取属性-attr" class="headerlink" title="1.8.2 获取属性 - attr()"></a>1.8.2 获取属性 - attr()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的例子演示如何获得链接中 href 属性的值：</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">        &lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">            $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获得链接中 href 属性的值：  </span></span><br><span class="line">                alert($(<span class="string">"#baidu"</span>).attr(<span class="string">"href"</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"//www.baidu.com"</span> <span class="attr">id</span>=<span class="string">"baidu"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;button&gt;显示 href 属性的值&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-9-attr-和-prop-的区别介绍："><a href="#1-9-attr-和-prop-的区别介绍：" class="headerlink" title="1.9 attr 和 prop 的区别介绍："></a>1.9 attr 和 prop 的区别介绍：</h3><p>对于 HTML 元素本身就带有的<strong>固有属性</strong>，在处理时，使用 <strong>prop</strong> 方法。</p><p>对于 HTML 元素我们自己<strong>自定义的 DOM 属性</strong>，在处理时，使用 <strong>attr</strong> 方法。</p><p><strong>prop()函数的结果:</strong></p><p>​      1.如果有相应的属性，返回指定属性值。</p><p>​      2.如果没有相应的属性，返回值是空字符串。</p><p><strong>attr()函数的结果:</strong></p><p>​      1.如果有相应的属性，返回指定属性值。</p><p>​      2.如果没有相应的属性，返回值是 undefined。</p><p>具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()</p><p>实例 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"https://www.baidu.com"</span> target=<span class="string">"_self"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn"</span>&gt;百度&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span>*这个例子里 &lt;a&gt; 元素的 DOM 属性有: href、target 和 <span class="class"><span class="keyword">class</span>，这些属性就是 &lt;<span class="title">a</span>&gt; 元素本身就带有的属性，也是</span></span><br><span class="line"><span class="class"><span class="title">W3C</span>标准里就包含有这几个属性，或者说在 <span class="title">IDE</span> 里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使</span></span><br><span class="line"><span class="class">用 <span class="title">prop</span> 方法。*/</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">a</span> <span class="title">href</span></span>=<span class="string">"#"</span> id=<span class="string">"link1"</span> action=<span class="string">"delete"</span> rel=<span class="string">"nofollow"</span>&gt;删除&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">这个例子里 &lt;a&gt; 元素的 DOM 属性有: href、id 和 action，很明显，前两个是固有属性，而后面一个 action 属性是</span><br><span class="line">我们自己自定义上去的，&lt;a&gt; 元素本身是没有这个属性的。这种就是自定义的 DOM 属性。处理这些属性时,建议使用attr</span><br><span class="line">方法。*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h3 id="1-10-设置内容和属性"><a href="#1-10-设置内容和属性" class="headerlink" title="1.10 设置内容和属性"></a>1.10 设置内容和属性</h3><h4 id="1-10-1设置内容-text-、html-以及-val-——-gt-本身没有内容"><a href="#1-10-1设置内容-text-、html-以及-val-——-gt-本身没有内容" class="headerlink" title="1.10.1设置内容 - text()、html() 以及 val()——-&gt;本身没有内容"></a>1.10.1设置内容 - text()、html() 以及 val()——-&gt;本身没有内容</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test1"</span>).text(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test2"</span>).html(<span class="string">"&lt;b&gt;Hello world!&lt;/b&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test3"</span>).val(<span class="string">"RUNOOB"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-10-2-text-、html-以及-val-的回调函数"><a href="#1-10-2-text-、html-以及-val-的回调函数" class="headerlink" title="1.10.2 text()、html() 以及 val() 的回调函数"></a>1.10.2 text()、html() 以及 val() 的回调函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test1"</span>).text(<span class="function"><span class="keyword">function</span>(<span class="params">i,origText</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"旧文本: "</span> + origText + <span class="string">" 新文本: Hello world! (index: "</span> + i + <span class="string">")"</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test2"</span>).html(<span class="function"><span class="keyword">function</span>(<span class="params">i,origText</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"旧 html: "</span> + origText + <span class="string">" 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: "</span> + i + <span class="string">")"</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-10-3-设置属性-attr"><a href="#1-10-3-设置属性-attr" class="headerlink" title="1.10.3 设置属性 - attr()"></a>1.10.3 设置属性 - attr()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变（设置）链接中 href 属性的值：</span></span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#baidu"</span>).attr(<span class="string">"href"</span>,<span class="string">"http://www.baidu.com/jquery"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也允许您同时设置多个属性。</span></span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#baidu"</span>).attr(&#123;</span><br><span class="line">        <span class="string">"href"</span> : <span class="string">"http://www.baidu.com/jquery"</span>,</span><br><span class="line">        <span class="string">"title"</span> : <span class="string">"jQuery 教程"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-10-4-attr-的回调函数"><a href="#1-10-4-attr-的回调函数" class="headerlink" title="1.10.4 attr() 的回调函数"></a>1.10.4 attr() 的回调函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符</span></span><br><span class="line">串。</span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#baidu"</span>).attr(<span class="string">"href"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i,origValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origValue + <span class="string">"/jquery"</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-11-获取和修改对比"><a href="#1-11-获取和修改对比" class="headerlink" title="1.11 获取和修改对比:"></a>1.11 获取和修改对比:</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nya90811j30bn0cbmzn.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyajh8awj30bv03nq3d.jpg" alt></p><h3 id="1-12-添加元素"><a href="#1-12-添加元素" class="headerlink" title="1.12 添加元素"></a>1.12 添加元素</h3><h4 id="1-12-1-添加新内容的-jQuery-方法如下："><a href="#1-12-1-添加新内容的-jQuery-方法如下：" class="headerlink" title="1.12.1 添加新内容的 jQuery 方法如下："></a>1.12.1 添加新内容的 jQuery 方法如下：</h4><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nxttq89kj30er06p76l.jpg" alt></p><h4 id="1-12-2-append-prepend和after-before区别举例"><a href="#1-12-2-append-prepend和after-before区别举例" class="headerlink" title="1.12.2 append/prepend和after/before区别举例:"></a>1.12.2 append/prepend和after/before区别举例:</h4><p><strong>append:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        $(<span class="string">"p"</span>).append(<span class="string">'&lt;span class="s2"&gt;s2&lt;/span&gt;'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/运行结果:</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span class="s1"&gt;s1&lt;/</span>span&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s2"</span>&gt;s2&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure><p><strong>prepend</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        $(<span class="string">"p"</span>).prepend(<span class="string">'&lt;span class="s2"&gt;s2&lt;/span&gt;'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/运行结果:</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span class="s2"&gt;s2&lt;/</span>span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure><p><strong>after</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        $(<span class="string">"p"</span>).after(<span class="string">'&lt;span class="s2"&gt;s2&lt;/span&gt;'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/结果是这样的:</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span class="s1"&gt;s1&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="s2"&gt;s2&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure><h4 id="1-12-3-总结："><a href="#1-12-3-总结：" class="headerlink" title="1.12.3 总结："></a>1.12.3 总结：</h4><p><strong>append/prepend 是在选择元素内部嵌入</strong>。prepend 是在内部且已有内容的最前面添加,append是在内部且已有内容的后面添加</p><p><strong>after/before 是在元素外面追加。</strong></p><h3 id="1-13-删除元素"><a href="#1-13-删除元素" class="headerlink" title="1.13 删除元素"></a>1.13 删除元素</h3><h4 id="1-13-1-一般可使用以下两个-jQuery-方法："><a href="#1-13-1-一般可使用以下两个-jQuery-方法：" class="headerlink" title="1.13.1 一般可使用以下两个 jQuery 方法："></a>1.13.1 一般可使用以下两个 jQuery 方法：</h4><ul><li>remove() - 删除被选元素（及其子元素）</li><li>empty() - 从被选元素中删除子元素</li></ul><p>在使用 remove() 的过滤器删除时，不能删除带有过滤器的子元素。就是说如果子元素符合过滤器中条件而父元素不符合的话，是不会删除符合条件的子元素，即过滤器中条件只能作用于同级，不能作用于子元素。</p><p><strong>$(selector)</strong> 语法的返回结果是一个元素的列表，即：将 <strong>$(“#div1”)</strong> 看作一个列表，<strong>remove()</strong> 中的筛选条件实际上是对这个列表中的元素进行筛选删除，而不会去删除这个列表中不存在的元素（子元素不在这个列表中）。</p><h4 id="1-13-2-remove和empty的区别"><a href="#1-13-2-remove和empty的区别" class="headerlink" title="1.13.2 remove和empty的区别:"></a>1.13.2 remove和empty的区别:</h4><p><strong>empty()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">"#div1"</span>).empty();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;div id="div1" style="height:100px;width:300px;border:1px solid black;background-</span></span><br><span class="line"><span class="regexp">color:yellow;"&gt;</span></span><br><span class="line"><span class="regexp"> 这是 div 中的一些文本。</span></span><br><span class="line"><span class="regexp">&lt;p&gt;这是在 div 中的一个段落。&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;这是在 div 中的另外一个段落。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">    &lt;button&gt;清空div元素&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>点击前</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o0bgpo4pj30do0553yg.jpg" alt></p><p>点击后</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o0bpdx4hj30d504lwea.jpg" alt></p><p><strong>remove()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">"#div1"</span>).remove();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="div1" style="height:100px;width:300px;border:1px solid black;background-</span></span><br><span class="line"><span class="regexp">color:yellow;"&gt;</span></span><br><span class="line"><span class="regexp">这是 div 中的一些文本。</span></span><br><span class="line"><span class="regexp">             &lt;p&gt;这是在 div 中的一个段落。&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;这是在 div 中的另外一个段落。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">    &lt;button&gt;移除div元素&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>点击前</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o0fz0txcj30bd04vmx3.jpg" alt></p><p>点击后</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o0g5sq0mj30ai03ejr6.jpg" alt></p><h3 id="1-14-常用选择器实例"><a href="#1-14-常用选择器实例" class="headerlink" title="1.14 常用选择器实例:"></a>1.14 常用选择器实例:</h3><table><thead><tr><th>语法:</th><th>选择器类型:</th><th></th><th>描述:</th></tr></thead><tbody><tr><td>$(“*”)</td><td>通配符选择器</td><td></td><td>选取所有元素</td></tr><tr><td>$(this)</td><td>元素选择器</td><td></td><td>选取当前 HTML 元素</td></tr><tr><td>$(“p.intro”)<br><br>==也可以为\$(“p[class = intro]”)==</td><td>交集选择器</td><td>元素选择器与类选择器组成的交集选择器<br><br>==也可以为 元素选择器与属性选择器==</td><td>选取 class值 为 intro 的 \<p> 元素</p></td></tr><tr><td>$(“p:first”)</td><td>基本的过滤器</td><td></td><td>选取第一个 \<p> 元素</p></td></tr><tr><td>$(“ul li:first”)</td><td>后代选择器和 过滤器</td><td></td><td>选取第一个 \<ul> 元素的第一个 \<li> 元素</li></ul></td></tr><tr><td>$(“ul li:first-child”)</td><td>后代选择器和 过滤器</td><td></td><td>选取每个 \<ul> 元素的第一个 \<li> 元素</li></ul></td></tr><tr><td>$(“[href]”)</td><td>属性选择器</td><td></td><td>选取带有 href 属性的元素</td></tr><tr><td>$(“a[target=’_blank’]”)</td><td>元素选择器和属性选择器</td><td></td><td>选取所有 target 属性值等于 “_blank” 的 \<a> 元素</a></td></tr><tr><td>$(“a[target!=’_blank’]”)</td><td>元素选择器和属性选择器</td><td></td><td>选取所有 target 属性值不等于 “_blank” 的 \<a> 元素</a></td></tr><tr><td><strong>$(“:button”)</strong></td><td><strong>表单选择器</strong></td><td></td><td><strong>==选取所有 type=”button” 的 \<input> 元素 和 \<button> 元素==</button></strong></td></tr><tr><td><strong>$(“button”)</strong></td><td><strong>元素选择器</strong></td><td></td><td><strong>==只能选取\<button> 元素==</button></strong></td></tr><tr><td>$(“tr:even”)</td><td>基本的过滤器</td><td></td><td>选取偶数位置的 \</td></tr><tr> 元素</tr><tr><td>$(“tr:odd”)</td><td>基本的过滤器</td><td></td><td>选取奇数位置的 \</td></tr><tr> 元素</tr></tbody></table><h2 id="二、jQuery与DOM"><a href="#二、jQuery与DOM" class="headerlink" title="二、jQuery与DOM"></a>二、jQuery与DOM</h2><h3 id="2-1-jQuery-和-DOM对象互转"><a href="#2-1-jQuery-和-DOM对象互转" class="headerlink" title="2.1 jQuery 和 DOM对象互转"></a>2.1 jQuery 和 DOM对象互转</h3><p><strong>jQuery对象: var $ x;</strong></p><p><strong>DOM对象:  var x;</strong></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyo070fjj30hl0b4tj0.jpg" alt></p><p><strong>jQuery对象转DOM对象: —–&gt; \$x[y]  或  $x.get(y)</strong></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyo9i740j30gp0b6jye.jpg" alt></p><p><strong>DOM对象转jQuery对象: —-&gt;$(DOM对象)</strong></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3nyohje7aj30gl07yafb.jpg" alt></p><h2 id="三、jQuery与Ajax"><a href="#三、jQuery与Ajax" class="headerlink" title="三、jQuery与Ajax"></a>三、jQuery与Ajax</h2><h3 id="3-1-什么是-AJAX？"><a href="#3-1-什么是-AJAX？" class="headerlink" title="3.1 什么是 AJAX？"></a>3.1 什么是 AJAX？</h3><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript And XML）。</p><p>简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p><h3 id="3-2-jQuery与Ajax联系"><a href="#3-2-jQuery与Ajax联系" class="headerlink" title="3.2 jQuery与Ajax联系"></a>3.2 jQuery与Ajax联系</h3><p>jQuery 提供多个与 AJAX 有关的方法。<br>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。</p><h3 id="3-3-load-方法"><a href="#3-3-load-方法" class="headerlink" title="3.3  load() 方法"></a>3.3  load() 方法</h3><p>jQuery load() 方法是简单但强大的 AJAX 方法。</p><p>load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</p><h4 id="3-3-1-语法"><a href="#3-3-1-语法" class="headerlink" title="3.3.1 语法:"></a>3.3.1 语法:</h4><p> <strong>$(selector).load(URL,data,callback);</strong></p><p>必需的 <em>URL</em> 参数规定您<strong>希望加载的 URL</strong>。</p><p>可选的 <em>data</em> 参数规定<strong>与请求一同发送</strong>的查询字符串键/值对集合。</p><p>可选的 <em>callback</em> 参数是<strong>load() 方法完成后所执行的函数名称</strong>。</p><h4 id="3-3-2-使用举例"><a href="#3-3-2-使用举例" class="headerlink" title="3.3.2 使用举例:"></a>3.3.2 使用举例:</h4><p>把文件 “demo_test.txt” 的内容加载到指定的 <div> 元素中：</div></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#div1"</span>).load(<span class="string">"demo_test.txt"</span>);</span><br></pre></td></tr></table></figure><p>也可以把 jQuery 选择器添加到 URL 参数。<br>下面的例子把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的 <div> 元素中：</div></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#div1"</span>).load(<span class="string">"demo_test.txt #p1"</span>);</span><br></pre></td></tr></table></figure><p>可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：</p><ul><li><em>responseTxt</em> - 包含调用成功时的结果内容</li><li><em>statusTXT</em> - 包含调用的状态</li><li><em>xhr</em> - 包含 XMLHttpRequest 对象</li></ul><p>下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示”外部内容加载成功！”，而如果失败，则显示错误消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#div1"</span>).load(<span class="string">"demo_test.txt"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">responseTxt,statusTxt,xhr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(statusTxt==<span class="string">"success"</span>)</span><br><span class="line">      alert(<span class="string">"外部内容加载成功!"</span>);</span><br><span class="line">    <span class="keyword">if</span>(statusTxt==<span class="string">"error"</span>)</span><br><span class="line">      alert(<span class="string">"Error: "</span>+xhr.status+<span class="string">": "</span>+xhr.statusText);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-3-3-load方法的应用"><a href="#3-3-3-load方法的应用" class="headerlink" title="3.3.3 load方法的应用"></a>3.3.3 load方法的应用</h4><p>为了避免多页面情形下的代码重复，可以利用 load() 方法，将重复的部分（例如导航栏）放入单独的文件，使用下列方法进行导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.当前文件中要插入的地方使用此结构：</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"include"</span> file=<span class="string">"***.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.***.html中放入内容，用html格式仅仅因为会有编辑器的书写辅助。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.代码：</span></span><br><span class="line">$(<span class="string">".include"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!!$(<span class="keyword">this</span>).attr(<span class="string">"file"</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> $includeObj = $(<span class="keyword">this</span>);</span><br><span class="line">        $(<span class="keyword">this</span>).load($(<span class="keyword">this</span>).attr(<span class="string">"file"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">            $includeObj.after(html).remove(); <span class="comment">//加载的文件内容写入到当前标签后面并移除当前标签</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">或者在index文件里只写重复部分，剩下的一股脑放各自单独文件 load() 进来~</span><br></pre></td></tr></table></figure><h3 id="3-4-get-和-post-方法"><a href="#3-4-get-和-post-方法" class="headerlink" title="3.4 get() 和 post() 方法"></a>3.4 get() 和 post() 方法</h3><p>jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。</p><h4 id="3-4-1-HTTP-请求：GET-vs-POST"><a href="#3-4-1-HTTP-请求：GET-vs-POST" class="headerlink" title="3.4.1 HTTP 请求：GET vs. POST"></a>3.4.1 HTTP 请求：GET vs. POST</h4><p>GET 基本上用于从服务器获得（取回）数据。注释：<strong>GET 方法可能返回缓存数据</strong>。</p><p>POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。</p><h4 id="3-4-2-get-方法"><a href="#3-4-2-get-方法" class="headerlink" title="3.4.2 $.get() 方法"></a>3.4.2 $.get() 方法</h4><p>$.get() 方法通过 HTTP GET 请求从服务器上请求数据。</p><h5 id="3-4-2-1-语法"><a href="#3-4-2-1-语法" class="headerlink" title="3.4.2.1 语法:"></a>3.4.2.1 语法:</h5><p><strong>$.get(<em>URL</em>,<em>callback</em>);</strong></p><p>①: 必需的 <em>URL</em> 参数规定您希望<strong>请求的 URL</strong>。</p><p>②: 可选的 <em>callback</em> 参数是<strong>请求成功后所执行的函数名</strong>。</p><h5 id="3-4-2-2-下面的例子使用-get-方法从服务器上的一个文件中取回数据："><a href="#3-4-2-2-下面的例子使用-get-方法从服务器上的一个文件中取回数据：" class="headerlink" title="3.4.2.2 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据："></a>3.4.2.2 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.<span class="keyword">get</span>("demo_test.php",function(data,status)&#123;</span><br><span class="line">        alert(<span class="string">"数据: "</span> + data + <span class="string">"\n状态: "</span> + status);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>$.get() 的第一个参数是我们希望请求的 URL（”demo_test.php”）。<br>第二个参数是回调函数。第一个回调参数data存放服务器返回的数据，第二个回调参数status存放请求的处理状态。</p><h4 id="3-4-3-post-方法"><a href="#3-4-3-post-方法" class="headerlink" title="3.4.3 $.post() 方法"></a>3.4.3 $.post() 方法</h4><p>$.post() 方法通过 HTTP POST 请求向服务器提交数据。</p><h5 id="3-4-3-1-语法"><a href="#3-4-3-1-语法" class="headerlink" title="3.4.3.1 语法"></a>3.4.3.1 语法</h5><p><strong>$.post(<em>URL,data,callback</em>);</strong></p><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。</p><p>可选的 <em>data</em> 参数规定连同请求发送的数据。</p><p>可选的 <em>callback</em> 参数是请求成功后所执行的函数名。</p><h5 id="3-4-3-2-下面的例子使用-post-连同请求一起发送数据："><a href="#3-4-3-2-下面的例子使用-post-连同请求一起发送数据：" class="headerlink" title="3.4.3.2 下面的例子使用 $.post() 连同请求一起发送数据："></a>3.4.3.2 下面的例子使用 $.post() 连同请求一起发送数据：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.post(<span class="string">"/try/ajax/demo_test_post.php"</span>,</span><br><span class="line">           &#123;</span><br><span class="line">        name:<span class="string">"百度"</span>,</span><br><span class="line">        url:<span class="string">"http://www.baidu.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">           <span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"数据: \n"</span> + data + <span class="string">"\n状态: "</span> + status);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>$.post() 的第一个参数是我们希望请求的 URL (“demo_test_post.php”)。</p><p>第二个参数{name:”百度”,url:”<a href="http://www.baidu.com&quot;},是准备发送给服务器的数据" target="_blank" rel="noopener">http://www.baidu.com&quot;},是准备发送给服务器的数据</a></p><p>“demo_test_post.php” 中的 PHP 脚本读取这些参数，对它们进行处理，然后返回结果。</p><p>第三个参数是回调函数function。第一个回调参数data存放服务器返回的数据，而第二个参数status存放请求的处理状态。</p><h2 id="四、jQuery与CSS-HTML"><a href="#四、jQuery与CSS-HTML" class="headerlink" title="四、jQuery与CSS/HTML"></a>四、jQuery与CSS/HTML</h2><h3 id="4-1-获取并设置-CSS-类"><a href="#4-1-获取并设置-CSS-类" class="headerlink" title="4.1 获取并设置 CSS 类"></a>4.1 获取并设置 CSS 类</h3><p>jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些：</p><ul><li>addClass() - 向被选元素添加一个或多个类</li><li>removeClass() - 从被选元素删除一个或多个类</li><li>toggleClass() - 对被选元素进行添加/删除类的切换操作</li><li>css() - 设置或返回样式属性</li></ul><h4 id="4-1-1-addClass-方法"><a href="#4-1-1-addClass-方法" class="headerlink" title="4.1.1 addClass() 方法"></a>4.1.1 addClass() 方法</h4><h5 id="4-1-1-1-向不同的元素添加-class-属性。当然，在添加类时，您也可以选取多个元素如p-h1-h2："><a href="#4-1-1-1-向不同的元素添加-class-属性。当然，在添加类时，您也可以选取多个元素如p-h1-h2：" class="headerlink" title="4.1.1.1 向不同的元素添加 class 属性。当然，在添加类时，您也可以选取多个元素如p,h1,h2："></a>4.1.1.1 向不同的元素添加 class 属性。当然，在添加类时，您也可以选取多个元素如p,h1,h2：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="string">"h1,h2,p"</span>).addClass(<span class="string">"blue"</span>);</span><br><span class="line">                $(<span class="string">"div"</span>).addClass(<span class="string">"important"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;style type="text/</span>css<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            .important</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                font-weight:bold;</span></span><br><span class="line"><span class="string">                font-size:xx-large;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        .blue</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            color:blue;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        &lt;/style&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;h1&gt;标题 1&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;标题 2&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;这是另外一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;这是一些重要的文本!&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;为元素添加 class&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><p>当执行上述代码,然后点击button按钮前后,代码应该变化如下: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击前:</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;标题 <span class="number">1</span>&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;h2&gt;标题 2&lt;/</span>h2&gt;</span><br><span class="line">&lt;p&gt;这是一个段落。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;这是另外一个段落。&lt;/</span>p&gt;</span><br><span class="line">&lt;div&gt;这是一些重要的文本!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;br&gt;</span><br><span class="line">    &lt;button&gt;为元素添加 <span class="class"><span class="keyword">class</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">//点击后:</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"blue"</span>&gt;标题 <span class="number">1</span>&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;h2 class="blue"&gt;标题 2&lt;/</span>h2&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"blue"</span>&gt;这是一个段落。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="blue"&gt;这是另外一个段落。&lt;/</span>p&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"important"</span>&gt;这是一些重要的文本!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;br&gt;</span><br><span class="line">    &lt;button&gt;为元素添加 <span class="class"><span class="keyword">class</span>&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-1-1-2-也可以在-addClass-方法中规定多个类"><a href="#4-1-1-2-也可以在-addClass-方法中规定多个类" class="headerlink" title="4.1.1.2 也可以在 addClass() 方法中规定多个类"></a>4.1.1.2 也可以在 addClass() 方法中规定多个类</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"body div:first"</span>).addClass(<span class="string">"important blue"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-1-2-CSS-方法"><a href="#4-1-2-CSS-方法" class="headerlink" title="4.1.2 CSS() 方法"></a>4.1.2 CSS() 方法</h4><p>css() 方法设置或返回被选元素的一个或多个样式属性。</p><h5 id="4-1-2-1-返回-CSS-属性"><a href="#4-1-2-1-返回-CSS-属性" class="headerlink" title="4.1.2.1 返回 CSS 属性"></a>4.1.2.1 返回 CSS 属性</h5><h6 id="4-1-2-1-1-语法"><a href="#4-1-2-1-1-语法" class="headerlink" title="4.1.2.1.1 语法:"></a>4.1.2.1.1 语法:</h6><p><strong>css(“<em>propertyname</em>“);</strong></p><h6 id="4-1-2-1-2-下面的例子将返回首个匹配元素的-background-color-值："><a href="#4-1-2-1-2-下面的例子将返回首个匹配元素的-background-color-值：" class="headerlink" title="4.1.2.1.2 下面的例子将返回首个匹配元素的 background-color 值："></a>4.1.2.1.2 下面的例子将返回首个匹配元素的 background-color 值：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"background-color"</span>);</span><br></pre></td></tr></table></figure><h5 id="4-1-2-2-设置-CSS-属性"><a href="#4-1-2-2-设置-CSS-属性" class="headerlink" title="4.1.2.2 设置 CSS 属性"></a>4.1.2.2 设置 CSS 属性</h5><h6 id="4-1-2-2-1-语法"><a href="#4-1-2-2-1-语法" class="headerlink" title="4.1.2.2.1 语法:"></a>4.1.2.2.1 语法:</h6><p><strong>css(“<em>propertyname</em>“,”<em>value</em>“);</strong></p><h6 id="4-1-2-2-2-下面的例子将为所有匹配元素设置-background-color-值："><a href="#4-1-2-2-2-下面的例子将为所有匹配元素设置-background-color-值：" class="headerlink" title="4.1.2.2.2 下面的例子将为所有匹配元素设置 background-color 值："></a>4.1.2.2.2 下面的例子将为所有匹配元素设置 background-color 值：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"background-color"</span>,<span class="string">"yellow"</span>);</span><br></pre></td></tr></table></figure><h5 id="4-1-2-3-设置多个-CSS-属性"><a href="#4-1-2-3-设置多个-CSS-属性" class="headerlink" title="4.1.2.3 设置多个 CSS 属性"></a>4.1.2.3 设置多个 CSS 属性</h5><h6 id="4-1-2-3-1-语法"><a href="#4-1-2-3-1-语法" class="headerlink" title="4.1.2.3.1 语法:"></a>4.1.2.3.1 语法:</h6><p><strong>css({“<em>propertyname</em>“:”<em>value</em>“,”<em>propertyname</em>“:”<em>value</em>“,…});</strong></p><h6 id="4-1-2-2-2-下面的例子将为所有匹配元素设置-background-color-和-font-size："><a href="#4-1-2-2-2-下面的例子将为所有匹配元素设置-background-color-和-font-size：" class="headerlink" title="4.1.2.2.2 下面的例子将为所有匹配元素设置 background-color 和 font-size："></a>4.1.2.2.2 下面的例子将为所有匹配元素设置 background-color 和 font-size：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(&#123;<span class="string">"background-color"</span>:<span class="string">"yellow"</span>,<span class="string">"font-size"</span>:<span class="string">"200%"</span>&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、jQuery简介&quot;&gt;&lt;a href=&quot;#一、jQuery简介&quot; class=&quot;headerlink&quot; title=&quot;一、jQuery简介:&quot;&gt;&lt;/a&gt;一、jQuery简介:&lt;/h2&gt;&lt;h3 id=&quot;1-1-介绍&quot;&gt;&lt;a href=&quot;#1-1-介绍&quot; class
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zzwwqq.xyz/categories/jQuery/"/>
    
    
      <category term="jQuery基础" scheme="https://zzwwqq.xyz/tags/jQuery%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>各种排序算法</title>
    <link href="https://zzwwqq.xyz/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
    <id>https://zzwwqq.xyz/各种排序算法.html</id>
    <published>2019-06-02T14:15:24.000Z</published>
    <updated>2019-06-03T06:03:36.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常见排序算法"><a href="#一、常见排序算法" class="headerlink" title="一、常见排序算法"></a>一、常见排序算法</h2><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3n6nbujiaj30rq0dbdnw.jpg" alt></p><h2 id="二、记忆口诀-对应上面框出部分"><a href="#二、记忆口诀-对应上面框出部分" class="headerlink" title="二、记忆口诀(对应上面框出部分)"></a>二、记忆口诀(对应上面框出部分)</h2><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3n6dkp6f1j30t30he4aq.jpg" alt></p><h2 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h2><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3n6q60e4yj30hw07ggql.jpg" alt></p><p>它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><p>该方法的基本思想是：</p><ul><li>1．先从数列中取出一个数作为基准数。</li><li>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>3．再对左右区间重复第二步，直到各区间只有一个数。  </li></ul><p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：<strong>挖坑填数+分治法</strong>：</p><p>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。</p><p>以一个数组作为示例，取区间第一个数为<strong>基准数</strong>。—-&gt;X 存放基准数</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3n8xda5m1j30nc02kgli.jpg" alt></p><ul><li><p>初始时，i = 0;  j = 9;   X = a[i] = 72</p></li><li><p>由于已经将 a[0] 中的数保存到 X 中，可以理解成在数组 a[0] 上挖了个坑，可以将其它数据填充到这来。</p></li><li><p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p></li><li><p>数组变为：</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3n8xlcchxj30n202fwee.jpg" alt></p><ul><li><p>i = 3;   j = 7;   X=72</p></li><li><p>再重复上面的步骤，先从后向前找，再从前向后找。</p></li><li><p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p></li><li><p>从i开始向后找，当i=5时，由于i==j退出。</p></li><li><p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p></li><li><p>数组变为：</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3n8xv51e3j30n602iwee.jpg" alt></p><ul><li><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。  </p></li><li><p>对挖坑填数进行总结:</p></li><li><ul><li>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</li><li>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</li><li>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</li><li>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</li></ul></li><li><p>照着这个总结很容易实现挖坑填数的代码：</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、常见排序算法&quot;&gt;&lt;a href=&quot;#一、常见排序算法&quot; class=&quot;headerlink&quot; title=&quot;一、常见排序算法&quot;&gt;&lt;/a&gt;一、常见排序算法&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0064Bnm
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zzwwqq.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序算法" scheme="https://zzwwqq.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Web相关的面试题及答案</title>
    <link href="https://zzwwqq.xyz/Web%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html"/>
    <id>https://zzwwqq.xyz/Web相关的面试题及答案.html</id>
    <published>2019-06-02T12:36:14.000Z</published>
    <updated>2019-06-03T15:09:55.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-WEB应用中如果有-class和-jar类型的文件一般分别应该放在什么位置？"><a href="#1-WEB应用中如果有-class和-jar类型的文件一般分别应该放在什么位置？" class="headerlink" title="1. WEB应用中如果有.class和.jar类型的文件一般分别应该放在什么位置？"></a>1. WEB应用中如果有.class和.jar类型的文件一般分别应该放在什么位置？</h3><p>答:.class文件放在WEB-INF/classes文件下，.jar文件放在WEB-INF/lib文件夹下</p><h3 id="2-元素中有一个输入框（-lt-input-type-’text’-name-”username”id-”username”value-””-gt-请用JavaScript语言写一行代码，取得这个输入框中的值"><a href="#2-元素中有一个输入框（-lt-input-type-’text’-name-”username”id-”username”value-””-gt-请用JavaScript语言写一行代码，取得这个输入框中的值" class="headerlink" title="2. 元素中有一个输入框（&lt; input type=’text’ name=”username”id=”username”value=””/&gt;,请用JavaScript语言写一行代码，取得这个输入框中的值"></a>2. 元素中有一个输入框（&lt; input type=’text’ name=”username”id=”username”value=””/&gt;,请用JavaScript语言写一行代码，取得这个输入框中的值</h3><p>答:document.getElementById(“username”).value;</p><h3 id="3-简单描述一下Servlet与JSP的的相同点和区别点。"><a href="#3-简单描述一下Servlet与JSP的的相同点和区别点。" class="headerlink" title="3. 简单描述一下Servlet与JSP的的相同点和区别点。"></a>3. 简单描述一下Servlet与JSP的的相同点和区别点。</h3><p>区别：</p><p>JSP是在HTML代码里写JAVA代码,框架是HTML;</p><p>而<strong>Servlet是在JAVA代码中写HTML代码</strong>，本身是个JAVA类。</p><p>JSP使人们把显示和逻辑分隔成为可能，这意味着两者的开发可并行进行；而Servlet并没有把两者分开。</p><p>Servlet独立地处理静态表示逻辑与动态业务逻辑.这样,任何文件的变动都需要对此服务程序重新编译;JSP允许用特殊标签直接嵌入到HTML页面, HTML内容与JAVA内容也可放在单独文件中,HTML内容的任何变动会自动编译装入到服务程序.</p><p><strong>Servlet需要在web.xml中配置</strong>，而JSP无需配置</p><p>目前JSP主要用在视图层，负责显示，而<strong>Servlet主要用在控制层，负责调度</strong></p><p>联系：</p><p>都是Sun公司推出的<strong>动态网页技术。</strong></p><p><strong>先有Servlet，针对Servlet缺点推出JSP</strong>。JSP是Servlet的一种特殊形式，<strong>每个JSP页面就是一个Servlet实例</strong>——JSP页面由系统翻译成Servlet，Servlet再负责响应用户请求。</p><h3 id="4-请简单描述下几个您熟悉JavaScript库，它们有哪些作用和特点？"><a href="#4-请简单描述下几个您熟悉JavaScript库，它们有哪些作用和特点？" class="headerlink" title="4. 请简单描述下几个您熟悉JavaScript库，它们有哪些作用和特点？"></a>4. 请简单描述下几个您熟悉JavaScript库，它们有哪些作用和特点？</h3><p>JavaScript 高级程序设计（特别是对浏览器差异的复杂处理），通常很困难也很耗时。为了应对这些调整，许多的 JavaScript库应运而生。这些 JavaScript 库常被称为 JavaScript 框架。</p><p>jQuery:</p><p>Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet applications）。</p><p>Prototype</p><p>MooTools。</p><p>YUI - Yahoo! User Interface Framework，涵盖大量函数的大型库，从简单的 JavaScript 功能到完整的 internet widget。</p><h3 id="5-简单描述HTML，CSS，Javascript在Web开发中分别起什么作用？"><a href="#5-简单描述HTML，CSS，Javascript在Web开发中分别起什么作用？" class="headerlink" title="5. 简单描述HTML，CSS，Javascript在Web开发中分别起什么作用？"></a>5. 简单描述HTML，CSS，Javascript在Web开发中分别起什么作用？</h3><p>1、什么是HTML（超文本标记语言 Hyper Text Markup Language），HTML 是用来<strong>描述网页</strong>的一种语言。</p><p>2、CSS(层叠样式表 Cascading Style Sheets),样式<strong>定义如何显示 HTML 元素</strong>，</p><p>语法为：selector {property：value} 即(选择符 {属性：值})</p><p>3、JavaScript是一种脚本语言，其源代码在发往客户端运行之前<strong>不需经过编译</strong>，而是将文本格式的字符代码发送给浏览器由<strong>浏览器解释运行</strong></p><p>对于一个网页，<strong>HTML定义网页的结构</strong>，<strong>CSS描述网页的样子</strong>，JavaScript动作</p><p>设置一个很经典的例子是说HTML就像 一个人的骨骼、器官，而CSS就是人的皮肤，有了这两样也就构成了一个植物人了，加上javascript这个植物人就可以对外界刺激做出反应，可以思 考、运动、可以给自己整容化妆（改变CSS）等等，成为一个活生生的人。</p><p>如果说HTML是肉身、CSS就是皮相、Javascript就是灵魂。没有Javascript,HTML+CSS是植物人，没有Javascript、CSS是个毁容的植物人。</p><p>如果说HTML是建筑师，CSS就是干装修的，Javascript是魔术师。</p><h3 id="6-举例说明JAVA中如何解析xml，不同方式有和优缺点？"><a href="#6-举例说明JAVA中如何解析xml，不同方式有和优缺点？" class="headerlink" title="6. 举例说明JAVA中如何解析xml，不同方式有和优缺点？"></a>6. 举例说明JAVA中如何解析xml，不同方式有和优缺点？</h3><p>答：</p><h4 id="6-1-DOM（Document-Object-Model"><a href="#6-1-DOM（Document-Object-Model" class="headerlink" title="6.1  DOM（Document Object Model)"></a>6.1  DOM（Document Object Model)</h4><p>DOM是用<strong>与平台和语言无关</strong>的方式表示XML文档的官方W3C标准。DOM是<strong>以层次结构组织的节点或信息片断的集合</strong>。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是<strong>基于树或基于对象</strong>的。</p><p>【优点】</p><p>①允许应用程序对<strong>数据和结构做出更改</strong>。</p><p>②<strong>访问是双向的</strong>，可以在任何时候在树中上下导航，获取和操作任意部分的数据。</p><p>【缺点】</p><p>①通常需要<strong>加载整个XML文档来构造层次结构，消耗资源大</strong>。</p><h4 id="6-2-SAX（Simple-API-for-XML"><a href="#6-2-SAX（Simple-API-for-XML" class="headerlink" title="6.2  SAX（Simple API for XML)"></a>6.2  SAX（Simple API for XML)</h4><p>SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点。事实上，应用程序甚至不必解析整个文档；它可以在某个条件得到满足时停止解析。一般来说，SAX还比它的替代者DOM快许多。</p><p>选择DOM还是选择SAX？ 对于需要自己编写代码来处理XML文档的开发人员来说， 选择DOM还是SAX解析模型是一个非常重要的设计决策。<strong>DOM采用建立树形结构的方式访问XML文档，而SAX采用的是事件模型</strong>。</p><p>DOM解析器把XML文档转化为一个包含其内容的树，并可以对树进行遍历。用DOM解析模型的优点是编程容易，开发人员只需要调用建树的指令，然后利用navigation APIs访问所需的树节点来完成任务。可以很容易的添加和修改树中的元素。然而由于<strong>使用DOM解析器的时候需要处理整个XML文档，所以对性能和内存的要求比较高</strong>，尤其是遇到很大的XML文件的时候。由于它的遍历能力，<strong>DOM解析器常用于XML文档需要频繁的改变的服务中</strong>。</p><p>SAX解析器采用了基于事件的模型，它在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法指定的标签已经找到。<strong>SAX对内存的要求通常会比较低</strong>，因为它让开发人员自己来决定所要处理的tag.特别是当<strong>开发人员只需要处理文档中所包含的部分数据时</strong>，SAX这种扩展能力得到了更好的体现。但用SAX解析器的时候<strong>编码工作会比较困难</strong>，而且很难同时访问同一个文档中的多处不同数据。</p><p>【优势】</p><p>①<strong>不需要等待所有数据都被处理</strong>，分析就能立即开始。</p><p>②<strong>只在读取数据时检查数据</strong>，不需要保存在内存中。</p><p>③可以在某个条件得到满足时停止解析，<strong>不必解析整个文档</strong>。</p><p>④<strong>效率和性能较高</strong>，能解析大于系统内存的文档。</p><p>【缺点】</p><p>①需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），<strong>文档越复杂程序就越复杂</strong>。</p><p>②<strong>单向导航</strong>，<strong>无法定位文档层次</strong>，很难同时访问同一文档的不同部分数据，不支持XPath。</p><h4 id="6-3-JDOM-Java-based-Document-Object-Model"><a href="#6-3-JDOM-Java-based-Document-Object-Model" class="headerlink" title="6.3 JDOM(Java-based Document Object Model)"></a>6.3 JDOM(Java-based Document Object Model)</h4><p>JDOM的目的是成为<strong>Java特定文档模型</strong>，它简化与XML的交互并且比使用DOM实现更快。由于是第一个Java特定模型，JDOM一直得到大力推广和促进。正在考虑通过“Java规范请求JSR-102”将它最终用作“Java标准扩展”。从2000年初就已经开始了JDOM开发。</p><p>JDOM与DOM主要有两方面不同。首先，<strong>JDOM仅使用具体类而不使用接口</strong>。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。</p><p>JDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题”（根据学习曲线假定为20%）。JDOM对于大多数Java/XML应用程序来说当然是有用的，并且大多数开发者发现API比DOM容易理解得多。JDOM还包括对程序行为的相当广泛检查以防止用户做任何在XML中无意义的事。然而，它仍需要您充分理解XML以便做一些超出基本的工作（或者甚至理解某些情况下的错误）。这也许是比学习DOM或JDOM接口都更有意义的工作。</p><p><strong>JDOM自身不包含解析器</strong>。它通常<strong>使用SAX2解析器来解析和验证输入XML文档</strong>（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。</p><p>【优点】</p><p>①使用具体类而不是接口，<strong>简化了DOM的API</strong>。</p><p>②<strong>大量使用了Java集合类</strong>，方便了Java开发人员。</p><p>【缺点】</p><p>①没有较好的灵活性。</p><p>②性能较差。</p><h4 id="6-4-DOM4J-Document-Object-Model-for-Java"><a href="#6-4-DOM4J-Document-Object-Model-for-Java" class="headerlink" title="6.4 DOM4J(Document Object Model for Java)"></a>6.4 DOM4J(Document Object Model for Java)</h4><p>虽然DOM4J代表了完全独立的开发结果，但最初，它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过DOM4J API和标准DOM接口具有并行访问功能。从2000下半年开始，它就一直处于开发之中。</p><p>为支持所有这些功能，DOM4J使用接口和抽象基本类方法。DOM4J大量使用了API中的Collections类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然DOM4J付出了更复杂的API的代价，但是它提供了比JDOM大得多的灵活性。</p><p>在添加灵活性、XPath集成和对大文档处理的目标时，DOM4J的目标与JDOM是一样的：针对Java开发者的易用性和直观操作。它还致力于成为比JDOM更完整的解决方案，实现在本质上处理所有Java/XML问题的目标。在完成该目标时，它比JDOM更少强调防止不正确的应用程序行为。</p><p>DOM4J是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML，特别值得一提的是连Sun的JAXM也在用DOM4J.</p><p>【优点】</p><p>①<strong>大量使用了Java集合类</strong>，方便Java开发人员，同时提供一些提高性能的<strong>替代方法</strong>。</p><p>②<strong>支持XPath</strong>。</p><p>③有很好的<strong>性能</strong>。</p><p>【缺点】</p><p>①大量使用了接口，<strong>API较为复杂</strong>。</p><h4 id="6-5-比较"><a href="#6-5-比较" class="headerlink" title="6.5 比较"></a>6.5 比较</h4><p>\1. DOM4J性能最好，连Sun的JAXM也在用DOM4J。目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的Hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J.</p><p>\2. JDOM和DOM在性能测试时表现不佳，在测试10M文档时内存溢出，但可移植。在小文档情况下还值得考虑使用DOM和JDOM.虽然JDOM的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM仍是一个非常好的选择。DOM实现广泛应用于多种编程语言。它还是许多其它与XML相关的标准的基础，因为它正式获得W3C推荐（与基于非标准的Java模型相对），所以在某些类型的项目中可能也需要它（如在JavaScript中使用DOM）。</p><p>\3. SAX表现较好，这要依赖于它特定的解析方式－事件驱动。一个SAX检测即将到来的XML流，但并没有载入到内存（当然当XML流被读入时，会有部分文档暂时隐藏在内存中）。</p><h4 id="6-6-我的看法："><a href="#6-6-我的看法：" class="headerlink" title="6.6 我的看法："></a>6.6 我的看法：</h4><p>如果<strong>XML文档较大且不考虑移植性问题建议采用DOM4J</strong>；如果<strong>XML文档较小则建议采用JDOM</strong>；<br>如果<strong>需要及时处理而不需要保存数据则考虑SAX</strong>。<br>但无论如何，还是那句话：适合自己的才是最好的，如果时间允许，建议大家讲这四种方法都尝试一遍然后选择一种适合自己的即可。</p><h3 id="7-char型变量中能不能存储一个中文汉字？"><a href="#7-char型变量中能不能存储一个中文汉字？" class="headerlink" title="7. char型变量中能不能存储一个中文汉字？"></a>7. char型变量中能不能存储一个中文汉字？</h3><p>答：1.java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</p><p>2.char 在java中是2个字节，所以可以存储中文</p><h3 id="8-接口与抽象类"><a href="#8-接口与抽象类" class="headerlink" title="8. 接口与抽象类"></a>8. 接口与抽象类</h3><p>一个类可以实现多个接口，但只能继承一个抽象类。</p><p>下面接着再说说两者在应用上的区别：</p><p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> classBaseServlet extends HttpServlet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException       </span>&#123;</span><br><span class="line">            记录访问日志</span><br><span class="line">            进行权限判断</span><br><span class="line">            <span class="keyword">if</span>(具有权限)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    doService(request,response);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Excetpion e)  &#123;</span><br><span class="line">                    记录异常信息</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException</span>;</span><br><span class="line">    <span class="comment">//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet1</span> <span class="title">extendsBaseServlet</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">voiddoService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> throwsIOExcetion,ServletException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        本Servlet只处理的具体业务逻辑代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。</p><p>备注：这道题的思路是先从总体解释抽象类和接口的<strong>基本概念</strong>，然后再比较两者的<strong>语法细节</strong>，最后再说两者的<strong>应用区别</strong>。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。</p><h3 id="9-比较一下Java-和JavaSciprt"><a href="#9-比较一下Java-和JavaSciprt" class="headerlink" title="9. 比较一下Java 和JavaSciprt"></a>9. 比较一下Java 和JavaSciprt</h3><p>答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</p><p>下面对两种语言间的异同作如下比较：</p><p>1）<strong>基于对象和面向对象</strong>：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</p><p>2）<strong>解释和编译</strong>：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</p><p>3）<strong>强类型变量和弱类型变量</strong>：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</p><p>4）代码格式不一样。</p><p>补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是<strong>一个是静态语言</strong>，<strong>一个是动态语言</strong>。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</p><h3 id="10-UML是什么？UML中有哪些图？"><a href="#10-UML是什么？UML中有哪些图？" class="headerlink" title="10. UML是什么？UML中有哪些图？"></a>10. UML是什么？UML中有哪些图？</h3><p>答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。</p><p>在这些图形化符号中，有三种图最为重要:分别是：</p><p>①: 用例图（用来<strong>捕获需求，描述系统的功能</strong>，通过该图可以迅速的了解系统的功能模块及其关系）</p><p>②: 类图（描述类以及<strong>类与类之间的关系</strong>，通过该图可以快速了解系统）</p><p>③: 时序图（描述执行特定任务时<strong>对象之间的交互关系以及执行顺序</strong>，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</p><h3 id="11-XML-文档定义有几种形式？它们之间有何本质区别？解析XML-文档有哪几种方式？"><a href="#11-XML-文档定义有几种形式？它们之间有何本质区别？解析XML-文档有哪几种方式？" class="headerlink" title="11. XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？"></a>11. XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？</h3><p>答： XML文档定义分为DTD和Schema两种形式；</p><p>其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析。</p><p>对XML的解析主要有DOM（文档对象模型）、SAX、StAX（JDK 1.6中引入的新的解析XML的方式，Streaming API for XML） 等，其中<strong>DOM处理大型文件时其性能下降</strong>的非常厉害，这个问题是由<strong>DOM 的树结构</strong>所造成的，这种结构占用的内存较多，而且<strong>DOM 必须在解析文件之前把整个文档装入内存,适合对XML 的随机访问</strong>（典型的用空间换取时间的策略）；<strong>SAX是事件驱动型的XML解析方式</strong>，<strong>它顺序读取XML文件，不需要一次全部装载整个文件</strong>。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，<strong>适合对XML 的顺序访问</strong>；如其名称所暗示的那样，StAX把重点放在流上。实际上，StAX与其他方法的区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（事实上 SAX 已经提出来了），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 </p><h3 id="12-你在项目中哪些地方用到了XML？"><a href="#12-你在项目中哪些地方用到了XML？" class="headerlink" title="12. 你在项目中哪些地方用到了XML？"></a>12. 你在项目中哪些地方用到了XML？</h3><p>答： XML的主要作用有两个方面：<strong>数据交换</strong>（曾经被称为业界数据交换的事实标准，现在此项功能在很多时候都被JSON取代）和<strong>信息配置</strong>。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理。目前很多软件都使用XML来存储配置信息，很多项目中我们通常也会<strong>将作为配置的硬代码（hard code）写在XML文件中</strong>，Java的很多框架也是这么做的。 </p><h3 id="13-用JavaScript实现用正则表达式验证，某个字符串是合法的6位数字的邮编的函数"><a href="#13-用JavaScript实现用正则表达式验证，某个字符串是合法的6位数字的邮编的函数" class="headerlink" title="13. 用JavaScript实现用正则表达式验证，某个字符串是合法的6位数字的邮编的函数"></a>13. 用JavaScript实现用正则表达式验证，某个字符串是合法的6位数字的邮编的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> testE(ss)&#123;</span><br><span class="line">    <span class="comment">//在正则表达式中，/顺斜杠是表示表达式的开始和结束的“定界符”。\反斜杠是表示转义字符。</span></span><br><span class="line">    <span class="comment">//其中^匹配输入字符串的开始位置,$匹配输入字符串的结束位置 </span></span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/^[1-9][0-9]&#123;5&#125;$/</span>;</span><br><span class="line">    <span class="keyword">if</span>(req.test(ss))&#123; <span class="comment">//这里调用JavaScript已有的test函数</span></span><br><span class="line">        alert(“邮编OK”)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(“邮编格式不正确”)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-请使用JQuery将页面上的所有元素边框设置为2pix宽的虚线？"><a href="#14-请使用JQuery将页面上的所有元素边框设置为2pix宽的虚线？" class="headerlink" title="14. 请使用JQuery将页面上的所有元素边框设置为2pix宽的虚线？"></a>14. 请使用JQuery将页面上的所有元素边框设置为2pix宽的虚线？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指定名称的样式使用带一个参数css方法,如果要修改指定名称的样式,则使用带两个参数的css方法</span></span><br><span class="line"><span class="comment">//*是通配符</span></span><br><span class="line">$(<span class="string">"*"</span>).css(<span class="string">"border"</span>,<span class="string">"2px dashed"</span>);</span><br></pre></td></tr></table></figure><h3 id="15-如何设定JQuery异步调用还是同步调用？"><a href="#15-如何设定JQuery异步调用还是同步调用？" class="headerlink" title="15. 如何设定JQuery异步调用还是同步调用？"></a>15. 如何设定JQuery异步调用还是同步调用？</h3><p>答案：调用jQuery中的ajax函数，设置其async属性来表明是异步还是同步，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="keyword">async</span>:<span class="literal">true</span><span class="comment">//表示异步，false表示同步</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="16-说出3条以上firefox和IE的浏览器兼容问题？"><a href="#16-说出3条以上firefox和IE的浏览器兼容问题？" class="headerlink" title="16. 说出3条以上firefox和IE的浏览器兼容问题？"></a>16. 说出3条以上firefox和IE的浏览器兼容问题？</h3><p>答案：</p><p>IE下,可以使用()或[]获取集合类对象; Firefox下,只能使用[]获取集合类对象. ——&gt;解决方法:<strong>统一使用[ ]获取集合类对象.</strong></p><p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性.——–&gt;解决方法:<strong>统一通过getAttribute()获取自定义属性</strong></p><h3 id="17-请用Jquery语言写出ajax请求或者post请求代码"><a href="#17-请用Jquery语言写出ajax请求或者post请求代码" class="headerlink" title="17. 请用Jquery语言写出ajax请求或者post请求代码"></a>17. 请用Jquery语言写出ajax请求或者post请求代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.post(&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="18-jQuery中有哪几种类型的选择器？"><a href="#18-jQuery中有哪几种类型的选择器？" class="headerlink" title="18. .jQuery中有哪几种类型的选择器？"></a>18. .jQuery中有哪几种类型的选择器？</h3><p>答案：</p><p>基本选择器</p><p>层次选择器</p><p>基本过滤选择器</p><p>内容过滤选择器</p><p>可见性过滤选择器</p><p>属性过滤选择器</p><p>子元素过滤选择器</p><p>表单选择器</p><p>表单过滤选择器</p><h3 id="19-body中的onload-（）函数和jQuery中document-ready-有什么区别？"><a href="#19-body中的onload-（）函数和jQuery中document-ready-有什么区别？" class="headerlink" title="19. body中的onload （）函数和jQuery中document.ready()有什么区别？"></a>19. body中的onload （）函数和jQuery中document.ready()有什么区别？</h3><p>答案：ready 事件的触发，表示<strong>文档结构已经加载完成</strong>（<strong>不包含图片等非文字媒体文件</strong>）</p><p>onload 事件的触发，表示页面<strong>包含图片</strong>等文件在内的<strong>所有元素都加载完成</strong>。</p><h3 id="20-请用Jquery语言写出ajax请求或者post请求代码"><a href="#20-请用Jquery语言写出ajax请求或者post请求代码" class="headerlink" title="20. 请用Jquery语言写出ajax请求或者post请求代码"></a>20. 请用Jquery语言写出ajax请求或者post请求代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.post(“show”,&#123;uname=”张三”，pwd=”<span class="number">123</span>”&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="21-分别写出一个div居中和其中的内容居中的css属性设置"><a href="#21-分别写出一个div居中和其中的内容居中的css属性设置" class="headerlink" title="21. 分别写出一个div居中和其中的内容居中的css属性设置"></a>21. 分别写出一个div居中和其中的内容居中的css属性设置</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    margin: auto,0px; //Div居中：</span><br><span class="line">    text-align: center;//内容居中:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-概述一下session与cookie的区别"><a href="#22-概述一下session与cookie的区别" class="headerlink" title="22. 概述一下session与cookie的区别"></a>22. 概述一下session与cookie的区别</h3><p>答案：</p><p><strong>①: 存储角度：</strong></p><p><strong>Session是服务器端</strong>的数据存储技术，cookie是客户端的数据存储技术</p><p><strong>②: 解决问题角度：</strong></p><p>Session解决的是<strong>一个用户不同请求</strong>的数据共享问题，cookie解决的是<strong>不同请求的请求</strong>数据的共享问题</p><p><strong>③: 生命周期角度：</strong></p><p>Session的id是依赖于cookie来进行存储的，<strong>浏览器关闭id就会失效</strong></p><p>Cookie可以单独的设置其在浏览器的存储时间。</p><h3 id="23-JavaScript-中-null和-undefined-是否有区别？有哪些区别？"><a href="#23-JavaScript-中-null和-undefined-是否有区别？有哪些区别？" class="headerlink" title="23. JavaScript 中 null和 undefined 是否有区别？有哪些区别？"></a>23. JavaScript 中 null和 undefined 是否有区别？有哪些区别？</h3><p>答案：</p><p><strong>①: 赋值角度说明：</strong></p><p>null 表示此处没有值，undefined表示<strong>此处定义了但是没有赋值</strong></p><p><strong>②: 从数据转换角度：</strong></p><p>Null在做数值转换时会被转换为0，<strong>undefined会被转换为NaN</strong></p><h3 id="23-Servlet中的doPost和doGet方法有什么区别-它们在传递和获取参数上有什么区别？"><a href="#23-Servlet中的doPost和doGet方法有什么区别-它们在传递和获取参数上有什么区别？" class="headerlink" title="23. Servlet中的doPost和doGet方法有什么区别?它们在传递和获取参数上有什么区别？"></a>23. Servlet中的doPost和doGet方法有什么区别?它们在传递和获取参数上有什么区别？</h3><p>答案：</p><p>区别：doPost用来处理post请求，doGet用来处理get请求，获取参数：获取的参数是相同的都是HttpServletRequest \HttpServletResponse</p><h3 id="24-请写出一段jQuery代码，实现把当前页面中所有的a元索中class-属性为“view-link”的链接都改为在新窗口中打开"><a href="#24-请写出一段jQuery代码，实现把当前页面中所有的a元索中class-属性为“view-link”的链接都改为在新窗口中打开" class="headerlink" title="24. 请写出一段jQuery代码，实现把当前页面中所有的a元索中class 属性为“view-link”的链接都改为在新窗口中打开"></a>24. 请写出一段jQuery代码，实现把当前页面中所有的a元索中class 属性为“view-link”的链接都改为在新窗口中打开</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"a[class = view-link]"</span>).prop(<span class="string">"target"</span>,<span class="string">"_blank"</span>)</span><br><span class="line">或者: $(<span class="string">"a[class = view-link]"</span>).attr(<span class="string">"target"</span>,<span class="string">"_blank"</span>)</span><br><span class="line">或者: $(<span class="string">"a.view-link]"</span>).attr(<span class="string">"target"</span>,<span class="string">"_blank"</span>)</span><br></pre></td></tr></table></figure><h3 id="25-Jquery中’-get-’与’-eq-’的区别"><a href="#25-Jquery中’-get-’与’-eq-’的区别" class="headerlink" title="25. Jquery中’.get()’与’.eq()’的区别"></a>25. Jquery中’.get()’与’.eq()’的区别</h3><p>答: eq返回的是一个jquery对象 get返回的是一个html对象</p><h3 id="26-TCP为何采用三次握手来建立连接，若釆用二次握手可以吗，请说明理由？"><a href="#26-TCP为何采用三次握手来建立连接，若釆用二次握手可以吗，请说明理由？" class="headerlink" title="26. TCP为何采用三次握手来建立连接，若釆用二次握手可以吗，请说明理由？"></a>26. TCP为何采用三次握手来建立连接，若釆用二次握手可以吗，请说明理由？</h3><p>答: 三次握手是为了防止已失效的连接请求再次传送到服务器端,让服务器错误打开连接。</p><p> 二次握手不可行，因为：如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到重传的请求连接后(每收到一个请求就打开一个连接)，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费</p><h3 id="27-以下HTTP相应状态码的含义描述正确的是（）"><a href="#27-以下HTTP相应状态码的含义描述正确的是（）" class="headerlink" title="27. 以下HTTP相应状态码的含义描述正确的是（）"></a>27. 以下HTTP相应状态码的含义描述正确的是（）</h3><table><thead><tr><th>A.</th><th>200ok表示请求成功</th></tr></thead><tbody><tr><td>B.</td><td>400不良请求表示服务器未发现与请求URL匹配内容</td></tr><tr><td>C.</td><td>404未发现表示由于语法错误而导致服务器无法理解请求信息</td></tr><tr><td>D.</td><td>500内部服务器错误，无法处理请求</td></tr><tr><td>答案：D<br>分析：<br>A <strong>200ok 表示的意思是一切正常</strong>。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。<br>B 400 表示指出客户端请求中的语法错误<br>C 404 客户端所给的地址无法找到任何资源</td></tr></tbody></table><h3 id="28-JSP的三大指令"><a href="#28-JSP的三大指令" class="headerlink" title="28 JSP的三大指令"></a>28 JSP的三大指令</h3><p>①: page指令<br>实例：&lt;%@ page language=”java” import=”java.util.<em>” pageEncoding=”UTF-8”%&gt;<br>import：等同与import语句<br>&lt;%@ page import=”java.util.</em>” %&gt;<br>&lt;%@ page import=”java.util., java.net.” %&gt;<br>在一个JSP页面中可以给出多个page指令，而且import是可以重复出现的<br>&lt;%@ page import=”java.util.<em>” %&gt;<br>&lt;%@ page import=”java.next.</em>” %&gt;</p><p>pageEncoding：指定当前页面的编码<br>如果pageEncoding没有指定，那么默认为contentType的值；<br>如果pageEncoding和contentType都没有指定，那么默认值为iso-8859-1</p><p>contentType：等同与调用response.setContentType(“text/html;charset=xxx”);<br>如果没有指定contentType属性，那么默认为pageEncoding的值；<br>如果contentType和pageEncoding都没有指定，那么默认值为iso-8859-1</p><p>errorPage：如果当前页面出现异常，那么跳转到errorPage指定的jsp页面。<br>例如：&lt;%@ page errorPage=”b.jsp” %&gt;<br>isErrorPage：上面示例中指定b.jsp为错误页面，但在b.jsp中不能使用内置对象exception，保有b.jsp中使用&lt;%@page isErrorPage=”true”%&gt;时，才能在b.jsp中使用错误页面。<br>autoFlush：当autoFlush为true时，表示out流缓冲区满时会自动刷新。默认为true<br>buffer：指定out流的缓冲区大小，默认为8KB<br>isELIgnored：当前JSP页面是否忽略EL表达式，默认为false，表示不忽略，即支持EL表达式</p><p><strong>page指令不常用的属性： </strong><br>language：当前JSP编译后的语言！默认为java，当前也只能选择java<br>info：当前JSP的说明信息<br>isThreadSafe：当前JSP是否执行只能单线程访问，默认为false，表示支持并发访问<br>session：当前页面是否可以使用session，默认为false，表示支持session的使用。<br>extends：指定JSP编译的servlet的父类！ </p><p>②: <strong>include指令</strong></p><p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。<br>Include指令的语法格式如下：<br>&lt;%@ include file=”文件相对 url 地址” %&gt;</p><p>③: <strong>taglib指令</strong></p><p>taglib指令是用来在当前jsp页面中导入第三方的标签库<br>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core”" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core”</a> % prefix=”c” &gt;<br>prefix：指定标签前缀，这个东西可以随意起名<br>uri：指定第三方标签库的uri（唯一标识） </p><p>当然，需要先把第三方标签库所需jar包放到类路径中。</p><h3 id="29-JSP的-7种页面元素"><a href="#29-JSP的-7种页面元素" class="headerlink" title="29. JSP的 7种页面元素"></a>29. JSP的 7种页面元素</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o6ikpwgqj30hw0b1abe.jpg" alt></p><p><strong>口诀: 禁止不要动,猪叫声.</strong></p><p><strong>静</strong>态内容—-&gt;禁<br><strong>指</strong>令—-&gt;止<br><strong>表</strong>达式—&gt;不要<br><strong>动</strong>作—-&gt;动<br><strong>注</strong>释—–&gt;猪<br><strong>脚</strong>本—–&gt;叫<br><strong>声</strong>明——&gt;声</p><h4 id="29-1-JSP指令："><a href="#29-1-JSP指令：" class="headerlink" title="29.1 JSP指令："></a>29.1 JSP指令：</h4><p>①: page指令：通常位于Jsp页面的顶端，同一个页面可以有多个page指令。</p><p>例如: &lt;%@page language=”java”  important=”java.util.*”  contentType=”text/html;charset=utf-8”%&gt;</p><p>②: include指令：将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。</p><p><strong>语法：&lt;%@include file=”URL”&gt;</strong></p><p>③: taglib指令：使用标签库定义新的自定义标签，在JSP页面中启用定制行为。</p><h4 id="29-2注释"><a href="#29-2注释" class="headerlink" title="29.2注释"></a>29.2注释</h4><p>①: HTML的注释：<!--html注释-->                               //客户端可见【查看网页源代码的时候可见】</p><p>②: JSP的注释：&lt;%–JSP注释–%&gt;                             //客户端不可见</p><p>③: JSP脚本【注意：&lt;% JSP脚本%&gt;】注释： 【客户端不可见】         //   单行注释        /<em> </em>/ 多行注释</p><h4 id="29-3-JSP脚本："><a href="#29-3-JSP脚本：" class="headerlink" title="29.3 JSP脚本："></a>29.3 JSP脚本：</h4><p>在JSP页面中执行的java代码</p><p><strong>语法：&lt;% java代码 %&gt;</strong></p><h4 id="29-4-JSP表达式："><a href="#29-4-JSP表达式：" class="headerlink" title="29.4 JSP表达式："></a>29.4 JSP表达式：</h4><p>在JSP页面中执行的表达式</p><p><strong>语法：&lt;%= 表达式 %&gt;</strong>    <strong>注意：表达式不以分号结束 </strong>                                                                          </p><h4 id="29-5-JSP声明："><a href="#29-5-JSP声明：" class="headerlink" title="29.5 JSP声明："></a>29.5 JSP声明：</h4><p>在JSP页面中定义变量或者方法</p><p><strong>语法：&lt;%!  java代码 %&gt;</strong></p><h4 id="29-6-动作"><a href="#29-6-动作" class="headerlink" title="29.6 动作"></a>29.6 动作</h4><p><strong>例如: &lt;jsp:include page=”Filename” &gt; </strong>       在jsp页面中包含另一个页面。</p><h4 id="29-7-静态内容"><a href="#29-7-静态内容" class="headerlink" title="29.7 静态内容"></a>29.7 静态内容</h4><p>就是html,css,javascript等内容</p><p><strong>注: &lt;%=%&gt; 不需要分号结尾，&lt;%%&gt; 需要以分号结尾，和java代码一样</strong></p><h3 id="30-JSP的九大内置对象"><a href="#30-JSP的九大内置对象" class="headerlink" title="30. JSP的九大内置对象"></a>30. JSP的九大内置对象</h3><p>答案：</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3o7hhrp0hj30mb0br422.jpg" alt></p><p>①: request对象</p><p>request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。</p><p>request对象的作用域为一次请求。</p><p>request对象的常用方法如下：<br>1　　 object getAttribute(String name) 　　返回指定属性的属性值<br>2 　　Enumeration getAttributeNames() 　　 返回所有可用属性名的枚举<br>3　　String getCharacterEncoding() 　　返回字符编码方式<br>4　　 int getContentLength() 　　返回请求体的长度(以字节数)<br>5　　 String getContentType() 　　得到请求体的MIME类型<br>6　　 ServletInputStream getInputStream()　　 得到请求体中一行的二进制流<br>7 　　String getParameter(String name) 　　返回name指定参数的参数值<br>8　　 Enumeration getParameterNames()　　 返回可用参数名的枚举<br>9 　　String[] getparameterValues(String name) 　　 返回包含参数name的所有值的数组<br>10　　 String getProtocol() 　　返回请求用的协议类型及版本号<br>11　　 String getScheme() 　　返回请求用的计划名,如:http https及ftp等<br>12 　　int getServerPort() 　　返回服务器接受此请求所用的端口号<br>13　　 String getServerName() 　　 返回接受请求的服务器主机名<br>14 　　BufferedReader getReader() 　　 返回解码过了的请求体<br>15 　　String getRemoteAddr() 　　 返回发送此请求的客户端IP地址<br>16 　　String getRemoteHost() 　　返回发送此请求的客户端主机名<br>17 　　void setAttribute(String key Object obj) 　　设置属性的属性值<br>18　　 String getRealPath(String path) 　　返回一虚拟路径的真实路径<br>19 　　void setCharacterEncoding(“gb2312”) 　　设置接受参数的字符集</p><p>②: response对象</p><p>隐藏对象response是javax.servlet.ServletResponse类的实例，response 代表的是对客户端的响应，服务器端的任何输出都通过response对象发送到客户端浏览器。主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。</p><p>每次服务器端都会响应一个response实例。</p><p>response对象的常用方法如下：<br>1 　　String getCharacterEncoding() 　　 返回响应用的是何种字符编码<br>2 　　ServletOutputStream getOutputStream() 　　返回响应的一个二进制输出流<br>3 　　PrintWriter getWriter() 　　返回可以向客户端输出字符的一个对象<br>4 　　 void setContentLength(int len) 　　设置响应头长度<br>5　　 void setContentType(String type) 　　设置响应的MIME类型<br>6 　　sendRedirect(java.lang.String location) 　　重新定向客户端的请求<br>7 　　void setCharacterEncoding(“gb2312”) 　　设置响应头的字符集</p><p>③: session对象</p><p>隐藏对象session是javax.servlet.http.HttpSession类的实例。<strong>session 对象是由服务器自动创建的</strong>与用户请求相关的对象。<strong>服务器为每个用户都生成一个session对象</strong>，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用<strong>Map类来保存数据</strong>，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。</p><p>session与cookie是记录客户访问信息的两种机制，<strong>session是用于服务器端保存用户信息，cookie用于在客户端保存用户信息</strong>。Servlet中通过request.getSession()来获取session对象，而JSP中可以直接使用。</p><p>如果JSP中配置了<strong>&lt;%@page session=”false”%&gt;</strong>,则隐藏对象session不可用。<strong>每个用户对应一个session对象</strong>。  <strong>session对象的常用方法如下: </strong><br>1　　 long getCreationTime() 　　返回Session创建时间<br>2 　　public String getId() 　　返回Session创建时JSP引擎为它设的唯一ID号<br>3 　　long getLastAccessedTime() 　　返回此Session里客户端最近一次请求时间<br>4　　 int getMaxInactiveInterval()　　 返回两次请求间隔多长时间此Session被取消(ms)<br>5　　 String[] getValueNames() 　　返回一个包含此Session中所有可用属性的数组<br>6　　 void invalidate() 　取消Session,使Session不可用<br>7 　　boolean isNew() 　　返回服务器创建的一个Session,客户端是否已经加入<br>8 　　void removeValue(String name) 　　删除Session中指定的属性<br>9　　 void setAttribute(String key,Object obj) 　　设置Session的属性<br>10　Object getAttribute(String name)　　 返回session中属性名为name的对象</p><p>④: application对象</p><p>隐藏对象application是javax.servlet.ServletContext类的对象。 <strong>application 对象可将信息保存在服务器中</strong>，<strong>直到服务器关闭</strong>，否则application对象中保存的信息会在整个应用中都有效。<strong>与session对象相比，application对象生命周期更长</strong>，<strong>类似于系统的“全局变量”</strong>。</p><p>application封装JSP所在Web应用程序的信息，例如web.xml中国配置的全局的初始化信息。Servlet中application对象需要通过ServletConfig.getServletContext()来获取。<strong>整个Web应用程序对应一个application对象</strong>。</p><p><strong>application对象常用的方法如下：</strong><br>1,　　Object getAttribute(String name)　　返回application中属性为name的对象<br>2，　　Enumeration getAttributeNames() 　　返回application中的所有属性名<br>3，　　void setAttribute(String name,Object value)　　设置application属性<br>4，　　void removeAttribute(String name) 　　移除application属性<br>5，　　String getInitParameter(String name)　　返回全局初始话函数<br>6，　　Enumeration getInitParameterNames(）　　返回所有的全局初始话参数<br>7，　　String getMimeType(String filename)　　返回文件的文档类型，例如getMimeType(“abc.html”)将返回“text.html”<br>8，　　String getRealPath(String relativePath）　　返回Web应用程序内相对网址对应的绝对路径</p><p>⑤: out 对象</p><p>隐藏对象out是javax.servlet.jsp.JspWriter类的实例. Servlet 和JSP中输出数据都需要使用out对象。Servlet 中的out对象是通过getWriter()方法获取的。而JSP中没有定义out对象却可以直接使用。这是因为out是JSP的内置隐藏对象。</p><p>out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。<br>服务器向客户输出的字符内容可以通过out对象输出。获取方法： PrintWriter out = response.getWriter();</p><p><strong>out对象常用的方法如下： </strong><br>①: void clear() 　　清除缓冲区的内容<br>②: void clearBuffer() 　　清除缓冲区的当前内容<br>③: void flush() 　　将缓冲内容flush到客户端浏览器<br>④: int getBufferSize() 　　返回缓冲大小，单位KB<br>⑤: int getRemaining() 　　返回缓冲剩余大小，单位KB<br>⑥: isAutoFlush() 　　返回缓冲区满时,是自动清空还是抛出异常<br>⑦: void close() 　　 关闭输出流</p><p>⑥: pageContext 对象</p><p>隐藏对象pageContext为javax.servlet.jsp.PageContext类的实例。pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。</p><p>pageContext对象代表当前JSP页面编译后的内容。通过pageContext能够获取到JSP中的资源。</p><p><strong>pageContext常用方法如下： </strong><br>1 　　 JspWriter getOut() 　　返回out对象<br>2 　　 HttpSession getSession() 　　 返回Session对象(session)<br>3 　　 Object getPage() 　　返回page对象<br>4 　　 ServletRequest getRequest() 　　 返回request对象<br>5 　　 ServletResponse getResponse() 　　 返回response对象<br>6 　　 void setAttribute(String name,Object attribute) 　　　设置属性及属性值 ，在page范围内有效<br>7 　　 void setAttribute(String name,Object obj,int scope)　在指定范围内设置属性及属性值 ，int1=page,2=request,3=session,4=application<br>8 　　public Object getAttribute(String name) 　　取属性的值<br>9　　 Object getAttribute(String name,int scope) 　　在指定范围内取属性的值<br>10　　 public Object findAttribute(String name) 　　寻找一属性,返回起属性值或NULL<br>11 　　void removeAttribute(String name) 　　删除某属性<br>12 　　void removeAttribute(String name,int scope) 　　 在指定范围删除某属性<br>13　　 int getAttributeScope(String name)　　 返回某属性的作用范围<br>14　　Enumeration getAttributeNamesInScope(int scope) 　　返回指定范围内可用的属性名枚举<br>15 　　void release() 　　释放pageContext所占用的资源<br>16　　void forward(String relativeUrlPath) 　　 使当前页面重导到另一页面<br>17 　　void include(String relativeUrlPath) 　　 在当前位置包含另一文件</p><p>⑦: config 对象</p><p>隐藏对象config是javax.servlet.ServletConfig类的实例. config 对象的主要作用是<strong>取得服务器的配置信息</strong>。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p><p>ServletConfig封装了配置在web.xml中初始化JSP的参数。JSP中通过config获取这些参数。每个JSP文件中共有一个config对象。</p><p>config对象的常用方法如表：<br>1　　String getInitParameter(String name)　　返回配置在web.xml中初始化参数<br>2　　Enumeration getInitParameterNames() 　　返回所有的初始化参数名称<br>3　　ServletContext getServletContext()　　返回ServletContext对象<br>4　　String getServletName　　返回Servlet对象</p><p>⑧: page 对象</p><p>page 对象代表JSP本身，<strong>只有在JSP页面内才是合法的</strong>。 page隐含对象本质上包含当前 Servlet接口引用的变量，<strong>类似于Java编程中的 this 指针</strong>。</p><p>⑨: exception 对象</p><p>隐藏对象exception为java.lang.Exception类的对象。exception封装了JSP中抛出的异常信息。要使用exception隐藏对象，需要设置<strong>&lt;%@page isErrorPage”true”%&gt;</strong>。隐藏对象exception通常被用来处理错误页面， </p><p>exception 对象的作用是显示异常信息，<strong>只有在包含 isErrorPage=”true” 的页面中才可以被使用</strong>，<strong>在一般的JSP页面中使用该对象将无法编译JSP文件</strong>。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p><h3 id="31-JSP的十大动作"><a href="#31-JSP的十大动作" class="headerlink" title="31. JSP的十大动作"></a>31. JSP的十大动作</h3><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>jsp:include</td><td>在页面被请求的时候引入一个文件。</td></tr><tr><td>jsp:useBean</td><td>寻找或者实例化一个JavaBean。</td></tr><tr><td>jsp:setProperty</td><td>设置JavaBean的属性。</td></tr><tr><td>jsp:getProperty</td><td>输出某个JavaBean的属性。</td></tr><tr><td>jsp:forward</td><td>把请求转到一个新的页面。</td></tr><tr><td>jsp:plugin</td><td>根据浏览器类型为Java插件生成OBJECT或EMBED标记。</td></tr><tr><td>jsp:element</td><td>定义动态XML元素</td></tr><tr><td>jsp:attribute</td><td>设置动态定义的XML元素属性。</td></tr><tr><td>jsp:body</td><td>设置动态定义的XML元素内容。</td></tr><tr><td>jsp:text</td><td>在JSP页面和文档中使用写入文本的模板</td></tr></tbody></table><h3 id="32-Ajax有四种技术组成：DOM-CSS-JavaScript，XmlHttpRequest，其中控制文档结构的是（）"><a href="#32-Ajax有四种技术组成：DOM-CSS-JavaScript，XmlHttpRequest，其中控制文档结构的是（）" class="headerlink" title="32. Ajax有四种技术组成：DOM,CSS,JavaScript，XmlHttpRequest，其中控制文档结构的是（）"></a>32. Ajax有四种技术组成：DOM,CSS,JavaScript，XmlHttpRequest，其中控制文档结构的是（）</h3><table><thead><tr><th>A.</th><th>DOM</th></tr></thead><tbody><tr><td>B.</td><td>CSS</td></tr><tr><td>C.</td><td>JavaScript</td></tr><tr><td>D.</td><td>XmlHttpRequest</td></tr><tr><td>答案：A</td></tr></tbody></table><h3 id="33-如何配置一个servlet"><a href="#33-如何配置一个servlet" class="headerlink" title="33.  如何配置一个servlet?"></a>33.  如何配置一个servlet?</h3><p>在web.xml中使用如下标签:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一: XML方式</span></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">//方法二: 注解方式: 类上面加下面这句</span><br><span class="line">@WebServlet(name="servlet", urlPatterns=&#123;"/*"&#125;)</span><br><span class="line">或者@WebServlet("/请求路径")</span><br></pre></td></tr></table></figure><h3 id="34-JavaScript，如何定义含有数值1至8的数组？"><a href="#34-JavaScript，如何定义含有数值1至8的数组？" class="headerlink" title="34. JavaScript，如何定义含有数值1至8的数组？"></a>34. JavaScript，如何定义含有数值1至8的数组？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="35-以下JavaScipt语句会产生运行错误的是-（）"><a href="#35-以下JavaScipt语句会产生运行错误的是-（）" class="headerlink" title="35. 以下JavaScipt语句会产生运行错误的是_（）"></a>35. 以下JavaScipt语句会产生运行错误的是_（）</h3><table><thead><tr><th>A.</th><th>var obj=( );</th></tr></thead><tbody><tr><td>B.</td><td>var obj=[ ];</td></tr><tr><td>C.</td><td>var obj=//;</td></tr><tr><td>D.</td><td>var obj=1;</td></tr><tr><td>答案：AC</td></tr></tbody></table><h3 id="36-HTML字符实体的作用及其常用字符实体"><a href="#36-HTML字符实体的作用及其常用字符实体" class="headerlink" title="36. HTML字符实体的作用及其常用字符实体"></a>36. HTML字符实体的作用及其常用字符实体</h3><h4 id="36-1-字符实体拥有三个部分"><a href="#36-1-字符实体拥有三个部分" class="headerlink" title="36.1 字符实体拥有三个部分:"></a>36.1 字符实体拥有三个部分:</h4><p>①: 一个and符号（&amp;）</p><p>②: 一个实体名或者一个实体号</p><p>③: 最后是一个分号（;）</p><h4 id="36-2-常见字符实体"><a href="#36-2-常见字符实体" class="headerlink" title="36.2 常见字符实体"></a>36.2 常见字符实体</h4><p><img src="https://ws1.sinaimg.cn/large/0064BnmZgy1g3oc23z5ckj30il0g6mxq.jpg" alt></p><h4 id="36-3-注意"><a href="#36-3-注意" class="headerlink" title="36.3 注意:"></a>36.3 注意:</h4><p>①: 在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）</p><p>②: 虽然 html 不区分大小写，但实体字符对大小写敏感。</p><p>③: 浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用<code>&amp;nbsp;</code>字符实体。</p><p>④: 一些在键盘上找不到的字符也可以使用字符实体来替换。</p><h3 id="37-HTML表单的作用和常用表单项类型"><a href="#37-HTML表单的作用和常用表单项类型" class="headerlink" title="37. HTML表单的作用和常用表单项类型"></a>37. HTML表单的作用和常用表单项类型</h3><p>表单的作用：</p><p>利用表单可以收集客户端提交的有关信息。</p><p>常用表单项类型：</p><table><thead><tr><th>input标签 type属性</th><th>功能</th><th>input标签 type属性</th><th>功能</th></tr></thead><tbody><tr><td>text</td><td>单行本框</td><td>reset</td><td>重置按钮</td></tr><tr><td>password</td><td>密码框</td><td>submit</td><td>提交按钮</td></tr><tr><td>radio</td><td>单选按钮</td><td>textarea</td><td>文本域</td></tr><tr><td>checkbox</td><td>复选框</td><td>select</td><td>下拉框</td></tr><tr><td>button</td><td>普通按钮</td><td>hidden</td><td>隐藏域</td></tr></tbody></table><h3 id="38-form中input设置为readonly和disabled的区别"><a href="#38-form中input设置为readonly和disabled的区别" class="headerlink" title="38. form中input设置为readonly和disabled的区别"></a>38. form中input设置为readonly和disabled的区别</h3><table><thead><tr><th></th><th>readonly</th><th>disabled</th></tr></thead><tbody><tr><td>有效对象</td><td>只针对type为text/password有效</td><td>对所有表单元素有效</td></tr><tr><td>表单提交</td><td>当表单元素设置readonly后，表单提交能将该表单元素的值传递出去。</td><td>当表单元素设置disabled后，表单提交不能将该表单元素的值传递出去。</td></tr></tbody></table><h3 id="39-引入样式的三种方式及其优先级别"><a href="#39-引入样式的三种方式及其优先级别" class="headerlink" title="39. 引入样式的三种方式及其优先级别"></a>39. 引入样式的三种方式及其优先级别</h3><p>①: 外部样式表（存放.css文件中）</p><p>不需要style标签;    </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">link</span> <span class="attr">rel</span>=<span class="string">”stylesheet”</span> <span class="attr">href</span>=<span class="string">”引用文件地址”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>②: 嵌入式样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">style</span> <span class="attr">type</span>=<span class="string">“text/css”</span>&gt;</span></span><br><span class="line">p&#123;color:red;&#125;</span><br><span class="line"><span class="tag">&lt; /<span class="attr">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③: 内联样式</p><p>标签属性名为style</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">p</span> <span class="attr">style</span>=<span class="string">“color:red;”</span>&gt;</span><span class="tag">&lt; /<span class="attr">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优先级级别：内联定义 &gt; 嵌入式样式表  &gt; 外部CSS</p><h3 id="40-盒子模型"><a href="#40-盒子模型" class="headerlink" title="40. 盒子模型"></a>40. 盒子模型</h3><p>盒子模型类似于生活中的盒子，具有4个属性，外边距，内边距，边框，内容。</p><p>外边距：margin，用于设置<strong>元素和其他元素</strong>之间的距离。</p><p>内边距：padding,用于设置<strong>元素内容和边框</strong>之间的距离。</p><p>边框：border,用于设置元素<strong>边框</strong>粗细，颜色，线型。</p><p>内容：width,height,用于设置<strong>元素内容</strong>显示的大小。</p><h3 id="41-JavaScript语言及其特点"><a href="#41-JavaScript语言及其特点" class="headerlink" title="41. JavaScript语言及其特点"></a>41. JavaScript语言及其特点</h3><p>Javascript一种基于对象(object-based)和事件驱动(Event Driven)的简单的并具有安全性能的脚本语言。特点：</p><p>①: 解释性： JavaScript不同于一些编译性的程序语言，例如C、C++等，它是一种解释性的程序语言，它的源代码不需要经过编译，而直接在浏览器中运行时被解释。</p><p>②: 基于对象： JavaScript是一种基于对象的语言。这意味着它能运用自己已经创建的对象。因此，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。</p><p>③: 事件驱动： JavaScript可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的响应，是以事件驱动的方式进行的。所谓事件驱动，就是指在主页中执行了某种操作所产生的动作，此动作称为“事件”。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。</p><p>④: 跨平台:JavaScript依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可正确执行。</p><h3 id="42-JavaScript常用数据类型有哪些"><a href="#42-JavaScript常用数据类型有哪些" class="headerlink" title="42. JavaScript常用数据类型有哪些"></a>42. JavaScript常用数据类型有哪些</h3><p>①: 数值型(Number)：整数和浮点数统称为数值。例如85或3.1415926等。</p><p>②: 字符串型(String)：由0个,1个或多个字符组成的序列。在JavaScript中，用双引号或单引号括起来表示，如“您好”、‘学习JavaScript’等。 不区分单引号、双引号。</p><p>③: 逻辑（布尔）型(Boolean)：用true或false来表示。</p><p>④: 空（null）值(Null)：表示没有值，用于定义空的或不存在的引用。</p><p>要注意，空值不等同于空字符串””或0。</p><p>⑤: 未定义（Undefined）值：它也是一个保留字。表示变量虽然已经声明，但却没有赋值。</p><p>⑥: 除了以上五种基本的数据类型之外，JavaScript还支持复合数据类型，包括对象和数组两种。</p><h3 id="43-Ajax的优点和缺点"><a href="#43-Ajax的优点和缺点" class="headerlink" title="43. Ajax的优点和缺点"></a>43. Ajax的优点和缺点</h3><p>优点：减轻服务器的负担,按需取数据,最大程度的减少冗余请求，局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验，基于xml标准化,并被广泛支持,不需安装插件等，进一步促进页面和数据的分离</p><p>缺点：AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.</p><h3 id="44-怎样防止表单刷新重复提交问题？（说出思路即可）"><a href="#44-怎样防止表单刷新重复提交问题？（说出思路即可）" class="headerlink" title="44. 怎样防止表单刷新重复提交问题？（说出思路即可）"></a>44. 怎样防止表单刷新重复提交问题？（说出思路即可）</h3><p>JS脚本方式:</p><p>第一种：定义全局变量，在form提交前判断是否已有提交过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> checkSubmitFlg = <span class="literal">false</span>; <span class="comment">//初始为false,表示没有提交过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSubmit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(checkSubmitFlg == <span class="literal">true</span>)&#123; <span class="comment">//如果为true,说明checkSubmitFlg的值被修改了,也就是之前提交过;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回false,阻止提交事件</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    checkSubmitFlg = <span class="literal">true</span>; <span class="comment">//如果能执行这一句,说明checkSubmitFlg==false,说明表单没有被提交过,此时可以提交,于是将checkSubmitFlg的值改为true;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true,表示运行提交</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;form action="" onsubmit="return checkSubmit();"&gt;&lt;/</span>form&gt;</span><br></pre></td></tr></table></figure><p>第二种：单击提交按钮后，立刻禁用改按钮</p><p>第三种：单击提交按钮后，弹出屏蔽层，防止用户第二次点击</p><h3 id="45-JQuery-get-和JQuery-ajax-方法之间的区别是什么？"><a href="#45-JQuery-get-和JQuery-ajax-方法之间的区别是什么？" class="headerlink" title="45. JQuery.get()和JQuery.ajax()方法之间的区别是什么？"></a>45. JQuery.get()和JQuery.ajax()方法之间的区别是什么？</h3><p>JQuery.ajax()是对原生的javaScript的ajax的封装，简化了ajax的步骤，用户可用JQuery.ajax()发送get或者post方式请求,</p><p>Jquery.get()是对ajax的get方式的封装，只能发送get方式的请求。</p><h3 id="46-Jquery里的缓存问题如何解决？例如（-ajax-以及-get-）"><a href="#46-Jquery里的缓存问题如何解决？例如（-ajax-以及-get-）" class="headerlink" title="46. Jquery里的缓存问题如何解决？例如（$.ajax()以及$.get()）"></a>46. Jquery里的缓存问题如何解决？例如（$.ajax()以及$.get()）</h3><p>方法一: $.ajax()请求时候加上cache:false的参数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type : <span class="string">"get"</span>,</span><br><span class="line">    url : <span class="string">"XX"</span>,</span><br><span class="line">    dataType : <span class="string">"json"</span>,</span><br><span class="line">    cache:<span class="literal">false</span>,</span><br><span class="line">    success : <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者:</p><p>方法二: $.get()请求时候加上时间，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("url","data"+new Date(),function(data)&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="47-Javascript是面向对象的，怎么体现Javascript的继承关系？"><a href="#47-Javascript是面向对象的，怎么体现Javascript的继承关系？" class="headerlink" title="47. Javascript是面向对象的，怎么体现Javascript的继承关系？"></a>47. Javascript是面向对象的，怎么体现Javascript的继承关系？</h3><p>Javascript里面没有像java那样的继承，javascript中的继承机制仅仅是靠模拟的，可以使用prototype原型来实现</p><h3 id="48-Javascript的有几种变量。变量范围有什么不同？"><a href="#48-Javascript的有几种变量。变量范围有什么不同？" class="headerlink" title="48. Javascript的有几种变量。变量范围有什么不同？"></a>48. Javascript的有几种变量。变量范围有什么不同？</h3><p>可以分为三种</p><p>①: 原生类型（string,number,boolean）</p><p>②: 对象（Date,Array）</p><p>③: 特殊类型（var vara;(只什么没有定义),var varb = null;(定义一个变量并赋值为null)）</p><h3 id="49-Js如何获取页面的dom对象"><a href="#49-Js如何获取页面的dom对象" class="headerlink" title="49. Js如何获取页面的dom对象"></a>49. Js如何获取页面的dom对象</h3><p>1、直接获取</p><p>//1.1 – id方式获取</p><p><code>var varid = document.getElementById(&quot;unameid&quot;);</code></p><p>//1.2 – name获取(获取的是数组对象)</p><p><code>var varname = document.getElementsByName(&quot;sex&quot;);</code></p><p>//1.3 – 元素获取(获取的是数组对象)</p><p><code>var varinput = document.getElementsByTagName(&quot;input&quot;);</code></p><p>2、间接方式获取</p><p>//2.1 父子关系 –childNodes</p><p><code>var varchilds = document.getElementById(&quot;div01&quot;).childNodes;</code></p><p>//2.2 子父关系–parentNode</p><p><code>var varfather2 = document.getElementById(&quot;unameid&quot;).parentNode;</code></p><p>//2.3 兄弟之间相互获取 nextSibling：下一个节点 previousSibling：上一个节点</p><h3 id="50-Servlet-API中forward-与redirect-的区别？"><a href="#50-Servlet-API中forward-与redirect-的区别？" class="headerlink" title="50. Servlet API中forward() 与redirect()的区别？"></a>50. Servlet API中forward() 与redirect()的区别？</h3><p>答：为实现程序的模块化，就需要保证在不同的Servlet之间可以相互跳转，而Servlet中主要有两种实现跳转的方式：FORWARD方式与redirect方式。 </p><p><strong>Forward() : 是服务器内部的重定向</strong>，服务器直接访问目标地址的URL，把那个URL的响应内容读取出来，而客户端并不知道，因此在客户端浏览器的地址栏里不会显示跳转后的地址，还是原来的地址。由于在整个定向的过程中用的是同一个Request，因此FORWARD会将Request的信息带到被定向的ＪＳＰ或Servlet中使用。</p><p><strong>Redirect():则是客户端的重定向</strong>，是完全的跳转，即客户端浏览器会获取跳转后的地址，然后重新发送请求，因此浏览器中会显示跳转后的地址。同时，由于这种方式比FORWARD方式多了一次网络请求，因此其<strong>效率低</strong>于FORWARD方式，需要注意到的是，客户端的重定向可以通过设置特定的HTTP 头或写JavaScript脚本来实现。</p><p>鉴于以上的区别，一般当FORWARD方式可以满足需求时，尽可能的使用FORWARD方式。<strong>但在有些情况下，例如，需要跳转到一个其他服务器上的资源时，则必须使用redirect 方式</strong>。</p><h3 id="51-Session域和request域什么区别？"><a href="#51-Session域和request域什么区别？" class="headerlink" title="51. Session域和request域什么区别？"></a>51. Session域和request域什么区别？</h3><p>作用域：存放数据，获取数据（传递数据）</p><p>有效的作用域：生命周期，作用范围</p><h4 id="51-1-httpServeltRequest"><a href="#51-1-httpServeltRequest" class="headerlink" title="51.1 httpServeltRequest:"></a>51.1 httpServeltRequest:</h4><p>生命周期：一次请求之间</p><p>作用范围：所有被请求转发过的servlet都能获取到</p><h4 id="51-2-httpSession"><a href="#51-2-httpSession" class="headerlink" title="51.2 httpSession:"></a>51.2 httpSession:</h4><p>生命周期：一次会话</p><p>作用范围：所有的servlet都可以获取到</p><h4 id="51-3-servletContex"><a href="#51-3-servletContex" class="headerlink" title="51.3 servletContex:"></a>51.3 servletContex:</h4><p>生命周期：从项目开始运行到服务器关闭</p><p>作用范围：所有的servlet都可以获取到 </p><h4 id="51-4-作用域如何选用？"><a href="#51-4-作用域如何选用？" class="headerlink" title="51.4 作用域如何选用？"></a>51.4 作用域如何选用？</h4><p>httpServeltRequest：和当前请求有关的信息</p><p>httpSession：和当前用户有关的信息</p><p>servletContex：访问量比较大，不易更改</p><h3 id="52-页面中有一个命名为bankNo的下拉列表，写js脚本获取当前选项的索引值，如果用jquery如何获取"><a href="#52-页面中有一个命名为bankNo的下拉列表，写js脚本获取当前选项的索引值，如果用jquery如何获取" class="headerlink" title="52. 页面中有一个命名为bankNo的下拉列表，写js脚本获取当前选项的索引值，如果用jquery如何获取"></a>52. 页面中有一个命名为bankNo的下拉列表，写js脚本获取当前选项的索引值，如果用jquery如何获取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js方式:</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByName(<span class="string">"bankNo"</span>)[<span class="number">0</span>].value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery方式:</span></span><br><span class="line"><span class="keyword">var</span> b = $(<span class="string">"select[name=bankNo]"</span>).val();</span><br></pre></td></tr></table></figure><h3 id="53-写出要求11位数字的正则表达式"><a href="#53-写出要求11位数字的正则表达式" class="headerlink" title="53. 写出要求11位数字的正则表达式"></a>53. 写出要求11位数字的正则表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//^开始, $结束   \d 匹配一个数字字符。等价于[0-9]。</span></span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\d&#123;<span class="number">10</span>&#125;$</span><br><span class="line">或者:</span><br><span class="line">^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-WEB应用中如果有-class和-jar类型的文件一般分别应该放在什么位置？&quot;&gt;&lt;a href=&quot;#1-WEB应用中如果有-class和-jar类型的文件一般分别应该放在什么位置？&quot; class=&quot;headerlink&quot; title=&quot;1. WEB应用中如果有
      
    
    </summary>
    
      <category term="面试题" scheme="https://zzwwqq.xyz/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Web相关面试题" scheme="https://zzwwqq.xyz/tags/Web%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>信息系统项目管理师案例分析知识点</title>
    <link href="https://zzwwqq.xyz/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://zzwwqq.xyz/信息系统项目管理师案例分析知识点.html</id>
    <published>2019-05-31T07:15:15.000Z</published>
    <updated>2019-06-02T12:42:53.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、项目建议书的内容（4个）"><a href="#1、项目建议书的内容（4个）" class="headerlink" title="1、项目建议书的内容（4个）"></a>1、项目建议书的内容（4个）</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.1.png" alt></p><a id="more"></a><h2 id="2、项目章程、项目管理计划的内容"><a href="#2、项目章程、项目管理计划的内容" class="headerlink" title="2、项目章程、项目管理计划的内容"></a>2、项目章程、项目管理计划的内容</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.2.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.3.png" alt></p><h2 id="3、项目范围说明书的内容、范围基准、WBS分解3个方法8个原则"><a href="#3、项目范围说明书的内容、范围基准、WBS分解3个方法8个原则" class="headerlink" title="3、项目范围说明书的内容、范围基准、WBS分解3个方法8个原则"></a>3、项目范围说明书的内容、范围基准、WBS分解3个方法8个原则</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.4.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.5.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.6.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.7.png" alt></p><h2 id="4、缩短活动工期的五种方法"><a href="#4、缩短活动工期的五种方法" class="headerlink" title="4、缩短活动工期的五种方法"></a>4、缩短活动工期的五种方法</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.8.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.9.png" alt></p><h2 id="5、成本控制的内容"><a href="#5、成本控制的内容" class="headerlink" title="5、成本控制的内容"></a>5、成本控制的内容</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.10.png" alt></p><h2 id="6、成本估算、预算的三个步骤-工具和技术"><a href="#6、成本估算、预算的三个步骤-工具和技术" class="headerlink" title="6、成本估算、预算的三个步骤/工具和技术"></a>6、成本估算、预算的三个步骤/工具和技术</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.11.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.12.png" alt></p><h2 id="7、质量控制的七种工具（老七、新七）、质量审计的目标、QA的职责"><a href="#7、质量控制的七种工具（老七、新七）、质量审计的目标、QA的职责" class="headerlink" title="7、质量控制的七种工具（老七、新七）、质量审计的目标、QA的职责"></a>7、质量控制的七种工具（老七、新七）、质量审计的目标、QA的职责</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.13.png" alt></p><h2 id="8、团队建设的五个阶段"><a href="#8、团队建设的五个阶段" class="headerlink" title="8、团队建设的五个阶段"></a>8、团队建设的五个阶段</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.14.png" alt></p><h2 id="9、管理项目团队的工具和技术、冲突的特点-解决的方法"><a href="#9、管理项目团队的工具和技术、冲突的特点-解决的方法" class="headerlink" title="9、管理项目团队的工具和技术、冲突的特点/解决的方法"></a>9、管理项目团队的工具和技术、冲突的特点/解决的方法</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.15.png" alt></p><h2 id="10、风险的应对措施（积极-消极，会举例子）"><a href="#10、风险的应对措施（积极-消极，会举例子）" class="headerlink" title="10、风险的应对措施（积极/消极，会举例子）"></a>10、风险的应对措施（积极/消极，会举例子）</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.16.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.17.png" alt></p><h2 id="11、配置管理的六个活动-基线和非基线配置项-配置库3个"><a href="#11、配置管理的六个活动-基线和非基线配置项-配置库3个" class="headerlink" title="11、配置管理的六个活动/基线和非基线配置项/配置库3个"></a>11、配置管理的六个活动/基线和非基线配置项/配置库3个</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.18.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.19.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.20.png" alt></p><h2 id="12、变更的八个工作程序、项目总结的意义、信息系统后评价的内容"><a href="#12、变更的八个工作程序、项目总结的意义、信息系统后评价的内容" class="headerlink" title="12、变更的八个工作程序、项目总结的意义、信息系统后评价的内容"></a>12、变更的八个工作程序、项目总结的意义、信息系统后评价的内容</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.21.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.22.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、项目建议书的内容（4个）&quot;&gt;&lt;a href=&quot;#1、项目建议书的内容（4个）&quot; class=&quot;headerlink&quot; title=&quot;1、项目建议书的内容（4个）&quot;&gt;&lt;/a&gt;1、项目建议书的内容（4个）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-2.1.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="考证" scheme="https://zzwwqq.xyz/categories/%E8%80%83%E8%AF%81/"/>
    
    
      <category term="信息系统项目管理师" scheme="https://zzwwqq.xyz/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试题及答案</title>
    <link href="https://zzwwqq.xyz/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html"/>
    <id>https://zzwwqq.xyz/Java面试题及答案.html</id>
    <published>2019-05-31T07:15:15.000Z</published>
    <updated>2019-06-02T12:44:06.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录结构:</strong></p><p>[TOC]</p><hr><h2 id="一、Java基础、语法"><a href="#一、Java基础、语法" class="headerlink" title="一、Java基础、语法"></a>一、Java基础、语法</h2><h3 id="1-面向对象的特征有哪些方面"><a href="#1-面向对象的特征有哪些方面" class="headerlink" title="1 面向对象的特征有哪些方面?"></a>1 面向对象的特征有哪些方面?</h3><p>答：面向对象的特征主要有以下几个方面：<br>1)抽象：抽象是将<strong>一类对象的共同特征总结出来构造类</strong>的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p>2)继承：继承是<strong>从已有类得到继承信息创建新类</strong>的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</p><p>3)封装：通常认为封装是把<strong>数据和操作数据的方法绑定</strong>起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</p><p>4)多态性：多态性是指允许<strong>不同子类型的对象对同一消息作出不同的响应</strong>。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为<strong>编译时的多态性和运行时的多态性</strong>。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。<strong>方法重载</strong>（overload）实现的是<strong>编译时的多态性</strong>（也称为前绑定），而<strong>方法重写</strong>（override）实现的是<strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：<strong>1. 方法重写</strong>（子类继承父类并重写父类中已有的或抽象的方法）；<strong>2. 对象造型</strong>（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p><p>多态性的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。</p><p>举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。</p><p>同一个事件发生在不同的对象上会产生不同的结果。</p><p>作用：消除类型之间的耦合关系</p><p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p>重载和重写都是多态的体现.</p><h3 id="2-访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2-访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2 访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2 访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p>答：区别如下：<br>  作用域    当前类  同包 子类 其他<br>  public         √        √       √      √<br>  protected   √        √       √      ×<br>  default       √        √       ×      ×<br>  private       √        ×       ×      ×<br>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</p><p>####2.1 类的访问权限只有两种</p><p><em>public</em>公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</p><p><em>default</em>默认的 可被同一个包中的类访问。</p><h4 id="2-2-成员（成员变量或成员方法）访问权限共有四种："><a href="#2-2-成员（成员变量或成员方法）访问权限共有四种：" class="headerlink" title="2.2 成员（成员变量或成员方法）访问权限共有四种："></a>2.2 成员（成员变量或成员方法）访问权限共有四种：</h4><p><em>public</em> 公共的 可以被项目中所有的类访问。(项目可见性)</p><p><em>protected</em> 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</p><p><em>default</em> 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</p><p><em>private</em> 私有的 只能被这个类本身访问。（类可见性）</p><h3 id="3-String-是最基本的数据类型吗"><a href="#3-String-是最基本的数据类型吗" class="headerlink" title="3 String 是最基本的数据类型吗?"></a>3 String 是最基本的数据类型吗?</h3><p>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了<strong>基本类型</strong>（primitive type）和<strong>枚举类型</strong>（enumeration type），剩下的都是<strong>引用类型</strong>（reference type）。</p><h3 id="4-float-f-3-4-是否正确"><a href="#4-float-f-3-4-是否正确" class="headerlink" title="4 float f=3.4;是否正确?"></a>4 float f=3.4;是否正确?</h3><p>  答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成<strong>精度损失</strong>，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p><h3 id="5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?"></a>5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</h3><p>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型,因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。<br>而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有<strong>隐含的强制类型转换</strong>。</p><h3 id="6-Java-有没有goto"><a href="#6-Java-有没有goto" class="headerlink" title="6 Java 有没有goto?"></a>6 Java 有没有goto?</h3><p>  答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p><h3 id="7-int-和Integer-有什么区别"><a href="#7-int-和Integer-有什么区别" class="headerlink" title="7 int 和Integer 有什么区别?"></a>7 int 和Integer 有什么区别?</h3><p>  答：</p><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即<strong>Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况</strong>，<br><strong>例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer</strong>。<br>在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，<strong>int不适合作为web层的表单数据的类型。</strong></p><p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p><p>Java是一个近乎纯洁的面向对象编程语言，但是<strong>为了编程的方便还是引入不是对象的基本数据类型</strong>，但是为了能够将这些基本数据类型当成对象操作，<strong>Java为每一个基本数据类型都引入了对应的包装类型</strong>（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了<strong>自动装箱/拆箱机制，使得二者可以相互转换</strong>。<br>Java 为每个原始类型提供了包装类型：<br>  原始类型: boolean，<strong>char</strong>，byte，short，int，long，float，double<br>  包装类型：Boolean，<strong>Character</strong>，Byte，Short，Integer，Long，Float，Double</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;              <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">&gt;   </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">&gt;          System.out.println(f1 == f2);</span><br><span class="line">&gt;          System.out.println(f3 == f4);</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>  如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。</p><p><strong>装箱的本质是什么呢？</strong>当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>IntegerCache是Integer的内部类</strong>，其代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment">     * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment">     * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment">     * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment">     * sun.misc.VM class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  简单的说，<strong>如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象</strong>，所以上面的面试题中f1f2的结果是true，而f3f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p><h3 id="8-amp-和-amp-amp-的区别和联系，-和-的区别和联系"><a href="#8-amp-和-amp-amp-的区别和联系，-和-的区别和联系" class="headerlink" title="8 &amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>8 &amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h3><h4 id="8-1-amp-和-amp-amp-的联系-共同点-："><a href="#8-1-amp-和-amp-amp-的联系-共同点-：" class="headerlink" title="8.1&amp;和&amp;&amp;的联系(共同点)："></a>8.1&amp;和&amp;&amp;的联系(共同点)：</h4><p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</p><p>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</p><p>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</p><p>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p><p>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p><p>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p><h4 id="8-2-amp-和-amp-amp-的区别-不同点-："><a href="#8-2-amp-和-amp-amp-的区别-不同点-：" class="headerlink" title="8.2 &amp;和&amp;&amp;的区别(不同点)："></a>8.2 &amp;和&amp;&amp;的区别(不同点)：</h4><p>(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</p><p>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p><p>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p><p>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</p><p>、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</p><p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</p><p><strong>注: 很多时候我们可能都需要用&amp;&amp;而不是&amp;</strong>，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，<strong>二者的顺序不能交换，更不能用&amp;运算符</strong>，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</p><h3 id="9-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#9-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h3><p>  答：通常我们定义一个<strong>基本数据类型的变量</strong>，一个<strong>对象的引用</strong>，还有就是<strong>函数调用的现场保存</strong>都使用内存中的<strong>栈空间</strong>；而通过new关键字和构造器创建的<strong>对象放在堆空间</strong>；程序中的<strong>字面量</strong>（literal）如直接书写的100、“hello”和<strong>常量都是放在静态存储区</strong>中。<strong>栈空间操作最快但是也很小</strong>，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。<br>  String str = new String(“hello”);<br>  上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。<br>  补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p><h3 id="10-Math-round（-11-2）的运行结果是"><a href="#10-Math-round（-11-2）的运行结果是" class="headerlink" title="10 Math.round（-11.2）的运行结果是"></a>10 Math.round（-11.2）的运行结果是</h3><p>答案: -11</p><p>分析：</p><p><strong>小数点后第一位=5</strong></p><p>正数：Math.round(11.5)=12</p><p>负数：Math.round(-11.5)=-11</p><p><strong>小数点后第一位&lt;5</strong></p><p>正数：Math.round(11.46)=11</p><p>负数：Math.round(-11.46)=-11</p><p><strong>小数点后第一位&gt;5</strong></p><p>正数：Math.round(11.68)=12</p><p>负数：Math.round(-11.68)=-12</p><p>根据上面例子的运行结果，我们还可以按照如下方式<strong>总结</strong>，或许更加容易记忆：</p><p>参数的小数点后第一位&lt;5，运算结果为参数整数部分。</p><p>参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。</p><p>参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分。</p><p><strong>终结：大于五全部加，等于五正数加，小于五全不加。</strong></p><h3 id="11-swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#11-swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h3><p>  答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。<strong>长整型（long）是不可以的。</strong></p><h3 id="12-用最有效率的方法计算2乘以8"><a href="#12-用最有效率的方法计算2乘以8" class="headerlink" title="12 用最有效率的方法计算2乘以8?"></a>12 用最有效率的方法计算2乘以8?</h3><p>  答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p><p>使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数。对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3</p><p>  补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num &lt;==&gt; (num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。<br>  <img src="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0kmpthpj30fe07qjsi.jpg" alt><br>  <img src="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ltusboj30fe0alq4j.jpg" alt></p><h3 id="13-数组有没有length-方法-String-有没有length-方法？"><a href="#13-数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="13 数组有没有length()方法?String 有没有length()方法？"></a>13 数组有没有length()方法?String 有没有length()方法？</h3><p>  答：<strong>数组没有length()方法</strong>，<strong>有length 的属性</strong>。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</p><h3 id="14-在Java-中，如何跳出当前的多重嵌套循环？"><a href="#14-在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14 在Java 中，如何跳出当前的多重嵌套循环？"></a>14 在Java 中，如何跳出当前的多重嵌套循环？</h3><p>  答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ok:</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ok;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果如下: </span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">2</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">3</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">4</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数</span></span><br><span class="line"><span class="comment">组中查找到某个数字。  */</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length &amp;&amp; !found;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">            System.out.println(“i=” + i + “,j=” + j);</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]  == <span class="number">5</span>) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//运行结果如下: </span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">2</span></span><br><span class="line">i=<span class="number">1</span>,j=<span class="number">0</span></span><br><span class="line">i=<span class="number">1</span>,j=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="15-构造器（constructor）是否可被重写（override）"><a href="#15-构造器（constructor）是否可被重写（override）" class="headerlink" title="15 构造器（constructor）是否可被重写（override）?"></a>15 构造器（constructor）是否可被重写（override）?</h3><p>  答：<strong>构造器不能被继承</strong>，因此不能被重写，但可以被重载。</p><h3 id="16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><p>  答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：<br>(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；<br>(2)如果两个对象的hashCode相同，它们并不一定相同。<br>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>  补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足<strong>自反性</strong>（x.equals(x)必须返回true）、<strong>对称性</strong>（x.equals(y)返回true时，y.equals(x)也必须返回true）、<strong>传递性</strong>（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和<strong>一致性</strong>（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。<br>实现高质量的equals方法的诀窍包括：</p><ol><li>使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. <strong>重写equals时总是要重写hashCode</strong>；6. 不要将equals方法参数中的Object对象替换为其他的类型，在<strong>重写时不要忘掉@Override注解</strong>。</li></ol><h3 id="17-是否可以继承String-类"><a href="#17-是否可以继承String-类" class="headerlink" title="17 是否可以继承String 类?"></a>17 是否可以继承String 类?</h3><p>  答：<strong>String 类是final类，不可以被继承</strong>。<br>  补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。</p><h3 id="18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p>  答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。<br>  补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</p><h3 id="19-String-和StringBuilder、StringBuffer-的区别"><a href="#19-String-和StringBuilder、StringBuffer-的区别" class="headerlink" title="19 String 和StringBuilder、StringBuffer 的区别?"></a>19 String 和StringBuilder、StringBuffer 的区别?</h3><p>  答：Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中<strong>String是只读字符串</strong>，也就意味着String引用的字符串内容是不能被改变的。而<strong>StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改</strong>。<strong>StringBuilder</strong>是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在<strong>单线程</strong>环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。<br>  补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。<br>  补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。<br>  <img src="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ohnh1bj30fe07275c.jpg" alt></p><h3 id="20-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><a href="#20-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分" class="headerlink" title="20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?"></a>20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?</h3><p>  答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。<br>  补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！</p><h3 id="21-描述一下JVM-加载class文件的原理机制"><a href="#21-描述一下JVM-加载class文件的原理机制" class="headerlink" title="21 描述一下JVM 加载class文件的原理机制?"></a>21 描述一下JVM 加载class文件的原理机制?</h3><p>  答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>  补充：<br>  1.由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被<strong>加载、连接(验证、准备和解析)和初始化</strong>。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个<strong>字节数组</strong>读入.class文件，然后产生与所加载类对应的<strong>Class对象</strong>。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括<strong>验证、准备(为静态变量分配内存并设置默认的初始值</strong>)和<strong>解析(将符号引用替换为直接引用)</strong>三个步骤。最后JVM对类进行<strong>初始化</strong>，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。<br>  2.类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：<br>  a)Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；<br>  b)Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；<br>  c)System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p><h3 id="22-char-型变量中能不能存贮一个中文汉字-为什么"><a href="#22-char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="22 char 型变量中能不能存贮一个中文汉字?为什么?"></a>22 char 型变量中能不能存贮一个中文汉字?为什么?</h3><p>  答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。<br>  补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</p><h3 id="23-抽象类（abstract-class）和接口（interface）有什么异同"><a href="#23-抽象类（abstract-class）和接口（interface）有什么异同" class="headerlink" title="23 抽象类（abstract class）和接口（interface）有什么异同?"></a>23 抽象类（abstract class）和接口（interface）有什么异同?</h3><p>  答：<strong>抽象类和接口都不能够实例化</strong>，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。<strong>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</strong>。</p><p>在接口中定义成员变量在声明的时候是必须要初始化的，并且都是 <code>public static final</code> 的。比如你在接口中定义一个变量 <code>i</code>，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的真正代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这是为什么呢？</p><p>因为在 Java 中，接口是高层次的抽象，体现的是 <code>OCP</code>（<strong>对修改关闭，对扩展开放</strong>）的设计原则，这也是我们设计中一直追求的。</p><p>首先要弄清接口的含义。接口就是提供一种统一的“协议”，而接口中的属性也属于“协议”中的成员。它们是<strong>公共的</strong>，<strong>静态的</strong>,<strong>不可变的</strong>常量，相当于全局常量。</p><p>抽象类是“不完全”的类，相当于是接口和具体类的一个中间层，即满足接口的抽象，也满足具体的实现。</p><p>如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。</p><p>也许你会想，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况：如果接口 <code>A</code> 中有一个 <code>public</code> 访问权限的静态变量 <code>a</code>。按照 java 的语义，我们可以不通过实现接口的对象来访问变量 <code>a</code>，通过 <code>A.a = xxx</code> 就可以改变接口中的变量 <code>a</code> 的值了。正如抽象类中是可以这样做的，那么实现接口 <code>A</code> 的所有对象也都会自动拥有这一改变后的 <code>a</code> 的值了，也就是说一个地方改变了 <code>a</code>，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以<strong>接口中的属性必然是常量，只能读不能改</strong>，这样才能为实现接口的对象提供一个统一的属性。</p><p>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。</p><p><strong>接口中的方法前面的public abstract ,属性前面的public static final都可以省略的。</strong></p><p>总之:  ①: 接口中没有变量,只有常量,且默认修饰符public static final; 另外接口中方法的默认修饰符: public abstract </p><p>②: 抽象类可以没有抽象方法,但如果一个类中有抽象方法,那么这个类必须声明为抽象方法.</p><h3 id="24-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#24-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h3><p> 答：内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out_x  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Inner1 inner1 = <span class="keyword">new</span> Inner1();</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span>  //在方法体内部定义的内部类</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                out_x = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner2 inner2 = <span class="keyword">new</span> Inner2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span>  //在方法体外面定义的内部类</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：</p><p>Outer outer = new Outer();</p><p>Outer.Inner1 inner1 = outer.new Innner1();</p><p>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。</p><p>对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。</p><p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            <span class="keyword">new</span> Runable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：</p><p>Outer.Inner inner = newOuter.Inner();</p><p>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。</p><p>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</p><p>备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</p><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扑克类（一副扑克）</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] suites = &#123;<span class="string">"黑桃"</span>, <span class="string">"红桃"</span>, <span class="string">"草花"</span>, <span class="string">"方块"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] faces = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Card[] cards;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cards = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; faces.length; j++) &#123;</span><br><span class="line">                cards[i * <span class="number">13</span> + j] = <span class="keyword">new</span> Card(suites[i], faces[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 洗牌 （随机乱序）</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = cards.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * len);</span><br><span class="line">            Card temp = cards[index];</span><br><span class="line">            cards[index] = cards[i];</span><br><span class="line">            cards[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 发牌的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Card <span class="title">deal</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cards[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卡片类（一张扑克）</span></span><br><span class="line"><span class="comment">     * [内部类]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String suite;   <span class="comment">// 花色</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> face;       <span class="comment">// 点数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">(String suite, <span class="keyword">int</span> face)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.suite = suite;</span><br><span class="line">            <span class="keyword">this</span>.face = face;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String faceStr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">switch</span>(face) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: faceStr = <span class="string">"A"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">11</span>: faceStr = <span class="string">"J"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">12</span>: faceStr = <span class="string">"Q"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">13</span>: faceStr = <span class="string">"K"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: faceStr = String.valueOf(face);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> suite + faceStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PokerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Poker poker = <span class="keyword">new</span> Poker();</span><br><span class="line">        poker.shuffle();            <span class="comment">// 洗牌</span></span><br><span class="line">        Poker.Card c1 = poker.deal(<span class="number">0</span>);  <span class="comment">// 发第一张牌</span></span><br><span class="line">        <span class="comment">// 对于非静态内部类Card</span></span><br><span class="line">        <span class="comment">// 只有通过其外部类Poker对象才能创建Card对象</span></span><br><span class="line">        Poker.Card c2 = poker.new Card(<span class="string">"红心"</span>, <span class="number">1</span>);    <span class="comment">// 自己创建一张牌</span></span><br><span class="line">        System.out.println(c1);     <span class="comment">// 洗牌后的第一张</span></span><br><span class="line">        System.out.println(c2);     <span class="comment">// 打印: 红心A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-Java-中会存在内存泄漏吗，请简单描述。"><a href="#25-Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="25 Java 中会存在内存泄漏吗，请简单描述。"></a>25 Java 中会存在内存泄漏吗，请简单描述。</h3><p>  答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：<br>  <img src="/" alt><br>  上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</p><h3 id="26-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#26-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h3><p>  答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p><h3 id="27-静态变量和实例变量的区别？"><a href="#27-静态变量和实例变量的区别？" class="headerlink" title="27 静态变量和实例变量的区别？"></a>27 静态变量和实例变量的区别？</h3><p>  答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p><h3 id="28-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#28-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>  答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</p><h3 id="29-如何实现对象克隆？"><a href="#29-如何实现对象克隆？" class="headerlink" title="29 如何实现对象克隆？"></a>29 如何实现对象克隆？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：有两种方式：<br>  1.实现Cloneable接口并重写Object类中的clone()方法；<br>  2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</p><p>下面是测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Car car;        <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", car="</span> + car + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小汽车类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5713945027627603702L</span>;</span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Car [brand="</span> + brand + <span class="string">", maxSpeed="</span> + maxSpeed + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person p1 = <span class="keyword">new</span> Person(<span class="string">"Hao LUO"</span>, <span class="number">33</span>, <span class="keyword">new</span> Car(<span class="string">"Benz"</span>, <span class="number">300</span>));</span><br><span class="line">            Person p2 = MyUtil.clone(p1);   <span class="comment">// 深度克隆</span></span><br><span class="line">            p2.getCar().setBrand(<span class="string">"BYD"</span>);</span><br><span class="line">            <span class="comment">// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span></span><br><span class="line">            <span class="comment">// 原来的Person对象p1关联的汽车不会受到任何影响</span></span><br><span class="line">            <span class="comment">// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span></span><br><span class="line">            System.out.println(p1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</p><h3 id="30-GC-是什么？为什么要有GC？"><a href="#30-GC-是什么？为什么要有GC？" class="headerlink" title="30 GC 是什么？为什么要有GC？"></a>30 GC 是什么？为什么要有GC？</h3><p>  答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。<br>  补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：<br>  •    伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。<br>  •    幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。<br>  •    终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。<br>  与垃圾回收相关的JVM参数：<br>  •    -Xms / -Xmx — 堆的初始大小 / 堆的最大大小<br>  •    -Xmn — 堆中年轻代的大小<br>  •    -XX:-DisableExplicitGC — 让System.gc()不产生任何作用<br>  •    -XX:+PrintGCDetail — 打印GC的细节<br>  •    -XX:+PrintGCDateStamps — 打印GC操作的时间戳</p><h3 id="31-String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#31-String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="31 String s=new String(“xyz”);创建了几个字符串对象？"></a>31 String s=new String(“xyz”);创建了几个字符串对象？</h3><p>  答：两个对象，一个是静态存储区的”xyz”,一个是用new创建在堆上的对象。</p><h3 id="32-接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#32-接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h3><p>  答：接口可以继承接口。抽象类可以实现(implements)接口，<strong>抽象类可继承具体类</strong>，但<strong>前提是具体类必须有明确的构造函数</strong>。</p><h3 id="33-一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33-一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><p>  答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p><h3 id="34-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#34-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>  答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现<strong>事件监听和回调。</strong></p><h3 id="35-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><p>  答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p><h3 id="36-Java-中的final关键字有哪些用法？"><a href="#36-Java-中的final关键字有哪些用法？" class="headerlink" title="36 Java 中的final关键字有哪些用法？"></a>36 Java 中的final关键字有哪些用法？</h3><p>答: </p><p>(1) 修饰类：表示该类不能被继承；</p><p>(2) 修饰方法：表示方法不能被重写但是允许重载；</p><p>(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）；</p><p>(4) 修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。</p><h3 id="37-指出下面程序的运行结果"><a href="#37-指出下面程序的运行结果" class="headerlink" title="37 指出下面程序的运行结果:"></a>37 指出下面程序的运行结果:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A ab = <span class="keyword">new</span> B();</span><br><span class="line">        ab = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p><p>考点：静态代码块优先级 &gt; 构造方法的优先级如果再加一个普通代码块，优先顺序如下：静态代码块&gt;普通代码块&gt;构造方法</p><h3 id="38-说说数据类型之间的转换"><a href="#38-说说数据类型之间的转换" class="headerlink" title="38 说说数据类型之间的转换:"></a>38 说说数据类型之间的转换:</h3><p>  1)如何将字符串转换为基本数据类型？<br>  2)如何将基本数据类型转换为字符串？<br>  答：<br>  1)调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；<br>  2)一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串</p><h3 id="39-如何实现字符串的反转及替换？"><a href="#39-如何实现字符串的反转及替换？" class="headerlink" title="39 如何实现字符串的反转及替换？"></a>39 如何实现字符串的反转及替换？</h3><p>  答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String originStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(originStr == <span class="keyword">null</span> || originStr.length() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> originStr;</span><br><span class="line">        <span class="keyword">return</span> reverse(originStr.substring(<span class="number">1</span>)) + originStr.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h3><p>  答：代码如下所示:<br>  String s1 = “你好”;<br>  String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”);</p><h3 id="41-日期和时间："><a href="#41-日期和时间：" class="headerlink" title="41 日期和时间："></a>41 日期和时间：</h3><p>  1)如何取得年,月,日、小时,分钟,秒？                        —-&gt;抽象类Calendar的方法<br>  2)如何取得从1970年1月1日0时0分0秒到现在的毫秒数？        —-&gt;两种常用方法<br>  3)如何取得某月的最后一天，第一天？                        —–&gt;也就是获取过去或未来的日期,使用<strong>add方法</strong><br>  4)如何格式化日期？                                    —–&gt;SimpleDateFormat类的format方法<br>  5)如何获取形如Sat Jun 01 10:29:07 CST 2019类型日期?           ——-&gt;Calendar调用getInstance后调用getTime方法, 或者调用Date类的无参构造器<br>  6) add()和roll()的区别                                     ——-&gt; roll方法是在本月内循环. </p><p>  答：操作方法如下所示：<br>  1)创建java.util.Calendar 实例，调用getInstance()方法后调用其get()方法传入不同的参数即可获得参数所对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前年份、月份、日期  </span></span><br><span class="line">        Calendar cale = Calendar.getInstance(); <span class="comment">////创建实例 默认是当前时刻  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Calendar类源码: public final static int YEAR = 1;  所以1则代表的是对年份操作，同理2是对月份</span></span><br><span class="line"><span class="comment">        操作，3是对星期操作，5是对日期操作，11是对小时操作，12是对分钟操作，13是对秒操作，14是对毫秒操作。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//其中Calendar.YEAR的值为1,这里也可以换为 int year = cale.get(1);</span></span><br><span class="line">        <span class="keyword">int</span> year = cale.get(Calendar.YEAR);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/*注: 加1是因为MONTH是从零计数,即0--&gt;11对应1月---&gt;12月; 例如:如果当前是2019年6月,则</span></span><br><span class="line"><span class="comment">        cale.get(Calendar.MONTH)的值就是5,要想与月份一致,则加1即可. </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> month = cale.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// DATE是DAY_OF_MONTH的同义词,本月的第一天值为1。</span></span><br><span class="line">        <span class="keyword">int</span> day = cale.get(Calendar.DATE);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hour = cale.get(Calendar.HOUR_OF_DAY);  </span><br><span class="line">        <span class="keyword">int</span> minute = cale.get(Calendar.MINUTE);  </span><br><span class="line">        <span class="keyword">int</span> second = cale.get(Calendar.SECOND);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*注: DAY_OF_WEEK:一个星期中的第几天,从1-7对应 星期日-星期六; 如果想让星期一作为一个星期的第一</span></span><br><span class="line"><span class="comment">             天,则减一即可.例如今天星期一,cale.get(Calendar.DAY_OF_WEEK)得到的值则为2,要想与星期相一致,</span></span><br><span class="line"><span class="comment">             则减1即可.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">int</span> dow = cale.get(Calendar.DAY_OF_WEEK)-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> dom = cale.get(Calendar.DAY_OF_MONTH); </span><br><span class="line">        <span class="keyword">int</span> doy = cale.get(Calendar.DAY_OF_YEAR);  </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Current Date: "</span> + cale.getTime());  </span><br><span class="line">        System.out.println(<span class="string">"Year: "</span> + year);  </span><br><span class="line">        System.out.println(<span class="string">"Month: "</span> + month);  </span><br><span class="line">        System.out.println(<span class="string">"Day: "</span> + day);  </span><br><span class="line">        System.out.println(<span class="string">"Hour: "</span> + hour);  </span><br><span class="line">        System.out.println(<span class="string">"Minute: "</span> + minute);  </span><br><span class="line">        System.out.println(<span class="string">"Second: "</span> + second);  </span><br><span class="line">        System.out.println(<span class="string">"Day of Week: "</span> + dow);  </span><br><span class="line">        System.out.println(<span class="string">"Day of Month: "</span> + dom);  </span><br><span class="line">        System.out.println(<span class="string">"Day of Year: "</span> + doy);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">Current Date: Fri May 31 21:51:04 CST 2019</span></span><br><span class="line"><span class="comment">Year: 2019</span></span><br><span class="line"><span class="comment">Month: 5</span></span><br><span class="line"><span class="comment">Day: 31</span></span><br><span class="line"><span class="comment">Hour: 21</span></span><br><span class="line"><span class="comment">Minute: 51</span></span><br><span class="line"><span class="comment">Second: 4</span></span><br><span class="line"><span class="comment">Day of Week: 6</span></span><br><span class="line"><span class="comment">Day of Month: 31</span></span><br><span class="line"><span class="comment">Day of Year: 151</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  2)以下方法均可获得该毫秒数:</p><p>java.lang.System.currentTimeMillis();—–&gt;通常用来计算时间差.</p><p>Calendar.getInstance().getTimeInMillis();</p><p>java.util.Date().getTime()——&gt;目前已经弃用</p><p>  3)示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*add方法: 在给定的日历字段中添加或减去指定的时间量 c.add(Calendar.DATE, X);//取指定天数的时期，</span></span><br><span class="line"><span class="comment">        取过去天的日期用负数，取未来天数日期用正数，在"X"处 如 c.add(Calendar.DATE, -1)取当前日期前</span></span><br><span class="line"><span class="comment">        一天的日期*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当月第一天和最后一天</span></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        String firstday, lastday;</span><br><span class="line">        Calendar cale = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 获取当前月的第一天</span></span><br><span class="line">        cale = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//add方法就可以解决大部分的功能。比如我们需要得到当前年，月，日，小时，分钟，秒，毫秒的前面时间或</span></span><br><span class="line">        <span class="comment">//者后面时间</span></span><br><span class="line">        cale.add(Calendar.MONTH, <span class="number">0</span>);</span><br><span class="line">        cale.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        firstday = format.format(cale.getTime());</span><br><span class="line">        <span class="comment">// 获取当前月的最后一天</span></span><br><span class="line">        cale = Calendar.getInstance();</span><br><span class="line">        cale.add(Calendar.MONTH, <span class="number">1</span>);</span><br><span class="line">        cale.set(Calendar.DAY_OF_MONTH, <span class="number">0</span>);</span><br><span class="line">        lastday = format.format(cale.getTime());</span><br><span class="line">        System.out.println(<span class="string">"本月第一天和最后一天分别是 ： "</span> + firstday + <span class="string">" and "</span> + lastday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line"><span class="comment">//本月第一天和最后一天分别是 ： 2019-05-01 and 2019-05-31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用: time.getActualMaximum(Calendar.DAY_OF_MONTH);</span></span><br></pre></td></tr></table></figure><p>4)利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date ss = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"一般日期输出："</span> + ss);</span><br><span class="line">        System.out.println(<span class="string">"时间戳："</span> + ss.getTime());</span><br><span class="line">        <span class="comment">//Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样</span></span><br><span class="line">        SimpleDateFormat format0 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String time = format0.format(ss.getTime());<span class="comment">//这个就是把时间戳经过处理得到期望格式的时间</span></span><br><span class="line">        System.out.println(<span class="string">"格式化结果0："</span> + time);</span><br><span class="line">        SimpleDateFormat format1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">        time = format1.format(ss.getTime());</span><br><span class="line">        System.out.println(<span class="string">"格式化结果1："</span> + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果: </span></span><br><span class="line"><span class="comment">一般日期输出：Fri May 31 22:18:07 CST 2019</span></span><br><span class="line"><span class="comment">时间戳：1559312287526</span></span><br><span class="line"><span class="comment">格式化结果0：2019-05-31 22:18:07</span></span><br><span class="line"><span class="comment">格式化结果1：2019年05月31日 22时18分07秒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>5) 获取形如Sat Jun 01 10:29:07 CST 2019类型日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Calendar.getInstance().getTime());</span><br><span class="line">或者</span><br><span class="line">System.out.println(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><p>6) add与roll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add()方法 </span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>); </span><br><span class="line">Calendar cal=Calendar.getInstance(); </span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2019</span>); <span class="comment">//Calendar.YEAR设值为2019</span></span><br><span class="line">cal.set(Calendar.MONTH,<span class="number">8</span>);<span class="comment">// Calendar.MONTH设值为8,对应的月份为8+1=9月</span></span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>); <span class="comment">//Calendar.DAY_OF_MONTH设为3,即9月的第3天,也就是2019年9月3日</span></span><br><span class="line">cal.add(Calendar.DATE, -<span class="number">4</span>);  <span class="comment">// Calendar.DATE 减 4, 即2019年9月3日向后退4天,就是2019年8月30 </span></span><br><span class="line">Date date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); <span class="comment">//输出为:2019-08-30 </span></span><br><span class="line">cal.add(Calendar.DATE, <span class="number">4</span>); <span class="comment">//上面的结果上Calendar.DATE 加 4, 即2006年8月30日向前4天,就是2006年9月3</span></span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); <span class="comment">//输出为:2019-09-03</span></span><br><span class="line">输出： </span><br><span class="line"><span class="number">2019</span>-<span class="number">08</span>-<span class="number">30</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">03</span> </span><br><span class="line"><span class="comment">//roll方法 </span></span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2019</span>); </span><br><span class="line">cal.set(Calendar.MONTH,<span class="number">8</span>); <span class="comment">// Calendar.MONTH设值为8,对应的月份为8+1=9月 </span></span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>);<span class="comment">//Calendar.DAY_OF_MONTH设为3,即9月的第3天,也就是2019年9月3日</span></span><br><span class="line">cal.roll(Calendar.DATE, -<span class="number">4</span>);<span class="comment">// Calendar.DATE 减 4, 即2019年9月3日向后退4天(在9月循环),就是2019年9月29 </span></span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); </span><br><span class="line">cal.roll(Calendar.DATE, <span class="number">4</span>); <span class="comment">//上面的结果上Calendar.DATE 加 4, 即2019年9月29日向前4天,就是2019年9月3</span></span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); <span class="comment">//输出为: 2019-09-03 </span></span><br><span class="line">输出： </span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">29</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">03</span> </span><br><span class="line">可见，roll()方法在本月内循环，一般使用add()方法；</span><br></pre></td></tr></table></figure><p>补充: </p><p>\1. java中主要使用:三个类来处理日期和时间</p><p>a. java.util.Date(日期) ,             ————–是一个具体类，用来表示一个<strong>时间点</strong>，表示的是（GMT即<strong>格林尼治标准时间</strong>）从1970年1月1日00:00:00这一刻开始经历的<strong>毫秒数</strong>,主要用于<strong>创建日期对象并获取</strong>日期</p><p>b. java.util.Calendar（日历） ,       ————–是一个抽象类，用来解释和处理时间，<strong>设置和获取日期</strong>数据的特定部分</p><p>c. java.text.DateFormat（日期格式化） ————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat</p><p>\2. 月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写，有要求</p><p>\3. 具体类<strong>Date的对象调用getTime（）</strong>方法得到的是毫秒数，形如： 1506582000000</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date().getTime());<span class="comment">//1559301422873</span></span><br></pre></td></tr></table></figure><p> 抽象类<strong>Calendar的对象调用getInstance方法后,调用getTime（）</strong>方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Calendar.getInstance().getTime());<span class="comment">//Fri May 31 19:27:52 CST 2019</span></span><br><span class="line">System.out.println(Calendar.getInstance());</span><br><span class="line"><span class="comment">/*java.util.GregorianCalendar[time=1559302072601,areFieldsSet=true,areAllFieldsSet=true,lenient=tru</span></span><br><span class="line"><span class="comment">e,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=fal</span></span><br><span class="line"><span class="comment">see,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2019,MONTH</span></span><br><span class="line"><span class="comment">=4,WEEK_OF_YEAR=22,WEEK_OF_MONTH=5,DAY_OF_MONTH=31,DAY_OF_YEAR=151,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MON</span></span><br><span class="line"><span class="comment">TH=5,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,MINUTE=27,SECOND=52,MILLISECOND=601,ZONE_OFFSET=28800000,DST_OFFSET=0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 对具体类<strong>Date</strong>和抽象类<strong>Calendar的时间进行格式化后</strong>，得到形如：2017-07-23 12:15:52</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mut4ubu5j30ss0bywmm.jpg" alt></p><hr><h3 id="42-打印昨天的当前时刻。"><a href="#42-打印昨天的当前时刻。" class="headerlink" title="42 打印昨天的当前时刻。"></a>42 打印昨天的当前时刻。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.add(Calendar.DATE, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(cal.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line">Fri May <span class="number">31</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><h3 id="43-比较一下Java-和JavaSciprt。"><a href="#43-比较一下Java-和JavaSciprt。" class="headerlink" title="43 比较一下Java 和JavaSciprt。"></a>43 比较一下Java 和JavaSciprt。</h3><p>  答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。<br>  下面对两种语言间的异同作如下比较：<br>  1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；<strong>JavaScript</strong>是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种<strong>基于对象（Object-Based）和事件驱动</strong>（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；<br>  2）解释和编译：Java 的源代码在执行之前，必须经过编译；<strong>JavaScript</strong> 是一种解释性编程语言，其<strong>源代码不需经过编译，由浏览器解释执行</strong>；<br>  3）强类型变量和弱类型变量：Java采用强类型变量检查，即所有变量在<strong>编译之前必须作声明</strong>；<strong>JavaScript</strong>中变量声明，采用其弱类型。即<strong>变量在使用前不需作声明</strong>，而是解释器在<strong>运行时检查</strong>其数据类型；<br>  4）代码格式不一样。<br>  补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和<strong>JavaScript</strong>最重要的区别是一个是静态语言，一个是<strong>动态语言</strong>。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</p><h3 id="44-什么时候用assert？"><a href="#44-什么时候用assert？" class="headerlink" title="44 什么时候用assert？"></a>44 什么时候用assert？</h3><p>  答：assertion(断言)在软件开发中是一种常用的<strong>调试方式</strong>，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。<br>  断言用于调试目的：<br>  assert(a &gt; 0); // throws an AssertionError if a &lt;= 0<br>  断言可以有两种形式：<br>  assert Expression1;<br>  assert Expression1 : Expression2 ;<br>  Expression1 应该总是产生一个布尔值。<br>  Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。<br>  断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：<br>  javac -source 1.4 Test.java<br>  要在运行时启用断言，可使用-enableassertions 或者-ea 标记。<br>  要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。<br>  要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。<strong>断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</strong></p><h3 id="45-Error-和Exception-有什么区别"><a href="#45-Error-和Exception-有什么区别" class="headerlink" title="45 Error 和Exception 有什么区别?"></a>45 Error 和Exception 有什么区别?</h3><p>  答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。<br>  补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</p><p>  因此，用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再递归而是回溯了）。</p><h3 id="46-try-里-有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#46-try-里-有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="46 try{}里 有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>46 try{}里 有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</h3><p>  答：会执行，<strong>在方法返回调用者前执行</strong>。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = temp5(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"c = "</span>+d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">temp5</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            c = c + <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"执行finally,修改c的值..."</span> +<span class="string">"修改后C为: "</span>+ c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行finally,修改c的值...修改后C为: 2</span></span><br><span class="line"><span class="comment">c = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在异常处理时提供 finally 块来执行任何清除操作。</p><p>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</p><p><strong>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</strong></p><h3 id="47-Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#47-Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><p>  答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，<strong>每个异常都是一个对象</strong>，<strong>它是Throwable 类或其子类的实例</strong>。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；<strong>可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。</strong></p><h3 id="48-运行时异常与受检异常有何异同？"><a href="#48-运行时异常与受检异常有何异同？" class="headerlink" title="48 运行时异常与受检异常有何异同？"></a>48 运行时异常与受检异常有何异同？</h3><p>答: 异常表示程序运行过程中可能出现的非正常状态: </p><p>运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。</p><p>受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。</p><p>Java编译器要求方法<strong>必须声明抛出可能发生的受检异常</strong>，但是并<strong>不要求必须声明抛出未被捕获的运行时异常</strong>。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：<br>  •    不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）<br>  •    对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br>  •    避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）<br>  •    优先使用标准的异常<br>  •    每个方法抛出的异常都要有文档<br>  •    保持异常的原子性<br>  •    不要在catch中忽略掉捕获到的异常</p><p><strong>异常的分类: 编译异常、运行异常、检查性异常、逻辑异常.</strong></p><p><strong>编译异常: 由于程序语法不合规范，编译不通过</strong></p><p><strong>非运行时异常: 又称检查性异常也称受检异常，此类异常必须被捕获处理</strong>—&gt;<strong>如IO操作错误,类没找到等</strong></p><p><strong>记忆方法: 检查性异常为”IO操作错误”,”类没找到”等,其他基本上是运行时异常.</strong></p><h3 id="49-列出一些你常见的运行时异常？"><a href="#49-列出一些你常见的运行时异常？" class="headerlink" title="49 列出一些你常见的运行时异常？"></a>49 列出一些你常见的运行时异常？</h3><p>  答：<br>  ArithmeticException（算术异常）<br>  ClassCastException （类转换异常）<br>  IllegalArgumentException （非法参数异常）<br>  IndexOutOfBoundsException （下表越界异常）<br>  NullPointerException （空指针异常）<br>  SecurityException （安全异常）</p><h3 id="50-final-finally-finalize-的区别"><a href="#50-final-finally-finalize-的区别" class="headerlink" title="50 final, finally, finalize 的区别?"></a>50 final, finally, finalize 的区别?</h3><p><em>final</em>修饰符（关键字）如果一个类被声明为final，意味着它<strong>不能再派生出新的子类，不能作为父类被继承</strong>例如：String类、Math类等。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写，但是能够重载。 使用final修饰的对象，对象的引用地址不能变，但是对象的值可以变！</p><p><em>finally</em>在异常处理时提供 finally 块来执行任何清除操作。如果有finally的话，则不管是否发生异常，finally语句都会被执行。一般情况下，都把关闭物理连接(IO流、数据库连接、Socket连接)等相关操作，放入到此代码块中。</p><p><em>finalize</em>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作。finalize() 方法是在垃圾收集器删除对象之前被调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。 一般情况下，此方法由JVM调用，程序员不要去调用！</p><h3 id="51-Java跨平台原理（字节码文件、虚拟机）"><a href="#51-Java跨平台原理（字节码文件、虚拟机）" class="headerlink" title="51 Java跨平台原理（字节码文件、虚拟机）"></a>51 Java跨平台原理（字节码文件、虚拟机）</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lozhtgddj324p1llaca.jpg" alt></p><p>C/C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</p><p>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</p><p>字节码文件不面向任何具体平台，只面向虚拟机。</p><p>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</p><p>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。</p><p>Java的跨平台原理决定了其性能没有C/C++高</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lp13dy65j32tn2degqx.jpg" alt></p><h3 id="52-Java三大版本"><a href="#52-Java三大版本" class="headerlink" title="52 Java三大版本"></a>52 Java三大版本</h3><p>Java2平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本：</p><p>Standard Edition(标准版) J2SE 包含那些构成Java语言核心的类。</p><p>比如：数据库连接、接口定义、输入/输出、网络编程</p><p>Enterprise Edition(企业版) J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。</p><p>比如servlet、JSP、XML、事务控制</p><p>Micro Edition(微缩版) J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。</p><p>比如：呼机、智能卡、手机、PDA、机顶盒</p><p>他们的范围是：J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类</p><p>应用场合，API的覆盖范围各不相同</p><h3 id="53-Java的安全性"><a href="#53-Java的安全性" class="headerlink" title="53. Java的安全性"></a>53. Java的安全性</h3><h4 id="53-1-语言层次的安全性主要体现在："><a href="#53-1-语言层次的安全性主要体现在：" class="headerlink" title="53.1 语言层次的安全性主要体现在："></a>53.1 语言层次的安全性主要体现在：</h4><p>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</p><p>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</p><p>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p><p>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</p><h4 id="53-2-底层的安全性可以从以下方面来说明"><a href="#53-2-底层的安全性可以从以下方面来说明" class="headerlink" title="53.2 底层的安全性可以从以下方面来说明"></a>53.2 底层的安全性可以从以下方面来说明</h4><p>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</p><p>在运行环境提供了四级安全性保障机制：</p><p>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</p><h3 id="54-什么是JVM？什么是JDK？-什么是JRE？"><a href="#54-什么是JVM？什么是JDK？-什么是JRE？" class="headerlink" title="54. 什么是JVM？什么是JDK？ 什么是JRE？"></a>54. 什么是JVM？什么是JDK？ 什么是JRE？</h3><h4 id="54-1-JVM"><a href="#54-1-JVM" class="headerlink" title="54.1 JVM :"></a>54.1 JVM :</h4><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</p><h4 id="54-2-JRE："><a href="#54-2-JRE：" class="headerlink" title="54.2 JRE："></a>54.2 JRE：</h4><p>JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到<strong>jre目录，里面有两个文件夹bin和lib</strong>,在这里可以认为<strong>bin里的就是jvm</strong>，<strong>lib中则是jvm工作所需要的类库</strong>，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），<strong>JRE的地位就象一台PC机一样</strong>，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 </p><h4 id="54-3-JDK："><a href="#54-3-JDK：" class="headerlink" title="54.3 JDK："></a>54.3 JDK：</h4><p>JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：<strong>bin、include、lib、jre</strong>。现在我们可以看出这样一个关系，<strong>JDK包含JRE，而JRE包含JVM</strong>。</p><p>bin:最主要的是编译器(javac.exe)</p><p>include:java和JVM交互用的头文件</p><p>lib：类库      </p><p>jre:java运行环境 </p><p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说<strong>JDK是用于java程序的开发,而 jre则是只能运行class而没有编译的功能</strong>。</p><p><strong>eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。</strong></p><h4 id="54-4-JDK-JRE-JVM三者关系概括如下："><a href="#54-4-JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="54.4 JDK,JRE,JVM三者关系概括如下："></a>54.4 JDK,JRE,JVM三者关系概括如下：</h4><p>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDK、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</p><h3 id="55-Java三种注释类型"><a href="#55-Java三种注释类型" class="headerlink" title="55 Java三种注释类型"></a>55 Java三种注释类型</h3><p>共有单行注释、多行注释、文档注释3种注释类型。使用如下：</p><p>①: 单行注释，采用“//”方式.只能注释一行代码。如：//类成员变量</p><p>②: 多行注释，采用“/<em>…</em>/”方式，可注释多行代码，其中不允许出现嵌套。如：</p><p>/*System.out.println(“a”);</p><p>System.out.println(“b”);</p><p>System.out.println(“c”);*/</p><p>③: 文档注释，采用“/*<em>…</em>/”方式。如：</p><p>/<strong><br>*子类 Dog<br>*@author Administrator<br>\</strong>/<br>public class Dog extends Animal{}</p><h3 id="56-i-和-i的异同之处"><a href="#56-i-和-i的异同之处" class="headerlink" title="56. i++和++i的异同之处"></a>56. i++和++i的异同之处</h3><p>####56.1  共同点：</p><p>1、i++和++i都是变量自增1，都等价于i=i+1</p><p>2、如果i++,++i是一条单独的语句，两者没有任何区别</p><p>3、i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</p><h4 id="56-2-不同点："><a href="#56-2-不同点：" class="headerlink" title="56.2 不同点："></a>56.2 不同点：</h4><p>如果i++,++i不是一条单独的语句，他们就有区别i++ ：先运算后增1。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=x++;</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x+<span class="string">", y="</span>+y);</span><br><span class="line"><span class="comment">//以上代码运行后输出结果为：x=6, y=5</span></span><br></pre></td></tr></table></figure><p>++i ： 先增1后运算。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=++x;</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x+<span class="string">", y="</span>+y);</span><br><span class="line"><span class="comment">//以上代码运行后输出结果为：x=6, y=6</span></span><br></pre></td></tr></table></figure><h3 id="57-基本数据类型的类型转换规则"><a href="#57-基本数据类型的类型转换规则" class="headerlink" title="57 基本数据类型的类型转换规则"></a>57 基本数据类型的类型转换规则</h3><p>基本类型转换分为自动转换和强制转换。</p><p>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可</p><p>以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。</p><p>强制转换规则：高级变为低级需要强制转换。</p><p>如何转换：</p><p>（1）赋值运算符“=”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</p><p>（2）赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</p><p>(3)可以将整型常量直接赋值给byte, short, char等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</p><h3 id="58-if多分支语句和switch多分支语句的异同之处"><a href="#58-if多分支语句和switch多分支语句的异同之处" class="headerlink" title="58 if多分支语句和switch多分支语句的异同之处"></a>58 if多分支语句和switch多分支语句的异同之处</h3><p>相同之处：都是分支语句，多超过一种的情况进行判断处理。</p><p>不同之处：</p><p>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，<strong>在分支执行完后（如果没有break跳出），不加判断地执行下去</strong>;</p><p>而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，<strong>只要一个分支被执行后，后边的分支不再执行</strong>。</p><p><strong>switch为等值判断（不允许比如&gt;= &lt;=</strong>），而if为等值和区间都可以，if的使用范围大。</p><h3 id="59-while和do-while循环的区别"><a href="#59-while和do-while循环的区别" class="headerlink" title="59. while和do-while循环的区别"></a>59. while和do-while循环的区别</h3><p>while先判断后执行，第一次判断为false,循环体一次都不执行</p><p>do while先执行 后判断，最少执行1次。</p><p>如果while循环第一次判断为true, 则两种循环没有区别。</p><h3 id="60-break和continue的作用"><a href="#60-break和continue的作用" class="headerlink" title="60. break和continue的作用"></a>60. break和continue的作用</h3><p>break: 结束当前循环并退出当前循环体。</p><p>break还可以退出switch语句</p><p>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。<strong>continue只是结束本次循环</strong>。</p><h3 id="61-递归的定义和优缺点"><a href="#61-递归的定义和优缺点" class="headerlink" title="61. 递归的定义和优缺点"></a>61. 递归的定义和优缺点</h3><p>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</p><p>递归算法解决问题的特点：</p><p>(1) 递归就是在过程或函数里调用自身。</p><p>(2) 在使用递归策略时，<strong>必须有一个明确的递归结束条件</strong>，称为递归出口。</p><p>(3) 递归算法解题通常显得很简洁，但运行<strong>效率较低</strong>。所以<strong>一般不提倡用递归</strong>算法设计程序。</p><p>(4) 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</p><h3 id="62-数组的特征"><a href="#62-数组的特征" class="headerlink" title="62. .数组的特征"></a>62. .数组的特征</h3><p>数组是（<strong>相同类型数据</strong>）的（<strong>有序</strong>）（集合）</p><p>数组会在内存中开辟<strong>一块连续的空间</strong>，每个空间相当于之前的一个变量，称为数组的元素element</p><p>元素的表示 数组名[下标或者索引] scores[7] scores[0] scores[9]</p><p><strong>索引从0开始</strong></p><p><strong>每个数组元素有默认值</strong>    double 0.0 boolean false int 0</p><p><strong>注: 数组元素有序的，不是大小顺序，是索引 的顺序</strong></p><p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，<strong>数组的类型是固定的</strong>，只能是一个</p><p><strong>没有length方法,但是有length属性</strong>,length是数组长度.</p><p>数组的<strong>长度是固定的</strong>，一经定义，不能再发生变化（数组的扩容）</p><h3 id="63-请写出冒泡排序代码"><a href="#63-请写出冒泡排序代码" class="headerlink" title="63. 请写出冒泡排序代码"></a>63. 请写出冒泡排序代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层循环，它决定一共走几趟</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;a.length-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//内层循环，它决定每趟走一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;a.length-i-<span class="number">1</span> ; ++j) &#123;</span><br><span class="line">            <span class="comment">//如果后一个大于前一个</span></span><br><span class="line">            <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j]) &#123;</span><br><span class="line">                <span class="comment">//换位</span></span><br><span class="line">                temp = a[j];a[j] = a[j + <span class="number">1</span>];a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;a.length-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;a.length-<span class="number">1</span>-i ; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j]) &#123;</span><br><span class="line">                    temp = a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="64-请写出选择排序的代码"><a href="#64-请写出选择排序的代码" class="headerlink" title="64. 请写出选择排序的代码"></a>64. 请写出选择排序的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 认为目前的数就是最小的, 记录最小数的下标</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 修改最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出for就找到这次的最小值</span></span><br><span class="line">        <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="65-请写出插入排序的代码"><a href="#65-请写出插入排序的代码" class="headerlink" title="65. 请写出插入排序的代码"></a>65. 请写出插入排序的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="66-类和对象的关系"><a href="#66-类和对象的关系" class="headerlink" title="66. 类和对象的关系"></a>66. 类和对象的关系</h3><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p><p>类和对象好比图纸和实物的关系，模具和铸件的关系。</p><p>比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</p><p>小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。</p><h3 id="67-面向过程和面向对象的区别"><a href="#67-面向过程和面向对象的区别" class="headerlink" title="67. 面向过程和面向对象的区别"></a>67. 面向过程和面向对象的区别</h3><p>两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lqb5dh8dj30g407yt8k.jpg" alt></p><p><strong>比喻</strong></p><p>蒋介石和毛泽东分别是面向过程和面向对象的杰出代表，这样充分说明，在解决复制问题时，面向对象有更大的优越性。</p><p>面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。</p><p><strong>区别</strong></p><p>编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</p><p>封装性：都具有封装性，但是<strong>面向过程是封装的是功能</strong>，而<strong>面向对象封装的是数据和功能。</strong></p><p>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</p><h3 id="68-方法重载和方法重写（覆盖）的区别"><a href="#68-方法重载和方法重写（覆盖）的区别" class="headerlink" title="68. 方法重载和方法重写（覆盖）的区别"></a>68. 方法重载和方法重写（覆盖）的区别</h3><table><thead><tr><th>英文</th><th>位置不同</th><th>作用不同</th><th></th></tr></thead><tbody><tr><td>重载</td><td>overload</td><td>同一个类中</td><td>在一个类里面为一种行为提供多种实现方式并提高可读性</td></tr><tr><td>重写</td><td>override</td><td>子类和父类间</td><td>父类方法无法满足子类的要求，子类通过方法重写满足要求</td></tr></tbody></table><table><thead><tr><th></th><th>修饰符</th><th>返回值</th><th>方法名</th><th>参数</th><th>抛出异常</th></tr></thead><tbody><tr><td>重载</td><td>无关</td><td>无关</td><td><strong>相同</strong></td><td><strong>不同</strong></td><td>无关</td></tr><tr><td>重写</td><td>大于等于</td><td>小于等于</td><td><strong>相同</strong></td><td><strong>相同</strong></td><td>小于等于</td></tr></tbody></table><h3 id="69-this和super关键字的作用"><a href="#69-this和super关键字的作用" class="headerlink" title="69. this和super关键字的作用"></a>69. this和super关键字的作用</h3><p>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；<strong>this可以调用成员变量，不能调用局部变量</strong>；this也可以调用成员方法，但是在普通方法中可以省略this，在<strong>构造方法中不允许省略</strong>，必须是构造方法的第一条语句。，而且在<strong>静态方法当中不允许出现this关键字</strong>。</p><p>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</p><p>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如<strong>不能访问private成员</strong>）；<strong>super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句</strong>。</p><h3 id="70-static关键字"><a href="#70-static关键字" class="headerlink" title="70. static关键字"></a>70. static关键字</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lvu9umcrj30db05s41y.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lvuvudilj30fa09pgr1.jpg" alt></p><p>static可以修饰变量、方法、代码块和内部类</p><p>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</p><p>static变量和非static变量的区别(都是成员变量，不是局部变量)</p><p>1.在内存中份数不同</p><p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</p><p>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</p><p>2.在内存中存放的位置不同</p><p>3.访问的方式不同</p><p>实例变量： 对象名.变量名 stu1.name=”小明明”;</p><p>静态变量：对象名.变量名 stu1.schoolName=”西二旗小学”; 不推荐如此使用</p><p>类名.变量名 Student.schoolName=”东三旗小学”; 推荐使用</p><p>4.在内存中分配空间的时间不同</p><p><strong>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</strong></p><p>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，<strong>且只被执行一次</strong>，主要作用是实现static属性的初始化。</p><p>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</p><h3 id="71-final和abstract关键字"><a href="#71-final和abstract关键字" class="headerlink" title="71.final和abstract关键字"></a>71.final和abstract关键字</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lw0h7727j30g60aiq6w.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3lw0t8b78j30kr07kdjq.jpg" alt></p><p><img src="![](https://ws1.sinaimg.cn/large/0064BnmZly1g3lw5i6gnvj30m307ddmt.jpg" alt></p><p><strong>abstract只能修饰方法和类，不能修饰字段；</strong></p><p>final和abstract是功能相反的两个关键字，可以对比记忆</p><p><em>abstract</em>可以用来修饰类和方法，<strong>不能用来修饰属性和构造方法</strong>；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</p><p><em>final</em>可以用来修饰类、方法和属性，<strong>不能修饰构造方法</strong>。使用final修饰的类<strong>不能被继承</strong>，使用final修饰的方法<strong>不能被重写</strong>，使用final修饰的变量的值<strong>不能被修改</strong>，所以就成了常量。</p><p><em>特别注意：</em>final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">package</span>` `com.bjsxt;` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>&#123;``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;``        ``<span class="keyword">final</span>` `Dog dog = ``<span class="keyword">new</span>` `Dog(``<span class="string">"欧欧"</span>``);``        ``dog.name = ``<span class="string">"美美"</span>``;``<span class="comment">//正确``        ``dog = ``new` `Dog(``"亚亚"``);``//错误``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><h3 id="72-写出java-lang-Object类的六个常用方法"><a href="#72-写出java-lang-Object类的六个常用方法" class="headerlink" title="72. 写出java.lang.Object类的六个常用方法"></a>72. 写出java.lang.Object类的六个常用方法</h3><p>(1)public boolean <strong>equals</strong>(java.lang.Object)//比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等；</p><p>(2)public native int <strong>hashCode</strong>() 获取哈希码</p><p>(3)public java.lang.String <strong>toString</strong>() 把数据转变成字符串</p><p>(4)public final native java.lang.Class <strong>getClass</strong>() 获取类结构信息</p><p>(5)protected void <strong>finalize</strong>() throws java.lang.Throwable   //垃圾回收前执行的方法</p><p>(6)protected native Object <strong>clone</strong>() throws java.lang.CloneNotSupportedException 克隆</p><p>(7)public final void <strong>wait</strong>() throws java.lang.InterruptedException   //多线程中等待功能</p><p>(8)public final native void <strong>notify</strong>() 多线程中唤醒功能</p><p>(9)public final native void <strong>notifyAll</strong>() 多线程中唤醒所有等待线程的功能</p><h3 id="73-继承条件下构造方法的执行过程"><a href="#73-继承条件下构造方法的执行过程" class="headerlink" title="73. 继承条件下构造方法的执行过程"></a>73. 继承条件下构造方法的执行过程</h3><p>继承条件下构造方法的调用规则如下：</p><p>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</p><p>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</p><p>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</p><p>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</p><h3 id="74-和equals的区别和联系"><a href="#74-和equals的区别和联系" class="headerlink" title="74.==和equals的区别和联系"></a>74.==和equals的区别和联系</h3><p>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</p><p>“==”使用情况如下：</p><p>a) 基本类型，比较的是值</p><p>b) 引用类型，比较的是地址</p><p>c) 不能比较没有父子关系的两个对象</p><p>equals()方法使用如下：</p><p>a) 系统类一般已经覆盖了equals()，比较的是内容。</p><p>b) 用户自定义类如果没有覆盖equals()，将调用父类的equals （比如是Object），而Object的equals的比较是地址（return (this == obj);）</p><p>c) 用户自定义类需要覆盖父类的equals()</p><p>注意：Object的==和equals比较的都是地址，作用相同</p><h3 id="75-谈谈Java的多态"><a href="#75-谈谈Java的多态" class="headerlink" title="75. 谈谈Java的多态"></a>75. 谈谈Java的多态</h3><p>实现多态的三个条件（前提条件，向上转型、向下转型）</p><p>1、继承的存在；（继承是多态的基础，<strong>没有继承就没有多态</strong>）</p><p>2、子类重写父类的方法。（多态下会调用子类重写后的方法）</p><p>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）</p><p>向上转型 Student person = new Student()</p><p>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</p><p>向下转型 Student stu = (Student)person;</p><p>将一个指向子类对象的父类引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，，否则将出现ClassCastException，不是任意的强制转换</p><p><strong>向下转型时可以结合使用instanceof运算符进行强制类型转换</strong>，比如出现转换异常—ClassCastException</p><h3 id="76-简述Java的垃圾回收机制"><a href="#76-简述Java的垃圾回收机制" class="headerlink" title="76. 简述Java的垃圾回收机制"></a>76. 简述Java的垃圾回收机制</h3><p>传统的C/C++语言，需要程序员负责回收已经分配内存。</p><h4 id="76-1显式回收垃圾回收的缺点："><a href="#76-1显式回收垃圾回收的缺点：" class="headerlink" title="76.1显式回收垃圾回收的缺点："></a>76.1显式回收垃圾回收的缺点：</h4><p>1）程序忘记及时回收，从而导致内存泄露，降低系统性能。</p><p>2）程序错误回收程序核心类库的内存，导致系统崩溃。</p><p>Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制，简称GC；</p><p>1）可以提高编程效率。</p><p>2）保护程序的完整性。</p><p>3）其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。</p><h4 id="76-2-垃圾回收机制的-特点"><a href="#76-2-垃圾回收机制的-特点" class="headerlink" title="76.2 垃圾回收机制的 特点"></a>76.2 垃圾回收机制的 特点</h4><p>1）垃圾回收机制回收JVM堆内存里的对象空间,<strong>不负责回收栈内存数据。</strong></p><p>2）对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。</p><p>3）垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</p><p>4）可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</p><p>现在的JVM有多种垃圾回收 实现算法，表现各异。</p><p>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</p><p>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。</p><p><strong>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</strong></p><h3 id="77-基本数据类型和包装类"><a href="#77-基本数据类型和包装类" class="headerlink" title="77. 基本数据类型和包装类"></a>77. 基本数据类型和包装类</h3><p>####77.1 八个基本数据类型的包装类</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h4 id="77-2-为什么为基本类型引入包装类"><a href="#77-2-为什么为基本类型引入包装类" class="headerlink" title="77.2 为什么为基本类型引入包装类"></a>77.2 为什么为基本类型引入包装类</h4><p>2.1基本数据类型有方便之处，简单、高效。</p><p>2.2但是Java中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是Object）。</p><p>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p><h4 id="77-3-包装类和基本数据类型之间的转换"><a href="#77-3-包装类和基本数据类型之间的转换" class="headerlink" title="77.3 包装类和基本数据类型之间的转换"></a>77.3 包装类和基本数据类型之间的转换</h4><p>3.1包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</p><p>3.2包装类——-new WrapperClass(primitive)</p><p>3.2包装类——-new WrapperClass(primitive)</p><p>4) 自动装箱和自动拆箱</p><p>JDK1.5提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</p><p>5) 包装类还可以实现基本类型变量和字符串之间的转换</p><h3 id="78-Integer与int的区别"><a href="#78-Integer与int的区别" class="headerlink" title="78. Integer与int的区别"></a>78. Integer与int的区别</h3><p>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</p><p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p><p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p><h3 id="79-java-sql-Date和java-util-Date的联系和区别"><a href="#79-java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="79.java.sql.Date和java.util.Date的联系和区别"></a>79.java.sql.Date和java.util.Date的联系和区别</h3><p>1） java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</p><p>2）JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.<strong>sql.Timestamp类比java.util.Date类精确度要高</strong>。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</p><p>总之，java.util.Date 就是Java的日期对象，<strong>而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分.</strong></p><h3 id="80-使用递归算法输出某个目录下所有文件和子目录列表"><a href="#80-使用递归算法输出某个目录下所有文件和子目录列表" class="headerlink" title="80. 使用递归算法输出某个目录下所有文件和子目录列表"></a>80. 使用递归算法输出某个目录下所有文件和子目录列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"D:/301SXT"</span>;</span><br><span class="line">        test(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(path);</span><br><span class="line">        File[] fs = f.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (File file : fs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(file.getPath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                test(file.getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="81-Java中接口的修饰符可以为（）（选择一项）"><a href="#81-Java中接口的修饰符可以为（）（选择一项）" class="headerlink" title="81. Java中接口的修饰符可以为（）（选择一项）"></a>81. Java中接口的修饰符可以为（）（选择一项）</h3><table><thead><tr><th>A</th><th>private</th></tr></thead><tbody><tr><td>B.</td><td>protected</td></tr><tr><td>C.</td><td>final</td></tr><tr><td>D.</td><td>abstract</td></tr><tr><td>答案：D<br>分析：<strong>接口中的访问权限修饰符只可以是public或default</strong>,接口中的所有的方法必须要实现类实现，所以<strong>不能使用final</strong>,接口中所有的方法默认都是abstract的，所以接口<strong>可以使用abstract修饰</strong>，但通常abstract可以省略不写</td></tr></tbody></table><h3 id="82-为什么接口里面的属性必须是常量即final修饰-且静态即static修饰"><a href="#82-为什么接口里面的属性必须是常量即final修饰-且静态即static修饰" class="headerlink" title="82. 为什么接口里面的属性必须是常量即final修饰, 且静态即static修饰"></a>82. 为什么接口里面的属性必须是常量即final修饰, 且静态即static修饰</h3><p>知识点1：一个类，首先他会在内存里面有一个类对象，然后由类对象生成类的对象 </p><p>知识点2：为什么接口Interface里面的属性必须是常量呢？ 因为类可以被实例化，实例化的类的对象里面的变量就会被赋初始值。比如String 是 null int是0，double是0.0。但是接口呢？接口不能被实例化，所以接口里面如果是变量的话不会被赋初始值这样就会出问题。所以接口里面的值必须是常量final而且一定是static不管写不写都是</p><p>知识点3：那为什么它要是静态的呢？因为static是什么？是所有对象可以访问，而且可以直接通过类名访问。接口有对象么？显然没有,因为接口不能被实例化，必须通过类名来访问所以是要静态的。</p><p>补充: </p><p>Java的interface中，成员变量的默认修饰符为：<strong>public static final</strong></p><p>Java的interface中，方法的默认修饰符是：<strong>public abstract</strong></p><p>以上两种都可以，老司机一般都是第二种。既然是静态最终的变量，也就意味着在外面访问的时候不能修改这个成员变量的值。所以在接口中定义成员变量的，一般都是常量。不会修改的。如果要进行修改的话，定义在接口具体实现类中。</p><h3 id="83-给定以下代码，程序将输出-（）（选择一项）"><a href="#83-给定以下代码，程序将输出-（）（选择一项）" class="headerlink" title="83. 给定以下代码，程序将输出 （）（选择一项）"></a>83. 给定以下代码，程序将输出 （）（选择一项）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>A</th><th>不能通过编译</th></tr></thead><tbody><tr><td>B.</td><td>通过编译，输出AB</td></tr><tr><td>C.</td><td>通过编译，输出B</td></tr><tr><td>D.</td><td>通过编译，输出A</td></tr><tr><td>答案：B<br>分析：在继承关系下，创建子类对象，先执行父类的构造方法，再执行子类的构造方法</td></tr></tbody></table><h3 id="84-为什么说静态的不能访问非静态的，而非静态的能访问静态的？"><a href="#84-为什么说静态的不能访问非静态的，而非静态的能访问静态的？" class="headerlink" title="84. 为什么说静态的不能访问非静态的，而非静态的能访问静态的？"></a>84. 为什么说静态的不能访问非静态的，而非静态的能访问静态的？</h3><p>原因：生命周期：静态的执行早于非静态的（也就是说晚生成的能调用早生成的，而早生成的不能调用晚生成的）</p><h3 id="85-选出合理的标识符（）（选择两项）"><a href="#85-选出合理的标识符（）（选择两项）" class="headerlink" title="85. 选出合理的标识符（）（选择两项）"></a>85. 选出合理的标识符（）（选择两项）</h3><table><thead><tr><th>A</th><th>_sysl_111</th></tr></thead><tbody><tr><td>B.</td><td>2 mail</td></tr><tr><td>C.</td><td>$change</td></tr><tr><td>D.</td><td>class</td></tr><tr><td>答案：AC<br>分析： 标识符的命令规范，可以包含字母、数字、下划线、$，不能以数字开头，不能是Java关键字</td></tr></tbody></table><h3 id="86-面向对象的特征有哪些方面？请用生活中的例子来描述"><a href="#86-面向对象的特征有哪些方面？请用生活中的例子来描述" class="headerlink" title="86. 面向对象的特征有哪些方面？请用生活中的例子来描述"></a>86. 面向对象的特征有哪些方面？请用生活中的例子来描述</h3><p>答:    面向对象的三大特征：封装、继承、多态。</p><p>举例：（比如设计一个游戏）我现在创建了一个对象，名叫战士。</p><p>战士的属性是—性别，年龄，职业，等级，战斗力，血量。</p><p>它的方法—战斗，逃跑，吃饭，睡觉，死。</p><p>后来，我又建了一个对象，叫人。</p><p>属性:性别，年龄，职业，等级，血量</p><p>方法:逃跑，吃饭，睡觉，死。</p><p>我让人，成为战士的父类，战士可以直接继承人的属性和方法。</p><p>战士修改成—</p><p>属性:战斗力。</p><p>方法:战斗。</p><p>看上去战士的资料变少了，实际上没有，我们仍然可以调用方法—战士.死。</p><p>而且我们还可以重载战士.死的方法，简称重载死法。</p><p>我还建了一个对象—法师，父类也是人。</p><p>属性:法力值</p><p>方法:施法，泡妞。</p><p>你看，用了继承，创建对象变得更方便了。</p><p>再后来，我又建立了一个对象，叫怪物。</p><p>属性:等级，战力，血量。</p><p>方法:战斗，死。</p><p>建了个对象，叫白兔怪，父类怪物，可继承怪物所有的属性和方法。</p><p>属性:毛色。</p><p>方法:卖萌，吃胡萝卜。</p><h3 id="87-说明内存泄漏和内存溢出的区别和联系"><a href="#87-说明内存泄漏和内存溢出的区别和联系" class="headerlink" title="87. 说明内存泄漏和内存溢出的区别和联系"></a>87. 说明内存泄漏和内存溢出的区别和联系</h3><p><strong>内存泄漏: </strong>是指你向系统申请分配内存进行使用(new)，可是<strong>使用完了以后却不归还(delete)</strong>，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</p><p><strong>内存溢出</strong>：一个盘子用尽各种方法<strong>只能装4个果子，你装了5个</strong>，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错</p><p>总结: memory leak会最终会导致out of memory！</p><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p><p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p><h3 id="88-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"><a href="#88-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？" class="headerlink" title="88.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"></a>88.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</h3><p>答：Java中的序列化机制能够将一个实例<strong>对象</strong>（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的<strong>状态信息</strong> <strong>写</strong>入到一个<strong>字节流</strong>中使其可以通过<strong>socket进行传输</strong>、或者<strong>持久化到存储数据库或文件系统</strong>中；然后在需要的时候通过字节流中的信息来重构一个相同的对象。</p><p>一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接口即可。</p><p>对象的序列化主要有两种用途：</p><p>1） 把对象的字节序列永久地<strong>保存到硬盘</strong>上，通常存放在一个文件中；</p><p>2） 在<strong>网络上</strong> 传送对象的字节序列。</p><p>在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p><p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p><h3 id="89-不通过构造函数也能创建对象吗？"><a href="#89-不通过构造函数也能创建对象吗？" class="headerlink" title="89. 不通过构造函数也能创建对象吗？"></a>89. 不通过构造函数也能创建对象吗？</h3><p>答：Java创建对象的几种方式（重要）：</p><p>1、 用<strong>new</strong>语句创建对象，这是最常见的创建对象的方法。</p><p>2、 运用<strong>反射</strong>手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</p><p>3、 调用对象的<strong>clone()</strong>方法。</p><p>4、运用<strong>反序列化</strong>手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p><p>(1)和(2)都会明确的<strong>显式的调用构造函数</strong> ；</p><p>(3)是在内存上对已有对象的影印，所以<strong>不会调用构造函数</strong> ；(4)是从文件中还原类的对象，也<strong>不会调用构造函数</strong>。</p><h3 id="90-匿名内部类可不可以继承或实现接口。为什么？"><a href="#90-匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="90. .匿名内部类可不可以继承或实现接口。为什么？"></a>90. .匿名内部类可不可以继承或实现接口。为什么？</h3><p>答：匿名内部类是没有名字的内部类,<strong>不能继承其它类</strong>,但一个内部类可以作为一个接口,由另一个内部类实现.</p><p>1、<strong>由于匿名内部类没有名字，所以它没有构造函数</strong>。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。</p><p>2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</p><p>3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</p><h3 id="91-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#91-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="91. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>91. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h3><p>(1) 在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt; K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt; K, V&gt;可以理解为HashMap&lt; Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。</p><p>虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型。</p><h3 id="92-简述Java中如何实现多态"><a href="#92-简述Java中如何实现多态" class="headerlink" title="92. 简述Java中如何实现多态"></a>92. 简述Java中如何实现多态</h3><p>实现多态有三个前提条件：</p><p>1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。</p><p>2、子类重写父类的方法。（多态下会调用子类重写后的方法）。</p><p>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</p><p>最后使用父类的引用变量调用子类重写的方法即可实现多态。</p><h3 id="93-Java-中-Math-random（）-Math-random（）值为？"><a href="#93-Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="93.Java 中 Math.random（）/Math.random（）值为？"></a>93.Java 中 Math.random（）/Math.random（）值为？</h3><p>如果除数与被除数均为0.0的话，则运行结果为NaN（Not a Number的简写），计算错误</p><h3 id="94-Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#94-Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="94. Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>94. Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？</h3><p>不是，两者没有任何关联；</p><p>Pair是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例化而已；所以，Pair&lt; Manager&gt;和Pair&lt; Employee&gt;不是子类的关系。</p><h3 id="95-接口和抽象类的区别"><a href="#95-接口和抽象类的区别" class="headerlink" title="95. 接口和抽象类的区别"></a>95. 接口和抽象类的区别</h3><p>抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现</p><p>两者的区别主要体现在两方面：语法方面和设计理念方面</p><p>语法方面的区别是比较低层次的，非本质的，主要表现在：</p><p>接口中只能定义全局常量(静态常量)，不能定义变量。抽象类中可以定义常量和变量。</p><p>接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。</p><p>抽象类中可以有构造方法，但不能用来实例化，而在子类实例化时执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。</p><p>一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。</p><p>一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。</p><p>抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a”的关系，即父类和子类在概念本质上应该是相同的。</p><p>接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。接口和实现之间可以认为是一种“has-a的关系”</p><h3 id="96-同步代码块和同步方法有什么区别"><a href="#96-同步代码块和同步方法有什么区别" class="headerlink" title="96. 同步代码块和同步方法有什么区别"></a>96. 同步代码块和同步方法有什么区别</h3><p>相同点：</p><p>同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。</p><p>而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。</p><p>一般情况下，如果此“目标”为this，同步方法和代码块没有太大的区别。</p><p>区别：</p><p>同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</p><h3 id="97-静态内部类和内部类有什么区别"><a href="#97-静态内部类和内部类有什么区别" class="headerlink" title="97. 静态内部类和内部类有什么区别"></a>97. 静态内部类和内部类有什么区别</h3><p>静态内部类<strong>不需要有指向外部类的引用</strong>。但非静态内部类需要持有对外部类的引用。</p><p>静态内部类可以<strong>有静态成员(方法，属性)</strong>，而非静态内部类则不能有静态成员(方法，属性)。</p><p>非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。</p><p>实例化方式不同：</p><p>1) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象</p><p>2) 非静态内部类：通过外部类的对象实例生成内部类对象</p><h3 id="98-反射的概念与作用"><a href="#98-反射的概念与作用" class="headerlink" title="98.反射的概念与作用"></a>98.反射的概念与作用</h3><p>反射的概念：</p><p>反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。</p><p>Java反射可以于运行时加载,探知和使用编译期间完全未知的类.</p><p>程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性;</p><p>加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射.</p><p>java反射使得我们可以在程序运行时动态加载一个类，动态获取类的基本信息和定义的方法,构造函数,域等。</p><p>除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获取类实例的域值。反射使java这种静态语言有了动态的特性。</p><p>反射的作用：</p><p>通过反射可以使程序代码访问装载到JVM 中的类的内部信息</p><p>1) 获取已装载类的属性信息</p><p>2) 获取已装载类的方法</p><p>3) 获取已装载类的构造方法信息</p><p>反射的优点：</p><p>增加程序的灵活性。</p><p>如struts中。请求的派发控制。</p><p>当请求来到时。struts通过查询配置文件。找到该请求对应的action。已经方法。</p><p>然后通过反射实例化action。并调用响应method。</p><p>如果不适用反射，那么你就只能写死到代码里了。</p><p>所以说，一个灵活，一个不灵活。</p><p>很少情况下是非用反射不可的。大多数情况下反射是为了提高程序的灵活性。因此一般框架中使用较多。因为框架要适用更多的情况。对灵活性要求较高。</p><h3 id="99-Java程序的种类有（）-多选"><a href="#99-Java程序的种类有（）-多选" class="headerlink" title="99.Java程序的种类有（）(多选)"></a>99.Java程序的种类有（）(多选)</h3><table><thead><tr><th>A</th><th>类 (Class)</th></tr></thead><tbody><tr><td>B.</td><td>Applet</td></tr><tr><td>C.</td><td>Application</td></tr><tr><td>D.</td><td>Servlet</td></tr><tr><td>答案：BCD<br>分析：是Java中的类，不是程序；内嵌于Web文件中，由浏览器来观看的Applet；可独立运行的 Application；服务器端的 Servlet。</td></tr></tbody></table><h3 id="100-下列标识符不合法的有（）-多选"><a href="#100-下列标识符不合法的有（）-多选" class="headerlink" title="100. 下列标识符不合法的有（）(多选)"></a>100. 下列标识符不合法的有（）(多选)</h3><table><thead><tr><th>A</th><th>new</th></tr></thead><tbody><tr><td>B.</td><td>$Usdollars</td></tr><tr><td>C.</td><td>1234</td></tr><tr><td>D.</td><td>car.taxi</td></tr><tr><td>答案：ACD<br>分析：new是Java的关键字；C. 数字不能开头；D. 不能有“.”。</td></tr></tbody></table><h3 id="101-不能用来修饰interface的有（）-多选"><a href="#101-不能用来修饰interface的有（）-多选" class="headerlink" title="101. 不能用来修饰interface的有（）(多选)"></a>101. 不能用来修饰interface的有（）(多选)</h3><table><thead><tr><th>A</th><th>private</th></tr></thead><tbody><tr><td>B.</td><td>public</td></tr><tr><td>C.</td><td>protected</td></tr><tr><td>D.</td><td>static</td></tr><tr><td>答案：ACD分析：能够修饰interface的只有public、abstract以及默认的三种修饰符。</td></tr></tbody></table><h3 id="102-下列说法错误的有（）-多选"><a href="#102-下列说法错误的有（）-多选" class="headerlink" title="102. 下列说法错误的有（）(多选)"></a>102. 下列说法错误的有（）(多选)</h3><table><thead><tr><th>A</th><th>在类方法中可用this来调用本类的类办法</th></tr></thead><tbody><tr><td>B.</td><td>在类方法中调用本类的类方法时可以直接调用</td></tr><tr><td>C.</td><td>在类方法中只能调用本类中的类方法</td></tr><tr><td>D.</td><td>在类方法中绝对不能调用实例方法</td></tr><tr><td>答案：ACD<br>分析：类方法是在类加载时被加载到方法区存储的，此时还没有创建对象，所以不能使用this或者super关键字；C. 在类方法中还可以调用其他类的类方法；D. 在类方法可以通过创建对象来调用实例方法。</td></tr></tbody></table><h3 id="103-下列说法错误的有（）-多选"><a href="#103-下列说法错误的有（）-多选" class="headerlink" title="103. 下列说法错误的有（）(多选)"></a>103. 下列说法错误的有（）(多选)</h3><table><thead><tr><th>A</th><th>Java面向对象语言容许单独的过栈与函数存在</th></tr></thead><tbody><tr><td>B.</td><td>Java面向对象语言容许单独的方法存在</td></tr><tr><td>C.</td><td>Java语言中的方法属于类中的成员（member）</td></tr><tr><td>D.</td><td>Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同</td></tr><tr><td>答案：ABC<br>分析：B. Java不允许单独的方法，过程或函数存在，需要隶属于某一类中；C. 静态方法属于类的成员，非静态方法属于对象的成员。</td></tr></tbody></table><h3 id="104-下列说法错误的有（）-多选"><a href="#104-下列说法错误的有（）-多选" class="headerlink" title="104. 下列说法错误的有（）(多选)"></a>104. 下列说法错误的有（）(多选)</h3><table><thead><tr><th>A</th><th>能被java.exe成功运行的java class文件必须有main()方法</th></tr></thead><tbody><tr><td>B.</td><td>J2SDK就是Java API</td></tr><tr><td>C.</td><td>Appletviewer.exe可利用jar选项运行.jar文件</td></tr><tr><td>D.</td><td>能被Appletviewer成功运行的java class文件必须有main()方法</td></tr><tr><td>答案：BCD<br>分析：<br>B. J2SDK是sun公司编程工具，API是指的应用程序编程接口；<br>C. Appletviewer.exe就是用来解释执行java applet应用程序的，一种执行HTML文件上的Java小程序类的Java浏览器；<br>D. 能被Appletviewer成功运行的java class文件可以没有main（）方法。</td></tr></tbody></table><h3 id="105-不通过-构造函数-也能创建对象么（）"><a href="#105-不通过-构造函数-也能创建对象么（）" class="headerlink" title="105. 不通过 构造函数 也能创建对象么（）"></a>105. 不通过 构造函数 也能创建对象么（）</h3><table><thead><tr><th>A</th><th>是</th></tr></thead><tbody><tr><td>B.</td><td>否</td></tr><tr><td>答案：A分析：Java创建对象的几种方式：<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。<br>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</td></tr></tbody></table><h3 id="106-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><a href="#106-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？" class="headerlink" title="106. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"></a>106. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</h3><p>答: 接口可以继承接口，抽象类可以实现接口，抽象类可以继承实体类。</p><h3 id="107-写一个Java正则，能过滤出html中的-lt-a-href-”url”-gt-title-lt-a-gt-形式中的链接地址和标题"><a href="#107-写一个Java正则，能过滤出html中的-lt-a-href-”url”-gt-title-lt-a-gt-形式中的链接地址和标题" class="headerlink" title="107.写一个Java正则，能过滤出html中的&lt; a href=”url”&gt;title&lt; /a&gt;形式中的链接地址和标题."></a>107.写一个Java正则，能过滤出html中的&lt; a href=”url”&gt;title&lt; /a&gt;形式中的链接地址和标题.</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3m21yjd2sj30d8021jr9.jpg" alt></p><table><thead><tr><th>\b</th><th>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</th></tr></thead><tbody><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如[^xyz]可以匹配“plain”中的“p”。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>\</td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr></tbody></table><h3 id="108-Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#108-Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="108. Class类的getDeclaredFields()方法与getFields()的区别？"></a>108. Class类的getDeclaredFields()方法与getFields()的区别？</h3><p>答:getDeclaredFields(): 可以<strong>获取所有本类自己声明的方法, 不能获取继承的方法</strong></p><p>getFields(): 只能<strong>获取所有public声明的方法, 包括继承的方法</strong></p><h3 id="109-在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"><a href="#109-在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？" class="headerlink" title="109. 在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"></a>109. 在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？</h3><p>答:不正确。</p><p>通常情况下，进行比较判断的处理，switch 和if-else可以互相转换来写；if-else作用的范围比switch-case作用范围要大，但是当switch-case和if-else都可以用的情况下，通常推荐使用switch-case。</p><p>比如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        System.out.println(<span class="string">"D"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">        System.out.println(<span class="string">"E"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"other"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换为if-else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == <span class="string">'a'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"A"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'b'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">'B'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'c'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"C"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'d'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"D"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"E"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Other"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="110-使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#110-使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="110.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>110.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>final修饰基本类型变量，其值不能改变。</p><p>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog(<span class="string">"欧欧"</span>);</span><br><span class="line">        dog.name = <span class="string">"美美"</span>;<span class="comment">//正确, 因为指向的堆内存中的对象的属性值仍旧可以改变</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"亚亚"</span>);<span class="comment">//错误, 因为栈内存中的引用不能改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="111-请解释以下常用正则含义：-d-D-s-0-9-6-d"><a href="#111-请解释以下常用正则含义：-d-D-s-0-9-6-d" class="headerlink" title="111. 请解释以下常用正则含义：\d,   \D,   \s,     .,      *,     ?,      |,     [0-9]{6},     \d+"></a>111. 请解释以下常用正则含义：\d,   \D,   \s,     .,      *,     ?,      |,     [0-9]{6},     \d+</h3><p>\d: 匹配一个数字字符。等价于[0-9]</p><p>\D: 匹配一个非数字字符。等价于[\^0-9]</p><p>\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]</p><p>.    ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</p><p>*：匹配前面的子表达式<strong>*零次或多次</strong>。要匹配 <em> 字符，请使用 \</em>。</p><p>+：匹配前面的子表达式<strong>一次或多次</strong>。要匹配 + 字符，请使用 +。</p><p>?:  匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</p><p>|:将两个匹配条件进行逻辑“或”（Or）运算</p><p>[0-9]{6}:匹配连续6个0-9之间的数字</p><p>\d+：匹配至少一个0-9之间的数字</p><p>{n,m}:  m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</p><h3 id="112-下面那些声明是合法的？（）"><a href="#112-下面那些声明是合法的？（）" class="headerlink" title="112 下面那些声明是合法的？（）"></a>112 下面那些声明是合法的？（）</h3><table><thead><tr><th>A</th><th>long l = 4990</th></tr></thead><tbody><tr><td>B.</td><td>int i = 4L</td></tr><tr><td>C.</td><td>float f = 1.1</td></tr><tr><td>D.</td><td>double d = 34.4</td></tr><tr><td>答案：AD<br>分析：<br>B int属于整数型应该是int=4 <br>C应该是float f=1.1f</td></tr></tbody></table><h3 id="113-重载和重写区别"><a href="#113-重载和重写区别" class="headerlink" title="113. 重载和重写区别"></a>113. 重载和重写区别</h3><p>重载：</p><p>方法重载（Overload）：一个类中有多个方法，名字必须相同，<strong>参数不同</strong>（如参数个数，种类，参数顺序不同），<strong>与返回值修饰符无关</strong>；</p><p>格式特点：<br>1.方法名必须相同。<br>2.方法的<strong>参数表必须不同</strong><br>如果参数个数不同，就不管它的参数类型了！<br>如果参数个数相同，那么参数的类型必须不同。<br>3.方法的返回类型、修饰符可以相同，也可不同。</p><p>重写：</p><p>方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，<strong>只是方法的实现不同, 返回值和权限修饰符可相同可不相同</strong></p><p>方法重写必须满足下列条件<br>(1) 子类的<strong>方法名、参数列表</strong>必须和覆盖的方法<strong>完全一致</strong><br>(2) 子类的方法<strong>返回类型</strong>[层次]必须<strong>小于等于</strong>所覆盖的方法   (java 5或者以前，必须一样，java 7 java 8可以不同，但是必须是父类返回值的派生类。)<br>(3) 子类的方法<strong>权限修饰符</strong>必须<strong>大于等于</strong>所覆盖的方法<br>(4) 子类抛出的<strong>异常</strong>下<strong>不能超过</strong>父类相应方法抛出的异常(子类异常不能大于父类异常)</p><h3 id="114-下面哪个函数是public-void-example-…-的重载函数？（）"><a href="#114-下面哪个函数是public-void-example-…-的重载函数？（）" class="headerlink" title="114. 下面哪个函数是public void example(){….}的重载函数？（）"></a>114. 下面哪个函数是public void example(){….}的重载函数？（）</h3><table><thead><tr><th>A</th><th>private void example（int m）{…}</th></tr></thead><tbody><tr><td>B.</td><td>public int example（）{…}</td></tr><tr><td>C.</td><td>public void example2（）{…}</td></tr><tr><td>D.</td><td>public int example（int m.float f）{…}</td></tr><tr><td>答案：AD<br>分析：<br>BC定义的是新函数,因为B中虽然方法名与题目中方法名相同,但参数表和题目中的参数表相同,不符合重载条件</td></tr></tbody></table><p>例2下面哪几个函数是public void example（）{….}的重载函数（）</p><table><thead><tr><th>A</th><th>public void example（int m）{…}</th></tr></thead><tbody><tr><td>B.</td><td>public int example（int m）{…}</td></tr><tr><td>C.</td><td>public void example2（）{…}</td></tr><tr><td>D.</td><td>public int example（int m，float f）{…}</td></tr><tr><td>答案：ABD</td></tr></tbody></table><h3 id="115-打印结果："><a href="#115-打印结果：" class="headerlink" title="115. 打印结果："></a>115. 打印结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Test t=<span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span> b = t.get();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果: 2</span></span><br></pre></td></tr></table></figure><h3 id="116-指出下列程序的运行结果"><a href="#116-指出下列程序的运行结果" class="headerlink" title="116. .指出下列程序的运行结果"></a>116. .指出下列程序的运行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1: </span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">zero</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2:</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//注意: </span></span><br><span class="line"><span class="string">'在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一</span></span><br><span class="line"><span class="string">'</span>个<span class="keyword">switch</span>块内，都必须包含一个<span class="keyword">default</span>语句并且放在最后，即使它什么代码也没有<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="117-什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#117-什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="117. 什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>117. 什么是编译型语言，什么是解释型语言？java可以归类到那种？</h3><p>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言<strong>翻译</strong>成机器语言，计算机才能运行高级语言所编写的程序。</p><p><strong>翻译的方式有两种，一个是编译，一个是解释。</strong></p><p>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为<strong>翻译只做了一次</strong>，运行时不需要翻译，所以一般而言，<strong>编译型语言的程序执行效率高</strong>。</p><p>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言<strong>每执行一次就要翻译一次</strong>，<strong>效率比较低</strong>。</p><p>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如<strong>JavaScript、VBScript、Perl、Python、Ruby、MATLAB</strong> 等等。</p><p><strong>JAVA语言是一种编译型-解释型语言</strong>，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者<strong>注意Java中所谓的“编译”和传统的“编译”的区别</strong>）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</p><h3 id="118-下面代码执行后的输出是什么（）"><a href="#118-下面代码执行后的输出是什么（）" class="headerlink" title="118. 下面代码执行后的输出是什么（）"></a>118. 下面代码执行后的输出是什么（）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    inner:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(j + <span class="string">" and "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>A</th><th>0 and 00 and 10 and 2</th></tr></thead><tbody><tr><td>B.</td><td>1 and 01 and 11 and 2</td></tr><tr><td>C.</td><td>2 and 02 and 12 and 2</td></tr><tr><td>答案：A</td></tr></tbody></table><h3 id="119-请问以下代码执行会打印出什么？"><a href="#119-请问以下代码执行会打印出什么？" class="headerlink" title="119. 请问以下代码执行会打印出什么？"></a>119. 请问以下代码执行会打印出什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FatherClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FatherClassCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"ChildClass Create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FatherClass fc = <span class="keyword">new</span> FatherClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//子类构造器第一行默认会有super();所以每次调用子类构造器,都会先执行父类构造器.</span></span><br><span class="line">        ChildClass cc = <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line">FatherClassCreate</span><br><span class="line">FatherClassCreate</span><br><span class="line">ChildClass Create</span><br></pre></td></tr></table></figure><h3 id="120-如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？"><a href="#120-如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？" class="headerlink" title="120. 如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？"></a>120. 如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？</h3><p>答：因为类A、B不是接口，所以是不可以直接实现的，但可以将A、B类定义成父子类，那么C类就能实现A、B类的功能了。假如A为B的父类，B为C的父类，此时C就能使用A、B的功能。</p><p>—–<strong>java中没有多继承但是有多重继承</strong></p><h3 id="121-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#121-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="121. 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>121. 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h3><p>答：构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</p><h3 id="122-如何将字符串2013-02-18-10-53-10转换为日期类型且格式化为：2013-02-18-10-53-10？"><a href="#122-如何将字符串2013-02-18-10-53-10转换为日期类型且格式化为：2013-02-18-10-53-10？" class="headerlink" title="122.如何将字符串2013-02-18 10:53:10转换为日期类型且格式化为：2013-02-18 10:53:10？"></a>122.如何将字符串2013-02-18 10:53:10转换为日期类型且格式化为：2013-02-18 10:53:10？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//第一步：将字符串（2013-02-18 10:53:10）转换成日期Date</span></span><br><span class="line">        DateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        String sdate=<span class="string">"2013-02-18 10:53:10"</span>;</span><br><span class="line">        Date date=sdf.parse(sdate);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：将日期Date转换成字符串String</span></span><br><span class="line">        DateFormat  sdf2=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        String sdate2=sdf2.format(date);</span><br><span class="line">        System.out.println(sdate2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">Mon Feb <span class="number">18</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">10</span> CST <span class="number">2013</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="123-下面哪些是对称加密算法（）"><a href="#123-下面哪些是对称加密算法（）" class="headerlink" title="123. 下面哪些是对称加密算法（）"></a>123. 下面哪些是对称加密算法（）</h3><table><thead><tr><th>A.</th><th>DES</th></tr></thead><tbody><tr><td>B.</td><td>MD5</td></tr><tr><td>C.</td><td>DSA</td></tr><tr><td>D.</td><td>RSA</td></tr><tr><td>分析：答案：A分析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES常用的非对称加密算法有：RSA、DSA、ECC使用单向散列函数的加密算法：MD5、SHA</td></tr></tbody></table><h3 id="124-以下Java代码段会产生几个对象"><a href="#124-以下Java代码段会产生几个对象" class="headerlink" title="124. 以下Java代码段会产生几个对象"></a>124. 以下Java代码段会产生几个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicvoid <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String a=<span class="string">"a"</span>;</span><br><span class="line">    String b=<span class="string">"b"</span>;</span><br><span class="line">    String c=<span class="string">"c"</span>;</span><br><span class="line">    c=a+<span class="string">""</span>+b+<span class="string">""</span>+c;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案: 一个对象，因为编译期进行了优化，3个字符串常量直接折叠为一个</p><h3 id="125-System-out-println-‘a’-1-的结果是"><a href="#125-System-out-println-‘a’-1-的结果是" class="headerlink" title="125.System.out.println(‘a’+1);的结果是"></a>125.System.out.println(‘a’+1);的结果是</h3><p>分析：’a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</p><h3 id="126-成员变量用static修饰和不用static修饰有什么区别？"><a href="#126-成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="126. 成员变量用static修饰和不用static修饰有什么区别？"></a>126. 成员变量用static修饰和不用static修饰有什么区别？</h3><p>1、两个变量的生命周期不同。</p><p>成员变量随着对象的创建而存在，随着对象的被回收而释放。</p><p>静态变量随着类的加载而存在，随着类的消失而消失。</p><p>2、调用方式不同。</p><p>成员变量只能被对象调用。</p><p>成员变量只能被对象调用。</p><p>成员变量只能被对象调用。</p><p>类名调用 ：Person.country</p><p>3、别名不同。</p><p>成员变量也称为实例变量。</p><p>静态变量称为类变量。 </p><p>4、数据存储位置不同。</p><p>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</p><p>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</p><h3 id="127-Java中关于super关键字的作用"><a href="#127-Java中关于super关键字的作用" class="headerlink" title="127. Java中关于super关键字的作用"></a>127. Java中关于super关键字的作用</h3><p>在子类继承父类中，一般有一行super的语句，需要记住三种使用方法：</p><p>1、super.变量/对象名；<br>使用这种方法可以直接访问父类中的变量或对象，进行修改赋值等操作</p><p>2、super.方法名()；<br>直接访问并调用父类中的方法</p><p>3、super();<br>调用父类的初始化方法，其实就是调用父类中的public xxx()方法，通常第三种指代的是super()的省略写法，系统会默认添加此句。</p><p>特殊情况：如果父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数，即不能使用系统默认的“super()”，而需要显性写出super(xxx)</p><h3 id="128-如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#128-如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="128. 如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>128. 如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h3><p>1、用final修饰的类不能被扩展，也就是说不可能有子类；</p><p>2、用final修饰的方法不能被替换或隐藏：</p><p>​    ① 使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</p><p>​    ② 使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏（hidden）；</p><p>3、用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：</p><p>​    ① 静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始    化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化表达式完成；</p><p>​    ② 实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行；</p><p>​    ③ 方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体    （body）结束，在此期间其值不能改变；</p><p>​    ④ 构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化，为对应实参值，终止于构造器体结束，在此期间其值不能改变；</p><p>​    ⑤ 异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</p><p>​    ⑥ 局部变量在其值被访问之前必须被明确赋值；</p><h3 id="129-Java反射技术主要实现类有哪些，作用分别是什么？"><a href="#129-Java反射技术主要实现类有哪些，作用分别是什么？" class="headerlink" title="129. Java反射技术主要实现类有哪些，作用分别是什么？"></a>129. Java反射技术主要实现类有哪些，作用分别是什么？</h3><p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</p><p>1）Class类：代表一个类</p><p>2）Field 类：代表类的成员变量(属性)</p><p>3）Method类：代表类的成员方法</p><p>4）Constructor 类：代表类的构造方法</p><p>5）Array类：提供了动态创建数组，以及访问数组的元素的静态方法</p><p>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</p><p>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的 结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</p><table><thead><tr><th>方 法</th><th>示 例</th></tr></thead><tbody><tr><td>对象名 .getClass()</td><td>String str=”bdqn”;<br>Class clazz = str.getClass();</td></tr><tr><td>对象名 .getSuperClass()</td><td>Student stu = new Student();<br>Class c1 = stu.getClass();<br>Class c2 = stu.getSuperClass();</td></tr><tr><td>Class.forName()</td><td>Class clazz = Class.forName(“java.lang.Object”);<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);</td></tr><tr><td>类名.class</td><td>类名.class<br>Class c2 = Student.class;<br>Class c2 = int.class</td></tr><tr><td>包装类.TYPE</td><td>包装类.TYPE<br>Class c2 = Boolean.TYPE;</td></tr></tbody></table><h3 id="131-反射的使用场合和作用、及其优缺点"><a href="#131-反射的使用场合和作用、及其优缺点" class="headerlink" title="131. 反射的使用场合和作用、及其优缺点"></a>131. 反射的使用场合和作用、及其优缺点</h3><p>1）使用场合</p><p>在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。</p><p>2）主要作用</p><p>通过反射可以使程序代码访问装载到JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息</p><p>3）反射的优点</p><p>反射提高了Java程序的<strong>灵活性和扩展性</strong>，<strong>降低耦合性</strong>，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的</p><p>4） Java反射技术应用领域很广，如软件测试等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术</p><p>5）反射的缺点</p><p><strong>性能问题：</strong>使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</p><p>使用反射会模糊程序内部<strong>逻辑</strong>：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</p><h3 id="132-面向对象设计原则有哪些"><a href="#132-面向对象设计原则有哪些" class="headerlink" title="132.面向对象设计原则有哪些"></a>132.面向对象设计原则有哪些</h3><p>面向对象设计原则是面向对象设计的基石，面向对象设计质量的依据和保障，设计模式是面向对象设计原则的经典应用</p><p>1）单一职责原则SRP</p><p>2）开闭原则OCP</p><p>3）里氏替代原则LSP</p><p>4）依赖注入原则DIP</p><p>5）接口分离原则ISP</p><p>6）迪米特原则LOD</p><p>7）组合/聚合复用原则CARP</p><p>8）开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他设计原则都可以看作是开闭原则的实现手段或方法</p><h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><h3 id="1-下面程序的运行结果是（）（选择一项）"><a href="#1-下面程序的运行结果是（）（选择一项）" class="headerlink" title="1. 下面程序的运行结果是（）（选择一项）"></a>1. 下面程序的运行结果是（）（选择一项）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"hello"</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br></pre></td></tr></table></figure><table><thead><tr><th>A.</th><th>true</th></tr></thead><tbody><tr><td>B.</td><td>false</td></tr><tr><td>C.</td><td>hello</td></tr><tr><td>D.</td><td>he</td></tr><tr><td>答案：B分析：str1没有使用new关键字，在堆中没有开辟空间，其值”hello”在常量池中，str2使用new关键字创建了一个对象，在堆中开辟了空间，”==”比较的是对象的引用，即内存地址，所以str1与str2两个对象的内存地址是不相同的</td></tr></tbody></table><h3 id="2-Java语言中，String类中的indexOf-方法返回值的类型是（）"><a href="#2-Java语言中，String类中的indexOf-方法返回值的类型是（）" class="headerlink" title="2. Java语言中，String类中的indexOf()方法返回值的类型是（）"></a>2. Java语言中，String类中的indexOf()方法返回值的类型是（）</h3><table><thead><tr><th>A.</th><th>int16</th></tr></thead><tbody><tr><td>B.</td><td>int32</td></tr><tr><td>C.</td><td>int</td></tr><tr><td>D.</td><td>long</td></tr><tr><td>答案：C</td></tr></tbody></table><h3 id="3-给定以下代码，程序的运行结果是-（）（选择一项）——-gt-易错题"><a href="#3-给定以下代码，程序的运行结果是-（）（选择一项）——-gt-易错题" class="headerlink" title="3. 给定以下代码，程序的运行结果是 （）（选择一项）——&gt;易错题"></a>3. 给定以下代码，程序的运行结果是 （）（选择一项）——&gt;易错题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    String str=<span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span> [] ch=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Example ex=<span class="keyword">new</span> Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str+<span class="string">"and"</span>);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String  str,<span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">        str=<span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>]=<span class="string">'g'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>A.</th><th>goodandabc</th></tr></thead><tbody><tr><td>B.</td><td>goodandgbc</td></tr><tr><td>C.</td><td>test okandabc</td></tr><tr><td>D.</td><td>test okandgbc</td></tr><tr><td>答案：B<br>分析：在方法调用时，在change方法中对str的值进行修改，是将str指向了常量池中的”test ok”，而主方法中的ex.str仍然指向的是常量池中的”good”。<br>字符型数组在方法调用时，将主方法中ex.ch的引用传递给change方法中的ch，指向是堆中的同一堆空间，所以修改ch[0]的时候,ex.ch可以看到相同的修改后的结果。</td></tr></tbody></table><h3 id="4-执行下列代码后，哪个结论是正确的（）（选择两项）"><a href="#4-执行下列代码后，哪个结论是正确的（）（选择两项）" class="headerlink" title="4. 执行下列代码后，哪个结论是正确的（）（选择两项）"></a>4. 执行下列代码后，哪个结论是正确的（）（选择两项）</h3><p>String[] s=new String[10];</p><table><thead><tr><th>A.</th><th>s[10]为””</th></tr></thead><tbody><tr><td>B.</td><td>s[9]为null</td></tr><tr><td>C.</td><td>s[0]为未定义</td></tr><tr><td>D.</td><td>s.length为10</td></tr><tr><td>答案：BD<br>分析：<br>引用数据类型的默认值均为null<br>s.length数组的长度</td></tr></tbody></table><h3 id="5-实现String类的replaceAll方法"><a href="#5-实现String类的replaceAll方法" class="headerlink" title="5. 实现String类的replaceAll方法"></a>5. 实现String类的replaceAll方法</h3><p>思路说明：replaceAll方法的本质是使用正则表达式进行匹配，最终调用的其实是Matcher对象的replaceAll方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringReplaceAll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"a1s2d3f4h5j6k7"</span>;</span><br><span class="line">        <span class="comment">// 将字符串中的数字全部替换为0</span></span><br><span class="line">        System.out.println(replaceAll(str, <span class="string">"\\d"</span>, <span class="string">"0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str:源字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> regex:正则表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStr:替换后的子字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回替换成功后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAll</span><span class="params">(String str, String regex, String newStr)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        Matcher mathcer = pattern.matcher(str);</span><br><span class="line">        String reslut = mathcer.replaceAll(newStr);</span><br><span class="line">        <span class="keyword">return</span> reslut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-在“-”后填写适当的内容："><a href="#6-在“-”后填写适当的内容：" class="headerlink" title="6. 在“=”后填写适当的内容："></a>6. 在“=”后填写适当的内容：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String []a=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">则：</span><br><span class="line">a[<span class="number">0</span>]~a[<span class="number">9</span>]=<span class="keyword">null</span>;</span><br><span class="line">a.length=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">如果是<span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">则：</span><br><span class="line">a[<span class="number">0</span>]~a[<span class="number">9</span>]= <span class="number">0</span></span><br><span class="line">a.length= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">如果为 <span class="keyword">int</span> b;</span><br><span class="line">则System.out.println(b); <span class="comment">//编译不通过,提示变量b未初始化</span></span><br></pre></td></tr></table></figure><h3 id="7-是否可以继承String类"><a href="#7-是否可以继承String类" class="headerlink" title="7. 是否可以继承String类?"></a>7. 是否可以继承String类?</h3><p>答:不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。</p><p>public final class String implements java.io.Serializable,</p><p>Comparable&lt; String&gt;, CharSequence</p><h3 id="8-给定两个字符串s和t，-写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。"><a href="#8-给定两个字符串s和t，-写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。" class="headerlink" title="8. 给定两个字符串s和t， 写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。"></a>8. 给定两个字符串s和t， 写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())<span class="comment">//长度不相等,则一定不是重组词</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> bit[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            bit[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--bit[t.charAt(i) - <span class="string">'a'</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-String-s-new-String-“abc”-创建了几个String对象。"><a href="#9-String-s-new-String-“abc”-创建了几个String对象。" class="headerlink" title="9. String s=new String(“abc”);创建了几个String对象。"></a>9. String s=new String(“abc”);创建了几个String对象。</h3><p>答: <strong>两个或一个</strong>，</p><p>”abc”对应一个对象，这个对象放在字符串常量缓冲区，常量”abc”不管出现多少遍，都是缓冲区中的那一个。</p><p>new String每写一遍，就创建一个新的对象，它依据那个常量”abc”对象的内容来创建出一个新String对象。如果以前就用过’abc’，这句代表就不会创建”abc”自己了，直接从缓冲区拿。</p><h3 id="10-输出结果？"><a href="#10-输出结果？" class="headerlink" title="10. 输出结果？"></a>10. 输出结果？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"hello"</span>;</span><br><span class="line">String str2=<span class="string">"he"</span>+<span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br><span class="line">System.out.println(str1.equal(str2));</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="11-下面哪个是正确的（）"><a href="#11-下面哪个是正确的（）" class="headerlink" title="11. 下面哪个是正确的（）"></a>11. 下面哪个是正确的（）</h3><table><thead><tr><th>A.</th><th>String temp[ ] = new String{“a”,”b”,”c”};</th></tr></thead><tbody><tr><td>B.</td><td>String temp[ ] = {“a”,”b”,”c”};</td></tr><tr><td>C.</td><td>String temp= {“a”,”b”,”c”};</td></tr><tr><td>D.</td><td>String[ ] temp = {“a”,”b”,”c”};</td></tr><tr><td>答案：BD<br>new 对象时是圆括号()<br>给数组赋值用花括号,给变量赋值不能用花括号</td></tr></tbody></table><h3 id="12-已知如下代码：执行结果是什么（）"><a href="#12-已知如下代码：执行结果是什么（）" class="headerlink" title="12. 已知如下代码：执行结果是什么（）"></a>12. 已知如下代码：执行结果是什么（）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.print(s1 == s2);</span><br><span class="line">        String s3 = <span class="string">"Hello"</span>;</span><br><span class="line">        String s4 = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.print(s3 == s4);</span><br><span class="line">        s1 = s3;</span><br><span class="line">        s2 = s4;</span><br><span class="line">        System.out.print(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>A.</th><th>false true true</th></tr></thead><tbody><tr><td>B.</td><td>true false true</td></tr><tr><td>C.</td><td>true true false</td></tr><tr><td>D.</td><td>true true false</td></tr><tr><td>答案：A</td></tr></tbody></table><h3 id="13-字符串如何转换为int类型"><a href="#13-字符串如何转换为int类型" class="headerlink" title="13. 字符串如何转换为int类型"></a>13. 字符串如何转换为int类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="keyword">int</span> num=Integer.parseInt(<span class="string">"123"</span>);</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        Integer in = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">        <span class="keyword">int</span> a =   in.intValue();</span><br><span class="line">        System.out.println(a);  </span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="keyword">int</span> num2=Integer.valueOf(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(num+<span class="string">"  "</span>+num2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mut4ubu5j30ss0bywmm.jpg" alt></p><h3 id="14-写一个方法，实现字符串的反转，如：输入abc，输出cba"><a href="#14-写一个方法，实现字符串的反转，如：输入abc，输出cba" class="headerlink" title="14. 写一个方法，实现字符串的反转，如：输入abc，输出cba"></a>14. 写一个方法，实现字符串的反转，如：输入abc，输出cba</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String result=reverse(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chArra = str.toCharArray();<span class="comment">//字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = chArra.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;<span class="comment">//从后往前取值</span></span><br><span class="line">            <span class="keyword">char</span> ch = chArra[i];</span><br><span class="line">            result.append(ch);<span class="comment">//连接取出的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();<span class="comment">//字符数组转换为字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-编写java，将“I-follow-Bill-Gate-Tom-Gate-John-Gate”中的“Gate”全部替换为“Gates”"><a href="#15-编写java，将“I-follow-Bill-Gate-Tom-Gate-John-Gate”中的“Gate”全部替换为“Gates”" class="headerlink" title="15. 编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”"></a>15. 编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> classDemo1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s=<span class="string">"I follow Bill Gate.Tom Gate.John Gate"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s=s.replaceAll(<span class="string">"Gate"</span>,<span class="string">"Gates"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-String-是最基本的数据类型吗"><a href="#16-String-是最基本的数据类型吗" class="headerlink" title="16. String 是最基本的数据类型吗?"></a>16. String 是最基本的数据类型吗?</h3><p>答： 不是 。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）—-&gt;(如类(例如String),数组,枚举,接口)。</p><h3 id="17-String-和StringBuilder、StringBuffer-的区别"><a href="#17-String-和StringBuilder、StringBuffer-的区别" class="headerlink" title="17. String 和StringBuilder、StringBuffer 的区别?"></a>17. String 和StringBuilder、StringBuffer 的区别?</h3><p>答： Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder</p><p>相同点：</p><p>它们都可以储存和操作字符串，同时三者都使用final修饰，都属于终结类不能派生子类，操作的相关方法也类似例如获取字符串长度等；</p><p>不同点：</p><p>其中<strong>String是只读字符串</strong>，也就意味着String引用的字符串内容是不能被改变的，而<strong>StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改</strong>，在修改的同时地址值不会发生改变。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在<strong>单线程</strong>环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的<strong>效率也比StringBuffer略高</strong>。</p><p>在此重点说明一下，String、StringBuffer、StringBuilder三者类型不一样，<strong>无法使用equals()方法比较其字符串内容是否一样！</strong></p><p>补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。</p><p>补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">smallT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"Programming"</span>;</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);</span><br><span class="line">        String c = <span class="string">"Program"</span> + <span class="string">"ming"</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">        System.out.println(a.equals(c));</span><br><span class="line">        System.out.println(a.intern() == b.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mvols8ucj30zu0dsglr.jpg" alt></p><p>解析：</p><p>String类存在intern()方法，含义如下：返回字符串对象的规范化表示形式.<br>它遵循以下规则:<br>对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。</p><p>字符串比较分为两种形式:</p><p>一种使用比较运算符”==”比较，他们比较的是各自的字符串在内存当中的地址值是否相同；<br>另一种是使用equals()方法进行比较，比较的是两个字符串的内容是否相同(前提是该类重写了equals方法,否则equals方法还是比较的是地址)！</p><h3 id="18-String类为什么是final的"><a href="#18-String类为什么是final的" class="headerlink" title="18. String类为什么是final的"></a>18. String类为什么是final的</h3><p>答：1） <strong>为了效率</strong>。若允许被继承，则其高度的被使用率可能会降低程序的性能。</p><p>2）<strong>为了安全</strong>。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性，如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点。</p><h3 id="19-String-s-”Hello”-s-s-”world-”-执行后，是否是对前面s指向空间内容的修改？"><a href="#19-String-s-”Hello”-s-s-”world-”-执行后，是否是对前面s指向空间内容的修改？" class="headerlink" title="19. String s=”Hello”;s=s+”world!”;执行后，是否是对前面s指向空间内容的修改？"></a>19. String s=”Hello”;s=s+”world!”;执行后，是否是对前面s指向空间内容的修改？</h3><p>答：不是对前面s指向空间内容的直接修改。</p><p><strong>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象</strong>。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p><p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。</p><p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。</p><p>例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">public</span> Demo &#123;</span><br><span class="line">        s = <span class="string">"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而非</p><p>s = new String(“Initial Value”);</p><p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。</p><p>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。</p><p>至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。</p><h3 id="20-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#20-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="20. 下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>20. 下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h3><p>答：对于如下代码：</p><p>String s1 = “a”;</p><p>String s2 = s1 + “b”;</p><p>String s3 = “a” + “b”;</p><p>System.out.println(s2 == “ab”);</p><p>System.out.println(s3 == “ab”);</p><p>第一条语句打印的结果为false，第二条语句打印的结果为true，<br>这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。</p><p>题目中的第一行代码被编译器在编译时优化后，相当于直接定义一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。</p><p>写如下两行代码，</p><p>String s = “a” + “b” + “c” + “d”;</p><p>System.out.println(s == “abcd”);</p><p>最终打印的结果应该为true。</p><h2 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h2><h3 id="1-Java集合体系结构（List、Set、Collection、Map的区别和联系）"><a href="#1-Java集合体系结构（List、Set、Collection、Map的区别和联系）" class="headerlink" title="1. Java集合体系结构（List、Set、Collection、Map的区别和联系）"></a>1. Java集合体系结构（List、Set、Collection、Map的区别和联系）</h3><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mwtqx3r3j30i60by7b8.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mwu91hxsj30cf07pmyx.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mw3bpxdij308w056dg0.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3n07pe84sj30ke09m402.jpg" alt></p><p>1、Collection 接口存储一组不唯一，无序的对象</p><p>2、List 接口存储一组不唯一，有序（插入顺序）的对象</p><p>3、Set 接口存储一组唯一，无序的对象</p><p>4、Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</p><h3 id="2-Vector和ArrayList的区别和联系"><a href="#2-Vector和ArrayList的区别和联系" class="headerlink" title="2. Vector和ArrayList的区别和联系"></a>2. Vector和ArrayList的区别和联系</h3><p>相同点：</p><p>1）<strong>实现原理</strong>相同—底层都使用数组</p><p>2）<strong>功能</strong>相同—实现增删改查等操作的方法相似</p><p>3）都是<strong>长度可变</strong>的数组结构，很多情况下可以互用</p><p>不同点：</p><p>1）Vector是早期JDK版本提供，ArrayList是新版本替代Vector的</p><p>2）<strong>Vector线程安全</strong>，ArrayList重速度轻安全，线程非安全长度需增长时，Vector默认增长一倍，ArrayList增长50%</p><h3 id="3-ArrayList和LinkedList的区别和联系"><a href="#3-ArrayList和LinkedList的区别和联系" class="headerlink" title="3. ArrayList和LinkedList的区别和联系"></a>3. ArrayList和LinkedList的区别和联系</h3><p>相同点：</p><p>两者都实现了List接口，都具有List中元素有序、不唯一的特点。</p><p>不同点：</p><p>ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mwdlumfsj30ch01gwea.jpg" alt></p><p>LinkedList采用链表存储方式。插入、删除元素时效率比较高</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3mwe1vdwaj30fm014dfm.jpg" alt></p><h3 id="4-HashMap和Hashtable的区别和联系"><a href="#4-HashMap和Hashtable的区别和联系" class="headerlink" title="4. HashMap和Hashtable的区别和联系"></a>4. HashMap和Hashtable的区别和联系</h3><p>相同点：</p><p>实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</p><p>不同点：</p><p>1、Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</p><p>2、Hashtable继承Dictionary类，HashMap实现Map接口</p><p>3、<strong>Hashtable线程安全</strong>，HashMap线程非安全</p><p>4、Hashtable不允许null值，HashMap允许null值</p><h3 id="5-HashSet的使用和原理（hashCode-和equals-）"><a href="#5-HashSet的使用和原理（hashCode-和equals-）" class="headerlink" title="5. HashSet的使用和原理（hashCode()和equals()）"></a>5. HashSet的使用和原理（hashCode()和equals()）</h3><p>1）哈希表的查询速度特别快，时间复杂度为O（1）。</p><p>2）HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</p><p>3）系统类已经覆盖了hashCode方法, 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</p><p>4）向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</p><p>5）<strong>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()</strong>。<strong>hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</strong></p><p>6）    Y=K(X) ：K是函数，X是哈希码，Y是地址</p><h3 id="6-TreeSet的原理和使用（Comparable和comparator）"><a href="#6-TreeSet的原理和使用（Comparable和comparator）" class="headerlink" title="6. TreeSet的原理和使用（Comparable和comparator）"></a>6. TreeSet的原理和使用（Comparable和comparator）</h3><p>1）TreeSet集合，元素不允许重复且有序(<strong>自然顺序)</strong></p><p>2）TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</p><p>3）可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</p><p>4）可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</p><h3 id="7-集合和数组的比较（为什么引入集合）"><a href="#7-集合和数组的比较（为什么引入集合）" class="headerlink" title="7. 集合和数组的比较（为什么引入集合）"></a>7. 集合和数组的比较（为什么引入集合）</h3><p>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合。具体如下：</p><p>1）数组的效率高于集合类.</p><p>2）数组能存放基本数据类型和对象，而<strong>集合类中只能放对象</strong>。</p><p>3）数组容量固定且无法动态改变，<strong>集合类容量动态改变</strong>。</p><p>4）<strong>数组无法判断其中实际存有多少元素</strong>，length只告诉了array的容量。</p><p>5）集合有<strong>多种实现方式和不同的适用场合</strong>，而不像数组仅采用顺序表方式。</p><p>6）集合<strong>以类的形式存在</strong>，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</p><h3 id="8-Collection和Collections的区别"><a href="#8-Collection和Collections的区别" class="headerlink" title="8. Collection和Collections的区别"></a>8. Collection和Collections的区别</h3><p>1）Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</p><p>2）Java中还有一个Collections类，专门用来操作集合类 ，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p><h3 id="9-下列说法正确的有（）（选择一项）"><a href="#9-下列说法正确的有（）（选择一项）" class="headerlink" title="9. 下列说法正确的有（）（选择一项）"></a>9. 下列说法正确的有（）（选择一项）</h3><table><thead><tr><th>A.</th><th>LinkedList继承自List</th></tr></thead><tbody><tr><td>B.</td><td>AbstractSet继承自Set</td></tr><tr><td>C.</td><td>HashSet继承自AbstractSet</td></tr><tr><td>D.</td><td>TreeMap继承自HashMap</td></tr><tr><td>答案： C<br>分析：<br>A：LinkedList实现List接口<br>B：AbstractSet实现Set接口<br>D：TreeMap继承AbstractMap</td></tr></tbody></table><h3 id="10-Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？"><a href="#10-Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？" class="headerlink" title="10. Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？"></a>10. Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？</h3><p>答：HashMap与Hashtable实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</p><p>两者的主要区别如下</p><p>1、Hashtable是<strong>早期JDK提供的接口</strong>，HashMap是新版JDK提供的接口</p><p>2、<strong>Hashtable继承Dictionary类</strong>，HashMap实现Map接口</p><p>3、<strong>Hashtable线程安全</strong>，HashMap线程非安全</p><p>4、<strong>Hashtable不允许null值</strong>，HashMap允许null值</p><p>HashSet与HashMap的区别</p><p>1、<strong>HashSet底层是采用HashMap实现的</strong>。HashSet 的实现比较简单，HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。</p><p>2、HashMap的<strong>key就是放进HashSet中对象</strong>，<strong>value是Object类型的</strong>。</p><p>3、当调用HashSet的add方法时，实际上是向HashMap中增加了一行(key-value对)，该行的key就是向HashSet增加的那个对象，该行的value就是一个Object类型的常量</p><h3 id="11-列出Java中的集合类层次结构？"><a href="#11-列出Java中的集合类层次结构？" class="headerlink" title="11. 列出Java中的集合类层次结构？"></a>11. 列出Java中的集合类层次结构？</h3><p>答:Java中集合主要分为两种：Collection和Map。Collection是List和Set接口的父接口；ArrayList和LinkedList是List的实现类；HashSet 和TreeSet是Set的实现类；LinkedHashSet是HashSet的子类。HashMap和TreeMap是Map的实现类；LinkedHashMap是HashMap的子类。</p><p>图中：虚线框中为接口，实线框中为类。</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g3n1etqz29j30by06y74l.jpg" alt></p><h3 id="12-List，Set，Map各有什么特点"><a href="#12-List，Set，Map各有什么特点" class="headerlink" title="12. List，Set，Map各有什么特点"></a>12. List，Set，Map各有什么特点</h3><p>答:List 接口存储一组可重复，有序（插入顺序）的对象。</p><p>Set 接口存储一组不可重复，无序的对象。</p><p>Map接口存储一组键值对象，提供key到value的映射。key无序，不可重复。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</p><h3 id="13-合并两个有序的链表"><a href="#13-合并两个有序的链表" class="headerlink" title="13.合并两个有序的链表"></a>13.合并两个有序的链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = l1.val &lt; l2.val ? l1 : l2;</span><br><span class="line">        ListNode other = l1.val &gt;= l2.val ? l1 : l2;</span><br><span class="line">        ListNode prevHead = head;</span><br><span class="line">        ListNode prevOther = other;</span><br><span class="line">        <span class="keyword">while</span> (prevHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = prevHead.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.val &gt; prevOther.val) &#123;</span><br><span class="line">                prevHead.next = prevOther;</span><br><span class="line">                prevOther = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prevHead.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                prevHead.next=prevOther;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHead=prevHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-用递归方式实现链表的转置。"><a href="#14-用递归方式实现链表的转置。" class="headerlink" title="14. 用递归方式实现链表的转置。"></a>14. 用递归方式实现链表的转置。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">ListNode next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ListNode(int x) &#123; </span></span><br><span class="line"><span class="comment">val = x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;<span class="comment">//递归结束条件</span></span><br><span class="line">          <span class="keyword">return</span> head;  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode prev = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。"><a href="#15-给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。" class="headerlink" title="15. 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。"></a>15. 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets (<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">//排序</span></span><br><span class="line">        dfs(nums, <span class="number">0</span>, item, res);  <span class="comment">//递归调用</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());  <span class="comment">//最后加上一个空集</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            item.add(nums[i]);</span><br><span class="line">            <span class="comment">//item是以整数为元素的动态数组，而res是以数组为元素的数组，在这一步，当item增加完元素后，item</span></span><br><span class="line">           <span class="comment">// 所有元素构成一个完整的子串，再由res纳入</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(item));</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>, item, res);</span><br><span class="line">            item.remove(item.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#16-Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="16. Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>16. Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h3><p>答：1. Map的实现类有HashMap,LinkedHashMap,TreeMap</p><p>\2. HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序(即<strong>插入有序</strong>)；TreeMap默认是自然升序(<strong>即自然有序</strong>)）</p><p>\3. LinkedHashMap<strong>底层存储结构是哈希表+链表</strong>，<strong>链表记录了添加数据的顺序</strong></p><p>\4. TreeMap底层存储结构是<strong>二叉树</strong>，二叉树的<strong>中序遍历保证了数据的有序性</strong></p><p>\5. LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</p><h3 id="17-下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？"><a href="#17-下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？" class="headerlink" title="17. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？"></a>17. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            list.addLast(x);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> Object <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.removeLast( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：将if( list.size() &lt;= 0 )改成：while( list.size() &lt;= 0 )</p><h3 id="18-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#18-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="18. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>18. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h3><p>答：</p><p>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小。</p><p>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</p><p>Collections 工具类的sort方法有两种重载的形式:</p><p>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</p><h3 id="19-Java-util-Map的实现类有"><a href="#19-Java-util-Map的实现类有" class="headerlink" title="19. Java.util.Map的实现类有"></a>19. Java.util.Map的实现类有</h3><p>分析：Java中的java.util.Map的实现类</p><p>1、HashMap</p><p>2、Hashtable</p><p>3、LinkedHashMap</p><p>4、TreeMap</p><h3 id="20-List里面如何剔除相同的对象？请简单用代码实现一种方法"><a href="#20-List里面如何剔除相同的对象？请简单用代码实现一种方法" class="headerlink" title="20. List里面如何剔除相同的对象？请简单用代码实现一种方法"></a>20. List里面如何剔除相同的对象？请简单用代码实现一种方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; li1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        li1.add(<span class="string">"8"</span>);</span><br><span class="line">        li1.add(<span class="string">"8"</span>);</span><br><span class="line">        li1.add(<span class="string">"9"</span>);</span><br><span class="line">        li1.add(<span class="string">"9"</span>);</span><br><span class="line">        li1.add(<span class="string">"0"</span>);</span><br><span class="line">        System.out.println(li1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法:将List中数据取出来来存到Set中</span></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; li1.size();i++)&#123;</span><br><span class="line">            set.add(li1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-List、Set、Map-是否继承自Collection-接口？"><a href="#21-List、Set、Map-是否继承自Collection-接口？" class="headerlink" title="21. List、Set、Map 是否继承自Collection 接口？"></a>21. List、Set、Map 是否继承自Collection 接口？</h3><p>答：List、Set 的父接口是Collection，Map 不是其子接口，而是与Collection接口是平行关系，互不包含。</p><p>Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 </p><h3 id="22-说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#22-说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="22. 说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>22. 说出ArrayList、Vector、LinkedList 的存储性能和特性？</h3><p>答：<strong>ArrayList 和Vector都是使用数组方式存储数据</strong>，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，</p><p>Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，</p><p>而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</p><p>补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖） 。同理，Stack类继承Vector也是不正确的。</p><h3 id="23-List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#23-List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="23. List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>23. List、Map、Set 三个接口，存取元素时，各有什么特点？</h3><p>答：List以特定索引来存取元素，可有重复元素。</p><p>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复） 。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 </p><h3 id="24-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#24-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="24. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>24. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h3><p>答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p><p>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</p><p>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型 （需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</p><p>例子1：</p><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;        <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;            <span class="comment">// 年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age; <span class="comment">// 比较年龄(年龄的升序)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test01.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();     <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</span><br><span class="line">        <span class="keyword">for</span>(Student stu : set) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      输出结果:</span></span><br><span class="line">        <span class="comment">//      Student [name=Bob YANG, age=22]</span></span><br><span class="line">        <span class="comment">//      Student [name=XJ WANG, age=32]</span></span><br><span class="line">        <span class="comment">//      Student [name=Hao LUO, age=33]</span></span><br><span class="line">        <span class="comment">//      Student [name=Bruce LEE, age=60]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取学生姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取学生年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test02.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过sort方法的第二个参数传入一个Comparator接口对象</span></span><br><span class="line">        <span class="comment">// 相当于是传入一个比较对象大小的算法到sort方法中</span></span><br><span class="line">        <span class="comment">// 由于Java中没有函数指针、仿函数、委托这样的概念</span></span><br><span class="line">        <span class="comment">// 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt; () &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());    <span class="comment">// 比较学生姓名</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Student stu : list) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      输出结果:</span></span><br><span class="line">        <span class="comment">//      Student [name=Bob YANG, age=22]</span></span><br><span class="line">        <span class="comment">//      Student [name=Bruce LEE, age=60]</span></span><br><span class="line">        <span class="comment">//      Student [name=Hao LUO, age=33]</span></span><br><span class="line">        <span class="comment">//      Student [name=XJ WANG, age=32]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录结构:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、Java基础、语法&quot;&gt;&lt;a href=&quot;#一、Java基础、语法&quot; class=&quot;headerlink&quot; title=&quot;一、Java基础、语法&quot;&gt;&lt;/a&gt;一、Jav
      
    
    </summary>
    
      <category term="面试题" scheme="https://zzwwqq.xyz/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="java基础面试题" scheme="https://zzwwqq.xyz/tags/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>信息系统项目管理师之论文部分</title>
    <link href="https://zzwwqq.xyz/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E4%B9%8B%E8%AE%BA%E6%96%87%E9%83%A8%E5%88%86.html"/>
    <id>https://zzwwqq.xyz/信息系统项目管理师之论文部分.html</id>
    <published>2019-04-22T04:44:31.000Z</published>
    <updated>2019-05-05T07:59:31.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十大知识领域、五大项目管理过程组、47个过程"><a href="#十大知识领域、五大项目管理过程组、47个过程" class="headerlink" title="十大知识领域、五大项目管理过程组、47个过程"></a>十大知识领域、五大项目管理过程组、47个过程</h3><p>启动过程组 2个<br>规划过程组 24个<br>执行过程组 8个<br>监控过程组 11个<br>收尾过程组 2个</p><a id="more"></a><h2 id="一、整体管理"><a href="#一、整体管理" class="headerlink" title="一、整体管理"></a>一、整体管理</h2><h3 id="1-1-可以从以下方面去写"><a href="#1-1-可以从以下方面去写" class="headerlink" title="1.1 可以从以下方面去写:"></a>1.1 可以从以下方面去写:</h3><p>①: 6个过程       (命题概率较大)</p><p>②: PDCA          (命题概率较大)</p><p>③: 5大过程组</p><p>注: PDCA是质量管理和项目管理的基本模型。PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Action(行动)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。</p><h3 id="1-2-写作思路"><a href="#1-2-写作思路" class="headerlink" title="1.2 写作思路:"></a>1.2 写作思路:</h3><table><thead><tr><th>过程</th><th>通俗解释</th><th>写作要点(举例: 根据子题目写)</th></tr></thead><tbody><tr><td>1 制定项目章程</td><td>正式批准项目的启动,为项目经理授权</td><td>不用写太多,一句话带过,如项目发起人发布了这个文件,项目启动了,我被授权了.</td></tr><tr><td>2 制定项目管理计划</td><td>和大家一起编制项目管理计划,为项目的执行奠定基础</td><td>可写计划编写的原则,工具,步骤等内容,列举项目管理计划包含了什么内容</td></tr><tr><td>3 指导和管理项目执行</td><td>按照项目管理计划来指定项目的执行</td><td>如何按照计划来指导和管理项目, 如: 根据计划做了什么安排,怎么安排等</td></tr><tr><td>4 监督和控制项目工作</td><td>做好项目的纠偏控制</td><td>如何设置监控点,如何进行监控和捕获项目信息,什么时候发现项目状态有问题,分析什么原因造成的,如何解决的.</td></tr><tr><td>5 整体变更管理</td><td>变更不可避免,当发生变更时严格按照变更流程进行项目变更管理工程.</td><td>具体举例,如何进行变更控制(6个流程)</td></tr><tr><td>6 项目收尾</td><td>项目通过验收,交付了产品,还要召开项目总结会议,进行项目总结和评估审计等工作.</td><td>写验收情况,项目总结会议的作用,内容,最后更新组织过程资产等</td></tr></tbody></table><h3 id="1-3-过程-输入-输出-工具和技术"><a href="#1-3-过程-输入-输出-工具和技术" class="headerlink" title="1.3 过程,输入,输出,工具和技术"></a>1.3 过程,输入,输出,工具和技术</h3><table><thead><tr><th>过程+输入</th><th>工具/技术</th><th>输出</th></tr></thead><tbody><tr><td><font color="red" size="5">1.3.1 制定项目章程 (启动过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目工作说明书</td><td>专家判断</td><td><strong>项目章程</strong></td></tr><tr><td>②: 商业论证</td><td>引导技术</td><td></td></tr><tr><td>③: 协议</td><td></td><td></td></tr><tr><td>④: 事业环境因素</td><td></td><td></td></tr><tr><td>⑤: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 工商议事有组织,专家引导出章程</font>(工:工作说明书,商: 商业论证,议: 协议,事: 事业环境因素,)</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.2 制定项目管理计划 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目章程</td><td>专家判断</td><td><strong>项目管理计划</strong></td></tr><tr><td>②: 其他过程的输出</td><td>引导技术</td><td></td></tr><tr><td>③: 事业环境因素</td><td></td><td></td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td>⑤: 初步项目范围说明书</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 章程输出靠业组,专家引导出计划</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.3 指导与管理项目执行 (执行过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td><strong>可交付性成果</strong></td></tr><tr><td>②: 批准的变更请求</td><td>项目管理信息系统</td><td><strong>工作绩效数据</strong></td></tr><tr><td>③: 事业环境因素</td><td>会议</td><td><strong>变更请求</strong></td></tr><tr><td>④: 组织过程资产</td><td></td><td>项目管理计划更新</td></tr><tr><td><font color="green" size="5">口诀: 计变业组会专项, 效果变更新文划</font>( 计: 项目管理计划, 业: 事业环境因素,专: 专家, 项: 项目管理信息系统,效:绩效,果:可交付性成果,变:变更请求,新:更新,文: 文件,划:计划)</td><td></td><td>项目文件更新</td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.4 监控项目工作 (监控过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>变更请求</td></tr><tr><td><strong>②: 进度预测</strong></td><td>项目管理信息系统</td><td><strong>工作绩效报告</strong></td></tr><tr><td>③: 成本预测</td><td>会议</td><td>项目管理计划更新</td></tr><tr><td>④: 确认的变更</td><td></td><td>项目文件更新</td></tr><tr><td>⑤: 工作绩效信息</td><td></td><td></td></tr><tr><td>⑥: 事业环境因素</td><td></td><td></td></tr><tr><td>⑦: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 计划进成预测后,业组确认变更信</font>(输入而言)</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.5 实施整体变更控制 (监控过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td><strong>批准的变更请求</strong></td></tr><tr><td>②: 工作绩效报告</td><td>会议</td><td><strong>变更日志</strong></td></tr><tr><td>③: 变更请求</td><td>变更控制工具</td><td>项目管理计划更新</td></tr><tr><td>④: 事业环境因素</td><td></td><td>项目文件更新</td></tr><tr><td>⑤: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 计划变更效业组,批准日志新文划</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">1.3.6 结束项目或阶段 (收尾过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>最终产品,服务或成果移交</td></tr><tr><td>②: 验收的可交付成果</td><td>分析技术</td><td>组织过程资产更新</td></tr><tr><td>③: 组织过程资产</td><td>会议</td><td>管理收尾规程</td></tr><tr><td><font color="green" size="5">口诀: 计划验收无事业,会议分析有专家</font></td><td></td><td>合同收尾规程</td></tr></tbody></table><h3 id="1-4-论文格式"><a href="#1-4-论文格式" class="headerlink" title="1.4 论文格式:"></a>1.4 论文格式:</h3><p>第一部分:</p><p>摘要部分: 300字左右</p><p>第二部分: </p><p>正文部分: 2700字左右</p><p><strong>总共3000字左右.</strong></p><h3 id="1-5-范文-举例"><a href="#1-5-范文-举例" class="headerlink" title="1.5 范文: 举例"></a>1.5 范文: 举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">论信息系统工程项目的整体管理</span><br><span class="line">摘要:</span><br><span class="line"></span><br><span class="line"><span class="number">2005</span> 年 <span class="number">3</span> 月我作为项目经理参与了某市的公安部人口管理信息系统，该项目是为了实现该市平安城市的 <span class="number">5</span> 年规</span><br><span class="line">划。它投资 <span class="number">800</span> 万元。工期为 <span class="number">1</span> 年。目标是采用统一的技术路线和架构体系构建开放的、集成的、一体化的信息化的应</span><br><span class="line">用环境.该项目主要实现了常住人口户籍办公管理、二代身份证管理、暂住人口户籍管理、租赁房屋管理等。<span class="number">2006</span> 年 </span><br><span class="line"><span class="number">3</span> 月通过了甲方的验收，获得了甲方的一致好评。本文以我的实际经验讨论了有关大型整体管理的体会，主要从制定项目</span><br><span class="line">章程、制定项目范围说明书(初步)、制定项目管理计划、指导和管理   项目执行、监督和控制项目工作、整体变更控制、</span><br><span class="line">项目收尾方面做了论述。</span><br><span class="line"></span><br><span class="line">正文:</span><br><span class="line"></span><br><span class="line">为了实现某市平安城市的 <span class="number">5</span> 年规划，某市决定开发一个公安系统的人口管理信息系统。工期为 <span class="number">1</span> 年，投资 <span class="number">800</span> 万</span><br><span class="line">元。我公司在 <span class="number">2005</span> 年 <span class="number">2</span> 月中标了该市的公安部人口管理信息系统项目，签署了建设合同。<span class="number">2006</span> 年 <span class="number">3</span> 月通过了甲方的</span><br><span class="line">验收。项目分为平台开发和项目部署 <span class="number">2</span> 个阶段。软件方面考虑到各区县地理位置分布的不集中，计算机硬件和软件存在较</span><br><span class="line">大的差异等问题，我们决定采用 J2EE 框架的 <span class="number">3</span> 层 BS 模式，解决了各种应用系统中应用的不兼容问题， 提高了该系统</span><br><span class="line">的易用性。数据库采用了 Oracle <span class="number">9</span>g 来管理各项数据。服务器操作软件采用比较通用的 Windows Server <span class="number">2003</span>。硬件方</span><br><span class="line">面采用 IBM System X 系列的服务器提高了系统的稳定性和高性能。在应用层面上我们实现了常住人口户籍办公管理、二</span><br><span class="line">代身份证管理、暂住人口户籍管理、租赁房屋管理等功能。由千该项目工期紧，工作量大，在制定项目章程的时候  决定</span><br><span class="line">了多个分项的项目经理和总经理。我作为项目总经理参与了该项目的管理。接下来我将结合实际工作从制定项目章程，制定</span><br><span class="line">项目范围说明书(初步)，制定项目管理计划，指导和管理项目执行，监督和控制项目工作，整体变更控制及项目收尾来讨</span><br><span class="line">论大型项目的整体管理。</span><br><span class="line"></span><br><span class="line">一、制定项目章程</span><br><span class="line"></span><br><span class="line">项目章程是实施项目开发的前提和确定项目开发什么产品的依据。经过公司领导的授权  我被任命为该项目的总经</span><br><span class="line">理。由千项目的规模比较大、工期较紧，我们根据合同、项目工作  说明书等过程资产确认了另外 <span class="number">3</span> 名项目经理。我作为</span><br><span class="line">总经理统一协调。</span><br><span class="line"></span><br><span class="line">二、制定项目管理计划</span><br><span class="line"></span><br><span class="line">俗话说得好，“磨刀不误砍柴工”，在实施项目开发之前，做好应有的准备工作是很有必要的。完备的计划是项目实施</span><br><span class="line">的根本前提。为此我组织召开了“项目工作计划的会议”，会议邀请了各团队的项目经理、业务专家和技术专家。</span><br><span class="line">在制定范围控制管理计划进行 WBS 分解的时候，我发现由千涉及的人员较多，个人的知识水平也参差不齐，信息尚</span><br><span class="line">不够明确。因此我们决定采用滚动波式计划。对于即将开展的活动进行详细的分析和计划，对于后期的活动尽量粗略地估</span><br><span class="line">计，避免出现大范围的变更。 在制定进度控制计划的历时估算时因为我有过许多类似项目管理的经验。因此大部分的活动</span><br><span class="line">我采用了类比估算法，从而节约了时间。此外我们还考虑了活动存在的风险情况。在与负责二代身份证管理的经理讨论的过</span><br><span class="line">程中，我们发现身份证采集的设备驱动程序来自第三方，驱动的连接是否正常直接影响到了信息采集活动的开展。因此相关</span><br><span class="line">的业务、技术专家和团队成员调整了估算方法，采用了三点估算法。该方法主要有 <span class="number">3</span> 个数据，分别是最乐观历时估算 a、</span><br><span class="line">最悲观历时估算 c、最有可能历时估算 b，而后利用 T=(a+<span class="number">4</span>b+c)取其平均值。经过个专家和开发团队成员的讨论，认为</span><br><span class="line">最乐观的时间为 <span class="number">2</span> 个工作日、最悲观的时间为 <span class="number">6</span> 个工作日、最有可能的时间为 <span class="number">4</span> 个工作日。最后该活动的历时为 <span class="number">4</span> 个</span><br><span class="line">工作日。为项目的按时完工打下了基础。</span><br><span class="line">在制定质量控制管理计划的时候我们发现客户的有些要求与相关的法律法规相冲突。为此我及时通知了客户，与客户</span><br><span class="line">进行了沟通，最后我们修改了相关质量标准，使项目的质量得到了保证。</span><br><span class="line">在制定人力资源计划的时候为了保证有充足的资源去完成项目。团队的所有项目经理、 相关业务专家和技术专家经过</span><br><span class="line">讨论决定采用自下而上的方式进行估算，对每一层下面工作所需的资源进行估算，最后将所有的资源进行汇总。比如二代身</span><br><span class="line">份证信息管理可以分解为身份证信息的采集、信息的存储、信息的修改、信息的存储。信息采集工作需要忱卡器一</span><br><span class="line">台、能够在 Java 中成功调用 DLL 动态库一个以及 Java 程序开发人员 <span class="number">2</span> 名；信息存储工作需要通用数据库存储过程一</span><br><span class="line">个、Java 程序开发人员 <span class="number">2</span> 名。暂住人口户籍管理、租赁房屋管理的分项经理这时提出也需要Java 的开发人员各 <span class="number">2</span> 名。</span><br><span class="line">我们检查公司的人力资源表后发现缺少 <span class="number">2</span> 名Java 程序员，我及时向公司领导汇报了情况，经领导同意我们又招聘了 <span class="number">2</span> 名</span><br><span class="line">程序员，完成了资源的合理分配。通过讨论我还制作了活动资源日历，保证每个活动都有后备的资源考虑。</span><br><span class="line">我们还制定了项目成本控制管理计划、沟通管理计划、采购管理计划、风险管理计划等。</span><br><span class="line"></span><br><span class="line">三、指导和管理项目执行</span><br><span class="line"></span><br><span class="line">“懂业务的不懂技术，懂技术的不懂业务”，在这种情况下项目的风险很大，一旦开发人 员没有理解业务去开发，将导致严</span><br><span class="line">重的返工，最终影响项目进度。因此在开发的时候我要求 每个开发的具体功能必须要求项目经理组织相关干系人对开发人</span><br><span class="line">员进行交底，避免返工的发 生。开发这一阶段在每完成一个里程碑式的可交付物时，我都会邀请客户来进行确认签字，</span><br><span class="line">保证了我们开发产品的有效性，减少了无谓的变更。</span><br><span class="line"></span><br><span class="line">四、监督和控制项目工作</span><br><span class="line"></span><br><span class="line">在项目执行的过程中总会遇到各种各样的问题。那么怎样才能预防和控制各种问题的发生呢？每周我会根据绩效信息</span><br><span class="line">与计划进度表进行比较，进行偏差分析，利用挣值技术计算进度偏差情况，及时采取纠正和预防措施。比如负责二代身份证</span><br><span class="line">信息管理项目的丁工还负责其他项目的系统需求分析和设计，因其他项目上的事情比较多，二代身份证管理的需求分析 和</span><br><span class="line">详细设计迟迟不能开始，已落后千计划，SV=-<span class="number">3</span>。如果再不提交将会影响到编码阶段。届时，我与丁工进行了沟通，与他协</span><br><span class="line">商决定，我负责帮他完成一部分其他项目的工作，他加班负责把马上要进行编码阶段的二代身份证信息管理的需求分析和设</span><br><span class="line">计提交出来，最终二代身份证信息管理的编码工作按计划开展。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">五、整体变更控制</span><br><span class="line"></span><br><span class="line">项目开发的过程中客户的需求经常会有变更。为了防止频繁的变更对项目进度等带来的 不利影响。项目的初期我们成</span><br><span class="line">立了由客户方、开发方和监理方组成项目控制委员会 CCB。客户或者开发方每个需要的变更都要经 CCB 的批准才能实行。</span><br><span class="line"></span><br><span class="line">六、项目收尾</span><br><span class="line"></span><br><span class="line">经过项目全体人员的共同努力，<span class="number">2006</span> 年 <span class="number">2</span> 月终千完成了压力测试，<span class="number">2006</span> 年 <span class="number">3</span> 月项目一次性通过了甲方的验收。</span><br><span class="line">回顾项目的进度管理工作的过程中，项目能成功通过验收得益千在 事前进行了充分的计划和准备工作。我觉得项目管理的</span><br><span class="line">能力和项目开发的能力是有很大的区 别的。一个成功而高效的项目开发必须要有一个能统筹管理和善千沟通的项目经理。</span><br><span class="line">特别是 作为大型项目经理，我们的主要工作就是平衡各种资源的利用，使其达到最佳的效率。怎样才能达到这个最佳。这</span><br><span class="line">个是我在今后的工作中需要长期实践和摸索的内容。虽然项目成功通过了验收没有大的事故发生，但仍然存在许多问题，主</span><br><span class="line">要有以下几点：</span><br><span class="line">(<span class="number">1</span>)在需要客户确认时，与客户的沟通方式比较单一，只是一味等待，导致某些工作落后 千计划进度，影响了整体计划。</span><br><span class="line">(<span class="number">2</span>)需求分析还不够全面，某些功能没有能够很完善地实现。</span><br><span class="line">(<span class="number">3</span>)软件测试不系统，用例准备仍不够充分，忽视了压力测试。系统实际运行后随着参保 职工和定点结算的增加，运行速</span><br><span class="line">度下降很快，达不到设计要求。虽然通过升级硬件缓解了这个问题，但造成资金的额外投入。</span><br></pre></td></tr></table></figure><h3 id="1-6-模板"><a href="#1-6-模板" class="headerlink" title="1.6 模板:"></a>1.6 模板:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">项目整体管理是项目管理的必要条件，是项目管理的有效基础，是项目管理的重要内容。为了保障项目的持续进展，</span><br><span class="line">确保项目的有序进行，保证项目能够顺利的上线，我从制定项目章程、制定初步范围说明书、制定项目管理计划、管理和指</span><br><span class="line">导项目执行、监控项目工作、整体变更控制和合同收尾等六个方面加强项目的整体管理。</span><br><span class="line"></span><br><span class="line">第一，制定项目章程。</span><br><span class="line"></span><br><span class="line">制定项目章程是项目整体管理的第一步。通过制定项目章程明确项目的整体目标，通过收益法判断整体的项目收益。</span><br><span class="line">整个项目采用项目型管理方式。正式任命我作为项目经理。假定某某省某某市的计划生育政策具有延续性，不会有大的变</span><br><span class="line">更，这样保障需求不会发生实质的变更。假定项目开发人员中的主力开发人员不会在项目开发过程离职。系统的人口信息表</span><br><span class="line">的存放数据量为<span class="number">600</span>万条，系统的响应时间不超过<span class="number">6</span>秒，系统的从需求分析到系统试运行时间为<span class="number">1</span>年，系统的并发用户为<span class="number">50</span></span><br><span class="line">个。系统的项目干系人分为四类：甲方的领导层，关心整体项目进度情况；甲方的业务人员，关心项目的具体业务的实现；</span><br><span class="line">乙方的领导层，关心项目的成本、质量及合同的收款情况；乙方的项目团队曾元，关心项目的需求、设计、编码、测试、实</span><br><span class="line">施上线。</span><br><span class="line"></span><br><span class="line">第二，制定初步范围说明书。</span><br><span class="line"></span><br><span class="line">项目初步范围说明书是项目整体管理的第二步。项目初步范围说明书是项目各个阶段提交的交付物和为提交交付物所</span><br><span class="line">做的工作。我初步制定了项目初步范围说明书包括需求分析报告、系统概要设计、系统详细设计、模块开发卷宗、测试规</span><br><span class="line">范、系统集成规范、系统验收规范、系统产品说明书、系统代码。制定了初步工作分解结构。</span><br><span class="line"></span><br><span class="line">第三、制定项目管理计划。</span><br><span class="line"></span><br><span class="line">制定项目管理计划是项目整体管理的第三步。项目管理计划包括成本管理计划、质量管理计划、时间管理计划、风险</span><br><span class="line">识别册、人力资源沟通计划等。通过制定项目管理计划，整个项目按照制定的计划预期稳步向前推进。</span><br><span class="line"></span><br><span class="line">第四，管理和指导项目执行。</span><br><span class="line"></span><br><span class="line">采用工具sourceSafe建立配置管理系统，对所有的文档及变更记录进行管理。采用OA系统作为所有项目干系人的沟通</span><br><span class="line">工具，所有的变更文档记录及相关的项目文档资料通过OA的流程管理进行处理。比如，有的程序员对J2EE比较熟悉，这次</span><br><span class="line">开发采用.NET路线，因此请对.NET精通的专家对不熟悉J2EE的程序员进行培训。要求质量管理人员按照编码规范对代码进</span><br><span class="line">行走查，不符合要求责令修改。</span><br><span class="line"></span><br><span class="line">第五，监控项目工作。</span><br><span class="line"></span><br><span class="line">监控项目工作是项目整体管理的第五个步骤。对整个项目在成本、风险、质量、进度等方面进行监控。在每个里程碑</span><br><span class="line">的节点上开面对面沟通会议，对前一阶段的工作进行审核把关，同时对出现的问题进行记录，寻找解决办法；通过每周的项</span><br><span class="line">目例会，对这一周的工作进行总结，出现的问题进行记录，及时把问题解决。通过每天的项目组成员的工作日志，记录成员</span><br><span class="line">每天的工作情况，以便于及时的把问题查找出来。通过每天的工作日志、每周的项目例会及里程碑节点的会议及时的与项目</span><br><span class="line">计划进行比对，找出偏差，及时处理。</span><br><span class="line"></span><br><span class="line">第六、整体变更控制。</span><br><span class="line"></span><br><span class="line">成立变更控制管理委员会，对整个项目的需求变更进行管理控制。变更管理委员会对申请的变更要审核、评估。批准</span><br><span class="line">后的变更要按计划执行，同时对执行后的项目进行追踪。</span><br><span class="line"></span><br><span class="line">第七，项目收尾。</span><br><span class="line"></span><br><span class="line">项目收尾包括管理收尾和合同收尾。通过项目范围说明书、合同等文档的要求，对提交给用户的可交付物进行比对。</span><br><span class="line">对已完成的可交付请求客户确认签字，对用户确定需要进一步完善的可交付物要及时的按照文档资料要求处理。最后整体验</span><br><span class="line">收。例如，按照合同要求，我们用惠普的loadrunner对系统进行了<span class="number">50</span>并发用户的压力测试，同时在开发的过程也组织了人</span><br><span class="line">力对人口的基础数据进行了录入，响应时间小于<span class="number">6</span>秒。同时提交的文档资料整体提交完毕，人员培训已经完成，系统试运行</span><br><span class="line">三个月情况良好，满足用户需求。</span><br></pre></td></tr></table></figure><h2 id="二、范围管理"><a href="#二、范围管理" class="headerlink" title="二、范围管理"></a>二、范围管理</h2><h3 id="2-1-可以从以下方面去写"><a href="#2-1-可以从以下方面去写" class="headerlink" title="2.1 可以从以下方面去写:"></a>2.1 可以从以下方面去写:</h3><p>①: 6个过程       (命题概率较大)</p><p>②: PDCA          (命题概率较大)</p><p>③: 范围结合需求</p><p>④: 问题解决的角度</p><p>注: <strong>其中 1 命题概率大，建议 6 个过程的角度必须准备</strong></p><h3 id="2-2-写作思路"><a href="#2-2-写作思路" class="headerlink" title="2.2 写作思路:"></a>2.2 写作思路:</h3><table><thead><tr><th>过程</th><th>通俗解释</th><th>写作要点</th></tr></thead><tbody><tr><td>1 范围规划</td><td>编写<strong>项目范围管理计划</strong></td><td>写我组织相关人员进行了项目范围管理计划的<strong>编制</strong>,在编制<strong>之前</strong>做了什么准备,通过什么<strong>方法</strong>进行编制,编制后的计划包含什么<strong>内容.</strong></td></tr><tr><td>2 收集需求</td><td><strong>记录</strong>并管理<strong>干系人的需要</strong>和需求过程</td><td>哪些<strong>类型</strong>的需求, <strong>输入,输出,工具技术</strong>,该过程的<strong>重要性</strong>,遇到什么<strong>问题</strong>,如何<strong>解决</strong>,需求文件,建立需求跟踪矩阵等.</td></tr><tr><td>3 范围定义</td><td>对项目和产品详细描述,并写到详细的范围说明书中,形成<strong>详细的范围说明书.</strong></td><td>举例描述,本项目的某个功能<strong>原来</strong>是怎么定义,<strong>现在</strong>是如何详细的表示,最终说明书包含什么</td></tr><tr><td>4 创建工作分解结构WBS</td><td>项目的<strong>可交付物和项目管理的工作进行分解</strong>,分解为更小更易于管理的单元.</td><td><strong>为什么要分解</strong>,是采用树形还是列表型,以什么作为<strong>第一层</strong>,分解的五个<strong>步骤</strong>是什么,遵循什么<strong>原则</strong></td></tr><tr><td>5 范围确认</td><td><strong>阶段性的接受</strong>项目的可交付物,对不可接受的说明理由,重新整改.</td><td>具体通过什么<strong>方式</strong>进行范围确认,哪些进行了确认,哪些没有,是什么<strong>原因</strong>,怎样整改.</td></tr><tr><td>6 范围控制</td><td><strong>管理好变更</strong>,避免出现<strong>范围蔓延</strong></td><td>写范围管理的<strong>重要性</strong>,<strong>如何</strong>进行范围控制的,如何防止<strong>范围蔓延</strong></td></tr></tbody></table><h3 id="2-3-过程-输入-输出-工具和技术"><a href="#2-3-过程-输入-输出-工具和技术" class="headerlink" title="2.3 过程,输入,输出,工具和技术"></a>2.3 过程,输入,输出,工具和技术</h3><table><thead><tr><th>过程+输入</th><th>工具/技术</th><th>输出</th></tr></thead><tbody><tr><td><font color="red" size="5">2.3.1 范围规划 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>范围管理计划</td></tr><tr><td>②: 项目章程</td><td>会议</td><td>需求管理计划</td></tr><tr><td>③: 事业环境因素</td><td>模板,表格,标准</td><td></td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td>⑤: 初步项目范围说明书</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 章程计划找业组, 专家会议两计划</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.2 收集需求 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 范围管理计划</td><td>访谈</td><td>需求文件</td></tr><tr><td>②: 需求管理计划</td><td>问卷</td><td>需求跟踪矩阵</td></tr><tr><td>③: 干系人管理计划</td><td>观察</td><td></td></tr><tr><td>④: 项目章程</td><td>标杆</td><td></td></tr><tr><td>⑤: 干系人登记册</td><td>原型</td><td></td></tr><tr><td><font color="green" size="5">口诀: 范需人划章程册, 需求文件矩阵出</font>(划: 管理计划),</td><td>文件分析</td><td></td></tr><tr><td></td><td>系统交互图</td><td></td></tr><tr><td></td><td>焦点小组</td><td></td></tr><tr><td></td><td>引导式研讨会</td><td></td></tr><tr><td></td><td>群体创新技术</td><td></td></tr><tr><td></td><td>群体决策技术</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.3 范围定义 (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 范围管理和计划</td><td>专家判断</td><td>项目范围说明书(详细)</td></tr><tr><td>②: 项目章程</td><td>产品分析</td><td>项目管理计划更新</td></tr><tr><td>③: 需求文件</td><td>可选方案识别</td><td></td></tr><tr><td>④: 组织过程资产</td><td>引导式研讨会</td><td></td></tr><tr><td><font color="green" size="5">口诀: 范划章程需文组, 文件更新出范书</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.4 创建工作分解结构WBS (规划过程组)</font></td><td></td><td></td></tr><tr><td>①: 范围管理计划</td><td>分解技术</td><td>范围基准</td></tr><tr><td>②: 详细项目范围说明书</td><td>专家判断</td><td>项目管理计划更新</td></tr><tr><td>③: 需求文件</td><td>WBS分解结构模板</td><td>WBS和WBS字典</td></tr><tr><td>④: 事业环境因素</td><td></td><td></td></tr><tr><td>⑤: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 范划范书需业组,文件更新出基准</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.5 范围确认 (监控过程组)</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>检查</td><td>验收的可交付性成果</td></tr><tr><td>②: 需求文件</td><td>群体决策</td><td>变更请求</td></tr><tr><td>③: 需求跟踪矩阵</td><td></td><td>工作绩效信息</td></tr><tr><td>④: 核实的可交付性成果</td><td></td><td>项目文件更新</td></tr><tr><td>⑤: 工作绩效数据</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 计划需文效成果,文件变更绩效出</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">2.3.6 范围控制</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>偏差分析</td><td>工作绩效信息</td></tr><tr><td>②: 需求文件</td><td>变更控制系统</td><td>变更请求</td></tr><tr><td>③: 需求跟踪矩阵</td><td>配置管理系统</td><td>项目管理计划更新</td></tr><tr><td>④: 工作绩效数据</td><td>重新规划</td><td>项目文件更新</td></tr><tr><td>⑤: 组织过程资产</td><td></td><td>组织过程资产更新</td></tr><tr><td><font color="green" size="5"> 口诀: 计划需文效矩组,计组文件齐更新 </font></td><td></td></tr></tbody></table><h3 id="2-4-范文"><a href="#2-4-范文" class="headerlink" title="2.4 范文:"></a>2.4 范文:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">论信息系统工程项目的范围管理</span><br><span class="line">摘要:</span><br><span class="line"><span class="number">2009</span> 年 <span class="number">5</span> 月，我作为项目经理，参与了××物流公司条形码项目。该项目是为了提升××物流公司日常业务运作中货物</span><br><span class="line">流转交换的准确性和及时性，解决该公司现有业务运作中的货物差错率高、装卸效率低、记录颗粒度粗等问题，进而提升整</span><br><span class="line">体运营服务质量，实现×× 物流公司由低端运输向高端公路快运转型的战略目标。</span><br><span class="line">作为该公司的重点战略项目，项目总投资 <span class="number">2000</span> 万元，项目工期为 <span class="number">2</span> 年，系统主要实现了以下功能：CD对货物流转</span><br><span class="line">交换过程中的每一个环节的扫描，实现货物运输全过程跟踪处理功能；＠基千计划与实际扫描结果的比对，实现装卸差错及</span><br><span class="line">时发现、及时解决；＠货物异常处理；＠提送货任务的指派与管理。</span><br><span class="line"><span class="number">2011</span> 年 <span class="number">6</span> 月，该项目通过了客户的验收，顾得了甲方的好评，成为公路运输行业实施条码技术的成功案例；得到业</span><br><span class="line">内的一致认可。本文结合作者的实际经验讨论了项目的范围管理，主要从制定范围计划、定义范围、创建 WBS，以及核实</span><br><span class="line">范围、控制范围这几个方面进行论述。</span><br><span class="line"></span><br><span class="line">正文:</span><br><span class="line"><span class="number">2009</span> 年 <span class="number">5</span> 月，我参与了××物流公司条形码项目建设，该项目应××物流公司由低端运输向高端公路快运转型的战略而</span><br><span class="line">立项，是 <span class="number">2009</span> 年该公司的重点项目。项目建设周期为 <span class="number">2</span>年，由 <span class="number">2009</span> 年 <span class="number">5</span> 月开始，到 <span class="number">2011</span> 年 <span class="number">6</span> 月验收结束，项目</span><br><span class="line">总投资为人民币 <span class="number">2000</span> 万元。其目标是建立一套高效实用的条码系统，全面提高流转交换的准确性和及时性，降低差错，</span><br><span class="line">提升运营服务质量，实现由低端运输向高端公路快运转型的战略目标。</span><br><span class="line">系统采用 C/S 架构，服务端应用采用 J2EE+Oracle 的模式开发，服务器使用 HP 的 <span class="number">580</span>G7， 操作系统为Redhat </span><br><span class="line">企业版 Linux <span class="number">5.4</span>，数据库使用 Oracle <span class="number">11</span>g R2 并做 RAC，中间件采用 IBM 的 WebSphere 并做集群，终端应用基千 </span><br><span class="line">Microsoft 的Windows CE 平台，采用 C#语言开发， 运行千 PDA 上。项目采用矩阵型组织结构，从各职能部门抽调主</span><br><span class="line">干成员，组成专门的项目团队。我被任命为该项目的项目经理，负责项目的管理工作，直接向项目总监汇报。下面我将结合</span><br><span class="line">本项目从制定范围管理计划、定义范围、创建工作分解结构、核实范围、控制范围这几个方面对项目的范围管理进行介绍。</span><br><span class="line">一、制定范围计划</span><br><span class="line">作为一名合格的项目管理者，做任何事之前都应该先做好计划。好的计划，是成功实施项目的基础。有些人为做项目</span><br><span class="line">范围计划花费了太多时间，不如把它们用千执行工作，项目将会更快更好地完成，我认为这是一个错误的想法，通过省略范</span><br><span class="line">围计划制定，虽然能短暂时间内节省一定的时间，但在长期来看，常常会因缺乏管理计划指导而使得范围定义不清、范围蔓</span><br><span class="line">延，以致无法完成项目。</span><br><span class="line">因此，在该项目中，我非常重视范围计划的制定，在正式做计划之前，我先查找了公司组织过程资产，找出制定范围管理计</span><br><span class="line">划的模板，再结合以往项目的经验，制定出一份初步的计划，然后召集项目团队成员讨论，对计划进行修改和完善，在全体</span><br><span class="line">参与下，最终完成一份详细的、科学的范围管理计划，用千指导项目如何定义、分解以及核实和控制范围。</span><br><span class="line"></span><br><span class="line">二、定义范围</span><br><span class="line">一个成功的项目，应该做且只做成功完成项目所需的全部工作。为了保证这一点，就需要在项目前期定义一个明确的</span><br><span class="line">项目范围。在项目的早期阶段，我带领团队，到了客户现场收集需求，我组织了客户的运营部门、服务质量部门、IT 部门</span><br><span class="line">以及我的需求团队，召开需求讨论会，共同商讨项目范围。在收集需求的时候，客户有时候需求描述得不是很清楚，造成了</span><br><span class="line">双方对需求理解有歧义，甚至有时候客户对千其需求自己都不清楚，只有一个模糊的概念； 针对这种情况，我采用原型法</span><br><span class="line">将收集到的需求，做成模型供客户参考确认，以此消除彼此的歧义，充分挖掘用户的需求，并基千团队自身的经验以及专业</span><br><span class="line">水平，对客户的需求进行引导、细化，将其模糊的概念形象化，粗糙的需求具体化。</span><br><span class="line">基于需求文件，我召集项目的主要干系人进行开会讨论，同时邀请了系统的最终用户代表（包括甲方的业务员，装卸</span><br><span class="line">工、调度等）对系统功能做评价，通过用户的角度，去发现和改进系统的功能，以此最终形成了完整的项目范围说明书，主</span><br><span class="line">要包含：CD条码项目的产品范围描述（包括取派件管理、装卸管理、异常管理等）；＠项目的主要可交付成果（用户文</span><br><span class="line">档、应用系统、源代码等）；＠产品验收标准（系统运行稳定、功能满足业务需求、相关文档齐全等）；＠项目的除外责任</span><br><span class="line">（该项目涉及的仓库环境改造，强电、弱电改造不包含在该项目范围中）；＠项目制约因素（之前的预算和系统设计仅针对</span><br><span class="line">定日达产品进行，如果扩展到零担，必须追加投入、延长项目时间）；＠项目假设条件（假设项目涉及的场站改造、人员素</span><br><span class="line">质提高可以配合条码项目进行持续改进，假设甲方的业务系统满足条码项目上线后给其增加的负载）；＠项目的目标、总预</span><br><span class="line">算、资源，以及主要里程碑等。</span><br><span class="line"></span><br><span class="line">三、创建 WBS</span><br><span class="line">基于项目范围说明书，我和我的团队开始对项目范围进行分解，以形成该项目的 WBS。在分解过程中，我按照以下原</span><br><span class="line">则进行分解。在各层次上保持项目的完整性，我将该项目涉及的需求调研、系统设计、开发、测试等完整的模块都一一列</span><br><span class="line">出，避免遗漏必要的组成部分。一个工作单元只从属千某个上层单元。对千该项目中的数据库设计，我就只将其归入系统设</span><br><span class="line">计单元中，在其他单元不再重复出现，避免了交叉从属。相同层次的工作单元应有相同性质。对千系统设计单元下的数据库</span><br><span class="line">设计、接口设计、系统设计等设计内工作，它们从属性上来讲， 都属千设计，因此我将其一并归入系统设计单元下。工作</span><br><span class="line">单元应能分开不同的责任者和不同的工作内容。对千该项目中每个工作包，我都指定唯一的负责人和其负责的工作内容，便</span><br><span class="line">千项目管理进行计划和控制的管理。对千该项目的每个工作包，我都对其进行编号，并与组织结构图和成本控制点深度融</span><br><span class="line">合，便千项目的日后管理。应包括项目管理工作，包括分包出去的工作。对千该项目，我将项目管理和外包的 AP 部署也</span><br><span class="line">一并纳入 WBS 中，并逐层分解。WBS 的最低层次的工作单元是工作包；对千该项目中工作单元，我参照 <span class="number">8</span>/<span class="number">80</span> 小时原则</span><br><span class="line">细化成具体的工作包，并指定具体的负责人。同时制作 WBS 词典，对工作包做具体描述。</span><br><span class="line"></span><br><span class="line">四、核实范围</span><br><span class="line"></span><br><span class="line">范围确认并不是件容易的事情，在与客户的沟通上，我们希望客户尽快确认以便尽快开展后续的开发阶段工作，而客</span><br><span class="line">户则可能认为自己什么也没看到，怎么确认呢？针对这种情况， 我在提交文档给客户的相关干系人后，重点对客户的 IT </span><br><span class="line">人员进行沟通培训，详细介绍系统的设计，然后用他们的声音去向客户的业务部门做出介绍，这样既有益千专业人员之间的</span><br><span class="line">技术沟通，也有益千客户业务部门对系统范围的认可与信任。同时，在与客户的业务部门沟通时，我重点强调，虽然范围确</span><br><span class="line">认是正式的，但这并不意味着项目的范围就是铁板一块，不能再修改了，只要走标准的变更流程，且审批通过的，都是可以</span><br><span class="line">进行变更的。这样就消除了客户的顾虑，便千快速、高效地完成范围确认。</span><br><span class="line"></span><br><span class="line">五、控制范围</span><br><span class="line"></span><br><span class="line">控制范围就是监督项目的范围状态，管理范围基础变更的过程。因此在项目中，我定期组织召开项目状态审查会，审查项目</span><br><span class="line">的范围，通过对照范围基础，找出范围偏差，并做分析，严格杜绝一切的范围蔓延以及锁金。</span><br><span class="line">例如，在一次状态审查会上，我发现项目的功能模块中，系统管理以及库存管理模块多了登录日志以及盘库两块功</span><br><span class="line">能，我查了一下系统变更日志，未找到有类似的变更记录，千是我参照责任分配矩阵，分别找到这两个模块开发的负责人询</span><br><span class="line">问原因，A 成员告诉我，他增加登录日志这个功能，是因为客户在一次电话中，向他提过希望在系统管理模块中加一个登</span><br><span class="line">录日志的功能，B 成员则是因为在开发库存管理模块时，发现整个库存管理没有库存盘点的功能，他认为做库存管理，肯</span><br><span class="line">定需要用到盘点功能，而且这是个亮点，所以他私自增加了这一功能。针对这两种情况，我首先向这两名成员强调了范围基</span><br><span class="line">准以及变更流程的重要性；其次， 针对这两项多出来的功能，我要求相关人员提交正式的变更申请，走正常的变更控制流</span><br><span class="line">程。从事项目管理工作的我深知，项目范围不是一经定义，就一成不变的，项目干系人出千项目利益以及各种情况考虑，总</span><br><span class="line">会有一些需求变更，管理这些变更，需要在项目规划时，就制定好变更控制流程以及成立一个专门的需求变更控制委员会</span><br><span class="line">（CCB）。</span><br><span class="line">因此，我和我的团队在项目早期就制定了一套标准的变更流程：CD提交变更申请；＠评估变更；＠报 CCB 审批；＠</span><br><span class="line">实施变更并调整基准；＠将变更信息通知相关干系人；＠对变更的结果进行追踪与审核。有了这些流程以及 CCB 的</span><br><span class="line">控制，项目的需求变更得以良性发展，变更带来更多的是项目利益以及效率的提升。</span><br><span class="line">经过我和我的团队不懈努力，该项目最终千 <span class="number">2011</span> 年 <span class="number">5</span> 月试运行成功，并在同年 <span class="number">6</span> 月通过了客户验收小组的验收，</span><br><span class="line">得到了甲方的好评，使得××物流公司运营的货物差错率降低了<span class="number">50</span>%，客户投诉率降低了 <span class="number">20</span>%，理赔损失降低了 <span class="number">20</span>%，提升</span><br><span class="line">了该公司的整体运营服务水平、客户满意度及公司形象，为××物流公司由低端运输向高端公路快运转型提供强有力的保</span><br><span class="line">障。项目最终能成功完成，得益千我在项目中有效的范围管理，采用科学的范围管理方法、工具和技术，为项目的范围管理</span><br><span class="line">带来了事半功倍的效果。同时，在该项目的实施过程中，也出现了一些问题，本人觉得处理得不是很好，主要在千项目中的</span><br><span class="line">冲突管理以及项目风险识别方面还存在不足，后续我将加强这两个方面的学历与知识积累，不断提升自身项目管理水平，为</span><br><span class="line">中国物流行业的信息化发展添砖加瓦</span><br></pre></td></tr></table></figure><h3 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">项目范围管理是项目管理的核心部分，是项目管理的必要条件，是项目管理持续发展的基础，是项目管理有效进行的前提。</span><br><span class="line">我从范围规划、范围定义、工作分解结构、范围确认、范围控制等五个方面开展了项目范围管理的工作。</span><br><span class="line"></span><br><span class="line">第一，范围规划。</span><br><span class="line">范围规划是项目范围管理的第一个环节。范围规划确保范围定义、工作分解结构、范围确认和范围控制如何开展。</span><br><span class="line"></span><br><span class="line">第二，范围定义。</span><br><span class="line">范围定义是制定项目范围说明书的过程，项目范围说明书是确定整个项目工作中的可交付物及提交可交付物所做的工作。本</span><br><span class="line">项目采用快速原型结合面向对象开发的方法。先根据甲方沟通，确定甲方的重要项目干系人分类。一类是甲方的领导层确定</span><br><span class="line">系统要达到的整体目标，另一类是甲方的业务人员，他们的要求是系统的具体功能。我方人员通过与各类项目干系人进行沟</span><br><span class="line">通，通过制作界面原型与甲方不断确认，把需求确定下来，把范围确定下来。</span><br><span class="line"></span><br><span class="line">第三，创建工作分解结构。</span><br><span class="line">创建工作分解结构项目范围管理的重要环节。通过工作分解结构把项目的整体工作分解成工作包。通过滚动式规划，把近期</span><br><span class="line">的工作分解较为详细，远期的工作分解较为初略。根据工作分解结构，初步整个项目分解成业务需求、用户需求、功能需</span><br><span class="line">求、概要设计、详细设计、系统编码、单元测试、整体测试、集成测试、安全测试、压力测试、系统培训、系统试运行。</span><br><span class="line"></span><br><span class="line">第四，范围确认。</span><br><span class="line">范围确认是我方与甲方对项目说明书确认的一个过程，对于系统开发过程中所提交的文档、资料、软件等可交付物及为这些</span><br><span class="line">交付物所做的工作的确认。整个范围确认是贯穿整个过程的始终。我方和用户方商定，所有的提交的可交付物，用户必须制</span><br><span class="line">定项目联系人签字盖章，如果拒绝提交，也要提出书面说明。</span><br><span class="line"></span><br><span class="line">第五，范围控制。</span><br><span class="line">范围控制是保证整个项目有效实施的重要内容。我方与用户方成立变更控制委员会。对用户方提出的范围变更请求必须提交</span><br><span class="line">书面申请，由变更控制委员会进行审核，审核通过后执行，并对执行的结果进行跟踪。建立sourcesafe软件配置管理系</span><br><span class="line">统。把所有的文档用配置管理系统管理起来，对整个项目的管理及范围变更有非常清晰的认识。</span><br></pre></td></tr></table></figure><h2 id="三、进度管理"><a href="#三、进度管理" class="headerlink" title="三、进度管理"></a>三、进度管理</h2><h3 id="3-1-可以从以下方面去写"><a href="#3-1-可以从以下方面去写" class="headerlink" title="3.1 可以从以下方面去写:"></a>3.1 可以从以下方面去写:</h3><p>①: 7个过程       (命题概率较大)</p><p>②: PDCA          (命题概率较大)</p><h3 id="3-2-写作思路"><a href="#3-2-写作思路" class="headerlink" title="3.2 写作思路:"></a>3.2 写作思路:</h3><table><thead><tr><th>过程</th><th>通俗解释</th><th>写作要点(举例: 根据子题目写)</th></tr></thead><tbody><tr><td>1 制定进度管理计划</td><td>写一个叫做进度管理计划的文档</td><td>我组织相关人员进行了进度管理计划的编制工作，在进行编制前做了什么准备,通过什么方法进行了编制，编制后的计划包含什么内容等，计划的重要性等等</td></tr><tr><td>2 定义活动</td><td>看项目里面到底有多少活动需要完成，识别出来并记录下来</td><td>活动定义和 WBS 的关系，举例写下结合本项目有哪些活动？</td></tr><tr><td>3 排列活动顺序</td><td>明确各活动之间的顺序等相互的依赖关系，并记录下来</td><td>举例描述下活动的逻辑关系</td></tr><tr><td>4 估算活动资源</td><td>估算下每个活动到底需要多少材料、人员、设备等等资源</td><td>某某活动需要什么资源，需要多少资源，什么时候需要等等。是通过什么方式进行估算的等内容</td></tr><tr><td>5 估算活动持续时间</td><td>估算下完成某活动所需要的持续时间</td><td>什么方法对本项目中的一些活动进行了历时估算，是多少时间等。</td></tr><tr><td>6 制定进度计划</td><td>分析这些活动的顺序、历时、资源需求和相关的一些进度约束等内容来编制项目的进度计划</td><td>通过什么方法进行进度计划的制定的</td></tr><tr><td>7 进度控制</td><td>监控项目的具体状态， 如果发现有偏差，我们需要进行纠偏</td><td>进度控制的重要性、工作内容，举例挣值分析，发现项目进度怎么样了，分析为什么，进行纠偏</td></tr></tbody></table><h3 id="3-3-过程-输入-输出-工具和技术"><a href="#3-3-过程-输入-输出-工具和技术" class="headerlink" title="3.3 过程,输入,输出,工具和技术"></a>3.3 过程,输入,输出,工具和技术</h3><table><thead><tr><th>过程+输入</th><th>工具/技术</th><th>输出</th></tr></thead><tbody><tr><td><font color="red" size="5">3.3.1 规划进度管理</font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>专家判断</td><td>进度管理计划</td></tr><tr><td>②: 项目章程</td><td>分析技术</td><td></td></tr><tr><td>③: 事业环境因素</td><td>会议</td><td></td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 章程计划找业组,分家会上进管子</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.2 定义活动</font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>分解</td><td>活动清单</td></tr><tr><td>②: 范围基准</td><td>滚动式规则</td><td>活动属性</td></tr><tr><td>③: 事业环境因素</td><td>专家判断</td><td>里程碑清单</td></tr><tr><td>④: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组进管炒基范,分家滚出清属里</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.3 排列活动顺序</font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>紧前关系绘图法PDM</td><td>项目进度网络图</td></tr><tr><td>②: 活动清单</td><td>确定依赖关系</td><td>项目文件更新</td></tr><tr><td>③: 活动属性</td><td>提前与滞后</td><td></td></tr><tr><td>④: 里程碑清单</td><td></td><td></td></tr><tr><td>⑤: 项目范围管理书</td><td></td><td></td></tr><tr><td>⑥: 事业环境因素</td><td></td><td></td></tr><tr><td>⑦: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 范进业组清属里, 前后紧赖网新文</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.4 估算活动资源 </font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>自下而上估算</td><td>资源分解结构</td></tr><tr><td>②: 活动清单</td><td>备选方案分析</td><td>活动资源需求</td></tr><tr><td>③: 活动属性</td><td>项目管理软件</td><td>项目文件更新</td></tr><tr><td>④: 资源日历</td><td>发布的估算数据</td><td></td></tr><tr><td>⑤: 风险登记册</td><td>专家判断</td><td></td></tr><tr><td>⑥: 活动成本估算</td><td></td><td></td></tr><tr><td>⑦:  事业环境因素</td><td></td><td></td></tr><tr><td>⑧: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组进管估成本,清属资历有风险</font></td><td>自选软件算专家</td><td>分解需求新文件</td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.5 估算活动持续时间 </font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>专家判断</td><td>活动持续时间估算</td></tr><tr><td>②: 活动清单</td><td>类比估算</td><td>项目文件更新</td></tr><tr><td>③: 活动属性</td><td>参数估算</td><td></td></tr><tr><td>④: 活动资源需求</td><td>三点估算</td><td></td></tr><tr><td>⑤: 资源日历</td><td>群体决策技术</td><td></td></tr><tr><td>⑥: 项目范围说明书</td><td>储备分析</td><td></td></tr><tr><td>⑦: 风险登记册</td><td></td><td></td></tr><tr><td>⑧: 资源分解结构</td><td></td><td></td></tr><tr><td>⑨: 事业环境因素</td><td></td><td></td></tr><tr><td>⑩: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组资需分日进,清属范书有风险</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.6 制定进度计划 </font></td><td></td><td></td></tr><tr><td>①: 进度管理计划</td><td>进度网络分析</td><td>进度基准</td></tr><tr><td>②: 活动清单</td><td>关键路径法</td><td>项目进度计划</td></tr><tr><td>③: 活动属性</td><td>关键链法</td><td>进度数据</td></tr><tr><td>④: 项目进度网络图</td><td>资源优化技术</td><td>项目日历</td></tr><tr><td>⑤: 活动资源需求</td><td>建模压缩技术</td><td>项目管理计划更新</td></tr><tr><td>⑥: 资源日历</td><td>提前与滞后</td><td>项目文件更新</td></tr><tr><td>⑦: 活动持续时间估算</td><td>进度压缩</td><td></td></tr><tr><td>⑧: 项目范围说明书</td><td>进度计划编制</td><td></td></tr><tr><td>⑨: 风险登记册</td><td></td><td></td></tr><tr><td>⑩: 项目人员分配</td><td></td><td></td></tr><tr><td>⑩: 资源分解结构</td><td></td><td></td></tr><tr><td>⑩: 事业环境因素</td><td></td><td></td></tr><tr><td>⑩: 组织过程资产</td><td></td><td></td></tr><tr><td><font color="green" size="5">口诀: 业组资需分日进,清属范书有风险,人员进</font></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><font color="red" size="5">3.3.7 控制进度计划 </font></td><td></td><td></td></tr><tr><td>①: 项目管理计划</td><td>绩效审查</td><td>工作绩效信息</td></tr><tr><td>②: 进度管理计划</td><td>项目管理软件</td><td>进度预测</td></tr><tr><td>③: 工作绩效数据</td><td>资源优化技术</td><td>变更请求</td></tr><tr><td>④: 项目日历</td><td>建模技术</td><td>项目管理计划更新</td></tr><tr><td>⑤: 进度数据</td><td>提前与滞后</td><td>项目文件更新</td></tr><tr><td>⑥: 组织过程资产</td><td>进度压缩</td><td>组织过程资产更新</td></tr><tr><td></td><td>进度计划编制工具</td><td></td></tr><tr><td><font color="green" size="5">口诀: 两数两划组日历</font></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-4-范文-举例"><a href="#3-4-范文-举例" class="headerlink" title="3.4 范文: 举例"></a>3.4 范文: 举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">论项目进度管理</span><br><span class="line">【摘要】</span><br><span class="line"><span class="number">2008</span> 年 <span class="number">10</span> 月，XX 发展股份有限公司作为系统集成项目的总包商承接了 XX 市人力资源和社会保障局所委托的XX</span><br><span class="line">市基本臣疗保险门诊实时结算信息系统建设项目，我作为项目经理负责全程管理该项目，该项目的主要业务目标是建设</span><br><span class="line">覆盖全市 <span class="number">1800</span> 家臣保定点臣疗机构的门诊实时结算系统;在实施该项目过程中，项目在时间管理方面具有以下特点:项</span><br><span class="line">目业务功能复杂，涉及到 XX 市 <span class="number">1800</span> 家臣保定点臣疗机构和 <span class="number">1300</span> 万臣保参保人，同时该项目工期较长历时一年</span><br><span class="line">多，涉及的项目干系人众多，并目_项目属千 <span class="number">2009</span> 年 XX 市政府折子土程，要求必须在 <span class="number">2009</span> 年底完成。因而该项目</span><br><span class="line">的时间管理是项目成功的关键。</span><br><span class="line">在充分分析了该项目特点的基础上，在时间管理方面我对项目的所有活动通过活动分解进行了定义，使用前导图的方法</span><br><span class="line">对项目活动进行了排序，经过对项目活动的资源估算、项目活动历时估算并制订了项目进度计划，形成了项目进度甘特</span><br><span class="line">图，在项目执行过程中依据项目甘特图，进行项目绩效测量，根据绩效测量的结果以及通过项目进度变更控制系统对项</span><br><span class="line">目进度进行了很好的控制。在项目的各个里程碑阶段都很好地在确保项目质量和成本的基础上， 按照项目时间进度计</span><br><span class="line">划完成了项目。最终，在 <span class="number">2009</span> 年底由 XX 市政府正式宣布系统一次性上线成功。</span><br><span class="line">该项目在时间管理过程中还存在一些不足，例如在活动历时估算时我们还应该更多的安排预留时间，为项目风险做好时</span><br><span class="line">间方面的准备;在制订顷目进度计划时，我们还应该更多考</span><br><span class="line">虑资源平衡方面的问题，使项目资源得到更充分的利用;在进度控制阶段，我们在各个里程碑评审过程中还应该增加用</span><br><span class="line">户参与，与用户更好地进行项目进度沟通。争取在今后的项目管理过程中百尺竿头、更进一步。</span><br><span class="line"></span><br><span class="line">【正文】</span><br><span class="line"><span class="number">2008</span> 年 <span class="number">10</span> 月，XX 发展股份有限公司作为系统集成总承包商承接了 XX 市人力资源和社会保障局所委托的 XX 市基</span><br><span class="line">本臣疗保险门诊实时结算项目，我作为项目经理负责全程项日管理，并参与了业务需求讨论和系统分析等工作。该项目</span><br><span class="line">覆盖了全市 <span class="number">18</span> 个区县、<span class="number">1800</span> 家臣保定点臣疗机构和 <span class="number">1300</span> 万参保人。在参保人门诊就臣费用结算时，使用社保片实</span><br><span class="line">时计算臣保基金和个人支付金额，参保个人只需负担个人支付金额即可完成结算过程，将门诊费用报销支付时间由几个</span><br><span class="line">月缩短为儿秒钟，极大地方便了参保人。该项目从 <span class="number">2008</span> 年 <span class="number">10</span> 月开工，到<span class="number">2009</span> 年 <span class="number">12</span> 月验收结束，历时一年多，</span><br><span class="line">项目涉及 XX 市和 <span class="number">18</span> 区县人社局、<span class="number">1800</span> 家定点臣疗机构，项目干系人众多，项目业务需求内容繁多。由千项目属千 </span><br><span class="line">XX 市政府折子工程，项目时间进度要求必须在 <span class="number">2009</span> 年底完成，项目管理过程中的时间管理尤为重要，是项目是否成</span><br><span class="line">功的重要评价标准。在具体管理过程中，我根据项目实际情况，遵循时间管理的主要方法， 对项目活动进行了定义、</span><br><span class="line">排序，资源估算、历时估算并制订了项目进度计划，在项目执行过程中，通过项目进度变更控制系统对项目进度进行很</span><br><span class="line">好的控制，最终在既定的时间完成了所有项目工作，取得了良好的效果。<span class="number">2009</span> 年底由 XX 市政府正式宣布一次性上线</span><br><span class="line">成功，目前运行情况良好。</span><br><span class="line"></span><br><span class="line">一、活动定义</span><br><span class="line">首先，我们根据项目范围说明书以及项目的 WBS 对项目的所有活动进行了定义。我们将项目先进行了阶段定义，包括</span><br><span class="line">项目的需求获取、需求分析、系统设计、系统开发、系统测试、用户测试、系统试点、系统正式上线阶段，然后，我根</span><br><span class="line">据项目进展的不同阶段，采用滚动规划方法，将项目涉及到的所有活动逐步进行了定义。对千近期需要完成的工作在工</span><br><span class="line">作分解结构最下层详细规划，远期需要完成的工作则表现在工作分解结构相对高的层次上。通过滚动规划方式随着项目</span><br><span class="line">工作的开展，项目活动也逐层逐步清晰。</span><br><span class="line"></span><br><span class="line">二、活动排序</span><br><span class="line">根据活动定义，我将所有活动进行了排序，通过前导图的方法，将所有活动之间的依赖关系整理形成项目网络图。在此</span><br><span class="line">阶段中最重要的就是明确各个活动之间的依赖关系，例如在系统测试试阶段，我们通过与用户沟通，最终明确先进行我</span><br><span class="line">们公司内部的自测工作，然后由用户代表在公司的实验室环境下进行用户测试，最后再选择两家试点臣院在臣院实地环</span><br><span class="line">境下进行现场测试;而对千公司内部测试阶段，我们将臣院端系统与区县经办机构端的系统进行同步闭环测试。</span><br><span class="line"></span><br><span class="line">三、活动的资源估算</span><br><span class="line">为了做好所有项目活动在所需资源上面的准备工作，我们还对项目活动的资源进行了估算，通过自下而上的估算方法我</span><br><span class="line">们整理了整个项目所需要的相关资源。例如在测试阶段，我们针对所需要测试的系统数量、每个系统的测试人员数量，</span><br><span class="line">以及试点测试臣院的数量，我们估算了所需要测试用忱卡机具以及测试卡的数量，在系统测试之前要求机具和卡片提供</span><br><span class="line">商必须按时提供测试用的设各以保证测试工作的顺利进行。</span><br><span class="line"></span><br><span class="line">四、活动的历时估算</span><br><span class="line">对千活动历时估算我们使用了活动历时二点估算法，由千在系统开发过程中业务算法相对比较复杂，具体开发过程中可</span><br><span class="line">能会遇到很多不确定因素，为此，我要求项目人员估算了最乐观、最悲观以及最可能的时间的开发时间，使用三点估算</span><br><span class="line">法计算公式计算出项目活动的历时估算。例如对千系统测试工作，无法很准确地估算测试 bug 的修改时间，为此我要</span><br><span class="line">求测试人员进行了三点估算，最乐观的时间为 <span class="number">3</span> 周，最悲观的时间为 <span class="number">8</span> 周，最可能的时间为 G 周，通过三点估算公</span><br><span class="line">式计算出估算时间为 <span class="number">5.9</span> 周。通过使用三点估算法设置统计权重，运用统计规律降低了项目历时的不确定性。</span><br><span class="line"></span><br><span class="line">五、制订进度计划</span><br><span class="line">在前期时间管理工作的基础上，我制订了项目进度计划，通过项目甘特图全面反映了项目进度状况。在制订进度计划过</span><br><span class="line">程中，使用了关键路径法，根据各项目活动之间的依赖关系以及项目活动所使用的资源情况，我们分析并寻找了项目的</span><br><span class="line">关键活动，并形成了项目的关键路径。通过平衡与协调项目资源使用情况，最终制订了项目计划甘特图。为了使项目干</span><br><span class="line">系人都了解和掌握项目进度计划，我们还将项目计划甘特图印刷成册，形成了项目手册，下发给项目参与各方，得到了</span><br><span class="line">用户方以及项目监理方的好评。</span><br><span class="line"></span><br><span class="line">六、进度控制</span><br><span class="line">在项目执行过程中，每周各子项目组根据项目进展报告进行挣值分析，并形成项目跟踪甘特图，并与项目计划甘特图进</span><br><span class="line">行比对，如果发现有滞后现象则安排项目组进行赶工。每两周项目整体进行绩效测量通过挣值分析以及项目跟踪甘特图</span><br><span class="line">进行绩效评估。如果出现进度变更，则通过项目组以及公司两级进度变更控制系统进行变更评审。对千项目工作重大的</span><br><span class="line">变更则由项目监理公司主持召开项目监理会，与用户方和监理方共同沟通项目进度变更情况，对千批准的变更申请，在</span><br><span class="line">监理会后形成项目进度变更报告，发送项目相关各方。</span><br><span class="line">【结束语】</span><br><span class="line">在门诊实时结算项目管理过程中，我全面应用了项目时间管理的方法，使得该项目在时间管理方面较好地达到了预期目</span><br><span class="line">的，确保了 <span class="number">2009</span> 年底系统上线。鉴千我们在项目初期通过项目工作分解进行了活动定义，使用了前导图法对项目活动</span><br><span class="line">进行了排序，并使用了自下而上的估算方法对项目活动进行了资源估算，使用了项目历时三点估算法降低了历时估算的</span><br><span class="line">不确定性，最终形成项目进度计划，并在项目执行过程中很好地运用了绩效测量以及项目组与公司两级进度控制系统，</span><br><span class="line">对项目进度进行了控制，并且在项目监理方的组织下与用户进行了有效的沟通，最终确保了在 <span class="number">2009</span> 年底完成了项目所</span><br><span class="line">有工作，并由 XX 市政府正式宣布一次性上线成功。</span><br><span class="line">通过总结，对千项目在时一间管理方面我认为还存在一些不足:</span><br><span class="line">第一，在项目活动历时一估算时还应该更多的安排预留时间，为项目风险做好时间方面的准备。</span><br><span class="line">第二，在制订进度计划方面还应该更多考虑资源平衡方面的问题，使项目在确保时间进度不变的情况下更好地减少成</span><br><span class="line">本。</span><br><span class="line">第三，在项目执行过程中，各个里程碑评审过程还应该加强用户参与，在项目进度方面增加与用户的沟通。如果对千以</span><br><span class="line">上方面能够进行更好的总结与提高，在今后的项目管理过程中时间管理的水平将得到不断提高，真正达</span><br><span class="line">到“百尺竿头、更进一步”的目标。</span><br></pre></td></tr></table></figure><h3 id="3-5-模板"><a href="#3-5-模板" class="headerlink" title="3.5 模板"></a>3.5 模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">项目时间管理是项目管理的一个非常重要的环节，是项目管理的必要条件之一，是保障项目的有序的进行的基础，确保项目</span><br><span class="line">的持续发展的前提。因此，我从活动定义、活动排序、活动资源评估、活动历时评估、制定进度表和进度控制等六个方面对</span><br><span class="line">项目时间管理进行了把握。</span><br><span class="line"></span><br><span class="line">第一，活动定义。</span><br><span class="line">根据项目范围说明书、项目管理计划、组织过程资产等资料，我对整个项目进行活动定义。通过四个步骤控制账户、规划定</span><br><span class="line">义、工作包、活动对整个项目进行分解。通过滚动式规划对近期发生的工作进行详细分解，把分解活动放在工作分解结构的</span><br><span class="line">最下层。把远期发生的工作暂时放在工作分解结构的上层。根据整个项目情况，工作包分解成需求分析、概要设计、详细设</span><br><span class="line">计、系统编码、系统测试、系统培训、系统试运行、系统上线。然后在把每个工作包在进行详细分解成活动。例如系统测试</span><br><span class="line">分解成单元测试、整体测试、集成测试、安全测试、压力测试。定义好后列出活动清单及活动属性。</span><br><span class="line"></span><br><span class="line">第二，活动排序。</span><br><span class="line">活动排序是时间管理的第二个步骤。根据活动清单用前导图的方法对活动进行排序。例如系统编码工作中，某程序员负责基</span><br><span class="line">础信息采集的子系统的编码，他所进行的工作分解后，按照活动顺序依次为行政区采集的编码，户人口信息的采集编码、户</span><br><span class="line">成员基础信息采集编码、已婚育龄妇女基础信息的采集编码、已婚育龄妇女指纹接口对接的编码、手术人员基础信息的采集</span><br><span class="line">编码、新生儿基础信息的采集编码。</span><br><span class="line"></span><br><span class="line">第三，活动资源估算。</span><br><span class="line">活动资源估算是每个活动占用的资源进行估算。根据活动的资源估算汇总成工作包所占的资源估算。例如，编码的活动定义</span><br><span class="line">和排序完成以后，根据活动的数量及难易程度，判断开发这些活动所需的高级程序员以及普通程序员的人数，某某省某某市</span><br><span class="line">人口计划和生育系统需要<span class="number">4</span>个高级程序员和<span class="number">2</span>个普通程序员。</span><br><span class="line"></span><br><span class="line">第四，活动历时估算。</span><br><span class="line">活动历时估算是估算每个活动所占用的时间。根据活动开发的工作量的大小判断活动的时间。根据过去开发项目的经验，我</span><br><span class="line">对这次项目开发进行了估算。例如权限管理和用户管理功能因过去有开发项目的源代码，因此编码及单元测试的时间估算为</span><br><span class="line"><span class="number">2</span>天。</span><br><span class="line"></span><br><span class="line">第五，制定进度表。</span><br><span class="line">制定进度表是项目时间管理中关键的一环，因此根据前导图，通过关键路径法制定出真个个开发过程的时间。需求分析<span class="number">1</span>个</span><br><span class="line">月、系统设计<span class="number">1</span>个月、系统编码<span class="number">6</span>个月、系统测试<span class="number">1</span>个月、系统培训<span class="number">1</span>个月、系统试运行<span class="number">3</span>个月。因此从系统需求分析到系统正</span><br><span class="line">式上线的周期大概为<span class="number">1</span>年零<span class="number">1</span>个月。</span><br><span class="line"></span><br><span class="line">第六，进度控制。</span><br><span class="line">进度控制对于项目时间管理来说是非常重要的环节。根据项目实际开发的时间与进度表的时间的偏差进行计算，判断项目时</span><br><span class="line">间进展情况。在开发的过程中，由于统计报表管理中人口计划生育国统七张表的统计口径根据政策发生了变更，然后活动重</span><br><span class="line">新进行了定义排序估算，根据新的时间，开发周期将会超期。为此，我们利用赶工的方法，加班加点把统计报表子系统在预</span><br><span class="line">计的周期内完成。</span><br></pre></td></tr></table></figure><h2 id="四、成本管理"><a href="#四、成本管理" class="headerlink" title="四、成本管理"></a>四、成本管理</h2><h2 id="五、质量管理"><a href="#五、质量管理" class="headerlink" title="五、质量管理"></a>五、质量管理</h2><h2 id="六、人力资源管理"><a href="#六、人力资源管理" class="headerlink" title="六、人力资源管理"></a>六、人力资源管理</h2><h2 id="七、沟通管理"><a href="#七、沟通管理" class="headerlink" title="七、沟通管理"></a>七、沟通管理</h2><h2 id="八、风险管理"><a href="#八、风险管理" class="headerlink" title="八、风险管理"></a>八、风险管理</h2><h2 id="九、采购管理"><a href="#九、采购管理" class="headerlink" title="九、采购管理"></a>九、采购管理</h2><h2 id="十、干系人管理"><a href="#十、干系人管理" class="headerlink" title="十、干系人管理"></a>十、干系人管理</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;十大知识领域、五大项目管理过程组、47个过程&quot;&gt;&lt;a href=&quot;#十大知识领域、五大项目管理过程组、47个过程&quot; class=&quot;headerlink&quot; title=&quot;十大知识领域、五大项目管理过程组、47个过程&quot;&gt;&lt;/a&gt;十大知识领域、五大项目管理过程组、47个过程&lt;/h3&gt;&lt;p&gt;启动过程组 2个&lt;br&gt;规划过程组 24个&lt;br&gt;执行过程组 8个&lt;br&gt;监控过程组 11个&lt;br&gt;收尾过程组 2个&lt;/p&gt;
    
    </summary>
    
      <category term="考证" scheme="https://zzwwqq.xyz/categories/%E8%80%83%E8%AF%81/"/>
    
    
      <category term="信息系统项目管理师" scheme="https://zzwwqq.xyz/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
      <category term="论文" scheme="https://zzwwqq.xyz/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>信息系统项目管理师常考知识点</title>
    <link href="https://zzwwqq.xyz/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://zzwwqq.xyz/信息系统项目管理师常考知识点.html</id>
    <published>2019-04-13T03:24:19.000Z</published>
    <updated>2019-05-24T07:27:49.996Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.5.png" alt="5"></p><a id="more"></a><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.22.png" alt="22"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.23.png" alt="23"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.24.png" alt="24"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.25.png" alt="25"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.26.png" alt="26"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.27.png" alt="27"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.28.png" alt="28"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.29.png" alt="29"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.30.png" alt="30"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.31.png" alt="31"></p><h3 id="十大知识领域、五大项目管理过程组、47个过程"><a href="#十大知识领域、五大项目管理过程组、47个过程" class="headerlink" title="十大知识领域、五大项目管理过程组、47个过程"></a>十大知识领域、五大项目管理过程组、47个过程</h3><p><strong>启动过程组 2个 </strong><br>规划过程组 24个<br>执行过程组 8个<br>监控过程组 11个<br><strong>收尾过程组 2个</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.65.png" alt="65"></p><p><strong>项目管理过程组</strong> 与 <strong>知识领域</strong>：</p><table><thead><tr><th>序号</th><th>十大知识领域</th><th>启动过程组</th><th>规划过程组</th><th>执行过程组</th><th>监控过程组</th><th>收尾过程组</th></tr></thead><tbody><tr><td>1</td><td>项目整合管理</td><td>1. 制定项目章程</td><td>2. 制定项目管理计划</td><td>3. 指导与管理项目工作</td><td>4. 监控项目工作<br>5. 管理控制变更</td><td>6. 结束项目或阶段</td></tr><tr><td>2</td><td>项目范围管理</td><td></td><td>7. 规划范围管理<br>8. 收集需求<br>9. 定义范围<br>10. 创建WBS</td><td></td><td>11. 确认范围<br>12. 控制范围</td><td></td></tr><tr><td>3</td><td>项目时间管理</td><td></td><td>13. 规划进度管理<br>14. 定义活动<br>15. 排列活动顺序<br>16. 估算活动资源<br>17. 估算活动持续时间<br>18. 制定进度计划</td><td></td><td>19. 控制进度</td><td></td></tr><tr><td>4</td><td>项目成本管理</td><td></td><td>20. 规划成本管理<br>21. 估算成本<br>22. 制定预算</td><td></td><td>23. 控制成本</td><td></td></tr><tr><td>5</td><td>项目质量管理</td><td></td><td>24. 规划质量管理</td><td>25. 实施质量保证</td><td>26. 控制质量</td><td></td></tr><tr><td>6</td><td>项目人力资源管理</td><td></td><td>27. 规划人力资源管理</td><td>28. 组件项目团队<br>29. 建设项目团队<br>30. 管理项目团队</td><td></td><td></td></tr><tr><td>7</td><td>项目沟通管理</td><td></td><td>31. 规划沟通管理</td><td>32. 管理沟通</td><td>33. 控制沟通</td><td></td></tr><tr><td>8</td><td>项目风险管理</td><td></td><td>34. 规划风险管理<br>35. 识别风险<br>36. 实施定性风险分析<br>37. 实施定量风险分析<br>38. 规划风险应对</td><td></td><td>39. 控制风险</td><td></td></tr><tr><td>9</td><td>项目采购管理</td><td></td><td>40. 规划采购管理</td><td>41. 实施采购</td><td>42. 控制采购</td><td>43. 结束采购</td></tr><tr><td>10</td><td>项目干系人管理</td><td>44. 识别干系人</td><td>45. 规划干系人管理</td><td>46. 管理干系人参与</td><td>47. 控制干系人参与</td></tr></tbody></table><p>记忆技巧: </p><p>①: 只有两个启动过程组,两个收尾过程组————-&gt;启动过程组只位于 整体管理 和 项目干系人管理; 收尾过程组只位于  整体管理 和 采购管理</p><p>②: 范围,时间,成本,风险    <strong>没有</strong> 执行过程组(<strong>口诀: 范进成风无执行</strong>)</p><p>③: 人力资源管理 <strong>没有</strong> 监控过程组(<strong>口诀: 人力资源无监控</strong>)</p><p>范围管理——范 6<br>时间管理(又称进度管理)——进 7<br>整体管理——整 6<br>沟通管理——狗 3<br>质量管理——子 3<br>成本管理——成 4<br>人力资源管理 , 项目干系人管理——人 4,4<br>风险管理——风 6<br>采购管理——采 4</p><p><strong>口诀: 范进整狗子,成人风采.</strong></p><p><strong>对应的过程数:</strong>  <strong>676    3344    464</strong></p><p><strong>口诀: 两启两收先来记</strong></p><p><strong>口诀: 范进成风无执行</strong></p><p><strong>口诀: 人力资源无监控</strong></p><p><strong>范围管理口诀: </strong></p><ul><li>范围需要先<strong>收集</strong>，裁剪补充再<strong>定义</strong>；</li><li>拆分工作<strong>创WBS</strong>，审批输出一基准</li><li><strong>控制</strong>范围先<strong>确认</strong>.</li></ul><p><strong>进度管理口诀:</strong></p><ul><li>进度先要<strong>定</strong>活动，然后才能<strong>排顺序</strong>；</li><li><strong>资源</strong> <strong>时间</strong>要估算，这样才能<strong>制计划</strong>。</li></ul><p><strong>风险管理口诀:</strong></p><ul><li>风险<strong>识别</strong>要靠前，<strong>定性定量</strong>分析全；</li><li>已知未知要了解，这样才能来<strong>应对</strong>。</li></ul><h2 id="PMBOK五大过程组是什么？"><a href="#PMBOK五大过程组是什么？" class="headerlink" title="PMBOK五大过程组是什么？"></a>PMBOK五大过程组是什么？</h2><p>PMBOK五大过程组是：启动过程、规划过程、执行过程、监控过程、收尾过程。<br>各用一句话概括项目管理知识体系五大过程组：<br>1、启动过程组：作用是设定项目目标，让项目团队有事可做；<br>2、规划过程组：作用是制定工作路线，让项目团队“有法可依”；<br>3、执行过程组：作用是“按图索骥”，让项目团队“有法必依”；<br>4、监控过程组：作用是测量项目绩效，让项目团队“违法必究”，并且尽量做到“防患于未然”；<br>5、收尾过程组：作用是了结项目（阶段）“恩怨”，让一切圆满。</p><h2 id="PMBOK十大知识领域是什么？"><a href="#PMBOK十大知识领域是什么？" class="headerlink" title="PMBOK十大知识领域是什么？"></a>PMBOK十大知识领域是什么？</h2><p>PMBOK十大知识领域是：整合管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理、干系人管理。<br>各用一句话概括项目管理知识体系十大知识领域：<br>1、整合管理：其作用犹如项链中的那根线；<br>2、范围管理：做且只做该做的事；<br>3、时间管理：让一切按既定的进度进行；<br>4、成本管理：算准钱和花好钱；<br>5、质量管理：<strong>目的是满足需求</strong>；<br>6、人力资源管理：让团队成员高效率地和你一起干；<br>7、沟通管理：在合适的时间让合适的人通过合适的方式把合适的信息传达给合适的人；<br>8、风险管理：“无事找事”，从而让项目“无险事”；<br>9、采购管理：当好甲方；<br>10、干系人管理：和项目干系人搞好关系并令其满意。</p><h2 id="一、UML相关知识"><a href="#一、UML相关知识" class="headerlink" title="一、UML相关知识:"></a>一、UML相关知识:</h2><p>UML: 统一的建模语言(Unified Modeling Language),<strong>独立于软件开发过程</strong>,它<strong>不是可视化的程序设计语言</strong>而是一种<strong>可视化建模语言</strong></p><h3 id="1-1-五种结构视图"><a href="#1-1-五种结构视图" class="headerlink" title="1.1 五种结构视图:"></a>1.1 五种结构视图:</h3><p>①: 用例视图(用例图)</p><p>②: <strong>逻辑视图</strong>    (类图 / 对象图): 又称<strong>设计视图</strong>描述系统的功能需求,表示了设计模型中在架构方面具有重要意义的部分,即类,子系统,包和用例实现的自己.</p><!-- more --><p>③: 进程视图(协作图,状态图,序列图,活动图): 并发问题, 关注进程,线程,对象等运行时概念,及<strong>并发,同步,通信</strong></p><p>④: 实现视图(构件图): 描述软件结构</p><p>构件图: 描述各种软件构件之间的依赖关系,是一种说明了<strong>系统静态实现</strong>视图</p><p>⑤: 部署视图(部署图): 分布问题</p><p>部署图: 显示系统软硬件之间的物理架构, 是一种说明了<strong>系统体系结构的静态实施</strong>视图</p><p><strong>口诀: 用逻辑进程实现部署, 静态实现构件图</strong></p><h3 id="1-2-UML2-0-中的14种图"><a href="#1-2-UML2-0-中的14种图" class="headerlink" title="1.2  UML2.0 中的14种图"></a>1.2  UML2.0 中的14种图</h3><p><strong>静态视图: </strong></p><p>①: 部署图—&gt;部<br>②: 对象图—–&gt;队<br>③: 用例图——&gt;用<br>④: 包图——-&gt;包<br>⑤: 复合图(组合结构图)—-&gt;袱<br>⑥: 制品图: 描述系统的物理结构,制品包括文件,数据库等—-&gt;制品<br>⑦: 构件图—–&gt;够<br>⑧: 类图—–&gt;累</p><p><strong>口诀: 部队用包袱制品够累</strong></p><p><strong>动态视图: </strong></p><p>①: 活动图—–&gt;东</p><p>②: 顺序图—-&gt;西<br>也称顺序图,按照<strong>时间顺序</strong>描述<strong>对象间的交互</strong>,强调对象间消息发送的顺序,显示对象间动态的合作关系.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.99.png" alt="31"></p><p>②: 状态图—–&gt;装</p><p>④: 通信图(UML1.0中 称 协作图)—-&gt;信<br>描述<strong>对象间</strong>的<strong>交互</strong>和链接,显示对象间<strong>如何发送</strong>消息,其中顺序号指明消息的嵌套关系,和发生顺序.</p><p>⑤: 定时图: 是一种<strong>交互图</strong>,强调消息跨越不同对象或参与者的实际时间,而不仅仅只是关心消息的相对顺序.—–&gt;是<br>⑥: 交互概览图(活动图和顺序图的混合物)—-&gt;交互</p><p><strong>口诀: 东西装信是交互</strong></p><h3 id="1-3-类之间的关系"><a href="#1-3-类之间的关系" class="headerlink" title="1.3 类之间的关系"></a>1.3 类之间的关系</h3><p>四种:<br>①: 关联(组合,聚合)<br>②: 泛化<br>③: 依赖<br>④: 实现</p><p><strong>【组合关系】：是整体与部分的关系</strong>，但<strong>部分不能离开整体而单独存在</strong>。如公司和部门是整体和部分的关系，没有公司就不存在部门,鸟和翅膀的关系</p><p><strong>口诀: 鸟翅组合强关联,相依为命同根生</strong></p><p><strong>【聚合关系】：是整体与部分的关系</strong>，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p><h3 id="1-4-用例图"><a href="#1-4-用例图" class="headerlink" title="1.4 用例图:"></a>1.4 用例图:</h3><p>从<strong>用户的角度</strong>描述系统功能,描述的是系统<strong>用户与系统</strong>,<strong>系统与外部系统的交互</strong>,是<strong>开发者与用户交流的工具.</strong></p><p>用例是系统的一个<strong>功能单元</strong></p><h4 id="1-4-1-用例图中用例之间的关系"><a href="#1-4-1-用例图中用例之间的关系" class="headerlink" title="1.4.1 用例图中用例之间的关系:"></a>1.4.1 用例图中用例之间的关系:</h4><p>①: 关联(association)<br>②: 泛化(generialize)关系.<br>③: <strong>包含include(或使用User)</strong><br>④: <strong>扩展(extends)</strong></p><p><strong>口诀: 类与用例两不同,包含扩展类中无</strong></p><h2 id="二、计算机组成原理相关"><a href="#二、计算机组成原理相关" class="headerlink" title="二、计算机组成原理相关"></a>二、计算机组成原理相关</h2><h3 id="2-1-关于总线"><a href="#2-1-关于总线" class="headerlink" title="2.1 关于总线:"></a>2.1 关于总线:</h3><p>总线: 计算机中<strong>各个部件相连</strong>的通信线,</p><h4 id="2-1-1-总线分以下4类"><a href="#2-1-1-总线分以下4类" class="headerlink" title="2.1.1 总线分以下4类:"></a>2.1.1 总线分以下4类:</h4><p>①: 中央处理器内部总线</p><p>寄存器与寄存器, 寄存器与运算器</p><p>②: 部件内总线</p><p>一块插卡的内部总线(片级总线), 如显卡,多功能卡等插卡都使用了~实现本卡上各芯片互联</p><p>③: 系统总线</p><p>各个功能部件(中央处理器,存储器,外设)之间互连的总线.</p><p>分为: 数据总线 ,地址总线 , 控制总线</p><p>④: 外部总线</p><p>计算机系统之间,或者是计算机和其他设备</p><h3 id="2-2-Cache"><a href="#2-2-Cache" class="headerlink" title="2.2 Cache:"></a>2.2 Cache:</h3><p>高速缓冲存储器,介于中央处理器和主存之间.</p><p>如果不命中则从主存中取出需要的块,同时送往CPU 和 Cache</p><p><strong>写回法: </strong>先写cache,并用标志位加以说明,直至经过重写的字块被从cache中替换出来时再写入主存</p><h2 id="三、信息系统"><a href="#三、信息系统" class="headerlink" title="三、信息系统:"></a>三、信息系统:</h2><p>一般指采集,处理,分析,存储,传输,检索信息的具有完整功能的集合体.</p><h3 id="3-1-信息库"><a href="#3-1-信息库" class="headerlink" title="3.1 信息库"></a>3.1 信息库</h3><p>存储大量数据,文档的资料库</p><p>包含内容:<br>①: 网络目录(存放了电子表格软件,项目信件和数据等)<br>②: 打印的文档<br>③: 一个或多个Case工具目录<br>②: 到上述组织的<strong>内联网网站接口</strong></p><h3 id="3-2-ERP"><a href="#3-2-ERP" class="headerlink" title="3.2 ERP"></a>3.2 ERP</h3><p>ERP: <strong>是一个软件</strong><br><strong>ERP项目: 管理变革项目</strong>,不像传统财务核算软件,只是替代用户的手工业务</p><p><strong>ERP强调 事前计划,事中控制,事后分析</strong>的管理理念和<strong>及时调整</strong>的管理策略—–<strong>前计中控后分析</strong></p><p>财务软件 强调 事后核算.</p><h3 id="3-3-建立企业信息系统原则"><a href="#3-3-建立企业信息系统原则" class="headerlink" title="3.3 建立企业信息系统原则:"></a>3.3 建立企业信息系统原则:</h3><p>自上而下的<strong>规划</strong>, 自下而上的分布<strong>实现</strong></p><h3 id="3-4-计算机的数据环境类型"><a href="#3-4-计算机的数据环境类型" class="headerlink" title="3.4 计算机的数据环境类型:"></a>3.4 计算机的数据环境类型:</h3><p>按照管理层次从低到高排列: <strong>数据文件—&gt;应用数据库—&gt;主题数据库—-&gt;信息检索数据库</strong></p><h3 id="3-5-总监理工程师代表-不能拥有的职权"><a href="#3-5-总监理工程师代表-不能拥有的职权" class="headerlink" title="3.5 总监理工程师代表 不能拥有的职权:"></a>3.5 总监理工程师代表 不能拥有的职权:</h3><p>①: 不能主持编写项目监理<strong>规划</strong><br>②: 不能签发工程<strong>开工</strong>报审表,工程<strong>竣工</strong>监理报告, 工程款<strong>支付</strong>证书<br>③: 不能调解<strong>合同</strong>争议,处理<strong>索赔</strong>,审批工程延期<br>④: 不能<strong>调换人员</strong><br><strong>总结: 不能拥有与规划,开工,支付,索赔,人员,相关的职权</strong></p><h3 id="3-6-WebService协议和技术"><a href="#3-6-WebService协议和技术" class="headerlink" title="3.6 WebService协议和技术:"></a>3.6 WebService协议和技术:</h3><p>WebService体系结构是一种<strong>面向服务</strong>的体系结构(SOA),这种体系结构设置了<strong>3个角色和3种操作.</strong></p><p>简单说就是 一种跨编程语言和操作系统平台的远程调用技术.</p><p>XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术.</p><p><strong>3个角色: </strong>服务提供者、服务请求者、服务注册中心(服务提供者在这里发布他们的服务描述)<br><strong>3种操作: </strong> <strong>发布</strong>服务描述、<strong>查询</strong>或查找服务描述、根据服务描述绑定或<strong>调用</strong>服务.</p><p>①: <strong>XML</strong> : 是WebService平台中表示<strong>数据的基本格式.</strong></p><p>②: <strong>SOAP:</strong> Simple Object Access Protocol <strong>简单对象访问协议</strong>, 实现系统间能用<strong>“软件-软件对话</strong>的方式相互调用”,打破了软件应用,网站,和各种设备之间格格不入的状态,实现<strong>基于Web无缝集成</strong>的目标</p><p>③: <strong>UDDI: </strong> 是一种<strong>规范</strong>,提供基于<strong>Web服务的注册</strong>和发现机制,目的是为电子商务建立标准.</p><p>UDDI它为Web服务提供3个重要的技术支持:</p><ul><li>①: 标准,透明,专门<strong>描述</strong>Web服务的机制</li><li>②: <strong>调用</strong>Web服务</li><li>③: <strong>访问</strong>Web服务注册中心</li></ul><h3 id="3-7-网络接入技术"><a href="#3-7-网络接入技术" class="headerlink" title="3.7 网络接入技术"></a>3.7 网络接入技术</h3><p>广义上说<strong>跟网络接入相关的都可以算是网络接入技术,</strong>如: LAN方式,拨号接入方式,DSL方式,光纤接入,Cabel Modem线缆调制解调器接入,IEEE802.11 无线局域网接入,GPRS和3G,HFC,XDSL,DDN,PSTN,ISDN</p><p>①: <strong>HFC: </strong>Hybrid Fiber Coaxial 混合光纤同轴电缆网,经济实用的综合数字服务宽带网接入技术,光纤干线,同轴电缆,用户配线网络三部分组成,有线电视台出来的节目信号,先变成光信号在干线上传输,到用户区后把光信号转为电信号,经过分配器分配后通过同轴电缆送到用户.</p><p>②:  <strong>XDSL :</strong>数字用户线路 (Digital Subscribe  Line)是各种DSL的总称,如ADSL,VDSL,SDSL等</p><ul><li>ADSL: Asymmetric Digital Subscribe  Line 非对称数字用户环路.所谓<strong>非对称指的是上行和下行带宽不对称.</strong></li><li>VDSL: Very Speed Digital Subscriber Line 超高速数字用户线路</li><li>CDMA: Code Division Multiple Access 码分多址</li></ul><p>③: <strong>DDN: </strong> (Digital  Data NetWork)<strong>专线上网方式</strong>,传输速率高,质量好,延时小等特点,将数万或数十万条光缆为主体的数字电路,通过数字电路管理设备构成的<strong>数据传输基础网络.</strong></p><p>注: <strong>NetBEUI: 不属于网络接入技术,它用于本地局域网</strong>,不能与其他网络的计算机进行沟通</p><h3 id="3-8-数据仓库"><a href="#3-8-数据仓库" class="headerlink" title="3.8 数据仓库"></a>3.8 数据仓库</h3><p>数据仓库的<strong>用户为管理层</strong>,它的<strong>数据随业务持续增长</strong>.</p><p>面向主题的,<strong>集成的</strong>,相对稳定的反映历史变化的<strong>数据集合</strong>,<strong>用于支持管理决策</strong></p><p>是对多个异构数据源(包括历史数据)的有效集成,集成后按照主题重组,<strong>其中的数据一般不再修改,且数据随业务持续增长.</strong></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.150.png" alt="150"></p><h3 id="3-9-SAN-存储区域网络"><a href="#3-9-SAN-存储区域网络" class="headerlink" title="3.9 SAN(存储区域网络)"></a>3.9 SAN(存储区域网络)</h3><p>包括FCSAN 和 IPSAN</p><p>FCSAN 使用数据传输协议中的 <strong>FiberChannel</strong>(FC: 一种高速网络技术标准,千兆位数据传输的技术标准)</p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.152.png" alt="152"></p><h3 id="3-10-ISCSI"><a href="#3-10-ISCSI" class="headerlink" title="3.10 ISCSI"></a>3.10 ISCSI</h3><p>Internet Small Computer System Interface, 它基于TCP/IP协议</p><h3 id="3-11-信息化项目监理"><a href="#3-11-信息化项目监理" class="headerlink" title="3.11 信息化项目监理"></a>3.11 信息化项目监理</h3><p>分三种:</p><p>①: 咨询式监理</p><p>②: 里程碑式监理</p><p>③: 全程式监理</p><h3 id="3-12-软件构件-软件中间件-的标准"><a href="#3-12-软件构件-软件中间件-的标准" class="headerlink" title="3.12 软件构件(软件中间件)的标准:"></a>3.12 软件构件(软件中间件)的标准:</h3><p>①: OMG组织(对象管理组织)提出的<strong>CORBA</strong></p><p>为解决<strong>分布式</strong>处理环境中<strong>软硬件的互连</strong>而提出.</p><p>②: 微软提出的<strong>COM</strong></p><p><strong>组件架构**</strong></p><p>③: SUN提出的<strong>EJB: </strong></p><p>用于<strong>封装业务,</strong> <strong>中间层业务功能由EJB构件实现,</strong>JSP用于实现业务逻辑处理结果的动态发布,构成动态的HTML页面,中间层也可用servlet实现更为灵活的动态页面.</p><h3 id="3-13-信息系统工程监理活动主要内容"><a href="#3-13-信息系统工程监理活动主要内容" class="headerlink" title="3.13 信息系统工程监理活动主要内容::"></a>3.13 信息系统工程监理活动主要内容::</h3><p><strong>四控,三管,一协调.</strong></p><p><strong>四控: </strong><br>信息系统工程的<strong>质量控制</strong><br><strong>进度</strong>控制<br><strong>投资</strong>控制<br><strong>变更</strong>控制</p><p><strong>三管:</strong></p><p>信息系统工程的<strong>合同管理</strong><br><strong>信息</strong>管理<br><strong>安全</strong>管理</p><p><strong>一协调: </strong></p><p>协调有关单位间的工作关系.</p><h3 id="3-14-监理文件"><a href="#3-14-监理文件" class="headerlink" title="3.14 监理文件"></a>3.14 监理文件</h3><h4 id="3-14-1-监理规划"><a href="#3-14-1-监理规划" class="headerlink" title="3.14.1 监理规划"></a>3.14.1 监理规划</h4><p>在监理委托合同签订后,由<strong>总监理工程师主持编写</strong>,监理单位技术负责人书面批准的<strong>指导监理开展工作</strong>的纲领性文件</p><p>作用:</p><p>①: 监理项目部<strong>职能</strong>的具体体现<br>②: <strong>指导</strong>监理项目部开展工作<br>③: <strong>信息系统工程监理管理部门</strong>进行<strong>监督</strong> <strong>监理单位</strong>的主要内容和依据<br>④: <strong>建设单位</strong> <strong>检查</strong> <strong>监理单位</strong>是否能认真,全面履行信息系统工程监理委托合同的重要依据</p><h4 id="3-14-2-监理实施细则"><a href="#3-14-2-监理实施细则" class="headerlink" title="3.14.2 监理实施细则"></a>3.14.2 监理实施细则</h4><p>在监理规划指导下,由专业监理工程师针对项目具体情况制定的更具有可实施,可操作的业务性文件,<strong>指导具体监理业务的开展.</strong></p><h4 id="3-14-3-监理大纲"><a href="#3-14-3-监理大纲" class="headerlink" title="3.14.3 监理大纲 :"></a>3.14.3 监理大纲 :</h4><p>是社会监理单位为了获得监理任务,在<strong>投标前</strong>由<strong>监理单位编制</strong>的项目监理方案性文件,是<strong>投标书</strong>的重要组成部分,</p><h3 id="3-16-进度控制"><a href="#3-16-进度控制" class="headerlink" title="3.16 进度控制"></a>3.16 进度控制</h3><p>技术手段:<br>①: 甘特图<br>②: 网络图<br>单代号网络图: 箭头是关系, 结点是活动<br>双代号网络图: 箭头是活动, 结点是事件.<br>③: 香蕉 曲线图法<br>两条S型曲线组合而成的闭合曲线:<br><strong>ES曲线</strong>是: 计划以各项工作的<strong>最早开始</strong>时间安排进度而绘制<br><strong>LS曲线</strong>是: 计划以各项工作的<strong>最迟开始</strong>时间安排进度而绘制<br>ES各点均在LS各点的左边,ES和LS起点和终点相同,所以ES与LS围成的图形像香蕉.</p><p><strong>注: ABC分析法:帕累托分析法,把分析的对象分成A,B,C三类,从而有区别地确定管理方式</strong></p><h3 id="3-17-旁站监理"><a href="#3-17-旁站监理" class="headerlink" title="3.17 旁站监理:"></a>3.17 旁站监理:</h3><p>是监理单位<strong>控制工程质量</strong>的重要手段,主要在<strong>关键部位或关键工序</strong>施工过程中,由监理人员在现场进行的<strong>监督活动.</strong><br>网络综合布线,设备开箱检验,机房建设等活动涉及隐蔽工程,需要进行旁站监理,确保这些活动的过程质量.</p><h3 id="3-18-信息系统常用开发方法"><a href="#3-18-信息系统常用开发方法" class="headerlink" title="3.18 信息系统常用开发方法:"></a>3.18 信息系统常用开发方法:</h3><p>①: 结构化方法</p><blockquote><p>三部分组成: 结构化方法.结构化设计,结构化程序设计.</p><p>基本思想: <strong>用户至上</strong>(开发人员始终与用户保持联系),<strong>自顶向下</strong>设计,<strong>自底向上</strong>逐步实现,<strong>模块化设计</strong></p><p>按照信息系统生命周期,应用结构化系统开发方法,将整个系统<strong>开发过程分为若干阶段,</strong>然后<strong>一步一步依次进行</strong>,前一阶段是后一阶段的依据.</p><p>包括数据流的分析方法: 数据流图,数据字典</p><p>缺点: 开发周期长, 难以适应需求变化,不适合开发大规模的复杂的系统</p></blockquote><p>②: 原型方法</p><blockquote><p><strong>需求不清, 快速开发</strong>一个原型系统, 通过反复修改来实现最终系统需求</p></blockquote><p>③: 面向对象方法OO</p><blockquote><p>面向对象法分三个阶段:</p><p><strong>分析:</strong></p><p>分析模型由 用例模型,类-对象模型,对象-关系模型,对象-行为模型组成.</p><p><strong>设计</strong></p><p>概要设计(软件基础架构),详细设计(完整的类架构)</p><p>主要是类设计,用例设计,子系统设计</p><p><strong>实现</strong></p></blockquote><p>④: 面向服务的方法SO</p><blockquote><p>跨构件的功能调用,进一步将接口定义和实现解耦,使信息系统<strong>快速响应需求与环境变化</strong></p></blockquote><h3 id="3-19-信息系统的生命周期"><a href="#3-19-信息系统的生命周期" class="headerlink" title="3.19 信息系统的生命周期:"></a>3.19 信息系统的生命周期:</h3><h4 id="3-19-1-项目的生命周期分四个阶段"><a href="#3-19-1-项目的生命周期分四个阶段" class="headerlink" title="3.19.1 项目的生命周期分四个阶段:"></a>3.19.1 项目的生命周期分四个阶段:</h4><p>①: 启动<br>②: 计划<br>③: 执行<br>④: 收尾</p><h4 id="3-19-2-信息系统的生命周期分四个阶段"><a href="#3-19-2-信息系统的生命周期分四个阶段" class="headerlink" title="3.19.2 信息系统的生命周期分四个阶段:"></a>3.19.2 信息系统的生命周期分四个阶段:</h4><p>①: 立项<br>②: 开发<br>③: 运维<br>④: 消亡</p><p><strong>开发阶段细分为5个阶段</strong></p><p>划——总体规划阶段<br>分——系统分析阶段<br>即——系统设计阶段<br>实——系统实施阶段<br>验——系统验收阶段 </p><p><strong>口诀: 划分即实验</strong></p><p>①: 系统规划阶段 (初步调查,可行性分析和项目开发计划)———-&gt;划</p><blockquote><p>做<strong>系统调查和可行性分析</strong></p><p>对现行系统的状况进行<strong>初步调查,</strong>研究建设新系统的<strong>必要性和可能性</strong>,拟定系统的备选方案,对这些方案进行<strong>可行性研究</strong>,写出可行性研究报告,可行性研究报告<strong>审议</strong>通过后,将新系统建设方案及实施计划编写成<strong>系统设计任务书</strong></p><p>可行性研究: 操作可行性,技术可行性,经济可行性.</p><p><strong>经济可行性分析: </strong> 包括 支出分析, 收益分析, 收益投资比, 投资回收期,<strong>敏感性分析.</strong> </p><p>该阶段最终形成<strong>可行性研究报告</strong> <strong>系统设计任务书</strong></p><p>可行性研究方法: 经济评价法,市场预测法,投资估算法,增量净收益法等.</p></blockquote><p>②: 系统分析阶段(需求分析) 又称逻辑设计阶段——–做什么———&gt;分</p><blockquote><p>根据<strong>系统设计任务书所确定的范围</strong>,对<strong>现行系统</strong>进行<strong>详细调查</strong>,描述缺陷和不足,然后确定<strong>新系统的目标和逻辑功能.</strong></p><p>为设计阶段提供<strong>新系统的逻辑模型</strong>,内容包括组织结构及功能分析,业务流程分析,<strong>数据和数据流程分析</strong><br><strong>数据流图DFD</strong></p><p>系统说明书: 既是给用户看的,也是下一阶段的工作依据,也是将来验收系统的依据,用户通过它了解未来系统的功能,判断是否为要求的系统</p><p>该阶段最终形成<strong>系统说明书</strong></p></blockquote><p>③: 系统设计阶段(概要设计,详细设计)————-怎么做——–&gt;即</p><blockquote><p>根据系统说明书中规定的功能要求,考虑实际条件,具体设计<strong>实现逻辑模型</strong>的技术方案.</p><p>系统架构设计,数据库设计,功能模块设计,安全控制方案设计等</p><p><strong>E-R图</strong>描述现实世界概念模型,用于数据库设计</p></blockquote><p>④: 系统实施阶段(编码,测试)——-&gt;实</p><blockquote><p>将设计的系统付诸实施,这一阶段包括 计算机等设备的购置,安装和调试,程序的编写和调试,人员培训,系统调试等<br>系统实施按实施计划分阶段完成,每阶段写出实施进展报告,系统测试后写出系统测试分析报告.</p><p>该阶段最终形成<strong>实施进展报告,系统测试分析报告</strong></p></blockquote><p>⑤: 系统维护阶段(或验收运行维护)———&gt;验</p><p><strong>口诀: 划分即实验</strong></p><p><strong>易错点: </strong></p><p><strong>①: 规划阶段产生 系统设计任务书</strong> 而不是设计阶段产生</p><p>②: <strong>分析阶段 产生 逻辑模型</strong>,<strong>设计阶段来实现</strong>, 而不是实施阶段来实现.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.43.png" alt="43"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.44.png" alt="44"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.45.png" alt="45"></p><h3 id="3-20-企业中信息系统的分类"><a href="#3-20-企业中信息系统的分类" class="headerlink" title="3.20 企业中信息系统的分类:"></a>3.20 企业中信息系统的分类:</h3><h3 id="3-20-1-根据服务对象而言分为"><a href="#3-20-1-根据服务对象而言分为" class="headerlink" title="3.20.1 根据服务对象而言分为:"></a>3.20.1 根据服务对象而言分为:</h3><p>①:  面向作业处理:</p><ul><li>OA办公自动化系统,DAMS<strong>数据采集与监测*</strong>系统</li></ul><p>②: 面向管理控制</p><ul><li>KM知识管理系统,CIMS计算机<strong>集成制造</strong>系统</li></ul><p>③: 面向决策计划</p><ul><li>MES<strong>管理专家系统,</strong>DSS决策支持系统,SIS战略信息系统</li></ul><h3 id="3-21-网络存储"><a href="#3-21-网络存储" class="headerlink" title="3.21: 网络存储"></a>3.21: 网络存储</h3><h4 id="3-21-1-现有存储的三大模式"><a href="#3-21-1-现有存储的三大模式" class="headerlink" title="3.21.1 现有存储的三大模式:"></a>3.21.1 现有存储的三大模式:</h4><p>①: 直接附加存储DAS,不带任何存储操作系统</p><p>②: 网络附加存储NAS(NetWork Attached Storage: ) </p><p>是将存储设备通过标准的网络拓扑结构(如以太网)连接到一系列计算机上. 它是一种专用的数据存储服务器,它以数据为中心,将存储设备和服务器彻底分开,NAS在网络中独立的设备,分配IP地址,通过网络来访问和存取.</p><ul><li><strong>支持多种TCP/IP协议</strong>,支持<strong>即插即用</strong>,类似于文件服务器</li></ul><p>③: 存储区域网络</p><p>SAN :<strong>易扩展</strong>的存储技术</p><p>注: <strong>哈希散列表存储:</strong> <strong>不是网络存储结构, </strong> 它是根据<strong>关键码值而直接进行访问</strong>的数据结构(也就是把关键码值映射到表中一个位置来访问记录,以加快查找速度)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.41.png" alt="41"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.42.png" alt="42"></p><h3 id="3-22-NET"><a href="#3-22-NET" class="headerlink" title="3.22 .NET"></a>3.22 .NET</h3><p>一般的高级程序语言(C#,VB)会直接将代码编译为机器语言,<br>而<strong>编译.NET是不同的,多了一个环节,就是先将高级语言编译成为中间语言(IL)</strong>,中间语言最终编译为机器代码.<br>这些中间语言是.NET框架中所有语言编译后的结果,比如C#,VB语言编写的两个类,编译后中间语言看起来一样,这就显示了.NET跨平台的事实.</p><h3 id="3-23-常见产品与语言"><a href="#3-23-常见产品与语言" class="headerlink" title="3.23 常见产品与语言:"></a>3.23 常见产品与语言:</h3><p>.NET Framework —&gt;可用于C#,C++,VB<br>WASP是web应用框架—–&gt;使用PHP5开发<br>DelPhi是集成开发环境IDE—-&gt;使用Pascal<br>GLUE是一种java扩展包</p><h3 id="3-24-CRM"><a href="#3-24-CRM" class="headerlink" title="3.24 CRM"></a>3.24 CRM</h3><p>是集成化的<strong>信息管理系统,</strong> <strong>存储了企业现有和潜在客户的信息</strong>,并且对这些信息进行<strong>自动的处理</strong>从而产生更人性化的市场管理策略.</p><p>它是<strong>以客户为中心</strong>的商业策略,而不是传统的以产品或市场为中心<br>将业务中心转移到客户,根据<strong>不同的客户有重点的采取不同的策略</strong></p><h3 id="3-25-工作流"><a href="#3-25-工作流" class="headerlink" title="3.25 工作流"></a>3.25 工作流</h3><p>工作流技术<strong>不是开发过程管理</strong>的技术,所以它<strong>不能提升开发过程的灵活性</strong></p><p>主要提供业务流程建模,管理,控制功能.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.141.png" alt="141"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.142.png" alt="142"></p><h3 id="3-26-2G-3G-4G标准"><a href="#3-26-2G-3G-4G标准" class="headerlink" title="3.26  2G/3G/4G标准"></a>3.26  2G/3G/4G标准</h3><p>GSM 是2G标准</p><p>GPRS是2G移动数据业务</p><p>四种国际3G标准: WCDMA,CDMA2000,WinMAX,<strong>TD-SCDMA(时同步码分多址,由中国自主研发) </strong></p><p>LTE是4G标准</p><h3 id="3-27-电子商务"><a href="#3-27-电子商务" class="headerlink" title="3.27 电子商务:"></a>3.27 电子商务:</h3><p>原始电子商务: 使用电子信息技术工具进行商务活动<br>凡使用诸如电报,电话,广播,点水,传真以及计算机,计算机网络等手段,工具进行商务活动,都可称之为电子商务.</p><h4 id="3-27-1-第四方物流"><a href="#3-27-1-第四方物流" class="headerlink" title="3.27.1 第四方物流"></a>3.27.1 第四方物流</h4><p>为第一,二,三方提供物流规划,咨询,物流信息系统,供应链管理等活动.它是一个供应链的集成商,是<strong>供需双方及第三方物流的领导力量.</strong></p><h4 id="3-27-2-第三方物流"><a href="#3-27-2-第三方物流" class="headerlink" title="3.27.2 第三方物流:"></a>3.27.2 第三方物流:</h4><p>生产经营企业为集中搞好业主,把原来属于自己处理的物流活动,<strong>以合同方式委托给专业物流服务企业</strong>,同时提供信息系统与物流企业保持密切联系,以达到对物流全程管理控制的一种物流运作和管理方式.</p><h3 id="3-28-经济计量分析"><a href="#3-28-经济计量分析" class="headerlink" title="3.28 经济计量分析:"></a>3.28 经济计量分析:</h3><p>工作程序顺序:<br><strong>设定</strong>模型—&gt;<strong>估计</strong>参数—&gt;<strong>检验</strong>模型—&gt;应用模型</p><h3 id="3-29-关于GCC"><a href="#3-29-关于GCC" class="headerlink" title="3.29 关于GCC"></a>3.29 关于GCC</h3><p>GNU Compiler Collection , 即GNU编译器套件 ,  它是以GPL许可证所发行的自由软件,也是GNU计划的关键部分.</p><h3 id="3-30-文件审批流程"><a href="#3-30-文件审批流程" class="headerlink" title="3.30 文件审批流程"></a>3.30 文件审批流程</h3><p><strong>承建方</strong>提交的&lt;&lt;项目质量管理计划&gt;&gt;先由<strong>建设方</strong>技术总监对内容,范围审核后,再送交<strong>监理方</strong>批准</p><h3 id="3-31-关于监理"><a href="#3-31-关于监理" class="headerlink" title="3.31 关于监理"></a>3.31 关于监理</h3><p>①: 当<strong>专业监理工程师需要调整时</strong>,<strong>总监理工程师应该</strong>  <strong>书面通知</strong> <strong>建设单位和承包单位.</strong></p><p>②: 当<strong>总监理工程师需要调整时</strong>,<strong>监理单位应该</strong>征得建设单位同意并书面通知建设单位</p><p><strong>监理单位</strong>应该于委托监理合同签订后<strong>10个工作日内</strong>将监理项目部的组织形式,人员构成及对总监理工程师的任命书书面形式通知<strong>建设单位.</strong></p><p><strong>建设单位</strong>应该将委托的监理单位,监理内容,<strong>书面通知承建单位.</strong></p><h3 id="3-32-企业信息化结构"><a href="#3-32-企业信息化结构" class="headerlink" title="3.32 企业信息化结构"></a>3.32 企业信息化结构</h3><p>分类:</p><p>①: 产品层<br>②: 作业层<br>③: 管理层<br>④: 决策层</p><h3 id="3-33-云计算"><a href="#3-33-云计算" class="headerlink" title="3.33 云计算"></a>3.33 云计算</h3><p>是一种服务<br>关键技术:<br>虚拟化 : 是一种资源管理技术,  包括<strong>服务器虚拟化 和 应用虚拟化</strong><br>分布式系统: <strong>分布式存储  和 分布式计算</strong></p><h3 id="3-34-操作系统安全"><a href="#3-34-操作系统安全" class="headerlink" title="3.34 操作系统安全"></a>3.34 操作系统安全</h3><p>①: 切断: </p><p>可用性的威胁: 如非法用户破坏硬盘,破坏系统资源等</p><p>②: 截取</p><p>机密性的威胁:非法窃取和拷贝文件等</p><p>③: 篡改</p><p>完整性的威胁,非法用户修改网络中正在传送的消息等</p><p>④: 伪造</p><p>合法性的威胁,如非法用户把伪造的消息插入系统中等</p><p><strong>口诀: 切可用,截机密,篡完整,伪合法</strong> </p><h3 id="3-35-信息安全"><a href="#3-35-信息安全" class="headerlink" title="3.35 信息安全:"></a>3.35 信息安全:</h3><p>①: 设备安全: 是信息系统安全的<strong>首要问题</strong>,<strong>稳定,可靠,可用性</strong></p><p>②: 数据安全: <strong>秘密,完整,可用性</strong></p><p>③: 内容安全: <strong>政治,法律,道德层次</strong></p><p>④: 行为安全</p><p>⑤: 物理安全: 机房出入口应该安排专人值守,控制,鉴别和记录进入的人员.</p><p><strong>注: 不包括人员安全</strong></p><h3 id="3-36-物联网"><a href="#3-36-物联网" class="headerlink" title="3.36 物联网"></a>3.36 物联网</h3><p>两项关键技术:</p><p>①: 传感器技术: 感受被测量的信息,将模拟信号转换为</p><p><strong>②: 嵌入式技术</strong></p><h3 id="3-37-智能-特点"><a href="#3-37-智能-特点" class="headerlink" title="3.37 智能  特点"></a>3.37 智能  特点</h3><p>①: 感知能力</p><p>②: <strong>记忆,思维能力</strong>: 能<strong>存储</strong>感知到的外部信息,及由思维产生的知识,同时能利用已有的知识对信息进行<strong>分析、计算、比较、判断、联想、决策</strong>.</p><p>③: <strong>学习,自适应能力</strong>: 通过与环境的相互作用,不断<strong>学习</strong>积累知识,使自己能<strong>适应环境.</strong></p><p>④: 行为决策能力</p><p><strong>注: 思维能力 和 学习能力自适应能力概念容易混淆, 所以 只要记住 出现 学习和自适应就是学习自适应能力 </strong></p><h3 id="3-38-区块链"><a href="#3-38-区块链" class="headerlink" title="3.38 区块链:"></a>3.38 区块链:</h3><h4 id="3-38-1-定义"><a href="#3-38-1-定义" class="headerlink" title="3.38.1 定义:"></a>3.38.1 定义:</h4><p>是<strong>分布式数据存储</strong> 、点对点传输、共识机制、机密算法等计算机技术的新型应用机制.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.46.png" alt="46"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.47.png" alt="47"></p><h4 id="3-38-2-区块链2-0-技术架构自下而上分为"><a href="#3-38-2-区块链2-0-技术架构自下而上分为" class="headerlink" title="3.38.2 区块链2.0 技术架构自下而上分为"></a>3.38.2 区块链2.0 技术架构自下而上分为</h4><p>数据层: </p><p>网络层: 包括 P2P组网机制, 数据传播机制,数据验证机制</p><p>共识层:</p><p>激励层:</p><p>智能合约层: </p><h3 id="3-39-IaaS-、PaaS-、SaaS"><a href="#3-39-IaaS-、PaaS-、SaaS" class="headerlink" title="3.39 IaaS 、PaaS 、SaaS"></a>3.39 IaaS 、PaaS 、SaaS</h3><p>云服务只是一个统称，可以分成三大类:</p><p>IaaS:   Infrastructure-as-a-service 基础设施即服务——-&gt;向用户提供计算机能力、<strong>存储空间</strong>,等基础设施方面的服务</p><p>PaaS: Platform-as-a-service 平台即服务——–&gt;向用户提供虚拟的<strong>操作系统、数据库管理系统、Web应用</strong>等平台化的服务.</p><p>SaaS: Software-as-a-service 软件即服务—–&gt;向用户提供<strong>应用软件</strong>如CRM、办公软件等,</p><p>简言之: </p><p>IAAS就是服务器，也就是硬件<br>PAAS就是开发工具<br>SAAS就是码农做出来的网站</p><p><a href="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html" target="_blank" rel="noopener">三者的区别详解: </a></p><p>请设想你是一个餐饮业者，打算做披萨生意。</p><p><strong>（1）方案一：IaaS</strong></p><p>他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。</p><p><strong>（2）方案二：PaaS</strong></p><p>除了基础设施，他人还提供披萨饼皮。</p><p>你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。</p><p><strong>（3）方案三：SaaS</strong></p><p>他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。</p><p><strong>SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。</strong>普通用户接触到的互联网服务，几乎都是 SaaS</p><p><strong>PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。</strong>下面这些都属于 PaaS。</p><p><strong>IaaS 是云服务的最底层，主要提供一些基础资源。</strong>它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。</p><h3 id="3-40-EAI-企业应用集成"><a href="#3-40-EAI-企业应用集成" class="headerlink" title="3.40 EAI 企业应用集成"></a>3.40 EAI 企业应用集成</h3><p>作用: 消除消息孤岛,将多个信息系统连接起来,实现无缝集成.</p><p>①: 控制集成: 在业务逻辑层上</p><p>②: 业务流程集成: 或称 过程集成, 超越了数据 和 系统, 由一系列的标准的统一的数据格式的工作流组成.</p><p>③: 数据集成是白盒集成</p><p>④: 表示集成: 也称 界面集成 <strong>属于黑盒集成</strong>.</p><p><strong>注: 控制集成  与  业务流程集成 概念上易混淆,  所以只记住 控制集成: 在业务逻辑层上就Ok.</strong></p><h3 id="3-41-设备安全"><a href="#3-41-设备安全" class="headerlink" title="3.41 设备安全"></a>3.41 设备安全</h3><p>①: 稳定性: 一定时间内<strong>不出故障</strong>的概率</p><p>②: 可靠性: 一定时间内能<strong>正常执行</strong>任务的概率</p><p>③: 可用性: <strong>随时</strong>可以<strong>正常使用</strong>的概率</p><h3 id="3-42-网络安全"><a href="#3-42-网络安全" class="headerlink" title="3.42 网络安全"></a>3.42 网络安全</h3><p>①: 防火墙: 将内部网和公众访问网分开.阻挡对网络的非法访问和不安全数据的传递,使得本地系统和网络免于受许多网络安全威胁</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.109.png" alt="109"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.110.png" alt="110"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.111.png" alt="111"></p><p>②: 入侵检测系统: 注重的是网络安全状况的<strong>监管</strong>,通过监视网络或系统资源,<strong>寻找 </strong> <strong>违反安全策略</strong>的行为或攻击迹象,<strong>并发出报警</strong>, <strong>核心是 数据分析</strong></p><p>③: 入侵防护系统: 倾向于提供主动防护,注重对入侵行为的控制,设计宗旨: 预先对入侵活动和攻击性网络流量进行拦截</p><p>④: 蜜罐技术: 通过模拟一个或多个易受攻击的主机和服务,给攻击者提供一个容易攻击的目标.</p><p>做个比喻: 防火墙相当于小区保安,在门口拦截一切可疑人等,而入侵检测系统相当于小区里的监控,监控小区里面发生的异常.</p><p>⑤: 访问控制: 分为自主访问控制和强制访问控制两大类</p><p><strong>自主访问控制:</strong> 用户有权对自己创建的对象进行访问,并可以将这些对象的访问权限授权于其他用户,或收回权限</p><p><strong>强制访问控制: </strong> 由系统(通过专门设置的系统安全员)对用户所创建的对象进行统一的强制性控制,按照规定的规则决定哪些用户可以对哪些对象进行什么样的操作,即使是创建者用户,在创建一个对象后,也可能无权访问该对象.</p><h3 id="3-43-信息系统规划工具"><a href="#3-43-信息系统规划工具" class="headerlink" title="3.43 信息系统规划工具"></a>3.43 信息系统规划工具</h3><p>P / O矩阵: 过程/组织矩阵(Progress/organization)</p><p>C/U矩阵: 创建/用户矩阵(Create/User): 数据类型 和 企业过程</p><p>R/D矩阵: 资源/数据矩阵(Resource/Data): </p><h3 id="3-44-CCB-变更控制委员会"><a href="#3-44-CCB-变更控制委员会" class="headerlink" title="3.44 CCB 变更控制委员会"></a>3.44 CCB 变更控制委员会</h3><p>CCB(Change Control Board) 在<a href="https://baike.baidu.com/item/CMMI" target="_blank" rel="noopener">CMMI</a>(Capability Maturity Model Integration)中，是“变更控制委员会”的含义，同时具有配置控制委员会（Configuration Control Board）的含义。</p><p>CCB可以由一个小组担任，也可以由多个不同的组担任，负责做出决定究竟将哪些已建议需求变更或新产品特性付诸应用。典型的变更控制委员会会同样决定在哪一些版本中纠正哪些错误。</p><p>CCB的成员应当能代表变更涉及的团体。其可能包括如下方面的代表：</p><p>1.产品或计划管理部门</p><p>2.项目管理部门</p><p>3.开发部门</p><p>4.测试或质量保证部门</p><p>5.市场部或客户代表</p><p>6.制作用户文档的部门</p><p>7.技术支持部门</p><h4 id="3-44-1-CCB负责组织-对-变更申请进行评估-并确定以下内容"><a href="#3-44-1-CCB负责组织-对-变更申请进行评估-并确定以下内容" class="headerlink" title="3.44.1 CCB负责组织 对 变更申请进行评估 并确定以下内容:"></a>3.44.1 CCB负责组织 对 变更申请进行评估 并确定以下内容:</h4><p>①: 变更对项目的影响</p><p>②: 变更的内容是否必要</p><p>③: 变更的范围是否考虑周全</p><p>④: 变更的实施方案是否可行</p><p>⑤: 变更工作量估计是否合理</p><p><strong>CCB决定是否接受变更,并将决定通知相关人员</strong></p><p><strong>变更由变更控制委员会CCB审批</strong></p><h3 id="3-45-变更请求"><a href="#3-45-变更请求" class="headerlink" title="3.45 变更请求:"></a>3.45 变更请求:</h3><p>由<strong>项目经理审查,评价</strong>, 由<strong>CCB来批准或否决.</strong></p><p>CCB决定是否变更项目基准.</p><p>项目经理负责项目的监控.</p><p><strong>注: 项目集指导委员会 是项目的决策机构,负责为项目集的管理方式提供支持.</strong> </p><h4 id="3-45-1-配置项的三种状态"><a href="#3-45-1-配置项的三种状态" class="headerlink" title="3.45.1 配置项的三种状态:"></a>3.45.1 配置项的三种状态:</h4><p>①: 草稿: 配置项刚建立时 如 V 0.X</p><p>②: 正式发布: 配置项通过评审后,其状态变为”正式发布”   如V 1.X; V2.X;  V3.X等</p><p>③: 正在修改: 正式发布后,如果修改必须依照”变更控制规程”执行,其状态变为”正在修改”.当配置项修改完毕并通过评审时,其状态又变为”正式发布”,如此循环.  如V 1.XY  V2.XY</p><p>小升级是升级小数点后面的数字,</p><p>第一次小升级为V1.1 ,第二次为V1.2 , 所以二次小的升级后版本号是V1.2 </p><p><strong>注: X.YZ  是表示正在修改的版本</strong></p><h3 id="3-46-两化融合"><a href="#3-46-两化融合" class="headerlink" title="3.46 两化融合"></a>3.46 两化融合</h3><p>①: 工业化 和 <strong>信息化</strong> 发展攻略的融合</p><p>主攻方向: 智能制造</p><h3 id="3-47-大数据"><a href="#3-47-大数据" class="headerlink" title="3.47 大数据"></a>3.47 大数据</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.39.png" alt="39"></p><h3 id="3-48-信息系统安全等级"><a href="#3-48-信息系统安全等级" class="headerlink" title="3.48 信息系统安全等级"></a>3.48 信息系统安全等级</h3><p>第一级: 用户自主保护——&gt;普通内联网用户—-&gt;<strong>普用</strong></p><p>第二级: 系统审计保护——&gt;通过内联网进行商业活动,需要保密的非重要单位.—<strong>商用</strong></p><p>第三级: 安全标记保护——-&gt;地方各级国家机关,该级别受到破坏后会对社会秩序,和公共利益造成严重损害,或对国家安全造成损害.—-<strong>地国</strong></p><p>第四级: 结构化保护——–&gt;中央级国家机关,国家重点科研单位机构—–<strong>中央国</strong></p><p>第五级: 访问验证保护级——-&gt;国防关键部门——<strong>最高级别</strong></p><p><strong>口诀: 一主二审三标四化五验证</strong></p><p><strong>口诀: 验国防,化中央,标地方</strong> </p><h3 id="3-49-互联网"><a href="#3-49-互联网" class="headerlink" title="3.49 互联网+"></a>3.49 互联网+</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.40.png" alt="40"></p><h3 id="3-50-项目建议书的内容"><a href="#3-50-项目建议书的内容" class="headerlink" title="3.50 项目建议书的内容"></a>3.50 项目建议书的内容</h3><p>①: 项目的必要性</p><p>②: 项目的市场预测</p><p>③: 项目建设必须的条件</p><p>④: 产品或服务的市场预测</p><p><strong>不包含风险因素和对策</strong></p><h3 id="3-51-开发总成本"><a href="#3-51-开发总成本" class="headerlink" title="3.51 开发总成本"></a>3.51 开发总成本</h3><p>①: 研发成本</p><p>②: 行政管理</p><p>③: 销售与分销</p><p>④: 财务费用和折旧</p><p><strong>注: 前三个成本的总和为经营成本</strong> </p><h3 id="3-52-变更性质"><a href="#3-52-变更性质" class="headerlink" title="3.52 变更性质"></a>3.52 变更性质</h3><p>①: 重大变更</p><p>②: 重要变更</p><p>③: 一般变更</p><h3 id="3-53-组织级项目管理"><a href="#3-53-组织级项目管理" class="headerlink" title="3.53 组织级项目管理"></a>3.53 组织级项目管理</h3><p>①: 项目组合管理: 通过选择正确的项目集和项目、设定工作的<strong>优先级</strong>并提供必要的资源的方式来促成组织的战略实现.</p><p>②: 项目集管理: 对其所包含的<strong>项目子集</strong>和项目的<strong>依赖关系</strong>进行有效的管理,从而实现项目集的特定利益</p><p>③: 项目管理: 通过制定和实施集合来完成特定的工作范围,支持项目集和项目组合目标的实现.最终确保组织战略得以实现.</p><p>要求三者战略方向一致</p><h3 id="3-54-评审和审计"><a href="#3-54-评审和审计" class="headerlink" title="3.54 评审和审计"></a>3.54 评审和审计</h3><p>①: 管理评审: <strong>监控进展</strong>决定计划和进度的状态,或评价用于达到目标所用管理方法的有效性.</p><p>②: 技术评审: <strong>评价软件产品</strong>,已确定其对使用<strong>意图的适合性.</strong></p><p><strong>口诀: 管监控,技意图</strong></p><p>评审者按照规范的步骤对软件需求、设计、代码或技术文档进行仔细地检查,以找出和消除其中的缺陷.<br>目的主要在于发现问题和验证符合性.</p><p><strong>注: 评价所用管理方法的有效性</strong>属于过程管理或过程审计的内容,<strong>不属于技术评审.</strong></p><p>③: 走查</p><p>④: 审计: 是正式组织的活动,识别违例情况,并要生成审计报告,采取根正性行动.</p><p>审计的目的: 提供软件产品对于可应用规则标准指南计划和流程的遵从性的<strong>独立评价.</strong></p><h3 id="3-55-权力-利益分析法"><a href="#3-55-权力-利益分析法" class="headerlink" title="3.55 权力/利益分析法:"></a>3.55 权力/利益分析法:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.50.png" alt></p><p>属于第二区域的项目干系人: 项目的客户, 项目经理的主管领导—————-权力大,利益高应该<strong>重点管理</strong></p><h4 id="3-55-1-成员"><a href="#3-55-1-成员" class="headerlink" title="3.55.1 成员:"></a>3.55.1 成员:</h4><p>项目团队成员属于:</p><p>供应商属于: </p><p>项目经理属于: </p><h4 id="3-55-2-管理策略原则"><a href="#3-55-2-管理策略原则" class="headerlink" title="3.55.2 管理策略原则:"></a>3.55.2 管理策略原则:</h4><p><strong>权力高,利益高</strong> 的干系人的管理策略是: <strong>重点管理,即使报告</strong></p><p><strong>权力高,利益低</strong> 的干系人 的管理策略是: <strong>令其满意</strong></p><p><strong>权力低,利益高</strong>的干系人 的管理策略是: <strong>随时告知</strong></p><p><strong>权力低,利益低</strong>的干系人 的管理策略是: <strong>花较少的精力监督即可.</strong></p><p><strong>口诀:  重点管理双高, 权高利低满意即可</strong></p><h3 id="3-56-项目计划"><a href="#3-56-项目计划" class="headerlink" title="3.56 项目计划"></a>3.56 项目计划</h3><p><strong>①: 一般的项目计划</strong>: 主要关注的是 <strong>项目活动的计划.</strong></p><p><strong>②: 大型及复杂的项目</strong>: <strong>制定活动计划</strong>  <strong>之前</strong>必须考虑<strong>项目的过程计划</strong>,也就是必须考虑用什么方法和过程来完成项目.</p><p><strong>过程计划:</strong> 制定过程, 执行过程,监督过程,但<strong>不包括 裁剪过程.</strong></p><p><strong>③: 大型及复杂的项目的控制过程 有3个重要因素: </strong></p><p>项目绩效跟踪,外部变更请求,变更控制.</p><p><strong>注: 里程碑设置 不管是 小项目还是大项目一般都需要</strong></p><h3 id="3-57-网络系统的设计原则"><a href="#3-57-网络系统的设计原则" class="headerlink" title="3.57 网络系统的设计原则"></a>3.57 网络系统的设计原则</h3><p>①: 可靠性原则</p><p>②: 安全性原则</p><p>③: 高效性原则</p><p>④: 可扩展性原则: 能在<strong>规模和性能</strong>两个方向上进行扩展</p><h3 id="3-58-项目管理办公室"><a href="#3-58-项目管理办公室" class="headerlink" title="3.58 项目管理办公室"></a>3.58 项目管理办公室</h3><p>①: 建立项目管理的支撑环境</p><p>②: 提供项目管理指导咨询</p><p>③: 多项目的管理和监控</p><p>注: 制定项目管理计划 由 各项目团队来做.</p><h3 id="3-59-信息物理系统CPS"><a href="#3-59-信息物理系统CPS" class="headerlink" title="3.59 信息物理系统CPS"></a>3.59 信息物理系统CPS</h3><p>是一个综合计算,网络和物理环境的多维复杂系统,通过3C(Computer,Communication,Control)技术的融合与深度写作实现大型工程系统的实时感知,动态控制和信息服务.CPS实现计算,通信,与物理系统的一体化,可以使物理系统更加可靠,高效,实时协同.</p><h3 id="3-60-布线"><a href="#3-60-布线" class="headerlink" title="3.60 布线"></a>3.60 布线</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.51.png" alt="51"></p><h3 id="3-61-对象模型技术OMT"><a href="#3-61-对象模型技术OMT" class="headerlink" title="3.61 对象模型技术OMT"></a>3.61 对象模型技术OMT</h3><p>把需求分析收集的信息构造在三层模型中,即对象模型,动态模型,功能模型 </p><p>对象模型: 对谁做</p><p>动态模型: 何时做</p><p>功能模型: 做什么 </p><h3 id="3-62-项目配置项"><a href="#3-62-项目配置项" class="headerlink" title="3.62 项目配置项"></a>3.62 项目配置项</h3><p><strong>详细设计,概要设计,源代码</strong>的成果是一定要进入基线配置项的,因为这些是软件开发的产品过程成果,必须纳入基线严格管理.</p><p><strong>注: 进度计划一般不会纳入基线来管理</strong></p><h3 id="3-63-软件版本号"><a href="#3-63-软件版本号" class="headerlink" title="3.63 软件版本号"></a>3.63 软件版本号</h3><p>小升级是升级小数点后面的数字,</p><p>第一次小升级为V1.1 ,第二次为V1.2 , 所以二次小的升级后版本号是V1.2 </p><p><strong>注: X.YZ  是表示正在修改的版本</strong></p><h3 id="3-64-未来经济发展的重要特征"><a href="#3-64-未来经济发展的重要特征" class="headerlink" title="3.64 未来经济发展的重要特征:"></a>3.64 未来经济发展的重要特征:</h3><p>数据驱动</p><h3 id="3-65-网络安全审计"><a href="#3-65-网络安全审计" class="headerlink" title="3.65 网络安全审计"></a>3.65 网络安全审计</h3><p>从审计级别上分为:</p><p>①: 系统级审计</p><p>②: 应用级审计</p><p>③: 用户级审计</p><h3 id="3-66-企业级项目管理办公室PMO"><a href="#3-66-企业级项目管理办公室PMO" class="headerlink" title="3.66 企业级项目管理办公室PMO"></a>3.66 企业级项目管理办公室PMO</h3><p>分类: 日常性职能,战略性职能</p><p>战略性职能: 项目组合管理,确定资源分配优先顺序,提高企业项目管理能力</p><h3 id="3-67-绩效评估的过程"><a href="#3-67-绩效评估的过程" class="headerlink" title="3.67 绩效评估的过程"></a>3.67 绩效评估的过程</h3><p>①: 制定绩效评估计划</p><p>②: 确定评估项</p><p>③: 组织评估团队</p><p>④: 收集审核绩效数据资料</p><p>⑤: 进行定量,定性分析</p><p>⑥: 归纳分析撰写评价报告</p><h3 id="3-68-需求阶段"><a href="#3-68-需求阶段" class="headerlink" title="3.68 需求阶段"></a>3.68 需求阶段</h3><p>本阶段的工作成功,应该 编制 <strong>需求规格说明书,初步用户手册,和数据要求说明.</strong></p><h3 id="3-69-项目的组织结构"><a href="#3-69-项目的组织结构" class="headerlink" title="3.69 项目的组织结构:"></a>3.69 项目的组织结构:</h3><p>职能型型组织:  </p><p>项目型:  </p><ul><li>1) 员工缺乏事业上连续性和保障,因为项目解散了,员工不好安排</li><li>2) 不利于沟通,技术知识共享</li><li>3) 难以监测控制</li></ul><p>矩阵型:  缺点: 项目组成员可能接受多头领导</p><h3 id="3-70-人员职责"><a href="#3-70-人员职责" class="headerlink" title="3.70 人员职责"></a>3.70 人员职责</h3><p>QA: 检查工作产品及过程与规范的符合性</p><p>项目经理:  组织对概要设计同行评审</p><p>过程改进小组:  组织对软件的过程的改进</p><p>配置管理员:  文件版本管理</p><h3 id="3-71-开放式系统的特点"><a href="#3-71-开放式系统的特点" class="headerlink" title="3.71 开放式系统的特点:"></a>3.71 开放式系统的特点:</h3><p>①: 可移植性/兼容性</p><p>②: 可裁剪性</p><p>③: 互操作性</p><h3 id="3-72-对称加密与非对称加密与数字摘要算法"><a href="#3-72-对称加密与非对称加密与数字摘要算法" class="headerlink" title="3.72 对称加密与非对称加密与数字摘要算法:"></a>3.72 对称加密与非对称加密与数字摘要算法:</h3><h4 id="3-72-1-对称加密"><a href="#3-72-1-对称加密" class="headerlink" title="3.72.1 对称加密:"></a>3.72.1 对称加密:</h4><p>加密和解密都是同一个密钥.</p><p>特点:  加密解密快, 密钥管理简单, 加密强度不高,  只适合一对一传输,不适合一对多加密传输.</p><p>举例: DES,,3DES, SDBI, RC4, AES, IDEA</p><p>DES: 64比特明文+ 64比特密钥———&gt;16次加密变换====&gt;得到64比特密文</p><p><strong>64比特密钥</strong>包含<strong>8比特奇偶校验位</strong>,所以<strong>实际密钥长度为56位.</strong></p><p>3DES: 三重DES,密钥长度128位,实际112位,3DES相当于两倍于DES密钥长度的加密效果.</p><p>IDEA: 密钥长度128位</p><h4 id="3-72-2-非对称加密"><a href="#3-72-2-非对称加密" class="headerlink" title="3.72.2 非对称加密"></a>3.72.2 非对称加密</h4><p><strong>一般A向B发送内容信息: 加密用公钥,解密用私钥</strong><br>如果是数字签名技术: 将摘要信息用发送者<strong>私钥加密</strong>,与原文一起发送给接收者,接收者只有用 发送者<strong>公钥解密</strong>才能得到被加密的摘要信息,然后用HASH函数对收到的原文产生一个摘要信息,与解密的摘要信息对比.</p><p><strong>注意:  综上: 非对称算法其实 并不区分加密密钥和解密密钥,每个密钥都可以用来加密 和 解密.</strong></p><p>密钥管理复杂,需要第三方认证中心</p><p>举例: RSA,ECC</p><h4 id="3-72-3-数字摘要"><a href="#3-72-3-数字摘要" class="headerlink" title="3.72.3 数字摘要"></a>3.72.3 数字摘要</h4><p>举例: MD5, SHA </p><h4 id="3-72-4-CA安全认证中心"><a href="#3-72-4-CA安全认证中心" class="headerlink" title="3.72.4 CA安全认证中心"></a>3.72.4 CA安全认证中心</h4><p>是发放,管理,废除数字证书的机构,并作为受信任的第三方,承担PKI体系中公钥合法性检验的责任.</p><p>数字签名: <strong>非对称密钥加密</strong>技术与<strong>数字摘要</strong>技术综合应用,<strong>可以防消息抵赖</strong></p><p>认证技术: 防信息被假冒,通常是PKI/CA证书体系</p><p>加密技术: 防信息被窃取,包括各种对称密钥,非对称密钥算法</p><p>完整性技术: 防信息被篡改,常见的数字摘要(HASH)算法有MD5,SHA</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.96.png" alt="96"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.97.png" alt="97"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.98.png" alt="98"></p><h4 id="3-73-软件设计"><a href="#3-73-软件设计" class="headerlink" title="3.73 软件设计"></a>3.73 软件设计</h4><p>分类: 结构设计, 数据接口设计,  过程设计</p><p>结构设计: 软件系统各主要部件之间的关系. </p><p>数据设计: </p><p>接口设计: 软件内部,软件和操作系统间以及 软件和人之间如何通性.</p><p>过程设计: </p><h3 id="3-74-配置管理"><a href="#3-74-配置管理" class="headerlink" title="3.74 配置管理"></a>3.74 配置管理</h3><h3 id="3-75-大型项目"><a href="#3-75-大型项目" class="headerlink" title="3.75 大型项目"></a>3.75 大型项目</h3><p>统一项目过程中<strong>没有优化过程</strong></p><h3 id="3-76-监理审查承建单位选择的分包单位的资质是在什么阶段"><a href="#3-76-监理审查承建单位选择的分包单位的资质是在什么阶段" class="headerlink" title="3.76 监理审查承建单位选择的分包单位的资质是在什么阶段?"></a>3.76 监理审查承建单位选择的分包单位的资质是在什么阶段?</h3><p>建设工程实施准备阶段</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.115.png" alt="115"></p><h3 id="3-77-建设和承建单位的区别"><a href="#3-77-建设和承建单位的区别" class="headerlink" title="3.77 建设和承建单位的区别"></a>3.77 建设和承建单位的区别</h3><p>建设单位: 执行国家建设计划,使用建设投资的单位</p><p>承建单位: 具体施工单位,没有什么权利</p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.156.png" alt="156"></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.157.png" alt="157"></p><h3 id="3-78-管理科学"><a href="#3-78-管理科学" class="headerlink" title="3.78 管理科学"></a>3.78 管理科学</h3><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.147.png" alt="147"></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.148.png" alt="148"></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.149.png" alt="149"></p><h3 id="3-79-J2EE核心技术"><a href="#3-79-J2EE核心技术" class="headerlink" title="3.79 J2EE核心技术"></a>3.79 J2EE核心技术</h3><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.151.png" alt="151"></p><h2 id="四、软件工程相关"><a href="#四、软件工程相关" class="headerlink" title="四、软件工程相关"></a>四、软件工程相关</h2><h3 id="4-1-数据流图"><a href="#4-1-数据流图" class="headerlink" title="4.1 数据流图:"></a>4.1 数据流图:</h3><h4 id="4-1-1-四个要素"><a href="#4-1-1-四个要素" class="headerlink" title="4.1.1 四个要素:"></a>4.1.1 四个要素:</h4><p>①: 数据流<br>②: 加工<br>③: 数据存储<br>④: <strong>外部实体</strong> : 存在于软件系统之外的<strong>人员或组织</strong></p><h3 id="4-2-软件维护"><a href="#4-2-软件维护" class="headerlink" title="4.2 软件维护:"></a>4.2 软件维护:</h3><p><strong>交付前和交付后,都要进行,</strong>是为需要提供软件支持的全部活动</p><h4 id="4-2-1-四种类型"><a href="#4-2-1-四种类型" class="headerlink" title="4.2.1 四种类型:"></a>4.2.1 四种类型:</h4><p>①: 纠正性维护: 改正测试阶段未发现,投入生产<strong>运行一段时间后暴露</strong>的问题——&gt;就<br>②: 适应性维护:  <strong>能适应变化</strong>(如<strong>迁移数据库</strong>,或操作系统),环境变化后能继续使用——-&gt;是<br>③: 预防性维护: 更正<strong>潜在错误</strong>,为改进软件未来的<strong>可维护性,和可靠性</strong>,或者给<strong>未来的改进</strong>提供更好的基础而做出的修改–&gt;鱼<br>④: 完善性维护: <strong>增加功能</strong>——&gt;丸</p><p><strong>口诀: 就是鱼丸</strong></p><p><strong>技巧: 题目中出现预防  /  未来  /  潜在 等字,基本可锁定预防性维护</strong></p><h3 id="4-3-开发方法"><a href="#4-3-开发方法" class="headerlink" title="4.3 开发方法:"></a>4.3 开发方法:</h3><h4 id="4-3-1-原型法"><a href="#4-3-1-原型法" class="headerlink" title="4.3.1 原型法:"></a>4.3.1 原型法:</h4><p><strong>需求不清, 快速开发</strong>一个原型系统, 通过反复修改来实现最终系统需求</p><h4 id="4-3-2瀑布模型"><a href="#4-3-2瀑布模型" class="headerlink" title="4.3.2瀑布模型:"></a>4.3.2瀑布模型:</h4><p><strong>明确所有需求,变更少,不需要二次开发</strong></p><p>瀑布模型将软件生命周期分为<strong>制定计划</strong>(问题定义,可行性研究),<strong>需求分析,软件设计(概要设计,详细设计),软件实现(编码),软件测试,运行维护</strong>等六个阶段.</p><h4 id="4-3-3-喷泉模型"><a href="#4-3-3-喷泉模型" class="headerlink" title="4.3.3 喷泉模型"></a>4.3.3 喷泉模型</h4><p>描述<strong>面向对象</strong>的软件开发过程</p><h4 id="4-3-4-V模型"><a href="#4-3-4-V模型" class="headerlink" title="4.3.4 V模型"></a>4.3.4 V模型</h4><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.64.png" alt="64"></p><p>①: <strong>开发和测试同等重要</strong>,左侧代表开发阶段,右侧代表测试阶段<br>②: 针对每个开发阶段,都有一个测试级别与之对应<br>③: 适用于<strong>需求明确和需求变更不频繁</strong>的情形</p><p>单元测试: 一般由开发人员来执行,   针对<strong>编码</strong>过程, 检查每个<strong>模块内</strong>是否正确实现了<strong>详细设计</strong>说明中的功能性能,接口等<br>集成测试: 针对<strong>概要设计</strong>,检查<strong>模块间</strong>的接口关系,和验证已集成的软件是否符合设计要求.<br>系统测试: 针对<strong>需求分析</strong>, 检查系统作为一个<strong>整体</strong>是否有效的得到运行,<br>验收测试: 通常由业务专家或<strong>用户进行</strong>,确认产品功能,性能是否符合用户业务上的需要是否和<strong>用户需求</strong>一致.</p><h4 id="4-3-5-增量迭代模型"><a href="#4-3-5-增量迭代模型" class="headerlink" title="4.3.5 增量迭代模型"></a>4.3.5 增量迭代模型</h4><p>需求不确定</p><p>很多不确定因素且项目参与人员还不能完全理解项目需求,范围,计划多期开发.</p><h3 id="4-4-CMMI-模型"><a href="#4-4-CMMI-模型" class="headerlink" title="4.4 CMMI 模型:"></a>4.4 CMMI 模型:</h3><p>Capability Maturity Model Integration 能力成熟度集成模型,整合了不同的CMM模型</p><p><strong>两种表示方法: </strong><br>①: 阶段式:  <strong>组织的成熟度等级</strong><br><strong>针对整个组织</strong>进行统一评价<strong>成熟度等级</strong></p><p>1) 初始级CMM1: 管理<strong>无章法</strong>，缺乏健全的管理制度</p><p><strong>2) 可重复级 CMM2</strong> : 新项目的计划和管理基于过去的实践经验，具有<strong>重复</strong>以前成功项目的环境和条件</p><p>3) 已定义级 CMM3 : 开发过程，包括技术工作和管理工作,均已实现<strong>标准化、文档化</strong>。建立了完善的培训制度和专家评审制度</p><p><strong>4) 已管理级(定量管理级)  CMM4</strong> : 产品和过程已建立了<strong>定量</strong>的质量目标。开发活动中的生产率和质量是可量度的</p><p>5) 优化级 CMM5 :  拥有防止出现缺陷、识别薄弱环节以及加以<strong>改进</strong>的手段</p><p><strong>已管理级 有7个过程域:</strong></p><p>过程和质量保证 : 使工作人员客观洞察过程和相关工作产品</p><p>②: 连续式:  <strong>组织的过程能力等级</strong></p><p>针对组织的某些过程度评级(<strong>相对单个过程域</strong>),即评价组织的某个PA的<strong>能力等级</strong>为2级或3级.</p><p><strong>口诀: 阶段组成熟,连续组过能</strong></p><h3 id="4-5-软件质量模型"><a href="#4-5-软件质量模型" class="headerlink" title="4.5 软件质量模型:"></a>4.5 软件质量模型:</h3><h4 id="4-5-1-McCall-质量模型"><a href="#4-5-1-McCall-质量模型" class="headerlink" title="4.5.1 McCall 质量模型:"></a>4.5.1 McCall 质量模型:</h4><p>三种视角来定义和识别软件质量</p><p>①: 产品<strong>转移</strong>: 可移植,可复用性</p><p>②: 产品<strong>修改</strong>: 可维护</p><p>③: 产品<strong>运行</strong>: 正确,可靠,效率,完整性</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.140.png" alt="140"></p><h3 id="4-6-需求分析"><a href="#4-6-需求分析" class="headerlink" title="4. 6 需求分析:"></a>4. 6 需求分析:</h3><h4 id="4-6-1-作用"><a href="#4-6-1-作用" class="headerlink" title="4.6.1 作用:"></a>4.6.1 作用:</h4><p>描述一个系统必须<strong>做什么</strong>,或者一个系统是什么(从用户那里了解需求的本质,知道软件需要做什么功能.)</p><h4 id="4-6-2-需求分析阶段用到的图形工具"><a href="#4-6-2-需求分析阶段用到的图形工具" class="headerlink" title="4.6.2 需求分析阶段用到的图形工具:"></a>4.6.2 需求分析阶段用到的图形工具:</h4><p>①: 层次方框图:</p><p>又称层次模块结构图, 将系统分为若干个子系统,子系统再划分为若干个模块,大模块再分为若干小模块,需求分析阶段可以用此图画出系统的功能蓝图.</p><p>②: 用例图:</p><p>从用户角度描述系统功能,是用户所能观察到的系统功能模型图,它可以用于需求分析阶段</p><p>③: IPO图:</p><p>Input Processing Output 输入加工输出, 描述功能需求的输入和输出,它可以用于需求分析阶段</p><p><strong>注: </strong> <strong>N-S图也称盒图,</strong>不能用于需求分析阶段, 在流程图中<strong>完全去掉流程线</strong>,全部算法写在一个矩形阵内,在框内还包含其他框的流程图形式.<strong>主要用于程序设计</strong></p><h4 id="4-6-3-产生的文档"><a href="#4-6-3-产生的文档" class="headerlink" title="4.6.3 产生的文档:"></a>4.6.3 产生的文档:</h4><p>软件需求规格说明,数据要求说明,<strong>初步用户手册</strong></p><p>初步用户手册通常是需求人员编写,写完需求文档,就可以写初步用户手册了(肯没有最终的功能界面,但已经可以作为联机帮助手册)</p><p><strong>注: 数据库设计是 详细设计的产物,    软件产品规格说明(产品说明书)  是 产品做出来后写的  </strong> </p><h3 id="4-7-软件需求"><a href="#4-7-软件需求" class="headerlink" title="4.7 软件需求"></a>4.7 软件需求</h3><h4 id="4-7-1-需求的层次"><a href="#4-7-1-需求的层次" class="headerlink" title="4.7.1 需求的层次:"></a>4.7.1 需求的层次:</h4><p>①: 业务需求</p><p>企业或客户对系统<strong>高层次</strong>的目标要求,业务需求通常来自 项目投资人,购买产品的客户,实际用户的管理者,市场营销部门或产品策划部门.</p><p>②: 用户需求</p><p>描述用户的目标, 用户要求系统<strong>必须能完成</strong>的任务</p><p>③: 系统需求</p><p>包括<strong>功能需求</strong>,<strong>非功能需求</strong><br><strong>非功能性需求:</strong> 系统必须具备的<strong>属性或品质</strong>,及<strong>设计约束</strong></p><h4 id="4-7-2-系统需求分类"><a href="#4-7-2-系统需求分类" class="headerlink" title="4.7.2 系统需求分类"></a>4.7.2 系统需求分类</h4><p>①: 功能需求:</p><p><strong>开发人员必须在产品中实现</strong>的软件功能,用户利用这些功能来完成任务,满足业务需求</p><p>例如: <strong>按照订单及原材料自动安排生产排序</strong><br><strong>定期生成销售分析报表</strong></p><p>②: 性能需求</p><p>软件或人与软件交互的静态或者动态<strong>数值需求</strong>.如响应<strong>速度</strong>,处理速度</p><p>③: 外部接口需求</p><p>用户接口,硬件接口,软件接口,通信接口</p><p>④: 设计约束和质量属性</p><p>设计约束: 受硬件限制<br>例如: 系统可实现对多字符集支持,GBK,BIG5,UTF-8等<br>必须运行在UNIX系统下等</p><p><strong>属性: 可用性,安全性,可维护性,可转移/转换性,效率</strong><br>例如: <strong>系统同时支持1000个独立站点的并发访问.</strong><br><strong>系统实行同城异地双机备份,保障数据安全</strong></p><p><strong>技巧:  </strong>看到”必须完成” 基本可以锁定功能需求<br>　　　看到”速度”基本可以锁定性能需求<br>　　　看到”安全,并发,字符集”基本可以锁定约束和质量属性</p><h4 id="4-7-3-质量功能部署QFD对需求的分类"><a href="#4-7-3-质量功能部署QFD对需求的分类" class="headerlink" title="4.7.3 质量功能部署QFD对需求的分类:"></a>4.7.3 质量功能部署QFD对需求的分类:</h4><p>QFD: Quality Function Deployment : 是一种将用户要求转换为软件需求的技术.</p><p>常规需求: 用户认为系统应具备的功能</p><p>期望需求: 用户<strong>想当然</strong>认为系统应具备的功能</p><p>意外需求: 用户没有提出的,开发人员自己加的</p><h4 id="4-7-4-需求分析的阶段"><a href="#4-7-4-需求分析的阶段" class="headerlink" title="4.7.4 需求分析的阶段"></a>4.7.4 需求分析的阶段</h4><p>①: 需求提出</p><p>②: 需求描述</p><p>③: 需求评审</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.54.png" alt="54"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.55.png" alt="55"></p><h3 id="4-8-敏捷方法"><a href="#4-8-敏捷方法" class="headerlink" title="4.8 敏捷方法"></a>4.8 敏捷方法</h3><p>敏捷软件开发宣言:<br>①: 个体和交互胜于过程和工具: <strong>以人为本</strong>的思想<br>②: 可以工作的<strong>软件胜于</strong>面面俱到的<strong>文档</strong><br>③: <strong>客户合作优于合同谈判</strong><br>④: 响应变化优于遵循计划</p><h3 id="4-9-软件过程改进"><a href="#4-9-软件过程改进" class="headerlink" title="4.9 软件过程改进"></a>4.9 软件过程改进</h3><h4 id="4-9-1-五条核心原则"><a href="#4-9-1-五条核心原则" class="headerlink" title="4.9.1 五条核心原则:"></a>4.9.1 五条核心原则:</h4><p>①: 注重问题<br>②: 强调知识创新<br>③: 鼓励参与<br>④: 领导层的统一<br>⑤: 计划不断改进</p><h3 id="4-10-软件测试"><a href="#4-10-软件测试" class="headerlink" title="4.10 软件测试"></a>4.10 软件测试</h3><p><strong>4.10.1 从是否关心软件内部结构和具体实现的角度分类:</strong></p><p>白盒测试</p><p>黑盒测试</p><p>灰盒测试: 介于白盒和黑盒之间,多用于集成测试阶段</p><h4 id="4-10-2-边界值分析法"><a href="#4-10-2-边界值分析法" class="headerlink" title="4.10.2 边界值分析法"></a>4.10.2 边界值分析法</h4><p>是一种黑盒测试用例设计方法,针对每一个边界,取一个<strong>刚好超出边界的值,再取一个刚好在边界内 或等于 </strong>的值.</p><p>例如: 10&lt;=X&lt;=100,X为整数, 则测试用例为   X=9,X=10,  X=100,X=101</p><p>例如10&lt;=X,X为整数,则测试用例为: X=9,X=10</p><p><strong>4.10.2 从是否执行程序的角度分类: </strong></p><p>静态测试 和 动态测试</p><h4 id="4-10-2-1-静态测试-不运行被测程序本身-仅通过分析或检查源程序的语法-结构过程-接口等来检查程序的正确性"><a href="#4-10-2-1-静态测试-不运行被测程序本身-仅通过分析或检查源程序的语法-结构过程-接口等来检查程序的正确性" class="headerlink" title="4.10.2.1 静态测试: 不运行被测程序本身,仅通过分析或检查源程序的语法,结构过程,接口等来检查程序的正确性."></a>4.10.2.1 静态测试: 不运行被测程序本身,仅通过分析或检查源程序的语法,结构过程,接口等来检查程序的正确性.</h4><p>代码的静态测试  和  文档的静态测试.</p><p>对文档的静态测试:  <strong>检查单</strong>的形式进行</p><p>对代码的静态测试: 采用<strong>桌前检查, 代码走查, 和代码审查</strong></p><p>桌面检查: 对程序执行情况,进行人工模拟,逐步<strong>检查源代码中有无逻辑或语法错误</strong>的方法来检测故障.</p><p>代码走查: 程序员或设计者引导开发组成员<strong>通读已经书写的设计文档或编码</strong></p><p>代码审计: 由某人、某小组或<strong>借助某种工具</strong>对代码进行<strong>独立的审查</strong>,以验证其<strong>是否 符合软件设计文件 和程序设计标准</strong>.</p><p>代码评审: 也称代码复查, 通过阅读代码来检查源代码与编码标准的符合性以及<strong>代码质量</strong>的活动.</p><p><strong>口诀: 捉错误, 揍设编, 审标准, 评质量</strong> </p><h4 id="4-10-2-2-动态测试-通过运行被测程序-检查运行结果与预测结果的差异-并分析运行效率-正确性和健壮性等性能-该方法由三部分组成-构造测试用例-执行程序-分析程序的输出结果"><a href="#4-10-2-2-动态测试-通过运行被测程序-检查运行结果与预测结果的差异-并分析运行效率-正确性和健壮性等性能-该方法由三部分组成-构造测试用例-执行程序-分析程序的输出结果" class="headerlink" title="4.10.2.2 动态测试: 通过运行被测程序,检查运行结果与预测结果的差异,并分析运行效率,正确性和健壮性等性能,该方法由三部分组成: 构造测试用例,执行程序,分析程序的输出结果."></a>4.10.2.2 动态测试: 通过运行被测程序,检查运行结果与预测结果的差异,并分析运行效率,正确性和健壮性等性能,该方法由三部分组成: 构造测试用例,执行程序,分析程序的输出结果.</h4><p>白盒测试属于动态测试</p><p><strong>注: 黑盒测试 : 也称 功能测试,不关注内部结构</strong></p><h3 id="4-11-设计模式"><a href="#4-11-设计模式" class="headerlink" title="4.11 设计模式"></a>4.11 设计模式</h3><p>①: 根据 处理范围不同: 分为类模式和对象模式</p><p>类模式处理类与子类之间的关系,通过继承建立,在编译期间确定,属于静态关系</p><p>对象模式 处理对象之间的关系,在运行时刻变化,更具有动态性.</p><p>②: 根据目的与用途分为 : 创建型, 行为型,结构型</p><h3 id="4-12-软件测试类型"><a href="#4-12-软件测试类型" class="headerlink" title="4.12 软件测试类型"></a>4.12 软件测试类型</h3><p>①: 回归测试: 修改了旧代码后,重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误.</p><p>②: 冒烟测试: 这一术语源于硬件行业</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.57.png" alt="57"></p><p>③: Alpha测试</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.100.png" alt="100"></p><p>④: Beta测试</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.101.png" alt="101"></p><p>⑤: 静态测试</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.103.png" alt="103"></p><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.1.png" alt="1"></p><p>OSI 7层模型: </p><p>物理层————巫<br>数据链路层——术<br>网络层————忘<br>传输层————传<br>会话层————会<br>表示层————彪<br>应用层————鹰 </p><p><strong>口诀: 巫术忘传会彪鹰</strong></p><h3 id="5-0-会话层"><a href="#5-0-会话层" class="headerlink" title="5.0 会话层"></a>5.0 会话层</h3><p>管理主机之间的会话进程,即<strong>负责建立,终止进程之间的会话</strong>,还利用在数据中插入校验点来实现<strong>数据同步.</strong></p><h3 id="5-1-传输层"><a href="#5-1-传输层" class="headerlink" title="5.1 传输层:"></a>5.1 传输层:</h3><p>传输层: 实现端用户之间可靠通信</p><p>SPX(序列分组交换协议)</p><h3 id="5-2-表示层"><a href="#5-2-表示层" class="headerlink" title="5.2 表示层"></a>5.2 表示层</h3><p>对上层数据或信息进行转换,以保证一个主机应用层信息,能被另一主机的应用程序理解.</p><p>MPEG协议</p><p><strong>数据加密,压缩,格式转换.</strong></p><h3 id="5-3-物理层"><a href="#5-3-物理层" class="headerlink" title="5.3 物理层:"></a>5.3 物理层:</h3><p>①: 集线器: 收集多个端口来的数据帧,并广播出去</p><p>是共享带宽式的,带宽由端口平均分配</p><p>②: 调制解调器: 模数/数模信号转换<br>③: 中继器: 用于<strong>完全相同的两类网络</strong>的互连,对数据信号<strong>重新发送或转发</strong>,来<strong>扩大网络传输距离</strong>. </p><p><strong>IEEE802.11</strong>: 标准定义了三种物理层通信技术:<br>直接序列扩频<br>跳频扩频<br>漫反射红外线</p><h3 id="5-4-数据链路层"><a href="#5-4-数据链路层" class="headerlink" title="5.4 数据链路层:"></a>5.4 数据链路层:</h3><p>以太网交换机,根据以太帧中的地址转发数据帧.</p><p>IEEE802系列规范</p><h3 id="5-5-网络层"><a href="#5-5-网络层" class="headerlink" title="5.5 网络层"></a>5.5 网络层</h3><h4 id="5-5-1-路由器"><a href="#5-5-1-路由器" class="headerlink" title="5.5.1 路由器:"></a>5.5.1 路由器:</h4><h4 id="5-5-2-路由协议分类"><a href="#5-5-2-路由协议分类" class="headerlink" title="5.5.2 路由协议分类:"></a>5.5.2 路由协议分类:</h4><p><strong>内部网关协议IGP:</strong> 在一个AS(AutonomousSystem)<strong>自制系统</strong>(指有权自主决定在本系统应该采用何种路由选择协议的网络)内的路由协议</p><p><strong>外部网关协议: </strong> <strong>AS之间的路由协议</strong></p><h3 id="5-6-100BaseFX"><a href="#5-6-100BaseFX" class="headerlink" title="5.6 100BaseFX:"></a>5.6 100BaseFX:</h3><p>F: fiber光纤</p><p>是在<strong>光纤</strong>上实现的100Mbps标准, 运行于<strong>光缆</strong>上,适合<strong>长距离/骨干传输</strong>,<strong>802.3u</strong>标准</p><h3 id="5-7-层次化网络设计"><a href="#5-7-层次化网络设计" class="headerlink" title="5.7 层次化网络设计:"></a>5.7 层次化网络设计:</h3><h4 id="5-7-1-三个关键层概念"><a href="#5-7-1-三个关键层概念" class="headerlink" title="5.7.1 三个关键层概念:"></a>5.7.1 三个关键层概念:</h4><p>①: 核心层: Core Layer</p><p>目标: 高效速度传输,为网络提供骨干组件</p><p>②: 汇聚层: Distribution Layer</p><p>核心层与终端用户接入层的分界面</p><p>完成<strong>网络访问的策略控制</strong>,广播域的定义,过滤寻址等数据处理业务.</p><p>③: 接入层: Access Layer</p><p>网络分段,广播/多播能力,介质访问的安全性,路由发现,MAC地址的过滤</p><p><strong>口诀: 汇策略,核骨干</strong></p><h3 id="5-8-关于TCP-UDP"><a href="#5-8-关于TCP-UDP" class="headerlink" title="5.8 关于TCP/UDP:"></a>5.8 关于TCP/UDP:</h3><h4 id="5-8-1-基于TCP协议"><a href="#5-8-1-基于TCP协议" class="headerlink" title="5.8.1 基于TCP协议 :"></a>5.8.1 基于TCP协议 :</h4><p>HTTP ,FTP,Telnet, SMTP ,POP3,  WWW</p><p>注: TFTP,NTP,SNMP是基于UDP</p><h3 id="5-9-网络交换"><a href="#5-9-网络交换" class="headerlink" title="5.9 网络交换"></a>5.9 网络交换</h3><h4 id="5-9-1-4-个发展阶段"><a href="#5-9-1-4-个发展阶段" class="headerlink" title="5.9.1   4 个发展阶段:"></a>5.9.1   4 个发展阶段:</h4><p>①: 电路交换<br><strong>面向连接</strong>,在通信前,需要为通信双方分配一条具有固定带宽的通信线路,通信双方在通信过程中将<strong>一直占用所分配的资源</strong>到通信结束.</p><p>②: 报文交换</p><p>采用<strong>存储转发机制</strong>,以报文为传送单元,用于实时性要求低,报文较短的通信业务</p><p>③: 分组交换</p><p><strong>面向无连接,采用存储转发方式,</strong>  将数据分割为小段并添加头部,作为数据传送的基本单元即分组, 比电路交换的电路利用率高,但时延大,适用于计算机网络,数据传输可靠,线路利用率较高</p><p>④: ATM   (Asynch-ronous TransferMode)</p><p><strong>异步传输模式</strong>,将<strong>面向连接机制和分组机制相结合</strong>,在通信开始前<strong>需要建立连接</strong>,但是该连接并<strong>不独占物理通道,</strong>而是和其他连接统计复用,同时所有的媒体信息,被分割并封装为<strong>固定长度的分组在网络中传送和交换.</strong></p><p>适合传送高速数据业务,ATM技术复杂性,导致ATM交换机造价及其昂贵</p><h3 id="5-10-双绞线"><a href="#5-10-双绞线" class="headerlink" title="5.10 双绞线"></a>5.10 双绞线</h3><p>屏蔽双绞线(Shielded  Twisted  Pair):</p><p>增加了全屏蔽层,减少了衰减和噪音, 价格贵重量重,不易安装,<strong>一般用于涉密信息等要求高的情况下</strong></p><p>非屏蔽双绞线(UnShielded  Twisted  Pair)</p><h3 id="5-11-AP"><a href="#5-11-AP" class="headerlink" title="5.11 AP"></a>5.11 AP</h3><p>AP接入点(Access Point) 是<strong>用于无线网络</strong>的无线HUB,是无线网络的核心.</p><p>它是移动计算机用户进入有线以太网骨干的接入点,AP可简单安装在天花板或墙壁,他在开放空间<strong>最大覆盖范围300米</strong>,无线<strong>传输速率11Mbps</strong>,理论上可<strong>同时接入1024 个移动设备</strong>.</p><h3 id="5-12-可用于查询IP地址的常见命令"><a href="#5-12-可用于查询IP地址的常见命令" class="headerlink" title="5.12 可用于查询IP地址的常见命令:"></a>5.12 可用于查询IP地址的常见命令:</h3><p>①: nslookup<br>②: tracert<br>③: ping</p><p>用法:    命令+ 域名 ,如 nslookup <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><strong>注: ipconfig 用于查询本地电脑IP,网关等信息的,命令后面不带网址.</strong></p><h3 id="5-13-网络分类"><a href="#5-13-网络分类" class="headerlink" title="5.13 网络分类"></a>5.13 网络分类</h3><h4 id="5-13-1-按照作用范围分"><a href="#5-13-1-按照作用范围分" class="headerlink" title="5.13.1 按照作用范围分:"></a>5.13.1 按照作用范围分:</h4><p>广域网WAN: (Wide Area Network)</p><p><strong>如北京到上海之间的网络按照作用范围分,它属于广域网</strong></p><p>城域网MAN</p><p>局域网LAN</p><h3 id="5-14-IEEE802"><a href="#5-14-IEEE802" class="headerlink" title="5.14 IEEE802"></a>5.14 IEEE802</h3><p>IEEE802.1: 定义局域网体系结构,寻址,网络互联和网络.</p><p>IEEE802.3 : 是以太网标准(局域网标准)</p><p>IEEE802.6: 城域网协议</p><p>IEEE802.11 : 是无线局域网WIFI的技术标准</p><h3 id="5-15-WLAN无线网络常用的认证与加密方式"><a href="#5-15-WLAN无线网络常用的认证与加密方式" class="headerlink" title="5.15 WLAN无线网络常用的认证与加密方式:"></a>5.15 WLAN无线网络常用的认证与加密方式:</h3><h4 id="5-15-1-WEP"><a href="#5-15-1-WEP" class="headerlink" title="5.15.1 WEP"></a>5.15.1 WEP</h4><p>Wired Equivalent Privacy ,有线等效保密,是对在两台设备间无线传输的数据进行加密的方式,用于防窃听</p><h4 id="5-15-2-WPA"><a href="#5-15-2-WPA" class="headerlink" title="5.15.2 WPA"></a>5.15.2 WPA</h4><p>WPA目前有四种认证方式:</p><p>WPA: 替代WEP, 加强了生成加密密钥的算法,增加了防数据中途被篡改的功能和认证功能</p><p>WPA2: 与WPA相比,增加了AES的加密方式</p><p>WPA-PSK</p><p>WPA2-PSK</p><h3 id="5-14-网络设备"><a href="#5-14-网络设备" class="headerlink" title="5.14 网络设备"></a>5.14 网络设备</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.2.png" alt="2"></p><h3 id="5-15-以太网"><a href="#5-15-以太网" class="headerlink" title="5.15 以太网"></a>5.15 以太网</h3><p>①: 使用CSMA/CD(即载波监听多路访问及冲突检测技术)</p><p>②: 支持半双工和全双工</p><p>③: 以太网帧长度不固定,如Ethernet II类型以太网帧最小长度为64字节(6+6+2+46+4),最大长度为1518字节(6+6+2+1500+4)</p><h3 id="5-16-WLAN无线网络"><a href="#5-16-WLAN无线网络" class="headerlink" title="5.16 WLAN无线网络"></a>5.16 WLAN无线网络</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.58.png" alt="58"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.59.png" alt="59"></p><h3 id="5-16-OSI七层模型中各层的功能"><a href="#5-16-OSI七层模型中各层的功能" class="headerlink" title="5.16 OSI七层模型中各层的功能:"></a>5.16 OSI七层模型中各层的功能:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.84.png" alt="84"></p><h3 id="5-17-网关"><a href="#5-17-网关" class="headerlink" title="5.17 网关:"></a>5.17 网关:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.91.png" alt="91"></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.153.png" alt="153"></p><h2 id="六、数据库"><a href="#六、数据库" class="headerlink" title="六、数据库"></a>六、数据库</h2><h3 id="6-1-六种范式"><a href="#6-1-六种范式" class="headerlink" title="6.1 六种范式:"></a>6.1 六种范式:</h3><p>①: INF<br>②: 2NF<br>③: 3NF<br>④: BCNF<br>⑤: 4NF<br>⑥: 5NF</p><p><strong>范式级别越高,数据冗余程度越小,存储同样的数据就需要分解成更多张表,数据库性能(速度)将下降</strong></p><h2 id="七、立项管理"><a href="#七、立项管理" class="headerlink" title="七、立项管理"></a>七、立项管理</h2><h3 id="7-1-立项管理的5个阶段"><a href="#7-1-立项管理的5个阶段" class="headerlink" title="7.1 立项管理的5个阶段"></a>7.1 立项管理的5个阶段</h3><p>①: 项目建议</p><p>②: 项目可行性分析</p><p>③: 项目审批</p><p>④: 项目招标</p><p>⑤: 项目合同谈判和签订</p><h3 id="7-2-系统方法论的基本原则"><a href="#7-2-系统方法论的基本原则" class="headerlink" title="7.2 系统方法论的基本原则:"></a>7.2 系统方法论的基本原则:</h3><p>①: 整体性原则</p><p>②: 相关性原则</p><p>③: 有序性原则</p><p>④: 动态性原则</p><p>⑤: 最优化原则</p><p><strong>注: 不包括易用性</strong></p><h3 id="7-3-大项目和普通项目区别"><a href="#7-3-大项目和普通项目区别" class="headerlink" title="7.3 大项目和普通项目区别"></a>7.3 大项目和普通项目区别</h3><p>大项目注重过程, <strong>先指定过程计划,再制定活动计划</strong></p><p><strong>即先确定用什么方法和过程,再平衡成本和收益</strong></p><h2 id="八、项目整体管理"><a href="#八、项目整体管理" class="headerlink" title="八、项目整体管理:"></a>八、项目整体管理:</h2><p>项目整合管理包括为识别、定义、组合、统一和协调各<a href="http://www.hihexo.com/pmp/chapter/128.htm" target="_blank" rel="noopener">项目管理过程组</a>的各种过程和活动而开展的过程与活动。在项目管理中，“整合”兼具统一、合并、沟通和集成的性质，对受控项目从执行到完成、成功管理干系人期望和满足项目要求，都至关重要。项目整合管理包括选择资源分配方案、平衡相互竞争的目标和方案，以及管理项目管理知识领域之间的依赖关系。虽然各项目管理过程通常以界限分明、相互独立的形式出现，但在实践中它们会以本指南无法全面叙述的方式相互交叠、相互作用。</p><p><a href="http://www.hihexo.com/pmp/chapter/137.htm" target="_blank" rel="noopener">4.1</a><a href="http://www.hihexo.com/pmp/chapter/137.htm" target="_blank" rel="noopener">制定项目章程</a>——编写一份正式<strong>批准项目并授权</strong>项目经理在项目活动中使用组织资源的文件的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/154.htm" target="_blank" rel="noopener">4.2</a>制定项目管理计划——定义、准备和协调所有子计划，并把它们整合为一份综合 <a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>的过程。<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>包括经过整合的<a href="http://www.hihexo.com/pmp/chapter/1105.htm" target="_blank" rel="noopener">项目基准</a>和子计划。</p><p><a href="http://www.hihexo.com/pmp/chapter/165.htm" target="_blank" rel="noopener">4.3</a>指导与管理项目工作——为实现项目目标而领导和执行<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>中所确定的工作，并实施已批准变更的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/183.htm" target="_blank" rel="noopener">4.4</a>监控项目工作——<strong>跟踪、审查和报告</strong>项目进展，以实现<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>中确定的绩效目标的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/278.htm" target="_blank" rel="noopener">4.5</a>实施整体变更控制——审查所有<a href="http://www.hihexo.com/pmp/chapter/179.htm" target="_blank" rel="noopener">变更请求</a>，批准变更，管理对<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>、<a href="http://www.hihexo.com/pmp/chapter/108.htm" target="_blank" rel="noopener">组织过程资产</a>、<a href="http://www.hihexo.com/pmp/chapter/1102.htm" target="_blank" rel="noopener">项目文件</a>和<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>的变更，并对变更处理结果进行沟通的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/295.htm" target="_blank" rel="noopener">4.6</a>结束项目或阶段——完结所有<a href="http://www.hihexo.com/pmp/chapter/128.htm" target="_blank" rel="noopener">项目管理过程组</a>的所有活动，以正式结束项目或阶段的过程。</p><p>通过考虑为完成项目而开展的其他类型的活动，可以更好地理解项目与项目管理的整合性质。以下是项目管理团队所开展的活动的例子：</p><p>确定、审查、分析并理解范围。包括项目需求、产品需求、准则、<a href="http://www.hihexo.com/pmp/chapter/1124.htm" target="_blank" rel="noopener">假设条件</a>、<a href="http://www.hihexo.com/pmp/chapter/1123.htm" target="_blank" rel="noopener">制约因素</a>和可能影响项目的其他因素，以及如何管理和处理这些内容。</p><p>使用结构化的方法（如PMBOK®指南中所述的方法）把收集到的项目信息转化为<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>。</p><p>开展活动，以产生项目的<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>。</p><p>测量和监督项目进展，并采取适当措施以实现项目目标。</p><p>在<a href="http://www.hihexo.com/pmp/chapter/128.htm" target="_blank" rel="noopener">项目管理过程组</a>的各过程间，经常反复发生联系。例如，在项目早期，规划过程组为执行过程组提供书面的<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>；然后，随着项目的进展，规划过程组还将根据变更情况，更新<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>。</p><h3 id="8-1-事业环境因素"><a href="#8-1-事业环境因素" class="headerlink" title="8.1 事业环境因素:"></a>8.1 事业环境因素:</h3><p>①: 国家标准或行业<strong>标准</strong><br>②: <strong>帮助管理项目的工具</strong>(<strong>项目管理信息系统</strong>)<br>③: 实施单位的<strong>企业文化</strong>和组织机构<br>④: <strong>市场状况</strong><br>⑤: 行业数据库<br>⑥: 现有<strong>设施</strong>和固定资产等<br>⑦: 项目干系人对风险的承受力</p><h3 id="8-2-组织过程资产"><a href="#8-2-组织过程资产" class="headerlink" title="8.2 组织过程资产"></a>8.2 组织过程资产</h3><p><strong>①: 变更控制流程 </strong>  项目团队可以   <strong>选择,增补</strong>   是   <strong>组织过程资产范畴</strong><br><strong>②: 合同 也 属于 组织过程资产</strong><br><strong>③: 产品组件标准 也 属于 组织过程资产</strong><br><strong>④: 以往项目的经验教训</strong></p><p><strong>组织内部形成的 而不是全行业 的 统一标准 则不能算组织过程资产</strong>.</p><p><strong>口诀: 合同教训 是 组织,叫鸡验指纹</strong></p><h3 id="8-3-五大过程组-47个子过程"><a href="#8-3-五大过程组-47个子过程" class="headerlink" title="8.3 五大过程组,47个子过程"></a>8.3 五大过程组,47个子过程</h3><h4 id="8-3-1-启动过程组-项目启动"><a href="#8-3-1-启动过程组-项目启动" class="headerlink" title="8.3.1 启动过程组(项目启动)"></a>8.3.1 启动过程组(项目启动)</h4><p><strong>定义并批准</strong>项目或项目阶段, <strong>制定项目章程,和识别项目干系人</strong></p><h4 id="8-3-2-计划过程组-指定项目计划"><a href="#8-3-2-计划过程组-指定项目计划" class="headerlink" title="8.3.2 计划过程组(指定项目计划)"></a>8.3.2 计划过程组(指定项目计划)</h4><p>①: 建立WBS 和 WBS字典<br>②: 项目风险分析<br>③: 定义和细化目标,规划最佳的行动方案.</p><p>活动排序</p><h4 id="8-3-3-执行过程组-指导和管理项目执行"><a href="#8-3-3-执行过程组-指导和管理项目执行" class="headerlink" title="8.3.3 执行过程组(指导和管理项目执行)"></a>8.3.3 执行过程组(指导和管理项目执行)</h4><p>项目团队的组建<br>项目质量保证<br>询价<br>卖方选择</p><h4 id="8-3-4-监督和控制组"><a href="#8-3-4-监督和控制组" class="headerlink" title="8.3.4 监督和控制组"></a>8.3.4 监督和控制组</h4><h4 id="8-3-5-项目收尾"><a href="#8-3-5-项目收尾" class="headerlink" title="8.3.5 项目收尾"></a>8.3.5 项目收尾</h4><p>合同收尾<br>管理收尾 : 也叫行政收尾,覆盖整个项目,阶段完成或项目完成都需要收尾(包括项目评价,总结经验教训,归档项目文件等)指导项目收尾的程序和方法, 包括收尾的所有活动 及角色 职责.</p><h3 id="8-4-项目管理计划过程的输入"><a href="#8-4-项目管理计划过程的输入" class="headerlink" title="8.4 项目管理计划过程的输入"></a>8.4 项目管理计划过程的输入</h3><p>①: 项目章程:  用于确定项目地位,对项目经理授权<br>②: 事业环境因素<br>③: 组织过程资产</p><h3 id="8-5-项目初步范围说明书内容"><a href="#8-5-项目初步范围说明书内容" class="headerlink" title="8.5 项目初步范围说明书内容:"></a>8.5 项目初步范围说明书内容:</h3><p><strong>①: 产品范围描述</strong><br><strong>②: 项目需求和可交付成果</strong><br>⑤: 产品或服务的需求和特点<br><strong>⑥: 制约因素</strong><br><strong>⑦: 假设条件</strong><br>⑧: 初始WBS<br>⑨: 成本概算<br>⑩: <strong>验收标准</strong><br>⑩: 进度里程碑<br>⑩: 项目边界<br>⑩: 最初定义的风险 </p><h3 id="8-6-项目工作说明书SOW内容"><a href="#8-6-项目工作说明书SOW内容" class="headerlink" title="8.6 项目工作说明书SOW内容:"></a>8.6 项目工作说明书SOW内容:</h3><p>SOW：对内部项目而言，由项目发起人提出；对外部项目而言，可以作为投标文档一部分从客户那里得到</p><p>①: <strong>业</strong>务需求: 一个组织的业务需求可能是培训,市场需求技术进步,法律需求或政府的标准</p><p>②: <strong>产</strong>品范围描述: 记录项目所要创建的产品的需求,以及产品或服务的特性.</p><p>③: 项目目标,<strong>战</strong>略计划: 所有项目都要支持组织的战略目标,执行组织要把战略计划作为项目选择的一个要素来考虑.</p><p><strong>口诀: 爷参战。</strong></p><h3 id="8-7-项目收尾的输出"><a href="#8-7-项目收尾的输出" class="headerlink" title="8.7 项目收尾的输出:"></a>8.7 项目收尾的输出:</h3><p>①: 合同收尾章程<br>②: 管理收尾章程<br>③: 组织过程资产更新</p><h3 id="8-8-合同收尾-的内容"><a href="#8-8-合同收尾-的内容" class="headerlink" title="8.8 合同收尾  的内容"></a>8.8 合同收尾  的内容</h3><p>项目验收</p><h3 id="8-9-项目评估"><a href="#8-9-项目评估" class="headerlink" title="8.9 项目评估"></a>8.9 项目评估</h3><p>主要由<strong>第三方实施</strong>, 而不是由建设方,承建方等</p><p><strong>主要特征:</strong><br>①: 整体性 : 综合集成经济,环境 ,风险,技术运行<br>②: 目标性<br>③: 相关性: 时间,知识,逻辑<br>④: 动态性: 项目生命周期</p><p><strong>依据: </strong></p><p>①: 项目建议书</p><p>②: 项目可行性研究报告</p><p>③: 报送单位的申请报告及主管部门的初审意见</p><p>④: 有关资源,配件,燃料,水,电等方面的协议文件</p><p><strong>注: 不包括项目变更管理策略</strong></p><h3 id="8-10-项目管理计划的内容"><a href="#8-10-项目管理计划的内容" class="headerlink" title="8.10 项目管理计划的内容:"></a>8.10 项目管理计划的内容:</h3><p>①: 范围基准: 范围说明书,WBS,WBS字典</p><p>②: 进度基准</p><p>③: 成本基准</p><p>④: 其他管理计划</p><p><strong>注: 项目绩效信息</strong> 是在 项目执行中产生的,<strong>不包括</strong>在项目管理计划中</p><h3 id="8-11-项目监控工作成果"><a href="#8-11-项目监控工作成果" class="headerlink" title="8.11 项目监控工作成果:"></a>8.11 项目监控工作成果:</h3><p>变更请求<br>工作绩效报告<br>项目管理计划更新<br>项目文件更新</p><p>注: 工作绩效报告  能提供当前项目的状态与预测项目状态的比较.</p><h3 id="8-12-项目章程的内容-很重要"><a href="#8-12-项目章程的内容-很重要" class="headerlink" title="8.12 项目章程的内容: (很重要)"></a>8.12 项目章程的内容: (很重要)</h3><p>项目章程包含来源于商业文件中的相关项目信息。既然商业文件不是项目文件，<strong>项目经理就不可以对它们进行更新或修改</strong>，<strong>只可以提出相关建议</strong>, <strong>本过程仅开展一次或仅在<a href="http://hellokittycn.com/chapter/77" target="_blank" rel="noopener">项目</a>的预定义点开展。</strong></p><p>指定项目经理及授权级别<br>概要的里程碑计划<br>干系人的影响<br>职能组织<br>项目目的或论证结果<br>商业需求,产品需求,项目需求,项目概述<br>概要预算<br>假设及约束条件<br>项目的业务方案<br>投资回报率</p><p>总结: 各种需求</p><p>作用: </p><p>①: 确定项目经理,规定项目经理的权利</p><p>②: 正式确认项目的存在,给项目一个合法的地位</p><p>③: 规定项目的总体目标,包括范围,质量,成本,时间等</p><p>④:  通过叙述项目启动的理由,把项目与执行组织的日常经营运作及战略计划联系起来.</p><h3 id="8-13-项目文件"><a href="#8-13-项目文件" class="headerlink" title="8.13 项目文件:"></a>8.13 项目文件:</h3><p>①: 质量管理计划</p><p>②: 范围管理计划</p><p>③: 进度管理计划</p><p>④: 成本管理计划</p><h2 id="九、项目范围管理"><a href="#九、项目范围管理" class="headerlink" title="九、项目范围管理:"></a>九、项目范围管理:</h2><p>项目范围管理包括确保项目做且只做所需的全部工作，以成功完成项目的各个过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/311.htm" target="_blank" rel="noopener">5.1</a>规划范围管理——创建<a href="http://www.hihexo.com/pmp/chapter/321.htm" target="_blank" rel="noopener">范围管理计划</a>，书面描述将如何定义、确认和控制项目范围的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/323.htm" target="_blank" rel="noopener">5.2</a>收集需求——为实现项目目标而确定、记录并管理干系人的需要和需求的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/347.htm" target="_blank" rel="noopener">5.3</a>定义范围——制定项目和产品详细描述的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/361.htm" target="_blank" rel="noopener">5.4</a>创建 WBS——将项目<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>和项目工作分解为较小的、更易于管理的组件的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/376.htm" target="_blank" rel="noopener">5.5</a>确认范围——正式验收已完成的项目<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/392.htm" target="_blank" rel="noopener">5.6</a>控制范围——监督项目和产品的范围状态，管理<a href="http://www.hihexo.com/pmp/chapter/374.htm" target="_blank" rel="noopener">范围基准</a>变更的过程。</p><p>在项目环境中，“范围”这一术语有两种含义：</p><p>产品范围——某项产品、服务或成果所具有的特性和功能。</p><p>项目范围——为交付具有规定特性与功能的产品、服务或成果而必须完成的工作。项目范围有时也包括产品范围。</p><p>管理项目范围所需的各个过程及支持工具与技术，会因项目而异。经过批准的项目<a href="http://www.hihexo.com/pmp/chapter/359.htm" target="_blank" rel="noopener">范围说明书</a>、<a href="http://www.hihexo.com/pmp/chapter/1113.htm" target="_blank" rel="noopener">工作分解结构</a>（WBS）和相应的<a href="http://www.hihexo.com/pmp/chapter/1114.htm" target="_blank" rel="noopener">WBS词典</a>构成项目<a href="http://www.hihexo.com/pmp/chapter/374.htm" target="_blank" rel="noopener">范围基准</a>。只有通过正式变更控制流程才能进行基准变更。在开展<a href="http://www.hihexo.com/pmp/chapter/376.htm" target="_blank" rel="noopener">确认范围</a>、<a href="http://www.hihexo.com/pmp/chapter/392.htm" target="_blank" rel="noopener">控制范围</a>及其他控制过程时，基准被用作比较的基础。</p><p>应该根据<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>（见<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">4.2.3.1</a>节）来衡量项目范围的完成情况，根据产品需求（见<a href="http://www.hihexo.com/pmp/chapter/323.htm" target="_blank" rel="noopener">5.2</a>节）来衡量产品范围的完成情况。项目范围管理各过程需要与其他知识领域中的过程整合起来，以确保项目工作能实现规定的产品范围。</p><h3 id="9-1-WBS的3种分解方法"><a href="#9-1-WBS的3种分解方法" class="headerlink" title="9.1 WBS的3种分解方法:"></a>9.1 WBS的3种分解方法:</h3><p>一般是滚动式滚则,不是一开始就将所有活动直接分解到工作包.</p><p>①: <strong>生命周期的各阶段</strong>作为分解的第二层,可交付性成果在第三层</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.3.png" alt="3"></p><p>②: <strong>主要可交付性成果</strong>在第二层</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.4.png" alt="4"></p><p>③:  子项目安排在第一层,再分解子项目的WBS</p><h3 id="9-2-WBS的分解过程注意事项"><a href="#9-2-WBS的分解过程注意事项" class="headerlink" title="9.2 WBS的分解过程注意事项:"></a>9.2 WBS的分解过程注意事项:</h3><p>①: 必须<strong>面向交付成果</strong></p><p>②: <strong>只由一个人负责</strong>,尽管可能多人参与</p><p>③: 任务分解应该控制在<strong>4~6层</strong></p><p>④: <strong>分包</strong>出去的工作,和<strong>项目管理</strong>工作也在WBS中</p><p>⑤: 并非一成不变</p><p>④: <strong>工作单元从属唯一</strong>,也就是一个工作单元只能从属于某个上层单元,避免交叉从属</p><p>⑤: <strong>相同层次的工作单元有相同的性质</strong></p><p>⑥:WBS的编制需要所有(主要)项目干系人的参与</p><p>⑦: 最底层应该具有可比性,可定量检查.</p><p>⑧: 工作单元应该能区分不同的责任者和不同的工作内容.</p><p>⑨: 树型结构不适合大型项目</p><p>⑨: 工作包8/80是一个推荐做法</p><p>⑨: 每个工作包不一定都要分配给一个成员,没有此规定,也就是 <strong>可以不分配</strong></p><p>注: WBS中<strong>必须包含全部工作内容</strong>,即100%原则,未包括的则不属于项目范围,如果要增加必须遵循变更流程.</p><p><strong>大项目的WBS分解</strong>,可按照产品结构,生命周期,3个层次制定分解,<strong>不包含风险分解结构.</strong></p><h3 id="9-3-WBS过程的功能"><a href="#9-3-WBS过程的功能" class="headerlink" title="9.3 WBS过程的功能:"></a>9.3 WBS过程的功能:</h3><p>①: <strong>责任分工明确</strong><br>②: 定义<strong>绩效考核</strong>和控制基线<br>③: 提高成本、时间和资源<strong>估算的准确度</strong><br>④: 识别可交付成果和工作包</p><p><strong>物料清单:</strong> 描述一个产品所需要的实际部件,组件和构件的分级表格.</p><h3 id="9-4-项目范围基线"><a href="#9-4-项目范围基线" class="headerlink" title="9.4 项目范围基线:"></a>9.4 项目范围基线:</h3><p>①: 批准的项目范围说明书<br>②: WBS<br>③: WBS字典:  提供WBS要素的详细信息.</p><h3 id="9-5-工作包"><a href="#9-5-工作包" class="headerlink" title="9.5 工作包"></a>9.5 工作包</h3><p>①: 工作包是<strong>进度安排和成本估算</strong>,资源需求及控制的依据,是<strong>底层单元</strong></p><p>②: 工作包<strong>必须</strong>是<strong>具体的</strong></p><p>注: 子项目一般还是很大,不是工作包,工作包是底层单元.</p><h3 id="9-6-需求跟踪矩阵"><a href="#9-6-需求跟踪矩阵" class="headerlink" title="9.6 需求跟踪矩阵:"></a>9.6 需求跟踪矩阵:</h3><p>目的: <strong>追溯</strong>需求实现情况,和<strong>回溯</strong>需求来源,而<strong>不是确认需求</strong></p><p>可改善产品质量,降低维护成本,容易实现重用</p><p><strong>回溯:</strong> 又称逆向跟踪, 检查设计文档,代码测试用例等是否能在<strong>&lt;&lt;产品需求规格说明书&gt;&gt;</strong>中找到出处</p><p>总结: 追溯:  是跟踪需求,以免需求被做漏,做偏;</p><p>回溯:  是查需求的源头,了解为什么要做这个需求</p><p><strong>口诀: 追漏回源</strong></p><h3 id="9-7-项目范围说明书"><a href="#9-7-项目范围说明书" class="headerlink" title="9.7 项目范围说明书:"></a>9.7 项目范围说明书:</h3><p>包含产品范围 和  项目范围</p><p>范围说明书的<strong>输入是  : 项目章程 </strong></p><p>范围说明书的 <strong>主要内容: 可交付成果,项目目标</strong></p><blockquote><p>项目范围说明书的详细介绍</p><p>它进一步并且正式明确了项目所应该产生的成果和项目可交付的特征，并在此基础上进一步明确和规定了项目<a href="https://baike.baidu.com/item/%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E8%80%85/11056660" target="_blank" rel="noopener">利益相关者</a>之间希望达成共识的项目范围，为未来项目的<a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96/1513" target="_blank" rel="noopener">决策</a>提供一个管理基线。</p><p>在进行范围确定前，一定要有范围<a href="https://baike.baidu.com/item/%E8%AF%B4%E6%98%8E%E4%B9%A6" target="_blank" rel="noopener">说明书</a>，因为范围说明书详细说明了为什么要进行这个项目，明确了项目的目标和主要的可交付成果，是项目班子和任务委托者之间签订协议的基础，也是未来项目实施的基础，并且随着项目的不断实施进展，需要对范围说明进行修改和细化，以反映项目本身和外部环境的变化。在实际的项目实施中，不管是对于项目还是<a href="https://baike.baidu.com/item/%E5%AD%90%E9%A1%B9%E7%9B%AE" target="_blank" rel="noopener">子项目</a>，项目管理人员都要编写其各自的项目范围说明书。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>详细的项目范围说明书应包含产品的范围描述、验收标准、可交付成果、项目的主要责任、制约因素、假设条件。</p><p>具体来看，项目的范围说明书主要应该包括以下三个方面的内容：</p><h3 id="项目的合理性说明"><a href="#项目的合理性说明" class="headerlink" title="项目的合理性说明"></a>项目的合理性说明</h3><p>1．项目的合理性说明。即解释为什么要实施这个项目，也就是实施这个项目的目的是什么。项目的合理性说明为将来提供了评估各种利弊关系的基础。</p><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><p>2．项目目标。前面已经讲过，<a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87" target="_blank" rel="noopener">项目目标</a>是所要达到的项目的<a href="https://baike.baidu.com/item/%E6%9C%9F%E6%9C%9B%E4%BA%A7%E5%93%81" target="_blank" rel="noopener">期望产品</a>或服务，确定了项目目标，也就确定了成功实现项目所必须满足的某些数量标准。项目目标至少应该包括费用、时间进度和技术性能或质量标准。当项目成功地完成时，必须向他人表明，项目事先设定的目标均已达到。值得注意的一点是，如果项目目标不能够被量化，则要承担很大的风险</p><h3 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h3><p>3．项目可交付成果清单。如果列入项目<a href="https://baike.baidu.com/item/%E5%8F%AF%E4%BA%A4%E4%BB%98%E6%88%90%E6%9E%9C" target="_blank" rel="noopener">可交付成果</a>清单的事项一旦被完满实现，并交付给使用者——项目的中间用户或最终用户，就标志着项目阶段或项目的完成。例如，某软件开发项目的可交付成果有能运行的电脑程序、用户手册和帮助用户掌握该电脑软件的交互式教学程序。但是如何才能得到他人的承认呢？这就需要向他们表明项目事先设立的目标均已达到，至少要让他们看到原定的费用、进度和质量均已达到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>一般来说，项目范围说明书要由项目班子来编写，而且在编写项目范围说明书时，项目班子需要在实际工作中考虑限制或制约自己行动的各种因素。例如，准备采取的行动是否有可能违背本组织的既定方针。</p><p>在编写项目范围说明书时必须有项目的成果说明书，以作为范围规划的前提依据。所谓成果，是指任务的委托者在项目结束或者项目某个阶段结束时要求项目班子交出的成果。比如，对于某软件开发项目来说，要求设计规划部门交出全部开发的<a href="https://baike.baidu.com/item/%E5%8F%AF%E4%BA%A4%E4%BB%98%E6%88%90%E6%9E%9C" target="_blank" rel="noopener">可交付成果</a>。显然，对于这些要求交付的成果都必须有明确的要求和说明。</p><p>范围说明书因项目类型的不同而不同。规模大、内容复杂的项目，其范围说明书也可能会很长。政府项目通常会有一个被称作<a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E8%AF%B4%E6%98%8E%E4%B9%A6" target="_blank" rel="noopener">工作说明书</a>（<a href="https://baike.baidu.com/item/SOW" target="_blank" rel="noopener">SOW</a>）的范围说明。有的工作说明书可以长达几百页，特别是要对产品进行详细说明的时候。总之，范围说明书应根据实际情况做适当的调整以满足不同的、具体的项目的需要。</p></blockquote><h4 id="9-7-1-产品范围和-项目范围的区别"><a href="#9-7-1-产品范围和-项目范围的区别" class="headerlink" title="9.7.1 产品范围和 项目范围的区别:"></a>9.7.1 产品范围和 项目范围的区别:</h4><p><strong>产品范围: 产品或 服务所应该包含的功能</strong></p><p><strong>项目范围: 为了能交付产品,项目所必须做的工作.</strong></p><h3 id="9-8-创建WBS的输入"><a href="#9-8-创建WBS的输入" class="headerlink" title="9.8 创建WBS的输入:"></a>9.8 创建WBS的输入:</h3><p>①: 范围管理计划<br>②: 项目范围说明书<br>③: 需求文件<br>④: 组织过程资产</p><h3 id="9-9-范围确认的输入"><a href="#9-9-范围确认的输入" class="headerlink" title="9.9 范围确认的输入:"></a>9.9 范围确认的输入:</h3><p>①: 项目范围说明书<br>②: WBS<br>③: 项目范围管理计划<br>④: 可交付物(可交付成果)</p><h4 id="9-9-范围确认和项目收尾区别"><a href="#9-9-范围确认和项目收尾区别" class="headerlink" title="9.9 范围确认和项目收尾区别:"></a>9.9 范围确认和项目收尾区别:</h4><p>范围确认 强调 核实与接受 可交付成果, 以及验收可交付成果</p><p>项目收尾 强调 结束项目所要做的流程性工作, 以及验收产品</p><h3 id="9-10-WBS字典"><a href="#9-10-WBS字典" class="headerlink" title="9.10 WBS字典:"></a>9.10 WBS字典:</h3><p>包括账户编码,工作描述,执行组织,里程碑列表,资源需求,成本估算,活动列表等是对工作包的细节描述.<br><strong>不包含管理储备</strong></p><h3 id="9-11-控制账户"><a href="#9-11-控制账户" class="headerlink" title="9.11 控制账户:"></a>9.11 控制账户:</h3><p>控制账户是一个<strong>管理控制点</strong>,在该控制点上,把范围预算,实际成本和进度加以整合,并与挣值比较,以<strong>测量绩效.</strong></p><p>每个工作包分配到一个控制账户,并根据”账户编码”为工作包建立唯一的标识,是<strong>创建WBS的最后一步.</strong></p><p><strong>每个控制账户可能包括一个或多个工作包</strong>,但<strong>一个工作包只能属于一个控制账户.</strong></p><h3 id="9-12-追溯和回溯区别"><a href="#9-12-追溯和回溯区别" class="headerlink" title="9.12 追溯和回溯区别:"></a>9.12 追溯和回溯区别:</h3><p>追溯: 客户需求向前追溯到需求, <strong>跟踪需求,以免被做漏做偏</strong></p><p>回溯: 从需求回溯相应的客户需求, <strong>查清需求源头</strong>,了解为什么要做这个需求</p><p><strong>需求跟踪: </strong>主要不是 确认需求,而是 追溯需求实现情况 和回溯需求来源.</p><h3 id="9-13-需求开发五过程"><a href="#9-13-需求开发五过程" class="headerlink" title="9.13 需求开发五过程:"></a>9.13 需求开发五过程:</h3><p>顺序如下:</p><p>①: 需求获取:   提炼出符合解决问题的用户需求,——-产生&lt;&lt;用户需求说明书&gt;&gt;</p><p>②: 分析: 对需求分析并抽象描述,建立概念模型</p><p>③: 定义:  根据分析的结果,进一步定义准确无误的产品需求,——产生&lt;&lt;需求规格说明书&gt;&gt;</p><p>④: 验证:  开发方和用户共同 对需求文档评审,双方达成共识后作出书面承诺,使需求文档具有商业合同的效果</p><p>⑤: 确定需求基线</p><p><strong>注:</strong>  <strong>先分析后定义</strong></p><p><strong>注: 需求阶段,应该编制 需求规格说明书, 初步用户手册, 数据要求说明.</strong></p><p><strong>需求规格说明书</strong> 需要经过<strong>阶段评审 和 技术评审</strong>后建立基线,它是阶段测试 和后续开发的重要基础.<strong>不能只通过同行评审</strong>就建立基线</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.56.png" alt="56"></p><h3 id="9-14-范围确认和-质量控制"><a href="#9-14-范围确认和-质量控制" class="headerlink" title="9.14 范围确认和 质量控制:"></a>9.14 范围确认和 质量控制:</h3><p>质量控制: 核实工作结果<strong>正确</strong>与否</p><p>范围确认: 有关工作结果是否<strong>可接受</strong> </p><p>质量保证: <strong>建立</strong>对未来输出或<strong>正在进行的工作</strong>在<strong>完工时满足特定需求和期望的信心</strong>.</p><p><strong>简言之: 控制正确性,确认可接受,保证信心.</strong></p><p><strong>口诀: 孔雀忍受暴行</strong></p><p>例如: ①对详细的范围说明书进行评审,提交客户签字确认<br>②:与客户开展审查,判断工作和交付成果是否符合标准.</p><h3 id="9-15-范围控制"><a href="#9-15-范围控制" class="headerlink" title="9.15 范围控制:"></a>9.15 范围控制:</h3><p>作用: 防止范围蔓延(范围蔓延就是范围不受控制)<br>例: 客户提出新的需求时,说服他放弃新需求</p><p>①: 影响导致范围变更的因素</p><p>②: 确保所有被请求的变更按照项目整体变更控制流程处理.</p><p>③: 范围变更发生时进行管理</p><p><strong>注: 不包括确定范围变更是否已经发生.</strong></p><h3 id="9-16-滚动式计划"><a href="#9-16-滚动式计划" class="headerlink" title="9.16 滚动式计划"></a>9.16 滚动式计划</h3><p>创建工作分解结构时,<strong>近期的要分解详细,以便于安排核实,</strong>远期的可以放一个规划包,滚动规划和分解.</p><h3 id="9-17-项目范围管理的流程"><a href="#9-17-项目范围管理的流程" class="headerlink" title="9.17 项目范围管理的流程:"></a>9.17 项目范围管理的流程:</h3><p>顺序如下:<br>①: 收集需求<br>②: 定义范围<br>③: 创建工作分解结构<br>④: 核实范围<br>⑤: 控制范围</p><h3 id="9-18-范围管理和时间管理的顺序"><a href="#9-18-范围管理和时间管理的顺序" class="headerlink" title="9.18 范围管理和时间管理的顺序:"></a>9.18 范围管理和时间管理的顺序:</h3><p><strong>范围规划——&gt;范围定义——-&gt;活动定义——-&gt;活动排序——–&gt;活动历时估算</strong></p><p><strong>注: 先规划,后定义</strong></p><h3 id="9-19-工具和技术"><a href="#9-19-工具和技术" class="headerlink" title="9.19 工具和技术"></a>9.19 工具和技术</h3><p>①: 收集需求 的工具: 引导式研讨会,标杆对照</p><p>②: 范围定义 的工具: 引导式研讨会,产品分析</p><p>③: 范围控制的工具: 偏差分析</p><h3 id="9-20-配置控制"><a href="#9-20-配置控制" class="headerlink" title="9.20 配置控制"></a>9.20 配置控制</h3><p>即配置项 和 基线的变更控制,包括下列任务:</p><p>①: 标识记录变更申请</p><p>②: 分析评价变更</p><p>③: 批准或否决申请</p><p>④: 实现、验证和发布已经修改的配置项</p><p><strong>注: 配置控制其实主要内容就是变更控制</strong></p><p>项目经理职责: </p><p>①: 确定受变更影响的关联配置项和有关基线</p><p>②: 将变更申请的决议通知受此变更影响的每个干系人</p><p>③: 组织修改配置项,并在相应的文档或程序代码中记录变更信息</p><p>项目经理的作用: 使用赋予项目的资源来实现项目特定目标</p><p>配置管理员职责: </p><p>将变更后的<strong>配置项纳入基线</strong>,并将变更内容和结果通知相关人.</p><p><strong>简言之:</strong><br>项目经理 负责记录变更,确定基线配置项,通知决议给干系人</p><h3 id="9-21-需求的状态值"><a href="#9-21-需求的状态值" class="headerlink" title="9.21 需求的状态值"></a>9.21 需求的状态值</h3><p>①: 已建议: 该需求被有权提出需求的人建立</p><p>②: 已批准: 该需求已经被分析,估计了对项目余下部分的影响,已用一个确定的版本号,或创建编号分配到相关基线中,软件开发团队已经同意实现该需求.</p><p>③: 已实现: 已经实现了代码的设计,编写,单元测试.</p><p>④: 已验证: 使用所选择的方法已验证了实现的需求,例如测试和检测</p><h3 id="9-22-分解"><a href="#9-22-分解" class="headerlink" title="9.22 分解:"></a>9.22 分解:</h3><p>将整个项目工作分解为工作包需要开展以下活动:</p><p>①: 识别和分析可交付成果及相关工作</p><p>②: 确定WBS结构和编排方法</p><p>③: 自上而下逐层细化分解</p><p>④: 为WBS组件制定和分配标识编码</p><p>⑤: 核实可交付成果分解的程度是否恰当.</p><h3 id="9-23-工作说明书与项目范围说明书的区别"><a href="#9-23-工作说明书与项目范围说明书的区别" class="headerlink" title="9.23 工作说明书与项目范围说明书的区别"></a>9.23 工作说明书与项目范围说明书的区别</h3><p>工作说明书是建设方出具的 ,范围说明书是承建方编写 </p><p>工作说明书 不在项目生命周期内</p><p>工作说明书是范围说明的依据。2.范围说明书是在工作说明书的基础制订。 </p><p>工作说明书：是项目对所要提供的产品、成果或服务的描述。<br>采购工作说明书：要详细规定采购的项目，以便替在的卖方确定他们是否有能力提供这些项目。<br>项目范围说明书：描述了项目的可交付物和产生这些可交付物所必须进行的项目工作。 </p><h2 id="十、进度管理"><a href="#十、进度管理" class="headerlink" title="十、进度管理"></a>十、进度管理</h2><p>项目时间管理包括为管理项目按时完成所需的各个过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/409.htm" target="_blank" rel="noopener">6.1</a>规划进度管理——为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/422.htm" target="_blank" rel="noopener">6.2</a>定义活动——识别和记录为完成项目<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>而需采取的具体行动的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/438.htm" target="_blank" rel="noopener">6.3</a>排列活动顺序——识别和记录项目活动之间的关系的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/455.htm" target="_blank" rel="noopener">6.4</a>估算活动资源——估算执行各项活动所需材料、人员、设备或用品的种类和数量的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/476.htm" target="_blank" rel="noopener">6.5</a>估算活动持续时间——根据资源估算的结果，估算完成单项活动所需工作时段数的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/498.htm" target="_blank" rel="noopener">6.6</a><a href="http://www.hihexo.com/pmp/chapter/498.htm" target="_blank" rel="noopener">制定进度计划</a>——分析活动顺序、持续时间、资源需求和进度<a href="http://www.hihexo.com/pmp/chapter/1123.htm" target="_blank" rel="noopener">制约因素</a>，创建项目进度模型的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/529.htm" target="_blank" rel="noopener">6.7</a>控制进度——监督项目活动状态，更新项目进展，管理<a href="http://www.hihexo.com/pmp/chapter/523.htm" target="_blank" rel="noopener">进度基准</a>变更，以实现计划的过程。</p><p>通过把填有项目数据的进度规划工具看做<strong>进度模型</strong>，可以把项目进度的呈现形式（进度计划）与产生<a href="http://www.hihexo.com/pmp/chapter/524.htm" target="_blank" rel="noopener">项目进度计划</a>（见<a href="http://www.hihexo.com/pmp/chapter/524.htm" target="_blank" rel="noopener">6.6.3.2</a>节）的进度数据（见<a href="http://www.hihexo.com/pmp/chapter/525.htm" target="_blank" rel="noopener">6.6.3.3</a>节）和计算工具区分开来。进度模型是项目活动执行计划的一种表示形式，其中包含持续时间、依赖关系和其他规划信息，用以生成<a href="http://www.hihexo.com/pmp/chapter/524.htm" target="_blank" rel="noopener">项目进度计划</a>及其他进度资料。关于进度模型的更多信息，参阅《进度计划实践标准》</p><p>在<a href="http://www.hihexo.com/pmp/chapter/421.htm" target="_blank" rel="noopener">进度管理计划</a>中规定项目时间管理的各过程及其工具与技术。通过<a href="http://www.hihexo.com/pmp/chapter/154.htm" target="_blank" rel="noopener">制定项目管理计划</a>过程（见<a href="http://www.hihexo.com/pmp/chapter/154.htm" target="_blank" rel="noopener">4.2</a>节），把<a href="http://www.hihexo.com/pmp/chapter/421.htm" target="_blank" rel="noopener">进度管理计划</a>整合进<a href="http://www.hihexo.com/pmp/chapter/164.htm" target="_blank" rel="noopener">项目管理计划</a>，成为其中的一个子计划。<a href="http://www.hihexo.com/pmp/chapter/421.htm" target="_blank" rel="noopener">进度管理计划</a>确定进度规划的方法和工具（图6-2），并为编制和控制进度计划建立格式和准则。在所选的进度规划方法中，规定进度编制工具的框架和算法，以便创建进度模型。一些耳熟能详的进度规划方法包括<a href="http://www.hihexo.com/pmp/chapter/515.htm" target="_blank" rel="noopener">关键路径法</a>（CPM）和<a href="http://www.hihexo.com/pmp/chapter/516.htm" target="_blank" rel="noopener">关键链法</a>（CCM）。</p><p>应该依据定义活动、<a href="http://www.hihexo.com/pmp/chapter/438.htm" target="_blank" rel="noopener">排列活动顺序</a>、<a href="http://www.hihexo.com/pmp/chapter/455.htm" target="_blank" rel="noopener">估算活动资源</a>、估算活动持续时间等过程的输出，并结合用于创建进度模型的进度编制工具，来编制<a href="http://www.hihexo.com/pmp/chapter/524.htm" target="_blank" rel="noopener">项目进度计划</a>。经批准的最终进度计划将作为基准用于控制进度过程（见<a href="http://www.hihexo.com/pmp/chapter/529.htm" target="_blank" rel="noopener">6.7</a>节）。随着项目活动的开展，项目时间管理的大部分工作都将发生在控制进度过程中，以确保项目工作按时完成。</p><h3 id="10-1-进度压缩的原则"><a href="#10-1-进度压缩的原则" class="headerlink" title="10.1 进度压缩的原则"></a>10.1 进度压缩的原则</h3><p>优先压缩关键路径上的活动和每压缩一天需要增加额外费用最小的活动</p><h3 id="10-2-PERT-资源平衡-进度压缩-关键链法"><a href="#10-2-PERT-资源平衡-进度压缩-关键链法" class="headerlink" title="10.2 PERT,资源平衡,进度压缩,关键链法"></a>10.2 PERT,资源平衡,进度压缩,关键链法</h3><p>①: PERT（Program/Project Evaluation and Review Technique）即计划评审技术简单地说，PERT是利用网络分析<strong>制定计划以及对计划予以评价</strong>的技术。它能协调整个计划的各道工序，合理安排人力、物力、时间、资金，加速计划的完成。在现代计划的编制和分析手段上，PERT被广泛地使用，是现代项目管理的重要手段和方法。</p><p>②: 资源平衡:</p><p>使资源利用更合理，会导致进度计划延长<br>调整任务的时间安排以<strong>使得资源不被过分使用</strong>，这被称为资源平衡。<br>资源平衡通常不会被用来缩短进度。</p><p>③: 进度压缩:</p><p>包括赶干、快速跟进。</p><p>赶工：拿资源换时间<br>赶工在项目管理中的定义：对成本和进度进行权衡，确定在尽量少增加费用的前提下最大限度地缩短项目所需要的时间。赶工进度并非总能产生可行的方案，反而常常增加成本。</p><p>赶工原则是“采用优先考虑赶工费用率最低的工作”。</p><p>快速跟进：调整逻辑关系<br>通过对各种逻辑关系<strong>并行</strong>确定来缩短项目周期。在进行项目设计中，当风险不大时，通过精心安排而使项目的前后阶段相互搭接以加快项目进展速度的做法叫快速跟进。</p><p>④: 关键链法: </p><p>是一个进度网络分析技术,<strong>根据有限的资源对项目进度计划进行调整</strong>。</p><h3 id="10-3-赶工和快速跟进的区别"><a href="#10-3-赶工和快速跟进的区别" class="headerlink" title="10.3 赶工和快速跟进的区别:"></a>10.3 赶工和快速跟进的区别:</h3><h3 id="10-4-正态分布"><a href="#10-4-正态分布" class="headerlink" title="10.4 正态分布"></a>10.4 正态分布</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.143.png" alt="143"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.144.png" alt="144"></p><p>### </p><h2 id="十一、成本管理"><a href="#十一、成本管理" class="headerlink" title="十一、成本管理"></a>十一、成本管理</h2><p><strong>估算</strong>————————产物—————————–&gt; <strong>预算</strong>—————–产物———————-&gt; <strong>成本基准</strong></p><p><a href="http://www.hihexo.com/pmp/chapter/552.htm" target="_blank" rel="noopener">项目成本管理</a>包含为使项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程，从而确保项目在批准的预算内完工。</p><p><a href="http://www.hihexo.com/pmp/chapter/553.htm" target="_blank" rel="noopener">7.1</a>规划成本管理——为规划、管理、花费和控制项目成本而制定政策、程序和文档的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/566.htm" target="_blank" rel="noopener">7.2</a>估算成本——对完成项目活动所需资金进行近似估算的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/593.htm" target="_blank" rel="noopener">7.3</a><a href="http://www.hihexo.com/pmp/chapter/593.htm" target="_blank" rel="noopener">制定预算</a>——汇总所有单个活动或<a href="http://www.hihexo.com/pmp/chapter/1120.htm" target="_blank" rel="noopener">工作包</a>的估算成本，建立一个经批准的<a href="http://www.hihexo.com/pmp/chapter/612.htm" target="_blank" rel="noopener">成本基准</a>的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/615.htm" target="_blank" rel="noopener">7.4</a>控制成本——监督项目状态，以更新项目成本，管理<a href="http://www.hihexo.com/pmp/chapter/612.htm" target="_blank" rel="noopener">成本基准</a>变更的过程。</p><h3 id="11-1-成本类型"><a href="#11-1-成本类型" class="headerlink" title="11.1 成本类型"></a>11.1 成本类型</h3><p>①: 可变成本: 如普通员工工资,消耗原材料</p><p>②: 固定成本: 如管理者工资,设备折旧费</p><p>③: 直接成本: <strong>直接归属于项目工作的成本</strong>,如项目使用的物料及设备使用费,项目团队的工资,奖金等,<strong>由项目经理直接控制</strong></p><p>④: 机会成本: 被舍弃的选项中价值最高者</p><p>⑤: 间接成本:  几个项目<strong>共同分摊的成本</strong>,如保安费,公司福利,财务部门费用等</p><p>⑥: 沉没成本: 过去发生且无法回收</p><h3 id="11-2-项目成本-直接成本"><a href="#11-2-项目成本-直接成本" class="headerlink" title="11.2 项目成本(直接成本)"></a>11.2 项目成本(直接成本)</h3><p>需求,设计,开发,实施(部署),上线验收,这些成本一般纳入项目成本.</p><p><strong>可行性研究费用</strong>, <strong>监理费用</strong>都是业主方负责(甲方)的费用,且一般在<strong>立项之前</strong>,所以不能纳入项目成本</p><p><strong>注: 业主方出钱,以及立项之前的成本 都不属于 项目成本</strong></p><h3 id="11-3-成本估算"><a href="#11-3-成本估算" class="headerlink" title="11.3 成本估算"></a>11.3 成本估算</h3><h4 id="11-3-1-成本估算的常用方法"><a href="#11-3-1-成本估算的常用方法" class="headerlink" title="11.3.1 成本估算的常用方法"></a>11.3.1 成本估算的常用方法</h4><p>①: 专家判断</p><p>②: 类比估算: 以<strong>过去类似项目参数值</strong>为基础,来估算当前项目同类参数或指标.</p><p>③: 参数估算(公式法): 利用<strong>历史数据之间的统计关系</strong></p><p><strong>注: 类比 和 参数估算易混淆, 所以 只记住 题目中出现 类似 就是类比估算</strong></p><p>④: 自下而上估算 :先对单个的工作包,进行细致的成本估算,然后向上汇总到更高层次.</p><p><strong>⑤: 三点估算法: </strong>考虑到估算的不确定性和风险<br>最乐观成本: 最好情况的成本</p><p>最可能成本: 比较现实的估算</p><p>最悲观成本: 最差情况的成本</p><p><strong>公式: 预期成本 =  (最乐观+ 4 * 最可能+ 最悲观) / 6</strong></p><p><strong>注:  挣值分析 不是 成本估算的方法,而是 成本控制的工具</strong> </p><h4 id="11-3-2-成本估算的输入"><a href="#11-3-2-成本估算的输入" class="headerlink" title="11.3.2 成本估算的输入"></a>11.3.2 成本估算的输入</h4><p>①: 项目进度管理计划</p><p>②: 项目管理计划</p><p>③: 风险事件</p><p><strong>注: 项目成本绩效报告不属于 成本估算的输入.</strong></p><p><strong>挣值分析法 是成本控制的工具和技术</strong></p><p>成本估算建议在WBS 的最底层进行, WBS 最底层是工作包,是进度安排,成本估计和监控的基础.成本和进度的估算应该在工作包 这一层进行.</p><h3 id="11-3-3-成本估算的内容"><a href="#11-3-3-成本估算的内容" class="headerlink" title="11.3.3 成本估算的内容:"></a>11.3.3 成本估算的内容:</h3><p>分析成本构成结果,找出各种可以<strong>相互替代</strong>的成本,<strong>协调</strong>各成本之间的关系.</p><h3 id="11-3-4-成本估算的步骤"><a href="#11-3-4-成本估算的步骤" class="headerlink" title="11.3.4 成本估算的步骤:"></a>11.3.4 成本估算的步骤:</h3><p>①: 识别并分析项目成本构成科目</p><p>②: 估算每一个成本科目的成本大小</p><p>③: 分析成本估算结果 ,找出各种可以<strong>相互替代</strong>的成本,<strong>协调</strong>各成本之间的关系.</p><h3 id="11-3-5-成本估算的工具和技术"><a href="#11-3-5-成本估算的工具和技术" class="headerlink" title="11.3.5 成本估算的工具和技术"></a>11.3.5 成本估算的工具和技术</h3><p>储备分析</p><h3 id="11-4-成本预算"><a href="#11-4-成本预算" class="headerlink" title="11.4 成本预算"></a>11.4 成本预算</h3><h4 id="11-4-1-输入"><a href="#11-4-1-输入" class="headerlink" title="11.4.1 输入"></a>11.4.1 输入</h4><p>①: 成本管理计划</p><p>②: 范围基准</p><p>③: 活动成本估算</p><p>④: 协议</p><p>⑤: 资源</p><p>⑥: 风险登记册</p><p>⑦: 组织过程资产</p><p>⑧: 项目进度计划</p><h4 id="11-4-2-输出"><a href="#11-4-2-输出" class="headerlink" title="11.4.2 输出:"></a>11.4.2 输出:</h4><p>①: 项目资金需求</p><p>②: 项目文件更新</p><p><strong>③: 成本基准</strong></p><h4 id="11-4-3-成本预算的内容"><a href="#11-4-3-成本预算的内容" class="headerlink" title="11.4.3 成本预算的内容"></a>11.4.3 成本预算的内容</h4><p>将项目的<strong>成本分配到项目的各项具体工作</strong>上属于成本预算</p><p><strong>注: 范围基准   是   创建WBS的输出</strong></p><p>项目的范围基准是 经过批准的项目范围说明书,WBS 和 WBS词典. </p><p>判断项目范围是否完成 需要 范围基准来衡量</p><p>判断产品范围是否完成 需要 根据产品是否满足了产品描述(软件需求规格说明书)来判断.</p><p><strong>总结: XXX基准一般是对应XXX过程的输出</strong></p><h4 id="11-4-4-管理储备"><a href="#11-4-4-管理储备" class="headerlink" title="11.4.4 管理储备:"></a>11.4.4 管理储备:</h4><p>①: <strong>它不是成本基线的一部分</strong>,属于<strong>成本基准外</strong>,但是在<strong>项目预算内.</strong></p><p>②: 由公司<strong>高层</strong>管理</p><p>③: 用来处理<strong>非预期且不确定</strong>事件</p><p>④: <strong>不参加</strong>挣值计算</p><p>⑤: 成本预算过程产生,风险控制过程使用</p><p>####11.4.5 产物: 成本基准计划</p><h4 id="11-4-6-应急储备"><a href="#11-4-6-应急储备" class="headerlink" title="11.4.6 应急储备:"></a>11.4.6 应急储备:</h4><p>①: 由项目经理管理使用</p><p>②: 成本估算过程中产生,风险控制过程使用</p><p>③: 处理 <strong>预期 但 不确定</strong>事件</p><p>其他与上面相反</p><p><strong>注: </strong><br>①: 总预算 ≠ 完工预算BAC<br>②: 总预算 ＝  完工预算BAC  +  管理储备</p><h3 id="11-5-挣值管理EVM"><a href="#11-5-挣值管理EVM" class="headerlink" title="11.5 挣值管理EVM"></a>11.5 挣值管理EVM</h3><p>是把范围,进度,资源绩效综合起来考虑,以评估项目绩效和进展的方法.</p><h4 id="11-5-1-关键指标-即计算公式"><a href="#11-5-1-关键指标-即计算公式" class="headerlink" title="11.5.1 关键指标 即计算公式:"></a>11.5.1 关键指标 即计算公式:</h4><p>PV : 计划值—–&gt;<strong>计划完成</strong>工作的<strong>预算</strong>成本</p><p>PV: (到某一天时应该完成多少活动任务,这就是进度,也可以将进度与资金挂钩,即当到某一天时应该完成的工作量占总工作量的比例等价于应该花掉的前占总资金的比例)将资金平摊到每一天, 当到达某一天时, 计划应该花掉多少钱,这个值就是计划值,也就是说PV的值与时间有关,也就是与进度有关.</p><p>EV: 挣值—–&gt;<strong>已完成</strong>工作的<strong>预算</strong>成本 (已完成 工作的 计划价值 之和)</p><p>EV: 按已经完成的工作量,计划应该花掉多少钱</p><p>AC: 实际成本——&gt;<strong>已完成</strong>工作的<strong>实际</strong>成本</p><p>BAC: 项目的总计划值(完工预算)</p><p>SV : 进度偏差             SV =  EV -  PV</p><p>CV: 成本偏差              CV  = EV  -  AC</p><p>SV 为负数 表示 进度落后,  正数则相反<br>CV 为负数 表示 成本超支,  正数则相反</p><p>SPI : 进度绩效指数          SPI =  EV  /  PV</p><p>CPI: 成本绩效指数        CPI  =  EV  /  AC </p><p>SPI &lt; 1.0   则表示 进度落后, &gt;1.0 则相反<br>CPI &lt; 1.0   则表示 成本超支,  &gt;1.0 则相反</p><p><strong>总结 :  </strong> </p><p><strong>①: SV,CV小于0 则 不好,   SPI,CPI 小于1 则 不好</strong></p><p><strong>②:  SPI,SV 都是 EV 和 PV之间运算,    CPI 和 AC 都是 EV 和 AC 之间运算.</strong></p><p>BAC:  完工预算<br>VAC: 完工偏差</p><p>估算: </p><p>ETC : 完工尚需估算(完成剩余部分)<br>EAC : 完工估算(完成所有工作,所需预期总成本) : </p><p>按照目前的情况继续发展,<strong>完工尚需成本ETC = (BAC - EV) /  CPI</strong><br>当进行纠偏之后: 则CPI = 1 , 所以<strong>ETC = BAC - EV</strong></p><p>当预计剩余工作的CPI与当前一致时,   则 <strong>EAC =  BAC /  CPI </strong></p><p><strong>完工估算EAC = 实际花费AC + 完工尚需估算ETC = AC + (BAC - EV) / CPI</strong></p><p><strong>完工偏差VAC = 完工预算BAC - 完工估算EAC</strong></p><p><strong>注: </strong><br><strong>①: 总预算 ≠ 完工预算BAC     只有 管理储备为0时 总预算 ＝  完工预算BAC </strong><br><strong>②: 总预算 ＝  完工预算BAC  +  管理储备</strong><br><strong>③: 成本基线不包括管理储备,管理储备不参与挣值计算</strong><br><strong>④: 成本基准 = 估算 + 应急储备</strong><br><strong>⑤: 项目预算 = 成本基准 + 管理储备 = 估算 + 应急储备 + 管理储备</strong></p><p>也就是项目总预算包括管理储备,BAC不包括 管理储备.</p><p><strong>完工工期估算=预算工期 / SPI  = 关键路径长度  /  SPI </strong> </p><p>例题</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.67.png" alt="48"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.68.png" alt="48"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.69.png" alt="48"></p><p>例题: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.48.png" alt="48"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.49.png" alt="49"></p><h3 id="11-6-成本预测"><a href="#11-6-成本预测" class="headerlink" title="11.6 成本预测"></a>11.6 成本预测</h3><h3 id="11-7-成本控制"><a href="#11-7-成本控制" class="headerlink" title="11.7 成本控制"></a>11.7 成本控制</h3><p>在项目过程中,对形成成本的要素进行<strong>跟踪,分析,监督,控制和调节.</strong></p><p>内容: 识别可能引起 项目成本 基准计划 发生变动的因素,对这些因素施加影响,以保证该变化朝着有利方向发展,以工作包为单位监督成本实施情况,查找偏差原因,作好实际成本的分析评估工作,对发生成本偏差工作包实施管理,并采取纠正措施,必要时修改项目成本基准计划,同时确保所有变更都准确记录在 成本基准计划中,将核准的成本变更后的 成本基准计划通知项目相关人员.</p><h3 id="11-8-净现值"><a href="#11-8-净现值" class="headerlink" title="11.8 净现值"></a>11.8 净现值</h3><p>指投资方案所产生的<a href="http://baike.baidu.com/view/309657.htm" target="_blank" rel="noopener">现金净流量</a>以<a href="http://baike.baidu.com/view/113105.htm" target="_blank" rel="noopener">资金成本</a>为<a href="http://baike.baidu.com/view/93166.htm" target="_blank" rel="noopener">贴现率</a><a href="http://baike.baidu.com/view/544078.htm" target="_blank" rel="noopener">折现</a>之后与<a href="http://baike.baidu.com/view/4166220.htm" target="_blank" rel="noopener">原始投资额</a>现值的差额。</p><p>例题: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.53.png" alt="53"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.52.png" alt="52"></p><p><strong>①: 净现值  =  未来报酬的总现值  －  初始投资</strong></p><p><strong>②: 净现值 = 净现金 *  折现系数</strong></p><p><strong>折现系数 =  1 /  [ ( 1 + 折现率) ^ N ]</strong></p><p><strong>公式: </strong> <strong>NPV=∑(CI-CO)/(1+i)^t</strong></p><p>NPV：净现值</p><p>CI：各年收益</p><p>CO：各年<a href="http://baike.baidu.com/view/737163.htm" target="_blank" rel="noopener">支出</a></p><p><strong>CI-CO：净现金流量</strong></p><p>t：时间，</p><p>i：<a href="http://baike.baidu.com/view/1037741.htm" target="_blank" rel="noopener">基准收益率</a>（贴现率，基准<a href="http://baike.baidu.com/view/431166.htm" target="_blank" rel="noopener">折现率</a>）</p><p>净现值指标是反映<a href="http://baike.baidu.com/view/1987629.htm" target="_blank" rel="noopener">项目投资</a><a href="http://baike.baidu.com/view/391678.htm" target="_blank" rel="noopener">获利能力</a>的<a href="http://baike.baidu.com/view/605645.htm" target="_blank" rel="noopener">指标</a>。</p><p>决策标准：</p><p>净现值≥0 方案可行；</p><p>净现值&lt;0 方案不可行；</p><p>净现值均&gt;0 净现值最大的方案为最优方案。</p><p><a href="http://baike.baidu.com/view/111718.htm" target="_blank" rel="noopener">净现值法</a>就是按净现值大小来评价方案优劣的一种方法。净<a href="http://baike.baidu.com/view/354965.htm" target="_blank" rel="noopener">现值</a>大于零则方案可行，且净现值越大，方案越优，投资效益越好。</p><p><strong>示例: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.32.png" alt="32"></p><p>设定折现率（基准收益率），即公式中的i 为8%</p><p>2009年，净现值=(0-800)/(1+0.08)= -740.74</p><p>2010年，净现值=(0-600)/(1+0.08)^2= -514.40</p><p>2011年，净现值=(2000-1500)/(1+0.08)^3 = 396.92</p><p>2012年，净现值=(1800-1200)/(1+0.08)^4= 441.02</p><p>2013年，净现值=(1900-1000)/(1+0.08)^5= 612.52</p><p>第五年结束时总净现值NPV= -740.74-514.40+396.92+441.02+612.52=195.32</p><p>例2: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.33.png" alt="33"></p><p>第0期，净现值=(-630)/(1+10%)^0= -630</p><p>第1期，净现值=(330)/(1+10%)^1 = 300</p><p>第2期，净现值= (440)/(1+10%)^2 = 363.6</p><p>NPV= 300+363.6-630=33.6≈34</p><p>例3:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.34.png" alt="34"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.35.png" alt="35"></p><p>方案A: </p><p>第0年(初始投入的成本):  (-30000)/(1+10%)^0=-30000</p><p>第一年: (14000)/(1+10%)^1=12727</p><p>第二年: (19000)/(1+10%)^2=15702</p><p>NPV=-30000+12727+15702=-1571</p><p>同理计算BCD方案.</p><h3 id="11-9-静态投资回收期"><a href="#11-9-静态投资回收期" class="headerlink" title="11.9 静态投资回收期:"></a>11.9 静态投资回收期:</h3><p><strong>不考虑时间价值,计算现金流量到什么时候为正值.</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.37.png" alt="37"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.38.png" alt="38"></p><h3 id="11-10-动态投资回收期"><a href="#11-10-动态投资回收期" class="headerlink" title="11.10 动态投资回收期"></a>11.10 动态投资回收期</h3><p>计算净现值的和什么时候为正值,就截止</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.107.png" alt="107"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.108.png" alt="108"></p><p>例2: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.133.png" alt="133"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.134.png" alt="134"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.135.png" alt="135"></p><h3 id="11-10-计算题"><a href="#11-10-计算题" class="headerlink" title="11.10 计算题:"></a>11.10 计算题:</h3><p><strong>例1: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.8.png" alt="8"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.9.png" alt="9"></p><p>按照目前的情况继续发展,ETC = (BAC - EV) /  CPI<br>EV : 已完成工作的预算成本<br>CPI = EV /  AC</p><p><strong>例2: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.10.png" alt="10"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.11.png" alt="11"></p><p>题目中说: </p><p>PV: 计划值, 与进度有关(一般与时间或者完成工作量有关).<br>一般指 到了某个工作日,完成当期计划进度的100%后, 此时应该使用了多少 资金.<br>此题而言:  PV =  40万 * ( 30 / 40 ) = 30 万, 也就是说,计划40天完成,且预算资金40万的情况下,那么,在第30天的时候且此时已经完成了30天所必须完成的工作量后 总共会用掉30万. </p><p>AC: 实际成本,与成本有关.</p><p><strong>例3:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.12.png" alt="12"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.13.png" alt="13"></p><p><strong>例4: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.14.png" alt="14"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.15.png" alt="15"></p><p><strong>例5:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.36.png" alt="36"></p><p>AC = 1000 + 2500 + 10000 + 15000 = 28500</p><p>EV = 1000*100%+3000*100%+8000*100%+13000*90%=23700</p><p>CPI=EV/AC=0.83</p><h3 id="11-11-控制成本的输入"><a href="#11-11-控制成本的输入" class="headerlink" title="11.11 控制成本的输入"></a>11.11 控制成本的输入</h3><p>①: 项目资金需求</p><h3 id="11-12-控制成本的输出"><a href="#11-12-控制成本的输出" class="headerlink" title="11.12 控制成本的输出"></a>11.12 控制成本的输出</h3><p>①: 工作绩效</p><p>②: 成本预测</p><p>③: 变更请求</p><p>④: 项目文件更新</p><p>⑤: 组织过程资产更新</p><p>⑥: 项目管理计划更新</p><h3 id="11-13-关键路径法"><a href="#11-13-关键路径法" class="headerlink" title="11.13 关键路径法:"></a>11.13 关键路径法:</h3><p>①: 找工期最长的那条路径</p><p>②: 关键路径上的活动总浮动时间为0, 自由浮动时间为0</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.63.png" alt="63"></p><p>③: 总浮动时间    =     晚完成-早完成    =    晚开始-早开始<br>④: 最早开始  + 工期 =  最早完成               最迟开始  + 工期  = 最迟完成<br><strong>总结: 上下相减是浮动,左右相减是工期</strong><br><strong>口诀: 早开始,迟完成,紧前紧后来分析, 其他皆可推.</strong></p><p>⑤: 第一个活动最早开始      =     项目最早开始                 最后一个项目最迟完成 = 项目最迟完成</p><p>⑥: 自由浮动时间:  是<strong>本活动与紧后活动</strong>的关系, 指<strong>不延误任何紧后活动的最早开始</strong>且不违反进度制约因素的前提下,活动可以从最早开始推迟或拖延的时间量.</p><p>自由浮动时间  =   <strong>紧后活动最早开始的最小值</strong>   -   <strong>本活动最早完成</strong></p><p><strong>总之:</strong>  在关键路径法 的活动结点中的值 需要我们求的 就是 <strong>最早开始  和 最迟完成 </strong> 其他的值可以依据公式推出.</p><p><strong>总浮动时间: 不影响工期</strong></p><p><strong>自由浮动时间: 不影响紧后活动的最早开始时间</strong></p><p>⑦:  网络图: </p><p>单代号网络图: 箭头是关系, 结点是活动<br>双代号网络图: 箭头是活动, 结点是事件.<br>时标网络图</p><p><strong>注: 双代号网络图的活动在箭线上,结点耗时为0,即结点的最早开始时间等于最早完成时间,从而合成一个最早开始时间(标注与结点上方)</strong></p><h4 id="11-13-1-一个非常重要的地方"><a href="#11-13-1-一个非常重要的地方" class="headerlink" title="11.13.1 一个非常重要的地方:"></a>11.13.1 一个非常重要的地方:</h4><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.60.png" alt="60"></p><p><strong>注: </strong>其中活动A和活动B可以同时进行, <strong>但只有活动A 和 活动B 都完成后, 活动C 才能开始.</strong></p><p>另外: 当一个活动有多个紧前活动时,<strong>要看最后一个完成的活动的最早完成时间.</strong></p><p>举个例子: C的紧前活动是A和B,  如果完成A活动需要9天,完成B活动需要10天,那么C活动最早开始时间是 第10天,而不是第九天.</p><p>总结: </p><p><strong>⑧: 最早开始时间的求法: </strong>要看<strong>紧前活动最早</strong>什么时候完成   (当一个活动有多个紧前活动时,<strong>要看最后一个活动的最早完成时的时间(也就是不延期时))</strong></p><p><strong>⑨: 最迟完成时间求法: </strong>要看<strong>紧后活动最迟</strong>什么时候开始(当一个活动有多个紧后活动时,要看最先一个开始的紧后活动的最迟开始时间————==原因: 确保所有的紧后活动不受影响.==)</p><p>画出双代号网络图, 计算节点的最早开始时间(标注于节点上方), 然后箭线上 每个的最早开始时间就是箭线起点的节点上方的值.<br><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.94.png" alt="61"><br><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.95.png" alt="61"></p><p>例题: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.61.png" alt="61"></p><p>解答:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.62.png" alt="62"></p><p>E 由于在关键路径上所以总浮动时间和自由浮动时间都为0</p><p>G 在非关键路径上: </p><p>方法一: 公式法: G的总浮动时间=G最迟开始时间 -  G最早开始时间</p><p>G最早开始是在第5天(因为只有一个紧前活动F,且F最早在第5天完成)</p><p>G最迟开始时间=G最迟完成-G的工期=G最迟完成-4</p><p>G最迟完成要看G的紧后活动最迟什么时候开始,G只有一个紧后活动E且最迟开始时间为10(因为G在关键路径上,最迟开始=最早开始=10)</p><p>G最迟开始时间=10-4=6</p><p>G的总浮动时间=6-5=1</p><p>方法二:</p><p>用工期21 减去G所在的最长路径20 得到的就是G 的总浮动时间为1天</p><p>G的自由浮动时间 = E的最早开始-G的最早完成</p><p>E最早第10天开始,G最早第9天完成</p><p>G的自由浮动时间=10-9=1</p><h3 id="11-14-投资回收期"><a href="#11-14-投资回收期" class="headerlink" title="11.14 投资回收期"></a>11.14 投资回收期</h3><p>以项目的净收益回收项目投资所需要的时间, <strong>一般以建设期开始算起</strong>,  <strong>也可以从投产年开始算起,但是必须注明</strong></p><p>投资回收期的判别基准是 <strong>基准投资回收期</strong>  而不是 基本投资回收期</p><p>评价标准: </p><p>将计算出的静态投资回收期Pt  与  所确定的基准投资回收期Pc 进行比较:</p><p>若Pt &lt;= Pc 表明项目投资能在规定时间内收回,则方案可以考虑</p><p>若Pt &gt; Pc , 则方案不可行</p><h3 id="11-15-计算题应该注意的地方"><a href="#11-15-计算题应该注意的地方" class="headerlink" title="11.15 计算题应该注意的地方:"></a>11.15 计算题应该注意的地方:</h3><p>①: 费用 : 有些时候指的是活动总费用,有时指的是一个人一天的费用——注意审题</p><h3 id="11-16-成本估算和成本预算的区别"><a href="#11-16-成本估算和成本预算的区别" class="headerlink" title="11.16 成本估算和成本预算的区别"></a>11.16 成本估算和成本预算的区别</h3><p>成本估算是在有了方案和初步设计的基础上作出的；成本预算是在有了详细的施工图纸的基础上作出的。二者的依据不同，深度不同。</p><p>估算和预算都是最终成本前的计算，和最终的成本一般多少是有出入的，顾名思义，估算只是初步的估计，比较粗，精确度不高和最终的成本相别相对来说是比较大的，但是预算就比较细了，每一项都需要列出来，最终的成本也是需要根据预算来进行的！</p><h3 id="11-17-活动和工作包的区别"><a href="#11-17-活动和工作包的区别" class="headerlink" title="11.17 活动和工作包的区别:"></a>11.17 活动和工作包的区别:</h3><p>活动是由工作包分解而来，是实现工作包所需的具体工作。</p><p>工作包是WBS底层的可交付成果，是WBS的一部分，活动不是WBS的一部分。</p><p>工作包不表示时间、也不表示顺序，只表示项目范围；活动可表示时间、顺序、是资源估算、历史估算、费用估算的重要依据</p><h2 id="十二、质量管理"><a href="#十二、质量管理" class="headerlink" title="十二、质量管理"></a>十二、质量管理</h2><p><a href="http://www.hihexo.com/pmp/chapter/635.htm" target="_blank" rel="noopener">项目质量管理</a>包括执行组织确定质量政策、目标与职责的各过程和活动，从而使项目满足其预定的需求。项目质量管理在项目环境内使用政策和程序，实施组织的质量管理体系； 并以执行组织的名义，适当支持持续的过程改进活动。项目质量管理确保项目需求，包括产品需求，得到满足和确认。</p><p><a href="http://www.hihexo.com/pmp/chapter/636.htm" target="_blank" rel="noopener">8.1</a><a href="http://www.hihexo.com/pmp/chapter/636.htm" target="_blank" rel="noopener">规划质量管理</a>——识别项目及其<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>的质量要求和/或标准，并书面描述项目将如何证明符合质量要求的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/659.htm" target="_blank" rel="noopener">8.2</a><a href="http://www.hihexo.com/pmp/chapter/659.htm" target="_blank" rel="noopener">实施质量保证</a>——审计质量要求和<a href="http://www.hihexo.com/pmp/chapter/692.htm" target="_blank" rel="noopener">质量控制测量结果</a>，确保采用合理的<a href="http://www.hihexo.com/pmp/chapter/1127.htm" target="_blank" rel="noopener">质量标准</a>和操作性定义的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/676.htm" target="_blank" rel="noopener">8.3</a><a href="http://www.hihexo.com/pmp/chapter/676.htm" target="_blank" rel="noopener">控制质量</a>——监督并记录质量活动执行结果，以便评估绩效，并推荐必要的变更的过程。</p><p>每个项目都应该有一个<a href="http://www.hihexo.com/pmp/chapter/654.htm" target="_blank" rel="noopener">质量管理计划</a>。项目团队应该遵循<a href="http://www.hihexo.com/pmp/chapter/654.htm" target="_blank" rel="noopener">质量管理计划</a>并且应该以数据证明自己遵守了计划。</p><p>在与ISO保持兼容性的前提下，现代质量管理方法力求缩小差异，交付满足既定要求的成果。现代质量管理方法承认以下几方面的重要性：</p><p>客户满意。了解、评估、定义和管理要求，以便满足客户的期望。这就需要把“符合要求”（确保项目产出预定的成果）和“适合使用”（产品或服务必须满足实际需求） 结合起来。</p><p>预防胜于检查。质量应该被规划和设计，并且在项目的管理过程或<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>生产过程中被建造出来（而不是被检查出来）。预防错误的成本通常远低于在检查或使用中发现并纠正错误的成本。</p><p>持续改进。由休哈特提出并经戴明完善的计划—实施—检查—行动（PDCA）循环是质量改进的基础。另外，诸如全面质量管理（TQM）、六西格玛和精益六西格玛等质量管理举措，也可以改进项目的管理质量及项目的产品质量。常用的过程改进模型包括马尔科姆·波多里奇模型、组织级项目管理成熟度模型（OPM3®）和能力成熟度集成模型（CMMI®）。</p><p>管理层的责任。项目的成功需要项目团队全体成员的参与。然而，管理层在其质量职责内，肩负着为项目提供具有足够能力的资源的相应责任。</p><p><a href="http://www.hihexo.com/pmp/chapter/646.htm" target="_blank" rel="noopener">质量成本</a>（COQ）。质量成本是指一致性工作和非一致性工作的总成本。一致性工作是为预防工作出错而做的附加努力，非一致性工作是为纠正已经出现的错误而做的附加努力。质量工作的成本在<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>的整个生命周期中都可能发生。例如，项目团队的决策会影响到已完工的<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>的运营成本。项目结束后，也可能因产品退货、保修索赔、产品召回而发生“后项目质量成本”。由于项目的临时性及降低后项目质量成本所带来的潜在利益，发起组织可能选择对产品质量改进进行投资。这些投资通常用在一致性工作方面，以预防缺陷或检查出不合格单元来降低缺陷成本。参见图8-2和<a href="http://www.hihexo.com/pmp/chapter/646.htm" target="_blank" rel="noopener">8.1.2.2</a>节。此外，与后项目质量成本有关的问题，也应该成为项目集管理和项目组合管理的关注点，以便项目、项目集和项目组合管理办公室专门开展审查，提供模板和分配资金。</p><p>图8-2IPECC、PDCA、<a href="http://www.hihexo.com/pmp/chapter/646.htm" target="_blank" rel="noopener">质量成本</a>模型和<a href="http://www.hihexo.com/pmp/chapter/128.htm" target="_blank" rel="noopener">项目管理过程组</a>在质量保证和质量控制方面的基本关系</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.89.png" alt="89"></p><h3 id="12-1-质量控制的输入"><a href="#12-1-质量控制的输入" class="headerlink" title="12.1 质量控制的输入"></a>12.1 质量控制的输入</h3><p>①: 项目管理计划</p><p>②: 质量度量指标</p><p>③: 工作绩效数据</p><p>④: 已批准的变更请求</p><p>⑤: 组织过程资产</p><p>⑥: 产品服务和结果</p><p>⑦: 质量检查表</p><h3 id="12-2-质量控制的输出"><a href="#12-2-质量控制的输出" class="headerlink" title="12.2 质量控制的输出"></a>12.2 质量控制的输出</h3><p>①: 确认的变更</p><p>②: 核实的可交付性成果</p><h3 id="12-3-质量管理过程"><a href="#12-3-质量管理过程" class="headerlink" title="12.3 质量管理过程"></a>12.3 质量管理过程</h3><p>①: 质量规划: 识别和项目有关的标准以及如何满足这些标准,确定需要<strong>对哪些过程</strong>和工作产品进行质量<strong>管理.</strong></p><p>②: 质量保证: 建立对未来输出或<strong>正在进行的工作</strong>在<strong>完工时满足特定需求和期望的信心</strong>.</p><p>③: 质量控制: <strong>采取措施</strong>,<strong>监督</strong>项目的具体实施<strong>结果</strong>是否符合相关的项目质量<strong>标准</strong>,并确定消除产品的不良结果的原因.</p><h3 id="12-4-软件质量特性"><a href="#12-4-软件质量特性" class="headerlink" title="12.4 软件质量特性"></a>12.4 软件质量特性</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.7.png" alt="7"></p><p>功能性——功能  5<br>可靠性——靠 3<br>可用性——用  3<br>效率———小 2<br>可维护性—护  4<br>可移植性—翼  4</p><p><strong>大特性口诀: 功能靠用小护翼</strong> </p><p><strong>功能性: </strong></p><p>合——适合性<br>准——准确性<br>用——互用性<br>一——依从性<br>安——安全性 </p><p><strong>可靠性: </strong></p><p>错——容错性<br>译——易恢复性<br>成——成熟性 </p><p><strong>易用性: </strong></p><p>学——易学性<br>姐——易理解性<br>操——易操作性 </p><p><strong>效率:</strong></p><p>石——时间特性<br>源——资源特性 </p><p><strong>维护性:</strong></p><p>试——可测试性<br>改——可修改性<br>定——稳定性<br>分——易分析性 </p><p><strong>可移植性:</strong></p><p>应——适应性<br>装——易安装性<br>一——一致性<br>T ——可替换性  </p><p>故事是这样的，某外语课，老师说了一段外语，谐音“合准用一安”（可以理解为：合准备用一安培），某同学错误翻译成“学姐操石源(日本人)”结果老师判定不及格，某同学试着修改定下的分数，别人告诉她，应该装一个套套去… </p><p><strong>口诀：合准用一安，错译成，学姐操，石源，试改定分，应装一T</strong>（套套一般都用T代替）  </p><h3 id="12-4-质量管理常用工具："><a href="#12-4-质量管理常用工具：" class="headerlink" title="12.4 质量管理常用工具："></a>12.4 质量管理常用工具：</h3><p>老七种工具：流程图、因果图、直方图、散点图、排列图、控制图、检查表。<br>新七种工具：矩阵图、树状图、相互关系图、亲和图、过程决策方法图、活动网络图、优先矩阵图。 </p><p><strong>编成一句诗：流因直点列制查，矩树相亲策动优。 </strong><br><strong>谐音是：刘英只点劣质茶，钜树相亲策动优。</strong> </p><p>诗文讲的故事是：有一个叫刘英的人在相亲时只敢点最便宜的劣质茶，为什么？家里穷呀。<br>原来，她是锯了家里的树，卖了钱，来相亲的。可见这次相亲的策划活动有多优秀。   </p><p><strong>口诀: 刘英只点劣质茶，钜树相亲策动优</strong></p><p>控制图: 用来分析过程是否稳定,是否发生异常情况.</p><h3 id="12-5-规划质量管理的输入"><a href="#12-5-规划质量管理的输入" class="headerlink" title="12.5 规划质量管理的输入"></a>12.5 规划质量管理的输入</h3><p>①: 项目管理计划</p><p>②: 干系人登记册</p><p>③: 风险登记册</p><p>④: 需求文件</p><p>⑤: 事业环境因素</p><p>⑥: 组织过程资产</p><p>⑦: 范围说明书</p><p>⑧: 产品说明书</p><p>⑨: 标准和规定</p><h3 id="12-6-统计方法"><a href="#12-6-统计方法" class="headerlink" title="12.6 统计方法:"></a>12.6 统计方法:</h3><p>①: 实验设计: 是一种<strong>统计方法</strong>,通过进行实验找出<strong>哪些变量对项目结果的影响最大</strong>. 用来<strong>识别</strong>哪些因素会对<strong>正在生产的产品</strong>或<strong>正在开发的流程</strong>的<strong>特定变量</strong>产生影响</p><p>②: 标杆对照</p><p>③: 过程分析: 主要是<strong>分析执行过程中</strong>的问题、无价值的活动等.用于识别问题、探究根本原因.并制定预防措施.</p><p>④: 质量审计:  对其他质量管理活动的<strong>结构性的审查</strong>,是决定一个项目质量活动<strong>是否符合组织政策</strong>,过程,程序的独立的评估.</p><h3 id="12-6-规划质量管理的输出"><a href="#12-6-规划质量管理的输出" class="headerlink" title="12.6 规划质量管理的输出"></a>12.6 规划质量管理的输出</h3><p><strong>①: 质量测量指标</strong>: 描述项目或产品属性  以及  用于在质量控制过程如何对属性进行测量质量测量指标的例子: 准时性、故障率、可用性、成本控制、和测试覆盖度等. <strong>提供了应该被测量的属性和允许的偏差.</strong></p><p><strong>②: 过程改进计划</strong>: 详细说明对项目管理过程和产品开发过程进行分析的各个步骤,以识别增值活动.</p><p>③: 质量管理计划: 描述如何实施组织的质量政策,以及如何达到项目的质量要求.</p><p>④: 质量核对单: 具体列出各项内容,用来核实所要求的一系列步骤,是否已经得到执行.</p><h3 id="12-7-质量管理执行阶段的技术"><a href="#12-7-质量管理执行阶段的技术" class="headerlink" title="12.7 质量管理执行阶段的技术"></a>12.7 质量管理执行阶段的技术</h3><p>①: 质量审计</p><p>②: 过程分析</p><p>③: 七种基本质量工具(过程决策程序图PDPC)、统计抽样、检查、审查已批准的变更请求.</p><p>过程决策程序图: 用于理解一个<strong>目标与达成此目标的步骤</strong>之间的关系.有助于制定应急计划,因为它能帮助团队预测哪些可能破坏目标实现的中间环节</p><h3 id="12-8-质量保证的输入"><a href="#12-8-质量保证的输入" class="headerlink" title="12.8 质量保证的输入"></a>12.8 质量保证的输入</h3><p>①: 质量测量指标</p><p>②: 质量管理计划</p><p>③: 过程改进计划</p><p>④: 工作绩效信息</p><p>⑤: 变更请求</p><h3 id="12-9-质量保证"><a href="#12-9-质量保证" class="headerlink" title="12.9 质量保证"></a>12.9 质量保证</h3><p>通过用规划过程预防缺陷,或者在执行阶段对正在进行的工作检查出缺陷,来保证质量的确定性, <strong>而不是</strong>通过<strong>执行产品检查</strong>并发现缺陷来实现的.</p><h4 id="12-9-1-质量保证的职能"><a href="#12-9-1-质量保证的职能" class="headerlink" title="12.9.1 质量保证的职能:"></a>12.9.1 质量保证的职能:</h4><p>主要职能是: 过程检查,过程改进</p><h3 id="12-10-确认过程"><a href="#12-10-确认过程" class="headerlink" title="12.10 确认过程"></a>12.10 确认过程</h3><p>目的: 确保产品<strong>满足</strong>其特定的<strong>目标</strong>, 是否达到上一阶段确立的需求的过程</p><p>举例:  我要求张三期末语文考100分,  到期末时,张三语文考了100分,  我确认张三达到了我的要求</p><h3 id="12-11-验证过程"><a href="#12-11-验证过程" class="headerlink" title="12.11 验证过程"></a>12.11 验证过程</h3><p>目的: 确保活动的输出产品<strong>满足</strong>活动的<strong>规范说明.</strong>, 是否和软件需求一致.</p><p>举例:  我要求张三期末语文考100分,  到期末时,张三数学考了100分,  我验证张三和我的要求不一致</p><h3 id="12-12-软件包质量要求"><a href="#12-12-软件包质量要求" class="headerlink" title="12.12 软件包质量要求:"></a>12.12 软件包质量要求:</h3><p>①: 产品描述要求</p><p>②: 用户文档要求</p><p>③: 程序和数据要求</p><h3 id="12-13-编制质量计划的工具和技术"><a href="#12-13-编制质量计划的工具和技术" class="headerlink" title="12.13 编制质量计划的工具和技术"></a>12.13 编制质量计划的工具和技术</h3><p>①: 基准分析:</p><p>将实际计划中的项目做法同其他类似项目的实际做法进行比较,通过比较来改善和提高目前项目的质量管理,以达到项目预期的质量.</p><h3 id="12-14-质量控制"><a href="#12-14-质量控制" class="headerlink" title="12.14 质量控制"></a>12.14 质量控制</h3><p>①: 主要是对<strong>产品或服务成果</strong>的<strong>控制和检查</strong>,不是评估项目绩效</p><p><strong>所以 检查关键交付物的质量 就属于 质量控制的职能.</strong></p><h3 id="12-15-外部度量"><a href="#12-15-外部度量" class="headerlink" title="12.15 外部度量"></a>12.15 外部度量</h3><p>①: 易学性度量: 评估软件的帮助文档和文档的有效性.</p><p>②: 易操作性度量</p><p>③: 易理解性度量</p><h3 id="12-16-故障成本"><a href="#12-16-故障成本" class="headerlink" title="12.16 故障成本"></a>12.16 故障成本</h3><p><strong>错误的纠正成本</strong>为<strong>非一致性成本</strong>,即<strong>故障成本</strong></p><p>举例: 某如那件系统测试发现有错误并不能满足质量需求,为了纠正其错误投入了10人天的成本,该成本就属于 故障成本</p><h3 id="12-17-控制质量的工具和技术"><a href="#12-17-控制质量的工具和技术" class="headerlink" title="12.17 控制质量的工具和技术"></a>12.17 控制质量的工具和技术</h3><p>①: 帕累托图: 特殊的垂直条形图,<strong>==用于识别造成大多数问题的少数重要原因==</strong>,在横轴上显示的原因类别,作为有效的概率分布,涵盖100%的可能观察结果.</p><p>②: 因果图: 又称鱼骨图, 发现问题的原因;   通常问题陈述放在鱼骨的头部作起点来追溯问题的来源</p><p>③: 流程图</p><p>④: 直方图: 用于<strong>描述集中趋势,分散程度</strong>,和统计分布形状, 与控制图不同它不考虑时间对分布内的变化的影响.</p><p>⑤: 散点图: 显示<strong>两个变量之间是否有关系</strong></p><p>⑥: 控制图: 实时展示<strong>项目进展</strong>信息的图表, 用于判断某一过程处于<strong>控制</strong>之中还是处于<strong>失控</strong>状态.</p><p>⑦: 核查表: 用于收集数据的查对清单(如收集缺陷数量和后果的数据)</p><p>技术:</p><p>⑧: 趋势分析</p><p>⑨: 缺陷修复审查</p><p>⑩: 检查(评审是检查)</p><h3 id="12-18-审计-和-评审区别"><a href="#12-18-审计-和-评审区别" class="headerlink" title="12.18 审计 和 评审区别"></a>12.18 审计 和 评审区别</h3><p>评审是检查,质量控制的工具.</p><p>质量审计是 审计其他质量管理活动的一个结构化审查,<strong>如果是问具体的流程,那么就不能用质量审计</strong></p><h3 id="12-19-工作绩效数据-工作绩效信息-工作绩效报告-区别与联系"><a href="#12-19-工作绩效数据-工作绩效信息-工作绩效报告-区别与联系" class="headerlink" title="12.19 工作绩效数据 工作绩效信息 工作绩效报告 区别与联系"></a>12.19 工作绩效数据 工作绩效信息 工作绩效报告 区别与联系</h3><p>工作绩效数据: </p><blockquote><p><strong>是执行过程的输出，监控过程的输入。</strong></p><p>在执行项目的工作过程中，从每个正在执行的活动中一边执行一边收集起来的，未经任何加工整理的<strong>原始观察结果</strong>和<strong>测量值</strong>用于真实，完整地记录工作的执行情况。它是<strong>指导与管理项目工作过程的输出</strong>。是项目监控时用来与计划要求做比较实际的实际数据。</p><p>例如：<strong>工作完成百分比</strong>，<strong>质量和技术绩效测量值</strong>，进度活动的<strong>开始和结束日期</strong>，<strong>变更请求的数量</strong>，<strong>缺陷数量</strong>，<strong>实际成本和实际持续时间</strong>等。</p><p>它强调的是<strong>原始的</strong>，基础的数据，再执行项目管理计划后，出现的能<strong>反映项目当前执行情况</strong>（主要是范围，进度，成本）的原始的，基础的数据。</p></blockquote><p>工作绩效信息: </p><blockquote><p><strong>是监控过程的输出。 </strong></p><p><strong>是对工作绩效数据进行加工整理（主要是与基准计划对比）后得到的</strong>，是各基层<strong>局部监控过程的输出</strong>。进行<strong>整合分析而得到的</strong>绩效数据。</p><p>在PMBOK指南中，总共有<strong>九个基层局部监控</strong>过程，即确认范围，控制范围，控制进度，控制沟通，控制质量，控制成本，控制干系人参与过程, 控制风险，控制采购。</p><p>例如：可交付成果物的<strong>状况</strong>，请求变更的执行<strong>状况</strong>，预测的完工估算。</p><p>它强调的是用<strong>工作绩效数据和基准计划的对比</strong>结果，也可以理解为<strong>偏差结果</strong>。</p><p>反映项目实际执行和计划要求之间的偏差,对偏差程度和原因的分析,以便决定是否需要变更</p><p>提供了沟通和支持项目决策的机制</p><p> 注意：”可交付成果物的完成状况“属于 工作绩效信息。</p></blockquote><p>工作绩效报告:</p><blockquote><p><strong>对绩效信息进一步加工，整理，汇编而得到的</strong>，关于项目绩效的专题和综合报告。他是<strong>监控工作过程的输出</strong>，</p><p>为指定决策，提出问题，采取行动或引起关注，而汇编工作绩效信息，所形成的<strong>实物或电子项目文件</strong> 是整个项目层次的更深入或更综合的执行与计划的比较。</p><p>例如：状况报告，备忘录，论证报告，信息札礼，电子报表，推荐意见或情况更新。</p><p>它强调的是可以正式提交给干系人，能全面反映项目情况的正式文件。</p></blockquote><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.66.png" alt="66"></p><h3 id="12-20-质量成本"><a href="#12-20-质量成本" class="headerlink" title="12.20 质量成本"></a>12.20 质量成本</h3><p>一致性成本:</p><ul><li><p>预防成本</p><ul><li>培训</li><li>流程文档化</li></ul></li><li><p>评价成本</p><ul><li>测试</li><li>检查</li><li>破坏性测试导致的损失</li></ul></li></ul><p>非一致性成本:</p><ul><li><p>内部失败成本</p><ul><li>返工</li><li>废品</li></ul></li><li><p>外部失败成本</p><ul><li>责任</li><li>报修</li></ul></li></ul><h3 id="12-21-规划质量管理的首要工作"><a href="#12-21-规划质量管理的首要工作" class="headerlink" title="12.21 规划质量管理的首要工作"></a>12.21 规划质量管理的首要工作</h3><p>识别相关质量标准</p><h3 id="12-22-质量保证和质量控制的区别"><a href="#12-22-质量保证和质量控制的区别" class="headerlink" title="12.22 质量保证和质量控制的区别"></a>12.22 质量保证和质量控制的区别</h3><p>质量保证: 是<strong>执行阶段</strong>对<strong>正在进行的工作</strong>进行检查———-针对过程</p><p>质量控制: 是对<strong>阶段末</strong>得到的 <strong>可交付物/产品</strong> 进行检查——-针对阶段性成果</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.105.png" alt="105"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.106.png" alt="106"></p><h3 id="12-23-软件质量分类"><a href="#12-23-软件质量分类" class="headerlink" title="12.23 软件质量分类"></a>12.23 软件质量分类</h3><p>内部质量</p><p>外部质量</p><p>使用质量</p><h2 id="十三、人力资源管理"><a href="#十三、人力资源管理" class="headerlink" title="十三、人力资源管理"></a>十三、人力资源管理</h2><p><a href="http://www.hihexo.com/pmp/chapter/701.htm" target="_blank" rel="noopener">项目人力资源管理</a>包括组织、管理与领导项目团队的各个过程。项目团队由为完成项目而承担不同<a href="http://www.hihexo.com/pmp/chapter/1131.htm" target="_blank" rel="noopener">角色与职责</a>的人员组成。项目团队成员可能具备不同的技能，可能是全职或兼职的，可能随项目进展而增加或减少。项目团队成员也可称为项目人员。尽管项目团队成员被分派了特定的<a href="http://www.hihexo.com/pmp/chapter/1131.htm" target="_blank" rel="noopener">角色和职责</a>，但让他们全员参与项目规划和决策仍是有益的。团队成员在规划阶段就参与进来，既可使他们对项目规划工作贡献专业技能，又可以增强他们对项目的责任感。</p><p><a href="http://www.hihexo.com/pmp/chapter/702.htm" target="_blank" rel="noopener">9.1</a>规划人力资源管理——识别和记录项目角色、职责、所需技能、报告关系，并编制<a href="http://www.hihexo.com/pmp/chapter/715.htm" target="_blank" rel="noopener">人员配备管理计划</a>的过程。</p><p><img src="https://ws1.sinaimg.cn/large/0064BnmZly1g32c9xf1i4j30fa0g7whx.jpg" alt></p><p><a href="http://www.hihexo.com/pmp/chapter/716.htm" target="_blank" rel="noopener">9.2</a>组建项目团队——确认人力资源的可用情况，并为开展项目活动而组建团队的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/731.htm" target="_blank" rel="noopener">9.3</a>建设项目团队——提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/747.htm" target="_blank" rel="noopener">9.4</a>管理项目团队——跟踪团队成员工作表现，提供反馈，解决问题并管理团队变更，以优化项目绩效的过程。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.6.png" alt="6"></p><h3 id="13-1-组织分解结构OBS"><a href="#13-1-组织分解结构OBS" class="headerlink" title="13.1 组织分解结构OBS"></a>13.1 组织分解结构OBS</h3><p>根据现有的部门,单位或团队进行分解.项目的活动和工作包列在负责的部门下面.</p><h3 id="13-2-优秀团队的建设阶段-塔克曼阶梯理论"><a href="#13-2-优秀团队的建设阶段-塔克曼阶梯理论" class="headerlink" title="13.2 优秀团队的建设阶段:(塔克曼阶梯理论)"></a>13.2 优秀团队的建设阶段:(塔克曼阶梯理论)</h3><p>团队发展阶段: </p><p>①: 形成阶段</p><p>②: 震荡阶段: 个体之间<strong>争执,互相指责</strong></p><p>③: 规范阶段: 经过一段时间的磨合,相互<strong>熟悉了解,矛盾基本解决</strong></p><p>④: 发挥阶段(表现阶段): 成员积极工作,<strong>集体荣誉感非常强</strong></p><p>⑤: 解散阶段: 随着项目的结束,团队也被遣散.</p><p><strong>注: 如果有新成员加入,团队又会回到形成阶段.</strong></p><h3 id="13-3-管理项目团队的工具和技术"><a href="#13-3-管理项目团队的工具和技术" class="headerlink" title="13.3 管理项目团队的工具和技术"></a>13.3 管理项目团队的工具和技术</h3><p>①: 观察和对话</p><p>②: <strong>项目绩效评估</strong></p><p>③: 冲突管理: </p><p>④: <strong>问题日志</strong>: </p><p><strong>注: 项目绩效,问题日志    属于   管理项目团队过程 而不是 建设项目团队过程</strong></p><h3 id="13-4-团队建设的内容"><a href="#13-4-团队建设的内容" class="headerlink" title="13.4 团队建设的内容"></a>13.4 团队建设的内容</h3><p>①: 培训</p><p>②: 认可和奖励</p><p>③: 同地办公(集中)</p><p>④: 基本原则</p><p>⑤: 团队建设活动</p><p>⑥: 一般管理技能 </p><p>⑦: 组织娱乐活动让大家认识</p><p><strong>注: 评价绩效 属于 管理团队的工具和技术</strong></p><h3 id="13-5-项目绩效评审"><a href="#13-5-项目绩效评审" class="headerlink" title="13.5 项目绩效评审"></a>13.5 项目绩效评审</h3><p>在一个阶段末的项目绩效评审<strong>主要目标是</strong>本阶段的任务是否已经完成,<strong>决定项目是否从当前阶段进入下一阶段</strong>.</p><h3 id="13-6-激励理论-X理论-Y理论-马斯洛理论-赫兹伯格理论-期望理论"><a href="#13-6-激励理论-X理论-Y理论-马斯洛理论-赫兹伯格理论-期望理论" class="headerlink" title="13.6 激励理论:  X理论 ,Y理论,马斯洛理论,赫兹伯格理论,期望理论"></a>13.6 激励理论:  X理论 ,Y理论,马斯洛理论,赫兹伯格理论,期望理论</h3><h4 id="13-6-1-X理论"><a href="#13-6-1-X理论" class="headerlink" title="13.6.1 : X理论"></a>13.6.1 : X理论</h4><p><strong>消极假设</strong></p><p>①: 人天性好逸恶劳,只要有可能就会逃避工作</p><p>②: 人生来就以自我为中心,漠视组织要求</p><p>③: 人们天生就反对改革</p><p>④: 人缺乏进取心,逃避责任.</p><p>优点: 加强管理</p><p>缺点: 成员通常比较被动工作</p><h4 id="13-6-2-Y理论"><a href="#13-6-2-Y理论" class="headerlink" title="13.6.2 Y理论"></a>13.6.2 Y理论</h4><p><strong>积极假设</strong></p><p>①:  人天性并不是好逸恶劳,他们热爱工作,从工作中的到满足感和成就感</p><p>②: 适当条件下人们愿意主动承担责任</p><p>③: 大多数人具有一定的创造力和想象力</p><p>优点: 激发员工主动性</p><p>缺点: 对于员工把握工作而言可能又放任过度.</p><h4 id="13-6-3-马斯洛需求"><a href="#13-6-3-马斯洛需求" class="headerlink" title="13.6.3 马斯洛需求"></a>13.6.3 马斯洛需求</h4><p>是一个5层金字塔结构,当某一级的需求满足后,才会追求更高一级的需求,如此逐级上升,成为他工作的动机.</p><p>分五个层次</p><p>①: <strong>生理</strong>需求: 对衣食住行的需求等 级别最低位于金字塔最底层.人们在转向较高层次的需求时 总是尽力满足这类需求,</p><p>常见的激励措施 : 员工宿舍,奖金,补贴等</p><p>②: <strong>安全</strong>需求: 包括对人身安全,生活稳定,不至于失业</p><p>常见激励措施: 养老保险,长期劳动合同,意外保险等</p><p>③: <strong>社会</strong>交往需求: 友谊,爱情等隶属关系的需求.</p><p>常见的激励措施 : 员工活动,聚会,比赛,俱乐部</p><p>④: <strong>受尊重</strong>需求: 自尊心,荣誉感</p><p>常见的激励措施: 荣誉性的奖励, 形象地位的提升,颁发奖章.</p><p>⑤: <strong>自我实现</strong>的需求</p><p>常见的激励措施: 参与决策,参与公司管理会议.</p><h4 id="13-6-4-赫兹伯格理论"><a href="#13-6-4-赫兹伯格理论" class="headerlink" title="13.6.4 赫兹伯格理论"></a>13.6.4 赫兹伯格理论</h4><p>双因素激励理论:</p><p>①: 保健因素: 与工作环境有关,能防止人们产生不满意感, 如工作环境,薪水,个人生活,人际关系,公司政策.</p><p>②: 激励因素: 与工作内容有关,能促使人们产生工作满意感,   如 工作成就感,认可和赞赏,成长和发展 类似于马斯洛理论中的 尊重和自我实现.</p><p>注: 注意 区别 保健因素 和  激励因素 ,<strong>前者的满足 可以 消除不满,后者的满足可以产生满意.</strong></p><h4 id="13-6-5-期望理论"><a href="#13-6-5-期望理论" class="headerlink" title="13.6.5 期望理论"></a>13.6.5 期望理论</h4><p>通过考察人们的<strong>努力行为</strong>与其获得的<strong>最终奖酬</strong>之间的因果关系,来说明激励过程,并以选择合适的行为达到最终的奖酬目标的理论</p><p>一个目标对人的激励程度有两个因素:</p><p>①: 目标效价: 实现目标后 能带来多少价值</p><p>②: 期望值: 实现目标的可能性</p><p>激发力量=目标效价  * 期望值</p><h3 id="13-7-人力资源管理计划的内容"><a href="#13-7-人力资源管理计划的内容" class="headerlink" title="13.7 人力资源管理计划的内容"></a>13.7 人力资源管理计划的内容</h3><p>①: 角色和职责: 某人承担的职务,为完成工作成员必须履行的工作和职责.</p><p>角色和职责的定义的三种形式: </p><ul><li><p>层级型: </p><ul><li>工作分解结构WBS: 显示如何把项目可交付成果分解为工作包</li><li>组织分解结构OBS: 在每个部门下列出其所负责的项目或工作包</li><li>资源分解结构RBS按照资源类别和类型对资源的层级列表.</li></ul></li><li><p>矩阵型: 责任分配矩阵RAM   用来显示分配给每个工作包的资源的表格,  即用来显示工作包与团队成员的关系,它能反映与每个人相关的所有活动,以及与每个活动相关的所有人员,它可确保任何一项任务都只有一个人负责.,从而避免职责不清.</p></li><li><p>文本型: 详细描述团队成员的职责.提供如职责,职权能力,资格等方面的信息.</p></li></ul><p>②: 项目的组织结构图: 以图形方式展示项目团队成员及其报告关系.</p><p>③: 人员配备管理计划: 说明何时何种方式获得项目团队成员,以及他们需要在项目中工作多久.</p><h3 id="13-8-人员配备管理计划的内容"><a href="#13-8-人员配备管理计划的内容" class="headerlink" title="13.8 人员配备管理计划的内容"></a>13.8 人员配备管理计划的内容</h3><p>①: 人员招募</p><p>②: 人员遣散计划</p><p>③: 认可与奖励</p><p>④: 资源日历</p><p>⑤: 培训需要</p><p>⑥: 合规性</p><h3 id="13-9-组建项目团队的输入"><a href="#13-9-组建项目团队的输入" class="headerlink" title="13.9 组建项目团队的输入"></a>13.9 组建项目团队的输入</h3><p>①: 角色和责任</p><p>②: 项目的组织结构图</p><p>③: 环境和组织结构图</p><h3 id="13-10-组建项目团队的输出"><a href="#13-10-组建项目团队的输出" class="headerlink" title="13.10  组建项目团队的输出"></a>13.10  组建项目团队的输出</h3><p>①: 资源日历</p><p>②: 团队成员的通讯录</p><p>③: 项目人员分配</p><h3 id="13-11-资源日历-项目日历-资源直方图区别"><a href="#13-11-资源日历-项目日历-资源直方图区别" class="headerlink" title="13.11 资源日历 ,项目日历, 资源直方图区别"></a>13.11 资源日历 ,项目日历, 资源直方图区别</h3><p>①: 资源日历</p><p>资源工作时段,如团队<strong>成员工作时段</strong>,或休息</p><p>②: 项目日历</p><p><strong>项目的工作日历, 如 工作日,休息日</strong>,特殊项目的休整期(台风期,汛期)</p><p>③: 资源直方图</p><p><strong>项目对资源的使用需求</strong>,如 某高级工程师在项目中的工作时长及负荷.</p><h3 id="13-12-项目财务绩效评估"><a href="#13-12-项目财务绩效评估" class="headerlink" title="13.12 项目财务绩效评估:"></a>13.12 项目财务绩效评估:</h3><h4 id="13-12-1-静态分析法"><a href="#13-12-1-静态分析法" class="headerlink" title="13.12.1 静态分析法"></a>13.12.1 静态分析法</h4><p><strong>不考虑资金的时间价值. </strong></p><p>包括: 投资收益率法,投资回收期法  ,<strong>最小费用法</strong></p><h4 id="13-12-2-动态分析法"><a href="#13-12-2-动态分析法" class="headerlink" title="13.12.2 动态分析法"></a>13.12.2 动态分析法</h4><p>考虑资金的时间价值,也叫贴现法. </p><p>包括: 净现值法,<strong>内部收益率法</strong>,投资回收期法等.</p><p>注意:  投资 回收期 有静态和动态的计算.</p><p><strong>口诀: 最小投收是静态</strong></p><h3 id="13-13-绩效评估"><a href="#13-13-绩效评估" class="headerlink" title="13.13 绩效评估"></a>13.13 绩效评估</h3><p>①: 包括定性和定量,<strong>主要是定量</strong></p><p>②: 评估人员 : 包括财务,管理,信息技术人员等</p><p>③: 评估过程: 归纳,分析,撰写评估报告</p><h3 id="13-14-对项目内部各成员制定绩效任务步骤"><a href="#13-14-对项目内部各成员制定绩效任务步骤" class="headerlink" title="13.14 对项目内部各成员制定绩效任务步骤:"></a>13.14 对项目内部各成员制定绩效任务步骤:</h3><p>①: 对每个岗位工作内容进行分解</p><p>②: 针对每个岗位的工作进度,成本,质量等设定KPI值,KPI 值需要设定 为高中低三种档次,给与不同的奖励</p><p>③: 确定KPI评分标准(各评分标准,指标权重)</p><p>④: 确定考核频率</p><h3 id="13-15-项目绩效审计"><a href="#13-15-项目绩效审计" class="headerlink" title="13.15  项目绩效审计"></a>13.15  项目绩效审计</h3><p>①: 经济审计</p><p>②: 效率审计</p><p>③: 效果审计</p><p><strong>注: 不包括 风险审计</strong></p><h3 id="13-16-项目人力资源管理的过程顺序"><a href="#13-16-项目人力资源管理的过程顺序" class="headerlink" title="13.16 项目人力资源管理的过程顺序"></a>13.16 项目人力资源管理的过程顺序</h3><h4 id="13-16-1-规划人力资源管理"><a href="#13-16-1-规划人力资源管理" class="headerlink" title="13.16.1 规划人力资源管理"></a>13.16.1 规划人力资源管理</h4><p><strong>识别和记录项目角色,职责</strong>,所需技能,并<strong>编制人员配备管理计划</strong></p><h4 id="13-16-2-组建项目团队"><a href="#13-16-2-组建项目团队" class="headerlink" title="13.16.2 组建项目团队"></a>13.16.2 组建项目团队</h4><p><strong>确认人力资源可用情况</strong>,并为开展项目活动而组建团队,</p><p>①: 项目人员分配</p><h4 id="13-16-3-建设项目团队"><a href="#13-16-3-建设项目团队" class="headerlink" title="13.16.3 建设项目团队"></a>13.16.3 建设项目团队</h4><p>提高工作<strong>能力</strong>,促进团队<strong>成员的互动,</strong>改善团队整体<strong>氛围</strong>,以提高项目<strong>绩效.</strong></p><h4 id="13-16-4-管理项目团队"><a href="#13-16-4-管理项目团队" class="headerlink" title="13.16.4 管理项目团队"></a>13.16.4 管理项目团队</h4><p><strong>跟踪</strong>团队成员的工作表现,提供<strong>反馈</strong>,解决问题并<strong>管理</strong>团队变更,以<strong>优化</strong>项目绩效.</p><h3 id="13-17-建设项目团队的工具和技术"><a href="#13-17-建设项目团队的工具和技术" class="headerlink" title="13.17 建设项目团队的工具和技术"></a>13.17 建设项目团队的工具和技术</h3><p>①: 培训(如 拓展、组织一些娱乐活动)</p><p>②: 集中办公</p><p>③: 认可和奖励</p><p>④: 团队建设活动</p><p>⑤: 基本规则</p><p>⑥: 通用管理技能</p><h3 id="13-18-管理项目团队的输入"><a href="#13-18-管理项目团队的输入" class="headerlink" title="13.18 管理项目团队的输入"></a>13.18 管理项目团队的输入</h3><p>①: 人力资源管理计划</p><p>②: 项目人员分配清单</p><p>③: 团队绩效评价 </p><p><strong>④: 问题日志</strong></p><p>⑤: 工作绩效报告</p><p>⑥: 组织过程资产</p><p><strong>注: 变更请求是 输出.</strong></p><p><strong>口诀:  绩效日志组织入,变更请求是输出</strong> </p><h3 id="13-19-冲突管理"><a href="#13-19-冲突管理" class="headerlink" title="13.19 冲突管理"></a>13.19 冲突管理</h3><h4 id="13-19-1-冲突的解决方法"><a href="#13-19-1-冲突的解决方法" class="headerlink" title="13.19.1 冲突的解决方法:"></a>13.19.1 冲突的解决方法:</h4><p>①: 撤退/回避</p><p>②: 妥协/协调: 双方都让步</p><p>③: 缓和/包容</p><p>④: 强迫/命令: 利用权力解决,使一方赢,一方输</p><p>⑤: 合作/解决问题</p><h3 id="13-20人际关系技能"><a href="#13-20人际关系技能" class="headerlink" title="13.20人际关系技能"></a>13.20人际关系技能</h3><p>①: 领导力</p><p>②: 沟通</p><p>③: 激励</p><p>④: 影响力</p><p>⑤: 谈判</p><p>⑥: 冲突管理</p><p>⑦:  团队建设</p><p>⑧: 管理技能</p><p>⑨: 建立信任</p><h3 id="13-21-项目经理权力来源"><a href="#13-21-项目经理权力来源" class="headerlink" title="13.21 项目经理权力来源"></a>13.21 项目经理权力来源</h3><p>①: 职位权力</p><p>②: 奖励权力</p><p>③: 惩罚权力</p><p>④: 专家权力</p><p>⑤: 参照权力</p><h3 id="13-22-虚拟团队"><a href="#13-22-虚拟团队" class="headerlink" title="13.22 虚拟团队"></a>13.22 虚拟团队</h3><p>特点: </p><p>①: 将在家办公的员工纳入团队———空间</p><p>②: 在组织内部地处不同地理位置的员工之间组织项目团队——-空间</p><p>③: 将行动不便的或残疾人纳入团队——-人员</p><p>④: 在工作班次,工作小时,或工作日不同的员工之间组件团队———时间</p><p>⑤: 执行那些因为差旅费过高而被否决的项目——–开销</p><h3 id="13-23-管理项目团队"><a href="#13-23-管理项目团队" class="headerlink" title="13.23 管理项目团队"></a>13.23 管理项目团队</h3><p>跟踪团队成员的工作表现,解决问题,管理团队变更,以优化项目绩效.</p><p>输入: </p><p>①: 人力资源管理计划</p><p>②: 项目人员分派</p><p>③: 团队绩效评价</p><p>④: 问题日志</p><p>⑤: 工作绩效报告</p><p>⑥: 组织过程资产</p><p>工具技术:</p><p>①: 观察交谈</p><p>②: 项目绩效评估</p><p>③: 冲突管理</p><p>④: 人机关系技能</p><p>输出: </p><p>①: 变更请求</p><p>②:项目管理计划更新</p><p>③: 项目文件更新</p><p>④: 事业环境因素更新</p><p>⑤: 组织过程资产更新</p><h3 id="13-24-责任分配矩阵"><a href="#13-24-责任分配矩阵" class="headerlink" title="13.24 责任分配矩阵"></a>13.24 责任分配矩阵</h3><p>责任分配矩阵（RAM）是一种将项目组织分解结构（OBS）和工作分解结构（WBS）联系起来的结构，有助于确保项目工作范围的每个组成部分都分配给某个人或某个团队。责任分配矩阵（RAM）显示工作包或活动与项目团队成员之间的联系。责任分配矩阵可确保任何一项任务都只有一个人负责，从而避免混乱，做到“事事有人管”。同时，项目团队作为一个临时组织而不养“闲人”，通过责任分配矩阵明确项目团队成员在项目中“人人有事做”。RAM的典型应用是RACI（执行、负责、咨询和知情），以针对个人或小组，分配工作。</p><p><strong>==责任分配矩阵是规划人力资源管理过程的工具。==*</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.90.png" alt="90"></p><h2 id="十四、沟通管理和关系人管理"><a href="#十四、沟通管理和关系人管理" class="headerlink" title="十四、沟通管理和关系人管理"></a>十四、沟通管理和关系人管理</h2><p><a href="http://www.hihexo.com/pmp/chapter/766.htm" target="_blank" rel="noopener">项目沟通管理</a>包括为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程。项目经理的绝大多数时间都用于与团队成员和其他干系人的沟通，无论这些成员或干系人是来自组织内部（位于组织的各个层级上）还是组织外部。有效的沟通在项目干系人之间架起一座桥梁，把具有不同文化和组织背景、不同技能水平、不同观点和利益的各类干系人联系起来。这些干系人能影响项目的执行或结果。</p><p><a href="http://www.hihexo.com/pmp/chapter/767.htm" target="_blank" rel="noopener">10.1</a><a href="http://www.hihexo.com/pmp/chapter/767.htm" target="_blank" rel="noopener">规划沟通管理</a>——根据干系人的信息需要和要求及组织的可用资产情况，制定合适的<a href="http://www.hihexo.com/pmp/chapter/795.htm" target="_blank" rel="noopener">项目沟通</a>方式和计划的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/782.htm" target="_blank" rel="noopener">10.2</a>管理沟通——根据<a href="http://www.hihexo.com/pmp/chapter/780.htm" target="_blank" rel="noopener">沟通管理计划</a>，生成、收集、分发、储存、检索及最终处置项目信息的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/799.htm" target="_blank" rel="noopener">10.3</a>控制沟通——在整个<a href="http://www.hihexo.com/pmp/chapter/119.htm" target="_blank" rel="noopener">项目生命周期</a>中对沟通进行监督和控制的过程，以确保满足项目干系人对信息的需求。</p><p>上述过程所涉及的沟通活动，可按多种维度进行分类。需要考虑的维度包括（但不限于）：</p><p>内部（在项目内）和外部（客户、供应商、其他项目、组织、公众）；</p><p>正式（报告、会议记录、简报）和非正式（电子邮件、备忘录、即兴讨论）；</p><p>垂直（上下级之间）和水平（同级之间）；</p><p>官方（新闻通讯、年报）和非官方（私下的沟通）；</p><p>书面和口头，以及口头语言（音调变化）和非口头语言（身体语言）。</p><p>大多数沟通技能对于通用管理和项目管理都是相通的，例如：</p><p>主动倾听和有效倾听；</p><p>通过提问、探询意见和了解情况，确保更好地理解；</p><p>开展教育，增加团队知识，以便更有效地沟通；</p><p>寻求事实，以识别或确认信息；</p><p>设定和管理期望；</p><p>说服个人、团队或组织采取行动；</p><p>通过激励来鼓舞士气或重塑信心；</p><p>通过训练来改进绩效和取得期望结果；</p><p>通过协商，达成各方都能接受的协议；</p><p>解决冲突，防止破坏性影响；</p><p>概述、重述，并确定后续步骤。</p><hr><p><a href="http://www.hihexo.com/pmp/chapter/1000.htm" target="_blank" rel="noopener">项目干系人管理</a>包括用于开展下列工作的各个过程：识别能影响项目或受项目影响的全部人员、群体或组织，分析干系人对项目的期望和影响，制定合适的管理策略来有效调动干系人参与项目决策和执行。干系人管理还关注与干系人的持续沟通，以便了解干系人的需要和期望，解决实际发生的问题，管理利益冲突，促进干系人合理参与项目决策和活动。应该把干系人满意度作为一个关键的项目目标来进行管理。</p><p><a href="http://www.hihexo.com/pmp/chapter/1001.htm" target="_blank" rel="noopener">13.1</a><a href="http://www.hihexo.com/pmp/chapter/1001.htm" target="_blank" rel="noopener">识别干系人</a>——识别能影响项目决策、活动或结果的个人、群体或组织，以及被项目决策、活动或结果所影响的个人、群体或组织，并分析和记录他们的相关信息的过程。这些信息包括他们的利益、参与度、相互依赖、影响力及对项目成功的潜在影响等。</p><p><a href="http://www.hihexo.com/pmp/chapter/1013.htm" target="_blank" rel="noopener">13.2</a><a href="http://www.hihexo.com/pmp/chapter/1013.htm" target="_blank" rel="noopener">规划干系人管理</a>——基于对干系人需要、利益及对项目成功的潜在影响的分析， 制定合适的管理策略，以有效调动干系人参与整个<a href="http://www.hihexo.com/pmp/chapter/119.htm" target="_blank" rel="noopener">项目生命周期</a>的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/1025.htm" target="_blank" rel="noopener">13.3</a><a href="http://www.hihexo.com/pmp/chapter/1025.htm" target="_blank" rel="noopener">管理干系人参与</a>——在整个<a href="http://www.hihexo.com/pmp/chapter/119.htm" target="_blank" rel="noopener">项目生命周期</a>中，与干系人进行沟通和协作，以满足其需要与期望，解决实际出现的问题，并促进干系人合理参与项目活动的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/1041.htm" target="_blank" rel="noopener">13.4</a><a href="http://www.hihexo.com/pmp/chapter/1041.htm" target="_blank" rel="noopener">控制干系人参与</a>——全面监督项目干系人之间的关系，调整策略和计划，以调动干系人参与的过程。</p><h3 id="14-1-项目干系人管理的主要目的"><a href="#14-1-项目干系人管理的主要目的" class="headerlink" title="14.1 项目干系人管理的主要目的"></a>14.1 项目干系人管理的主要目的</h3><p><strong>避免</strong>项目干系人 在 项目管理中 的<strong>严重 分歧</strong></p><h3 id="14-2-沟通管理的过程"><a href="#14-2-沟通管理的过程" class="headerlink" title="14.2 沟通管理的过程"></a>14.2 沟通管理的过程</h3><p>①: 编制沟通计划</p><p>②: 记录工作日志</p><p>③: 发布项目信息</p><h3 id="14-3-沟通升级的原则"><a href="#14-3-沟通升级的原则" class="headerlink" title="14.3 沟通升级的原则"></a>14.3 沟通升级的原则</h3><p>与对方沟通—–&gt;与对方上级沟通——-&gt;与自己上级沟通——&gt;上级与上级沟通.</p><h3 id="14-4-绩效报告的输出"><a href="#14-4-绩效报告的输出" class="headerlink" title="14.4 绩效报告的输出"></a>14.4 绩效报告的输出</h3><p><strong>绩效报告 和  需求变更</strong> ,因为 绩效报告 一般 是 与同领导或客户汇报,经常都带来或大或小的变更.</p><h3 id="14-5-项目沟通计划"><a href="#14-5-项目沟通计划" class="headerlink" title="14.5 项目沟通计划"></a>14.5 项目沟通计划</h3><p>第一个工具与技术 : 干系人分析</p><p>输入: 项目章程</p><h3 id="14-6-语义障碍-和-认知障碍"><a href="#14-6-语义障碍-和-认知障碍" class="headerlink" title="14.6 语义障碍 和 认知障碍"></a>14.6 语义障碍 和 认知障碍</h3><p>语义障碍 主要发生在<strong>沟通传送</strong>时<br>认知障碍 通常发生在 信息的<strong>加工和理解</strong>上.</p><h3 id="14-7-项目绩效评审-目标"><a href="#14-7-项目绩效评审-目标" class="headerlink" title="14.7 项目绩效评审 目标"></a>14.7 项目绩效评审 目标</h3><p>评审本阶段的任务是否完成,决定项目是否 从当前阶段进入下一阶段.</p><h3 id="14-8-绩效评估实施过程"><a href="#14-8-绩效评估实施过程" class="headerlink" title="14.8 绩效评估实施过程"></a>14.8 绩效评估实施过程</h3><p>①: 首要任务: 确定绩效评估项</p><p>②: 组织评估团队</p><p>③: 收集审核绩效数据资料</p><p>④: 进行定量 和定性 评价,归纳,分析,撰写评价报告.</p><h3 id="14-9-绩效报告的内容"><a href="#14-9-绩效报告的内容" class="headerlink" title="14.9 绩效报告的内容"></a>14.9 绩效报告的内容</h3><p>①: 项目<strong>进展</strong>和执行情况和调整情况</p><p>②: <strong>成本</strong>使用情况</p><p>③: 团队成员<strong>绩效</strong>情况</p><p>④: <strong>项目存在的问题及解决措施</strong></p><p>⑤: 对项目的<strong>预测</strong></p><p>⑥: <strong>变更请求</strong></p><p>⑦: 绩效<strong>目标及依据</strong></p><p><strong>注: 不包括 干系人沟通需求,干系人沟通需求是 在沟通管理计划里面</strong></p><h3 id="14-10-计算题"><a href="#14-10-计算题" class="headerlink" title="14.10 计算题"></a>14.10 计算题</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.16.png" alt="16"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.17.png" alt="17"></p><h3 id="14-11-项目干系人分析"><a href="#14-11-项目干系人分析" class="headerlink" title="14.11 项目干系人分析"></a>14.11 项目干系人分析</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.18.png" alt="18"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.19.png" alt="19"></p><h3 id="14-12-项目干系人管理输入"><a href="#14-12-项目干系人管理输入" class="headerlink" title="14.12 项目干系人管理输入:"></a>14.12 项目干系人管理输入:</h3><p>①: 干系人管理计划</p><p>②: 沟通管理计划</p><p>③: 变更日志</p><p>④: 组织过程资产</p><p><strong>注: 问题日志 是 管理干系人参与的 输出. </strong></p><h3 id="14-13-沟通方法"><a href="#14-13-沟通方法" class="headerlink" title="14.13 沟通方法"></a>14.13 沟通方法</h3><p>有多种方法在干系人间共享信息</p><p>①: 拉式沟通: 用于信息量大,受众很多的情况,要求接收者自行地访问信息内容,例如: <strong>企业内网,电子在线课程</strong>,经验教训数据库,知识库<br>②: 推式沟通: 把信息发送给需要接收这些信息的特定接收方,例如: <strong>电子邮件,传真,信件</strong>等<br>③: 交互式沟通: 在两方或多方进行多向信息交换,例如: <strong>会议,电话,视频会议</strong>等</p><p><strong>注: 最有效的沟通并解决干系人之间问题的方法————-面对面会议</strong></p><h3 id="14-14-沟通管理计划的工具和技术"><a href="#14-14-沟通管理计划的工具和技术" class="headerlink" title="14.14 沟通管理计划的工具和技术"></a>14.14 沟通管理计划的工具和技术</h3><p>①: 沟通需求分析</p><h3 id="14-15-沟通管理计划的输入"><a href="#14-15-沟通管理计划的输入" class="headerlink" title="14.15 沟通管理计划的输入"></a>14.15 沟通管理计划的输入</h3><p>①: 组织过程资产</p><p>②: 项目章程</p><p>③: 项目范围说明书</p><h2 id="十五、风险管理"><a href="#十五、风险管理" class="headerlink" title="十五、风险管理"></a>十五、风险管理</h2><p><a href="http://www.hihexo.com/pmp/chapter/816.htm" target="_blank" rel="noopener">项目风险管理</a>包括规划风险管理、识别风险、实施风险分析、规划风险应对和控制风险等各个过程。项目风险管理的目标在于提高项目中积极事件的概率和影响，降低项目中消极事件的概率和影响。</p><p><a href="http://www.hihexo.com/pmp/chapter/817.htm" target="_blank" rel="noopener">11.1</a>规划风险管理——定义如何实施项目风险管理活动的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/830.htm" target="_blank" rel="noopener">11.2</a>识别风险——判断哪些风险可能影响项目并记录其特征的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/855.htm" target="_blank" rel="noopener">11.3</a>实施定性风险分析——评估并综合分析风险的发生概率和影响，对风险进行优先排序，从而为后续分析或行动提供基础的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/871.htm" target="_blank" rel="noopener">11.4</a>实施定量风险分析——就已识别风险对项目整体目标的影响进行定量分析的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/885.htm" target="_blank" rel="noopener">11.5</a>规划风险应对——针对项目目标，制定提高机会、降低威胁的方案和措施的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/897.htm" target="_blank" rel="noopener">11.6</a>控制风险——在整个项目中实施风险应对计划、跟踪已识别风险、监督残余风险、识别新风险，以及评估风险过程有效性的过程。</p><h3 id="15-1-风险识别的输入"><a href="#15-1-风险识别的输入" class="headerlink" title="15.1 风险识别的输入:"></a>15.1 风险识别的输入:</h3><p>①: 风险管理计划</p><p>②: 成本</p><p>③: 进度</p><p>④: 质量</p><p>⑤: 人力资源</p><p>⑥: 范围</p><p>⑦: 活动成本估算</p><p>⑧: 活动持续时间估算</p><p>⑨: 干系人登记册</p><p>⑩: 项目文件</p><p>⑩: 采购文件</p><p>⑩: 事业环境因素</p><p>⑩: 组织过程资产</p><h3 id="15-2-风险管理计划的内容"><a href="#15-2-风险管理计划的内容" class="headerlink" title="15.2 风险管理计划的内容:"></a>15.2 风险管理计划的内容:</h3><p>①: 风险类别</p><p>风险类别: </p><p>它提供了一种<strong>结构化方法</strong>以便<strong>使风险识别的过程系统化,全面化</strong>,这样就能在<strong>统一的框架</strong>下进行风险识别,目的是<strong>提高风险识别的工作质量和有效性</strong></p><p>②: 风险概率和影响力的定义</p><p>③: 概率及影响矩阵</p><p>④: 预算</p><p>⑤: 方法论</p><p>⑥: 角色与职责</p><p>⑦: 已修订的项目干系人对风险的忍受度</p><p>⑧: 报告的格式</p><p>⑨: 制定的时间表</p><p>⑩: 跟踪</p><h3 id="15-3-定性风险分析"><a href="#15-3-定性风险分析" class="headerlink" title="15.3 定性风险分析"></a>15.3 定性风险分析</h3><p>对<strong>风险概率</strong>或<strong>影响</strong>进行<strong>评估和汇总</strong>,进而对风险进行排序,<strong>确定项目整体风险的等级,</strong>以便随后进一步分析或行动.</p><h3 id="15-4-风险识别的工具"><a href="#15-4-风险识别的工具" class="headerlink" title="15.4 风险识别的工具"></a>15.4 风险识别的工具</h3><p>①: 德尔菲技术</p><p>通过多轮征询获得专家对项目的一致见解, 项目风险专家<strong>以匿名方式参与</strong>活动,防止个人对结果产生过大影响, 当专家不在现场时,适合此方法</p><p>所以只看最后一个回合的值</p><p>②: 头脑风暴</p><p>目的是取得一份综合的风险清单,与会人员就项目风险 集思广益</p><p>③: 访谈</p><p>④: 根本原因识别</p><p>⑤: SWOT: 从项目的每个<strong>优势,劣势,机会,威胁</strong>出发,对项目进行考察,从而更全方面的考虑风险.</p><h3 id="15-5-风险分类"><a href="#15-5-风险分类" class="headerlink" title="15.5 风险分类"></a>15.5 风险分类</h3><p><strong>①: 从性质分:</strong></p><p>静态风险: <strong>自然力</strong>的不规则作用,<strong>人们的错误判断</strong>,和<strong>错误行为</strong>导致的风险.</p><p>动态风险: 由于<strong>人们欲望</strong>的变化,<strong>生产方式</strong>和<strong>生产技术</strong>的变化以及<strong>企业组织</strong>的<strong>变化</strong>导致的风险.</p><p><strong>②: 从结果分:</strong></p><p>纯粹风险: 仅仅造成损害</p><p>投机风险: 可能产生利润,可能造成损失</p><p><strong>③: 从风险源分:</strong></p><p>自然事件</p><p>人为事件</p><p>软件风险</p><p>软件过程风险</p><p>项目管理风险</p><p>应用风险</p><p>用户使用风险</p><p>商业风险: 开发的产品不符合市场需求</p><h3 id="15-6-项目风险识别的图解技术"><a href="#15-6-项目风险识别的图解技术" class="headerlink" title="15.6 项目风险识别的图解技术:"></a>15.6 项目风险识别的图解技术:</h3><p>①: <strong>因果分析图</strong>: 又称 <strong>鱼骨图</strong>: 用于<strong>确定风险的起因</strong></p><p>②: 系统或过程的<strong>流程图</strong>: 反映某一系统内部各要素之间是如何相互联系的,并反映发生因果关系的机制.</p><p>③:<strong>影响图</strong>: 是一种图解表示问题的方法,反映了变量和结果之间的因果关系的相互作用,事件的时间顺序及其他关系.</p><h3 id="15-7-风险应对策略"><a href="#15-7-风险应对策略" class="headerlink" title="15.7 风险应对策略:"></a>15.7 风险应对策略:</h3><p>①: 消极风险应对策略: 改变计划,以排除风险,或保护项目目标不受影响,或对受威胁的一些项目目标放松要求.</p><h3 id="15-8-风险识别"><a href="#15-8-风险识别" class="headerlink" title="15.8 风险识别"></a>15.8 风险识别</h3><p>①: 参与者: 尽可能多,尽可能广泛的人员参与,主要是 项目团队、客户、项目干系人等</p><p>②: 风险识别是一个不断重复的系统活动,而不是一次性的</p><p>③: 识别内部和外部风险</p><h3 id="15-9-风险监控的输出"><a href="#15-9-风险监控的输出" class="headerlink" title="15.9 风险监控的输出"></a>15.9 风险监控的输出</h3><p>①: 建议的纠正措施</p><p>②: 新发现的风险</p><p>③: 新的风险管理知识</p><p>④: 变更申请 但不是批准的变更申请</p><h3 id="15-10-风险三要素"><a href="#15-10-风险三要素" class="headerlink" title="15.10 风险三要素"></a>15.10 风险三要素</h3><p>①: 风险事件</p><p>②: 风险概率</p><p>③: 风险结果</p><h3 id="15-11-权变措施"><a href="#15-11-权变措施" class="headerlink" title="15.11 权变措施"></a>15.11 权变措施</h3><p>是风险监控过程中,对未识别的风险进行临时权变处理.</p><p>风险监控过程 输出 中的”建议的纠正措施”里的临时措施,即为 权变措施.</p><p>①: 对不利风险事件的未经计划的应对</p><h3 id="15-12-定量风险分析的技术"><a href="#15-12-定量风险分析的技术" class="headerlink" title="15.12 定量风险分析的技术:"></a>15.12 定量风险分析的技术:</h3><p>期望货币值技术</p><h3 id="15-13-预期收益计算"><a href="#15-13-预期收益计算" class="headerlink" title="15.13 预期收益计算"></a>15.13 预期收益计算</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.82.png" alt="19"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.83.png" alt="19"></p><p>注意: EMV的计算,不是 75%* 300+60*25%+(-100)</p><p>也不是 75% *150 +25%*70+(-40)</p><h2 id="十六、采购管理"><a href="#十六、采购管理" class="headerlink" title="十六、采购管理"></a>十六、采购管理</h2><p><a href="http://www.hihexo.com/pmp/chapter/916.htm" target="_blank" rel="noopener">项目采购管理</a>包括从项目团队外部采购或获得所需产品、服务或成果的各个过程。项目组织既可以是项目产品、服务或成果的买方，也可以是卖方。</p><p>项目采购管理包括合同管理和变更控制过程。通过这些过程，编制合同或订购单，并由具备相应权限的项目团队成员签发，然后再对合同或订购单进行管理。</p><p>项目采购管理还包括控制外部组织（买方）为从执行组织（卖方）获取项目<a href="http://www.hihexo.com/pmp/chapter/177.htm" target="_blank" rel="noopener">可交付成果</a>而签发的任何合同，以及管理该合同所规定的项目团队应承担的合同义务。</p><p><a href="http://www.hihexo.com/pmp/chapter/917.htm" target="_blank" rel="noopener">12.1</a>规划采购管理——记录项目采购决策、明确采购方法、识别潜在卖方的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/941.htm" target="_blank" rel="noopener">12.2</a>实施采购——获取卖方应答、选择卖方并授予合同的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/966.htm" target="_blank" rel="noopener">12.3</a>控制采购——管理采购关系、监督合同执行情况，并根据需要实施变更和采取纠正措施的过程。</p><p><a href="http://www.hihexo.com/pmp/chapter/989.htm" target="_blank" rel="noopener">12.4</a>结束采购——完结单次项目采购的过程。</p><h3 id="16-1-采购规划的输出"><a href="#16-1-采购规划的输出" class="headerlink" title="16.1 采购规划的输出"></a>16.1 采购规划的输出</h3><p>①: 采购工作说明书</p><h3 id="16-2-采购规划的输入"><a href="#16-2-采购规划的输入" class="headerlink" title="16.2 采购规划的输入"></a>16.2 采购规划的输入</h3><p>①: 干系人登记册</p><p>②: 风险登记册</p><p>③: 项目管理计划</p><h3 id="16-3-关于合同"><a href="#16-3-关于合同" class="headerlink" title="16.3 关于合同:"></a>16.3 关于合同:</h3><p>在编制项目采购计划时,根据采购类型的不同,需要不同类型的合同来配合.</p><p>①: 总价合同: 采用固定总价格,适用于<strong>产品范围较明确</strong>,<strong>买方风险小.</strong></p><p>②: 成本补偿合同: 包括支付给卖方的<strong>实际成本</strong>, 加上一些通常作为<strong>卖方利润</strong>的费用,适合<strong>产品范围不明确,或项目存在较高风险,卖方风险小.</strong></p><p>③: 工时和材料合同:  也称单价合同,是综合了固定总价和成本补偿的优点的合同,适用于 <strong>数量和时长不确定</strong>,工作<strong>规模或产品界定不甚明确</strong>.如聘请专家等</p><h3 id="16-4-采购计划编制工具和技术"><a href="#16-4-采购计划编制工具和技术" class="headerlink" title="16.4 采购计划编制工具和技术:"></a>16.4 采购计划编制工具和技术:</h3><p>①: 自制/外购分析</p><p>②: 专家判断</p><p>③: 合同类型</p><h2 id="十七、合同管理"><a href="#十七、合同管理" class="headerlink" title="十七、合同管理"></a>十七、合同管理</h2><h3 id="17-1-注意事项"><a href="#17-1-注意事项" class="headerlink" title="17.1 注意事项"></a>17.1 注意事项</h3><p>①: 如果合同中有附件,当<strong>附件</strong>和主合同产生<strong>矛盾</strong>时,应该<strong>以主合同为准.</strong></p><h3 id="17-2-合同描述"><a href="#17-2-合同描述" class="headerlink" title="17.2 合同描述:"></a>17.2 合同描述:</h3><p>①: 合同<strong>不是</strong>解决两方或多方当事人分歧的 <strong>而是</strong>双方订立的一种约定</p><h3 id="17-3-合同管理"><a href="#17-3-合同管理" class="headerlink" title="17.3 合同管理"></a>17.3 合同管理</h3><p>合同付款, 绩效测量</p><h3 id="17-4-合同管理的目"><a href="#17-4-合同管理的目" class="headerlink" title="17.4 合同管理的目"></a>17.4 合同管理的目</h3><p>①: 审核并记录供应商的<strong>绩效</strong>以建立必须的<strong>纠正</strong>措施并作为将来选择供应商的参考</p><p>②: 管理合同相关的变更利于项目客户的合同关系</p><p>③: </p><h2 id="十八、知识产权与标准规范"><a href="#十八、知识产权与标准规范" class="headerlink" title="十八、知识产权与标准规范"></a>十八、知识产权与标准规范</h2><h3 id="18-1-标准代号"><a href="#18-1-标准代号" class="headerlink" title="18.1  标准代号"></a>18.1  标准代号</h3><p>①: GSB: 我国国家实物标准代号(国实标)</p><p>②: GB / T 推荐性国家标准(国标/推)</p><p>③: GA / T 我国公安部制定的推荐性标准 (国安/推)  ——&gt;  <strong>属于行业标准,不属于国家标准</strong></p><p>④: GB / Z 国家标准指导性技术文件</p><p>⑤: BS 英国国家标准</p><p>⑥: ANSI: 美国国家标准</p><h3 id="18-2-lt-lt-中华人民共和国政府采购法-gt-gt"><a href="#18-2-lt-lt-中华人民共和国政府采购法-gt-gt" class="headerlink" title="18.2 &lt;&lt;中华人民共和国政府采购法&gt;&gt;"></a>18.2 &lt;&lt;中华人民共和国政府采购法&gt;&gt;</h3><p>政府采购实行集中采购 和 分散采购</p><p>①: 集中采购: 由省级以上人民政府公布的集中采购目录确定, <strong>属于中央预算的</strong>政府采购项目,其集中采购目录 <strong>由国务院</strong> 确定并公布;<strong>属于地方预算的</strong>政府采购项目,其集中采购目录 <strong>由 省 自治区, 直辖市人民政府</strong>,或其授权的机构确定.</p><p>②: 分散采购: </p><p>③: 采购人,采购代理机构对政府采购项目每项采购活动的<strong>采购文件</strong>保存期限为 从采购结束之日起 <strong>至少保存 15年.</strong></p><p><strong>④: 采购文件:  </strong> 中包含采购活动记录,采购预算,招标文件(由招标方准备),投标文件,评标标准,评估报告,合同文件等</p><p><strong>⑤: 竞争性谈判:</strong> 主要依据: <strong>条件相当下的报价最低</strong>的原则 确定供应商,  <strong>而不是 根据综合实力</strong></p><p>⑥: 政府采购合同履行中,采购人需要追加与合同标的相同的货物等,在不改变合同其他条款前提下,可以与供应商协商签订 <strong>补充合同</strong>,但采购金额<strong>不得超过原合同采购金额的 10%</strong>.</p><p>⑦: 采购人采购<strong>纳入</strong> <strong>集中采购目录的政府采购项目</strong>,<strong>必须委托集中采购机构代理采购</strong>;<br><strong>未纳入集中采购目录的政府采购项目,可以自行采购</strong>,也可以委托集中采购机构在委托的范围内代理采购.</p><p>⑧: 采购人有权自行选择采购代理机构, 任何单位和个人不能以任何方式为采购人指定采购代理机构</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.112.png" alt="112"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.113.png" alt="113"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.114.png" alt="114"></p><h3 id="18-3-lt-lt-中华人民共和国-招标投标法-gt-gt"><a href="#18-3-lt-lt-中华人民共和国-招标投标法-gt-gt" class="headerlink" title="18.3  &lt;&lt;中华人民共和国 招标投标法&gt;&gt;"></a>18.3  &lt;&lt;中华人民共和国 招标投标法&gt;&gt;</h3><p>①: 招标人设有标底的,<strong>标底必须保密.</strong></p><p>②: 招标人不得向他人透露 已 获取招标文件的潜在投标人的名称,数量,以及可能影响公平竞争的有关招标投标的其他情况.</p><p>③: 中标人按照<strong>合同约定</strong> 或者经过 <strong>招标人同意</strong>,可以将 中标项目的部分<strong>非主体</strong>,<strong>非关键性</strong>工作<strong>分包</strong>给他人完成,<strong>接受分包的人</strong>应当具备相应的条件,并<strong>不得再次 分包</strong>.</p><p>④: 招标人对已发出的招标文件进行必要的澄清 或者<strong>修改</strong>的,应该在 招标文件要求提交投标文件的截止时间<strong>至少 15 日前</strong>,以书面形式<strong>通知所有招标文件收受者.</strong></p><p>⑤: <strong>30日内</strong>签订合同</p><p>⑥: 评审委员会人数 必须 <strong>5人以上单数</strong></p><p>⑦: 确定中标人 后 要<strong>通知所有 投标人</strong></p><p>⑧: 招标人最迟应当在 <strong>书面合同签订后5日内</strong>向中标人,和未中标的投标人<strong>退换投标保证金</strong>及银行同期存款利息</p><p>⑨: 评审委员会成员 中 技术,经济等方面<strong>专家不得少于</strong>成员<strong>总数的 2/3.</strong></p><p>⑩: <strong>开标由招标人主持</strong>,邀请所有投标人参加.</p><p>⑩: 招标人可以授权 评标委员会 <strong>直接确定中标人.</strong></p><p>⑩: 招标人有权自行选择招标代理机构,委托其办理招标事宜.</p><p>⑩: 招标人具有编制招标文件和组织评标能力的,可以自行办理招标事宜.</p><p>⑩: 招标人<strong>收到投标文件</strong>后,应当<strong>签收保存,不得开启.</strong></p><p>⑩: 合同中未说明时,合同生效日期,以<strong>邮戳为准</strong></p><p>⑩: 自招标文件开始发出之日起至投标人提交投标文件截止日为止,最短<strong>不得少于20日</strong>.</p><p>⑩: <strong>开标 由招标人主持</strong>, 邀请所有投标人参加.</p><p><strong>注意: 开标 由招标人主持, 而不是招标监督机构主持</strong></p><p><strong>注意: 几个数字: 签合同30, 截止20, 修改/ 投诉 / 质疑15, 推押金5,专家比例2/3</strong></p><h3 id="18-4-软件维护指南GB-T-14079-1993"><a href="#18-4-软件维护指南GB-T-14079-1993" class="headerlink" title="18.4 软件维护指南GB/T 14079-1993"></a>18.4 软件维护指南GB/T 14079-1993</h3><p><strong>属于开发标准, 而不是文档标准.</strong></p><h3 id="18-5-软件文档"><a href="#18-5-软件文档" class="headerlink" title="18.5 软件文档"></a>18.5 软件文档</h3><p>三种类型:</p><h4 id="18-5-1-开发文档"><a href="#18-5-1-开发文档" class="headerlink" title="18.5.1 开发文档"></a>18.5.1 开发文档</h4><p>描述开发过程本身.</p><p>①: 可行性研究和项目任务书</p><p>②: 需求规格说明</p><p>③: 功能规格说明</p><p>④: 设计规格说明(包括程序和数据规格说明)</p><p>⑤: 开发计划</p><p>⑥: 软件集成和测试计划</p><p><strong>⑦: 质量保证计划,标准,进度.</strong></p><p>⑧: 安全和测试信息</p><h4 id="18-5-2-产品文档"><a href="#18-5-2-产品文档" class="headerlink" title="18.5.2 产品文档"></a>18.5.2 产品文档</h4><p>① : 培训手册</p><p>②: 参考手册和用户指南</p><p>③: 产品手册</p><p>④: 软件支持手册</p><h4 id="18-5-3-管理文档"><a href="#18-5-3-管理文档" class="headerlink" title="18.5.3 管理文档"></a>18.5.3 管理文档</h4><p><strong>记录项目管理的信息</strong></p><p>①: 开发过程的每个阶段的<strong>进度和 进度变更</strong>的记录.</p><p>②: <strong>软件变更</strong>情况 的记录</p><p>③: 相对于开发的判定记录</p><p>④: <strong>职责定义</strong></p><p><strong>口诀: 开计划,产手册,管变更</strong></p><h3 id="18-6-软件质量保证计划规范-GB-T12504-1990"><a href="#18-6-软件质量保证计划规范-GB-T12504-1990" class="headerlink" title="18.6 软件质量保证计划规范 GB/T12504-1990"></a>18.6 软件质量保证计划规范 GB/T12504-1990</h3><p>项目开发组组长或其代表 <strong>可作为评审组成员</strong>,但是<strong>不能 担任 评审组 组长 或副组长</strong></p><p>①: 验证(重点是: 是否达到需求)</p><p>确定软件<strong>开发周期中</strong>的一个给定阶段的额产品<strong>是否达到 上一阶段 确立的 需求</strong> 的过程</p><p>②: 确认(重点是: 是否 与需求<strong>一致</strong>)</p><p>软件<strong>开发过程结束</strong> 时 对软件进行评价以确定它<strong>是否 和软件需求 相一致</strong>的过程.</p><p>③: 测试</p><p>通过执行程序 来有意识 地<strong>发现</strong> 程序设计 <strong>错误</strong> 和编码错误的过程.</p><h3 id="18-7-质量管理"><a href="#18-7-质量管理" class="headerlink" title="18.7 质量管理"></a>18.7 质量管理</h3><p>①: 重要工作: 评价和改进</p><p>②: 重点: 持续改进</p><h3 id="18-8-软件保护条例"><a href="#18-8-软件保护条例" class="headerlink" title="18.8 软件保护条例"></a>18.8 软件保护条例</h3><p><strong>包括</strong> <strong>程序 和文档</strong> ,但<strong>不包括 开发该软件所用的思想.</strong></p><h3 id="18-9-评标委员会-和-评标方法-暂行规定"><a href="#18-9-评标委员会-和-评标方法-暂行规定" class="headerlink" title="18.9 评标委员会 和 评标方法 暂行规定"></a>18.9 评标委员会 和 评标方法 暂行规定</h3><p>投标文件中 大写金额和 小写金额 不一致 的 ,以 大写金额 为准;总价金额 与 单价金额  不一致的 以单价金额为准.,但单价金额小数点有错误的除外,对不同文本发生异议的,以中文为准.</p><h3 id="18-10-文档质量"><a href="#18-10-文档质量" class="headerlink" title="18.10 文档质量"></a>18.10 文档质量</h3><p>可按照文档形式 和 列出的要求划分为4级</p><p>①: 最低限度文档(1级文档): 开发工作量低于 一个人月的开发者自用程序</p><p>②: 内部文档(2级文档): 没有与其他用户共享资源的专用程序</p><p>③: 工作文档(3级文档): 同一单位若干人联合开发的程序</p><p>④: 正式文档(4级文档): 正式发行供普遍使用的软件产品.</p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.154.png" alt="154"></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.155.png" alt="155"></p><h3 id="18-11-软件质量属性"><a href="#18-11-软件质量属性" class="headerlink" title="18.11 软件质量属性"></a>18.11 软件质量属性</h3><p>①: 功能性: </p><p>②: 可靠性: 成熟,容错,易恢复</p><p>③: 易用性: 使用的难易程度及规定</p><p>④: 效率: <strong>软件性能水平</strong>和所用资源之间的关系</p><p>⑤: 维护性</p><p>⑥: 可移植性</p><h3 id="18-12-完整的综合布线系统-6个部分"><a href="#18-12-完整的综合布线系统-6个部分" class="headerlink" title="18.12 完整的综合布线系统(6个部分)"></a>18.12 完整的综合布线系统(6个部分)</h3><p>①: 建筑群子系统: 实现建筑物之间的相互连接,通常介质是光缆.</p><p>②: 垂直干线子系统: 负责连接<strong>管理间子系统,到设备间子系统,</strong>使用光缆或UTP.</p><p>③: 水平配线子系统: 实现信息<strong>插座和管理子系统</strong>的连接.</p><p>④: 设备间子系统: 由设备中的电缆,连接器和相关支撑设备组成,与公共系统设备相连.</p><p>⑤: 工作区子系统: <strong>终端设备连到信息插座</strong></p><p>⑥: 管理子系统: 是<strong>干线子系统和水平子系统的桥梁</strong>,同时又可为同层组网提供条件,为<strong>连接其他子系统提供连接手段</strong>,由配线架,HUB,机柜,电源灯组成.</p><h3 id="18-13-lt-lt-中华人民共和国著作权法-gt-gt"><a href="#18-13-lt-lt-中华人民共和国著作权法-gt-gt" class="headerlink" title="18.13 &lt;&lt;中华人民共和国著作权法&gt;&gt;"></a>18.13 &lt;&lt;中华人民共和国著作权法&gt;&gt;</h3><p>①: 改编,翻译,注释,整理已有作品而产生的作品,著作权<strong>由 改编,翻译,注释,整理人 享有..</strong></p><p>②: 作者的署名权,修改权,保护作品完整权的 保护期不受限制.</p><p>③: 公民的作品,其发表权,使用权和获得报酬权的保护期 为作者终生及其死亡 后 50 年, 截止 于 作者死亡后 第50年的12月31日.</p><p>④: 计算机软件和口述作品等受著作权保护</p><p><strong>注: </strong></p><p>①: 不适用于: <strong>法律,法规,行政,司法性质的文件</strong>等</p><p>②: 不适用于<strong>时事新闻</strong></p><p>③: 不适用于 <strong>历法,通用数表,通用表格和公式</strong>.</p><h3 id="18-14-软件文档管理指南GB-T16680-1996"><a href="#18-14-软件文档管理指南GB-T16680-1996" class="headerlink" title="18.14 软件文档管理指南GB/T16680-1996"></a>18.14 软件文档管理指南GB/T16680-1996</h3><p>文档评审:<br>由软件开发小组成员,<strong>用户代表</strong>,软件开发单位负责人,标准化人员,科技管理人员组成评审小组.</p><p><strong>注: 用户代表 必须参加.</strong></p><h3 id="18-15-电子计算机机房规范GB50174-1993"><a href="#18-15-电子计算机机房规范GB50174-1993" class="headerlink" title="18.15 电子计算机机房规范GB50174-1993"></a>18.15 电子计算机机房规范GB50174-1993</h3><p>四种接地方式:</p><p>①: <strong>直流</strong>工作接地:  接地电阻 应按照计算机系统具体要求, 一般不大于<strong>1欧姆</strong></p><p>②: <strong>交流</strong>工作接地:  接地电阻 不应大于<strong>4欧姆</strong></p><p>③: <strong>安全</strong>工作接地:  接地电阻 不应大于<strong>4欧姆</strong></p><p>④: <strong>防雷</strong>接地:  应该按照现行 国家标准 &lt;&lt;建筑防雷设计规范&gt;&gt;执行,一般不大于<strong>10 欧姆</strong></p><p>注: <strong>静电</strong>接地 可以经过限流电阻 及自己的连接线与接地装置相连,限流电阻的阻值宜为<strong>1M欧姆.</strong></p><p><strong>口诀: 1直男交4女友被雷劈10</strong></p><h3 id="18-16-合同法"><a href="#18-16-合同法" class="headerlink" title="18.16 合同法"></a>18.16 合同法</h3><p>①: 当事人订立合同,采取方式 有 “要约”,和”承诺”方式. </p><p>②: 当事人 采用信件,数据电文等形式订立合同的,可以在合同成立之前要求签订确认书,签订确认书时合同成立.</p><h4 id="18-16-1-要约"><a href="#18-16-1-要约" class="headerlink" title="18.16.1 要约"></a>18.16.1 要约</h4><p>表示<strong>自己希望和他人</strong>订立合同</p><p>例如: 投标人向招标人投递标书———提交的投标文件是 投标人希望同招标人订立合同</p><h4 id="18-16-2-要约邀请"><a href="#18-16-2-要约邀请" class="headerlink" title="18.16.2 要约邀请"></a>18.16.2 要约邀请</h4><p>表示<strong>希望他人向自己</strong>   <strong>发出要约</strong>,例如: <strong>征婚广告</strong>,拍卖公告,招标公告,商业广告,寄送的价目表等都是要约邀请.</p><p><strong>注: 要约到达受要约人时生效.</strong></p><h4 id="18-16-3-承诺"><a href="#18-16-3-承诺" class="headerlink" title="18.16.3 承诺"></a>18.16.3 承诺</h4><p>表示受要约人<strong>同意要约</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.85.png" alt="85"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.86.png" alt="86"></p><h3 id="18-17-格式条款-与-非格式条款"><a href="#18-17-格式条款-与-非格式条款" class="headerlink" title="18.17 格式条款 与  非格式条款"></a>18.17 格式条款 与  非格式条款</h3><h4 id="18-17-1-格式条款"><a href="#18-17-1-格式条款" class="headerlink" title="18.17.1 格式条款:"></a>18.17.1 格式条款:</h4><p>①: 又称标准条款,指当事人为重复使用而预先拟定的,并在<strong>订立合同时未与对方协商的条款,</strong>如保险合同,拍卖成交确认书等都是格式合同.</p><p>②: 采用订立合同的,提供格式条款的一方应当遵循公平原则确定当事人之间的权利和义务,并采取合理的 方式提请对方注意免除或者限制其责任的条款.</p><p>③: 当格式条款与 非格式条款<strong>不一致时 应当 采用 非格式 条款.</strong></p><p>④: 提供格式条款 一方<strong>免除其责任,加重对方责任</strong>,排除对方主要权利的<strong>该条款无效.</strong></p><h4 id="18-17-2-非格式条款"><a href="#18-17-2-非格式条款" class="headerlink" title="18.17.2 非格式条款"></a>18.17.2 非格式条款</h4><h3 id="18-18-有效性计算"><a href="#18-18-有效性计算" class="headerlink" title="18.18 有效性计算"></a>18.18 有效性计算</h3><p>有效性 = ( 总运行时间  -  故障恢复时间 ) /  总运行时间</p><p>例题: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.20.png" alt="20"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.21.png" alt="21"></p><h3 id="18-19-政府采购的招标程序"><a href="#18-19-政府采购的招标程序" class="headerlink" title="18.19 政府采购的招标程序"></a>18.19 政府采购的招标程序</h3><p>①: <strong>采购人</strong> <strong>编制计划</strong>,报县级以上人民政府的<strong>财政部门</strong>批准</p><p>②: <strong>采购办</strong>与<strong>招标代理机构</strong> 办理委托手续,确定<strong>招标方式</strong></p><p>③: <strong>建设单位</strong>委托 相关 的<strong>咨询公司</strong>进行 <strong>市场调查</strong>, 与<strong>采购人</strong>确认采购项目后,<strong>编制招标文件.</strong></p><p>④: <strong>发布招标公告</strong>,或招标邀请函</p><p>⑤: <strong>出售招标文件</strong>,对潜在的投标人资格预审</p><p>⑥: 接受投标人标书</p><p>⑦: 在公告或邀请函中规定的时间,地点<strong>公开开标</strong></p><p>⑧: 由评标委员对投标文件评标</p><p>⑨: 依据评标原则确定中标人</p><p>⑩: 向中标人发送中标通知书,并通知所有投标人</p><p>⑩: 组织中标人与采购单位签订合同</p><h3 id="18-20-软件工程术语GB-T11457-2006"><a href="#18-20-软件工程术语GB-T11457-2006" class="headerlink" title="18.20 软件工程术语GB/T11457-2006"></a>18.20 软件工程术语GB/T11457-2006</h3><p>对于配置管理有以下三种基线:</p><p>①: 功能基线</p><p>②: 分配基线</p><p>③: 产品基线</p><h3 id="18-21-机房工程设计原则"><a href="#18-21-机房工程设计原则" class="headerlink" title="18.21 机房工程设计原则"></a>18.21 机房工程设计原则</h3><p>①: 实用性和先进性:  <strong>满足当前</strong>业务需求,<strong>兼顾未来</strong>的业务需求,尽可能采用先进设备,技术.</p><p>②: 安全可靠性: 决不能出现单点故障</p><p>③: 灵活可扩展性:  能根据业务不断深入发展的需要,扩大设备容量,提高可容纳用户数,支持多种网络传输,多种物理接口的能力等</p><p>④: 标准化</p><p>⑤: 经济性,投资保护</p><p>⑥: 可管理性</p><h3 id="18-22-著作权"><a href="#18-22-著作权" class="headerlink" title="18.22 著作权"></a>18.22 著作权</h3><p>公民完成法人或其他组织工作任务所创作的作品是职务作品,其一般职务作品的著作权由作者享有,但法人或非法人单位有权在其业务范围内优先使用,作品完成两年内,未经过单位同意, 作者不得许可第三人使用.</p><h3 id="18-23-合同法"><a href="#18-23-合同法" class="headerlink" title="18.23 合同法"></a>18.23 合同法</h3><p>①: 法律,行政法规规定或当事人约定采用书面形式订立合同,当事人未采用书面形式,但一方已经履行主要义务,对方接受的,该合同成立</p><p>②: 采用合同书形式订立合同,在签字或盖章前,一方已经履行了主要义务,对方接受的,该合同成立.</p><p>③: 标的物在订立合同之前已为买受人占有的,合同生效时间为交付时间.</p><h3 id="18-24-关于政府采购的招标流程"><a href="#18-24-关于政府采购的招标流程" class="headerlink" title="18.24 关于政府采购的招标流程:"></a>18.24 关于政府采购的招标流程:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.104.png" alt="104"></p><h3 id="18-25-机房等级"><a href="#18-25-机房等级" class="headerlink" title="18.25 机房等级"></a>18.25 机房等级</h3><p>A 容错——-最高级别</p><p>B 冗余</p><p>C 需求</p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.158.png" alt="158"></p><h3 id="18-26-文档质量四个等级"><a href="#18-26-文档质量四个等级" class="headerlink" title="18.26 文档质量四个等级"></a>18.26 文档质量四个等级</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.136.png" alt="136"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.137.png" alt="137"></p><h3 id="18-27-软件生存周期过程-GB-T-8566-2001"><a href="#18-27-软件生存周期过程-GB-T-8566-2001" class="headerlink" title="18.27 软件生存周期过程 GB/T 8566-2001"></a>18.27 软件生存周期过程 GB/T 8566-2001</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.139.png" alt="139"></p><h2 id="十九、干系人管理"><a href="#十九、干系人管理" class="headerlink" title="十九、干系人管理"></a>十九、干系人管理</h2><h3 id="19-1-干系人登记册"><a href="#19-1-干系人登记册" class="headerlink" title="19.1 干系人登记册"></a>19.1 干系人登记册</h3><p>为项目的沟通计划提供了干系人的信息,从干系人的登记册中,可知道项目中干系人的信息: <strong>主要沟通对象,关键影响人,次要沟通对象.</strong></p><h3 id="19-2-管理干系人的参与-输入"><a href="#19-2-管理干系人的参与-输入" class="headerlink" title="19.2 管理干系人的参与 输入:"></a>19.2 管理干系人的参与 输入:</h3><p>①: 干系人管理计划</p><p>②: 沟通管理计划</p><p><strong>③: 变更日志</strong></p><p>④: 组织过程资产</p><h3 id="19-3-管理干系人的参与-输出"><a href="#19-3-管理干系人的参与-输出" class="headerlink" title="19.3 管理干系人的参与 输出:"></a>19.3 管理干系人的参与 输出:</h3><p><strong>①: 问题日志</strong></p><h3 id="19-4项目干系人管理"><a href="#19-4项目干系人管理" class="headerlink" title="19.4项目干系人管理:"></a>19.4项目干系人管理:</h3><p>主要内容: </p><p>①: 项目干系人分析: 识别干系人,并分析干系人兴趣,影响力理解关键干系人的希望期望需要.</p><p>②: 沟通管理: </p><p>③: 问题管理: 对沟通过程发现的问题,记录并采取行动解决.</p><h3 id="19-5-项目干系人管理-与-人力资源管理-区别"><a href="#19-5-项目干系人管理-与-人力资源管理-区别" class="headerlink" title="19.5 项目干系人管理 与 人力资源管理 区别"></a>19.5 项目干系人管理 与 人力资源管理 区别</h3><p>干系人管理 与 沟通管理:   如何与形形色色的人打交道</p><p>人力资源管理:   如何管人,带团队</p><h2 id="二十、速记口诀"><a href="#二十、速记口诀" class="headerlink" title="二十、速记口诀"></a>二十、速记口诀</h2><p><strong>口诀: 范进整狗子,成人风采.</strong></p><p><strong>对应的过程数:</strong>  <strong>676    3344    464</strong></p><p><strong>口诀: 两启两收先来记</strong></p><p><strong>口诀: 范进成风无执行</strong></p><p><strong>口诀: 人力资源无监控</strong></p><p><strong>范围管理口诀: </strong></p><ul><li>范围需要先<strong>收集</strong>，裁剪补充再<strong>定义</strong>；</li><li>拆分工作<strong>创WBS</strong>，审批输出一基准</li><li><strong>控制</strong>范围先<strong>确认</strong>.</li></ul><p><strong>进度管理口诀:</strong></p><ul><li>进度先要<strong>定</strong>活动，然后才能<strong>排顺序</strong>；</li><li><strong>资源</strong> <strong>时间</strong>要估算，这样才能<strong>制计划</strong>。</li></ul><p><strong>风险管理口诀:</strong></p><ul><li>风险<strong>识别</strong>要靠前，<strong>定性定量</strong>分析全；</li><li>已知未知要了解，这样才能来<strong>应对</strong>。</li></ul><p><strong>口诀: 用逻辑进程实现部署, 静态实现构件图</strong></p><p><strong>口诀: 部队用包袱制品够累</strong>—–静态视图</p><p><strong>口诀: 东西装信是交互</strong>——动态视图</p><p><strong>口诀: 鸟翅组合强关联,相依为命同根生</strong></p><p><strong>口诀: 类与用例两不同,包含扩展类中无</strong></p><p><strong>口诀: 追漏回源</strong>—–追溯与回溯区别</p><p><strong>四控,三管,一协调.———&gt;镜子投资变更控,  信安合管一协调,</strong></p><p><strong>口诀: 划分即实验</strong>—–生命周期</p><p><strong>口诀: 窃可用,截机密,篡完整,伪合法</strong> </p><p><strong>口诀: 一主二审三标四化五验证</strong><br><strong>口诀: 验国防,化中央,标地方</strong> </p><p><strong>口诀: 就是鱼丸</strong>—–软件维护四过程</p><p><strong>口诀: 阶段组成熟(阶乘),连续组过能</strong>——-CMMI</p><p><strong>口诀: 捉错误, 揍设编, 审标准, 评质量</strong> </p><p><strong>口诀: 巫术忘传会彪鹰</strong>—–OSI七层模型</p><p><strong>口诀: 汇策略,核骨干</strong>——汇聚层</p><p><strong>口诀: </strong> <strong>叫计验指纹</strong>—–教训、企业<strong>计</strong>划、经验、指导方针、文档等。——–组织过程资产</p><p><strong>口诀: 孔雀忍受暴行 —————–&gt;质量控制正确性,范围确认可接受,质量保证信心.</strong></p><p><strong>大特性口诀: 功能靠用小护翼</strong> </p><p><strong>小特性口诀：合准用一安，错译成，学姐操石源，试改定分，应装一T</strong></p><p><strong>口诀:  绩效日志组织入,变更请求是输出———-&gt;管理项目团队</strong> </p><p><strong>赫兹伯格保激理论</strong></p><p><strong>马斯洛5层需求金字塔</strong></p><p><strong>塔克曼阶梯5阶段—&gt;形震规发终解散</strong></p><p>项目评估的基本方法：</p><p>静态分析法：<strong>小偷偷偷2</strong>———–最小费用法，投资收益率法，<strong>投资回收期法</strong>，追加投资回收期法</p><p>动态分析法：<strong>投资回收期法 </strong>和 <strong>贱内</strong>  ———（净现值法，内部收益率法）</p><p><strong>注: 投资回收期法 既是静态分析法, 也是 动态分析法.</strong></p><p><strong>口诀: 最小投收是静态</strong></p><p><strong>口诀:  重点管理双高, 权高利低满意即可</strong></p><p><strong>口诀: 开计划,产手册,管变更</strong></p><p><strong>总结: 上下相减是浮动,左右相减是工期</strong>——-关键路径<br><strong>口诀: 早开始,迟完成,紧前紧后来分析, 其他皆可推.</strong>——关键路径</p><p>项目收尾：包括管理收尾和合同收尾；</p><p>合同收尾过程涉及产品正式验收和管理收尾</p><p><strong>口诀: 1直男交4女友被雷劈10次</strong>———机房中防雷、直流交流电阻相关知识</p><p>项目目标特性：<strong>口诀: 鲜橙多。</strong>优先性，层次性，多目标性；</p><p>项目特点：临时性、独特性、渐进性。</p><p>软技能：<strong>口诀: 勾引领导，激谈解决</strong>——有效的沟通，对组织施加影响，领导，激励，谈判与冲突管理，解决问题。</p><p>事前检查、事中评审、事后审计</p><p>项目阶段末可以进行一次审查，目的是取得对结束当前阶段并启动下一阶段的核准</p><p>五大过程组：启动，规划，执行，监控，收尾；</p><p>PDCA：计划，执行，检查，行动。</p><p>可行性研究的内容：<strong>基金运疯计。</strong>技术，经济，运行环境，风险分析,项目计划, 其他方面（法律，社会）可行性分析。不包括项目评估方法</p><p>可行性研究的方法：<strong>惊世娘子。</strong>经济评价法，市场预测法，增量净效益法，投资估算法。</p><p>可行性研究的原则：<strong>客观公。</strong>科学性、客观性和公正性。</p><p>可行性研究的风险：<strong>急诊室。</strong>技术风险，政治风险，市场风险。</p><p>可行性研究的步骤：<strong>木桶鸡粗腿变焦。1）确定项目规模和目标，2）研究正在运行的系统，3）建立新系统的逻辑模型，4）导出和评价各种方案，5）推荐可行性方案，6）编写可行性方案，7）递交可行性方案。</strong></p><p><strong>投资前期四个阶段(可行性研究的顺序)：</strong>机会研究，初步可行性研究，详细可行性研究，可行性研究评估与决策;  实际工作中,前三个阶段依据项目规模和繁简程度可以把前两阶段省略或者合二为一,但详细可行性研究不可缺少.升级改造项目只做初步和详细研究,小项目只做详细可行性研究.</p><p><strong>项目论证三个阶段</strong>：机会研究（寻求投资机会，鉴别投资方向，±30%），初步可行性研究（项目是否有生命力，是否盈利，±20%），详细可行性研究（详细技术经济论证，多方案中选择最优方案，±10%）。</p><p><strong>项目论证：</strong>分为内部论证和外部论证，可以贯穿于可行性研究的整个阶段，项目论证费用属于<strong>立项前费用</strong>，<strong>不计入项目的总投资之内</strong>；<strong>注意: 项目评估由第三方进行</strong>；论证和评估可以同时进行,项目论证的<strong>核心是财务经济</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.87.png" alt="87"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.88.png" alt="88"></p><p>项目建议书：包含项目必要性，市场，预测，<strong>不包含风险因素。</strong></p><p>数据库和数据仓库：动态变化和不变，数据仓库4个特性：面向主题，稳定，集成，反映历史变化。</p><p>软件文档：<strong>开餐馆。 开，产，管。</strong></p><p>程序流程图（设计阶段）、数据流程图DFD（分析阶段）是结构化方法使用的主要工具；</p><p>多路复用技术：<strong>贫富，薄雾，试题，马戏。频分FDMA，波分WDMA，时分TDMA，码分CDMA。</strong></p><p>OLAP的实现方法3种：<strong>官多喝。ROLAP（关系数据库）、MOLAP（多维数据存储）、HOLAP（混合）。</strong></p><p>CRM要素：1）以客户为中心，2）注重客户满意度，增加企业获利能力，3）针对不同客户采取不同措施。</p><p>CRM组成：触发中心，挖掘中心。</p><p>对象是一个封装，三要素：对象标识，对象状态，对象行为；对象是类的实例，类是对象的模板。</p><p>RUP四个阶段：<strong>粗细尖椒。 初始阶段，细化阶段，构建阶段，交付阶段。</strong></p><p>软件架构模式：1）管道/过滤器模式，2）面向对象模式，3）事件驱动模式（典型的图形界面工具），4）分层模式，5）知识库模式（知识源，黑板，语音和识别），6）C/S模式（C/S需要客户端，B/S使用浏览器）。</p><p>分布式对象中间件：<strong>呕血，色，妈的。OMG的CORBA，SUN的EJB，MICROSOFT的DCOM。</strong></p><p>数据库访问中间件：WINDOWS平台的ODBC，JAVA平台的JDBC。</p><p>面向消息中间件：IBM的MQSERIES。</p><p>物联网三层：<strong>敢裸泳。感知层 网络层 应用层。</strong></p><p>云计算：IAAS（基础设施），SAAS（软件），PAAS（平台）。</p><p>IPV6：2的128次方，IPV4：2的32次方。</p><p>ERP：管理层面，设计层面用其他方法。</p><p>JAVA：单继承语言</p><p>WEB SERVICE：翻译，桥梁，异构，单机和局域网不适用，是实现SOA的最主要方法，SOAP（执行服务调用）,UDDI（发布查找服务）,WSDL（描述服务和接口）是基于XML的。SOAP使用XML进行编码，与应用平台完全无关。</p><p>J2EE和.NET：跨平台和不跨；J2EE运行环境包括：构件（应用逻辑的代码），容器（构件的运行环境），服务（功能接口）。</p><p>.NET开发框架：ADO.NET技术用于访问数据库；基础类库提供接口，基于下一代网络应用；通用语言运行环境处于.NET最底层，是基础。</p><p>工作流3个阶段：流程建模、仿真、改进或优化。</p><p>信息化知识点：<strong>鹰上鸡下人左龟右。应（龙头）资（核心）网，产人（成功之本）政（根本保障）。</strong></p><p>电子商务：涉及4种流：<strong>戏子伤我</strong>（信息流、资金流、商流、物流），<strong>戏不可少。</strong>信息流是最基本必不可少的。</p><p>现代电子商务包括：1）基于因特网，2）多个参与方，3）活动范围扩大。</p><p>电子政务建设原则：1）统一规划，加强领导，2）需求主导，突出重点，3）整合资源，拉动产业，4）统一标准，保障安全。</p><p>B2B：阿里巴巴，B2C：京东、淘宝、一号店，C2C：淘宝网。</p><p>支付技术：电子钱包，电子现金，智能卡，支付形式：支付网关，第三方支付（淘宝），直接支付。协议SSL（传输层），SET（应用层）。</p><p>SSL、TLS是传输层安全协议；IPSEC是网络层安全协议；TTPT是链路层安全协议</p><p>PPTP和IPSEC协议用于虚拟专用网。</p><p>商业智能BI（要有决策有结果），数据挖掘（线性回归，描述，分类，预测），企业应用集成EAI （跟过程有关，核心ESB），CRM客户关系管理（一定要为企业盈利，不对）。</p><p>法律法规知识点：5天（退还保证金，资格预审），5个工作日（卖标书），7个工作日（质疑），15天（修改，确定中标人上报），15个工作日（投诉），20天（截止），28天（索赔），30天（签合同，暂停时间），30个工作日（书面通知投诉人），15年（采购文件保存）。</p><p>公司倒闭了合同无效。</p><p>著作权50年，发明专利权20年，新型、外观设计10年，商标保护10年；地域性无效，50年后失效。</p><p>国家标准有效期为5年。</p><p>计算机系统集成资质认证工作：根据认证和审批分离原则，先由认证机构认证，再由信息产业主管部门审批。</p><p>投标单位主要活动：1）收集招标信息，2）索购并填报资格预审文件，3）购买招标文件，4）提出问题，5）编制投标文件，6）提交投标文件，7）参加开标会议，8）讲解投标文件，9）回应招标方质疑或提交补充材料，10）如果中标，还需要签订书面合同。</p><p>监理知识点：1）监理合同是解决争议的依据；2）总监负责制；4）监理大纲是投标阶段方案性文件，监理规划是签合同后纲领性文件，监理实施细则是可操作性业务文件；5）监理不可参与验收方案的制订；6）总监负责人、工期、钱、规划；监理四级：甲乙丙暂定级，总监负责制，旁站隐蔽工程，索赔28天；7）内容：四控三管一协调。<strong>只见头变心何安8）分为咨询式、里程碑式和全过程监理。</strong>（质量、进度、投资和变更控制，信息、合同和安全管理，协调）；</p><p>连接2个以太网的设备是网桥。</p><p>网络规划：分界内的自己，分界外的运营商负责。</p><p>PING：看网络配置是否正确,127本机网卡是否正确。</p><p>UDP：面向无连接、不可靠的传输协议。</p><p>机房工程：2-3层，A（需要配备柴油发电机）BC三个等级，机房等电位连接方式，耐火材料不低于2级。</p><p>MAC地址：ARP协议转换的，MAC对于一个IP而言可以有多个，使用路由器时。</p><p>静电电压：1000V ；<strong>1**</strong>直交4<strong><strong>个女友雷10</strong></strong>。**</p><p>局域网3个网络协议：1）微软的NETBEUI；2）NOVELL的IPX/SPX；3）TCP/IP。</p><p>LAN分为：总线型（逻辑）、星型（物理，分带宽）、环型局域网。</p><p>RAID0（n），RAID1（n/2），RAID5（n-1）。</p><p>完全备份&gt;差分备份&gt;增量备份&gt;按需备份。</p><p>无线网络四类：WLAN，WMAN，WWAN，WPAN（无线个人网）。</p><p>无线接入：WIMAX（50千米）使用802.16协议，WI-FI（10-300米）使用802.11协议，Zigbee（10米）使用802.15.4属于WPAS，网络桥接器AP（100-300米），蓝牙10米。</p><p>802.11定义了3种物理层通信技术：直接序列扩频，窄带微波，漫反射红外线。</p><p>光纤接入方式：FTTR远端接点，FTTB大楼，FTTC路边，FTTZ小区，FTTH户，FTTD桌面。</p><p>打印服务器：采用TCP/IP协议。</p><p>信息插座到网卡之间使用无屏蔽双绞线，布线距离最大10米。</p><p>FTP基于TCP20和TCP21完成面向连接、可靠的数据传输；TFTP基于UDP69端口号；HTTP基于TCP80端口号；Serv-U是一种广泛运用的FTP服务器端软件。</p><p>交叉线：同种设备之间、ADSL MODEM和集线器HUB连接时；其余用直连线。</p><p>三层交换机：即核心交换机，具有组播功能。</p><p>3G标准4种：WCDMA\CDMA2000\TD-CDMA\WIMAX。</p><p>LTE比3G更好：高数据速率，分组传送，延迟降低，广域覆盖，向下兼容。</p><p>病毒是一些可以自我复制到可执行文件中的代码段；</p><p>蠕虫是一种可以自我复制传播且<strong>不需要宿主</strong>的完整的程序（熊猫烧香）；</p><p>木马是一种程序，可以隐藏在正常程序中执行破坏功能（灰鸽子）；</p><p>DOS攻击破坏可用性。</p><p> <strong>范围管理：</strong></p><p><strong>规定贱人制，</strong>（范围规划，范围定义，创建WBS分解结构，范围确认，范围控制）</p><p><strong>标杆分检查。</strong>（模板表格和标准，产品和干系人分析，分解，检查，变更控制系统和偏差分析）。项目范围和产品范围：项目范围强调过程，产品范围强调结果。项目范围是否完成以项目管理计划、项目范围说明书、WBS、WBS字典作为衡量标准，产品范围是否完成以产品需求说明书作为衡量标准。</p><p>范围管理计划内容：1）如何基于初步的项目范围说明书准备一个详细的项目范围说明书，2）如何从详细的项目范围说明书创建WBS， 3）如何对已完成项目的可交付物进行正式的确认和接受的，4）如何对详细的项目范围说明书申请变更，这个过程直接与整体变更控制过程相关联。</p><p>详细的范围说明书包括：<strong>标书求姐夫，厂家约疯子，北京惩治囚犯。1）项目目标，2）产品范围描述，3）项目需求，4）项目边界，5）项目的可交付物，6）产品可接受的标准，7）项目的假设条件，8）项目的约束条件，9）初始风险，10）初始的项目组织，11）进度里程碑，12）资金限制，13）成本估算，14）项目配置管理需求，15）已批准的需求，16）项目规范。</strong></p><p>分级树型：直观而不容易修改，适合小中项目；表格形式：不直观而方便，适合大项目。</p><p>WBS三个方法：<strong>吃饺子。1）把主要的项目可交付物和子项目作为第一层，2）子项目作为第一层，3）把项目的生命期作为第一层，项目交付物作为第二层。WBS一般3到5层，它是组织的核心。</strong></p><p>WBS八个原则：1）在各层次上保持项目的完整性，避免遗漏必要的组成部分，2）一个工作单元只能从属于某个上层单元，避免交叉从属，3）相同层次的工作单元应用相同性质，4）工作单元应能分开不同的责任者和不同工作内容，5）便于项目管理计划、控制的管理需要，6）最底层工作应该具有可比性，是可管理的，可定量检查的，7）应包括项目管理工作，包括分包出去的工作。</p><p>WBS主要步骤：1）识别项目交付物和相关项目工作，2）对WBS的结构进行组织，3）对WBS进行分解，4）对WBS中各级工作单元分配标识符或编号，5）对当前的分解级别进行检验，以确保它们是必须的，而且是足够详细的。</p><p>WBS\OBS\RBS：工作分解结构WBS根据可交付物进行分解，组织分解结构OBS根据组织的部门、单位或团队进行分解，资源分解结构RBS根据资源进行分解，风险分解结构RBS根据已识别的风险进行分解。</p><p>范围基线包括：已批准的项目范围说明书（详细）、WBS、WBS字典。它是创建WBS的输出。</p><p>范围确认和质量控制：范围确认是有关工作结果的可接受问题，而质量控制是有关工作结果是否满足质量需求的问题。质量控制通常在范围确认之前进行，也可以并行。</p><p> 范围确认应该是贯穿项目的始终，采用检查，范围确认完成时，同时应当对确认中的WBS和WBS字典进行更新。</p><p>范围蔓延原因：<strong>三无。1）无基线2）需求挖掘不够3）无变更控制程序。</strong></p><p>变更原因：1）项目外部环境发生变化，2）项目范围的计划编制不周密详细，有一定的错误或遗漏，3）世界上出现了或是设计人员提出了新技术、手段或方案，4）项目实施组织本身发生了变化，5）客户对项目、项目产品或服务的要求发生变化。</p><p>变更控制的焦点问题：1）对造成范围变更的因素施加影响，以确保这些变更得到更一致的认可，2）确定范围变更已经发生，3）当范围变更发生时，对实际的变更进行管理。</p><p>范围变更后，要更新基准、预算、项目管理计划。</p><p>范围管理中常见问题和建议：1）不完整的需求：得到完整的需求，2）缺乏用户参与：联系所有项目干系人，3）不现实的期望：加强沟通，4）需求改变：进行范围控制，5）缺乏计划：增强项目计划，6）在压力下放弃计划：增强项目计划，7）遗漏必要的任务：加强范围确认，8）开发人员的镀金：界定项目边界，9）功能蔓延：进行范围控制。</p><p>范围问题应想到建立变更控制管理流程，质量问题应想到建立质量管理体系，建立标准，基线，重新制定完善管理计划，对流程进行优化。</p><p><strong>进度管理：</strong></p><p><strong>腚需圆，利画质。</strong>（活动定义，活动排序，活动资源估算，活动历时估算，制订进度计划，进度控制）</p><p>腚需圆（<strong>专替姑管下</strong>：专家判断法，替换方案确定，公开估算数据，项目管理软件，自下而上的估算），利（<strong>专流沧桑泪</strong>：专家判断，预留时间，参数式估算，历时的三点估算，类比估算法）画质</p><p>项目计划（进度）网络图：是活动排序的输出，进度计划编制的输入。</p><p>资源估算：输入（企业环境因素，组织过程资产，活动清单，活动属性，资源可用性，项目管理计划），工具（专家判断法，替换方案确定，公开估算数据，项目管理软件，自下而上的估算），输出（活动资源需求，更新的活动属性，资源分解结构RBS，更新的资源日历，变更请求），它不包括后备分析。</p><p>历时估算：输入（企业环境因素，组织过程资产，项目范围说明书，活动清单，活动清单属性，活动资源需求，资源日历，项目管理计划），工具（专家判断，预留时间，类比估算法，参数式估算，历时的三点估算），输出（活动历时估算结果，更新的活动清单属性）。</p><p>关键链：缓冲段防范风险。</p><p>进度估算工期方法：1）明确定义项目的WBS；2）根据以往经验，采用类比估算法；3）联系业界专家，采用德尔菲法；4）依据数据采用参数估算法和三点估算法。</p><p>加快进度的措施：<strong>新加支筷子。</strong>新技术，加班，增加资源，快速跟进，资源平衡。</p><p>进度压缩工期方法：1）缩小范围，2）外包，3）并行工作，4）明确奖惩机制，提高员工工作绩效，5）赶工，6）加强阶段性检查和控制，避免后期返工，7）加强沟通，争取客户能够对项目范围，以及需求、设计和验收标准进行确认，避免后期频繁出现变更。</p><p>进度跟踪方法：1）制定活动网络图和项目工作计划，2）建立监督和测量机制，3）建立评审机制，4）及时纠正和预防问题，进行有效的变更管理，5）使用有效的项目管理工具，提高工作效率。</p><p><strong>整体管理：</strong></p><p><strong>章书记指空整薇，</strong>（制定项目章程，制定初步的项目范围说明书，制定项目计划，指导和管理项目执行，监控项目执行，整体变更控制，项目收尾。）</p><p>项目章程：正式批准一个项目或者批准项目是否进入下一阶段的文档，并对项目经理授权。由组织外的发起人或资助人发布。</p><p>项目章程内容：<strong>需需的任干碑，职假约翻概。</strong></p><ul><li><p>1）<strong>项目需求</strong>，反映干系人的要求和期望，</p></li><li><p>2）项目必须实现的<strong>商业需求</strong>，<strong>项目概述</strong>或<strong>产品需求</strong>，</p></li><li><p>3）项目的目<strong>的</strong>或论证结果，</p></li><li><p>4）<strong>任</strong>命项目经理并授权级别，</p></li><li><p>5）<strong>干</strong>系人的影响，</p></li><li><p>6）里程<strong>碑</strong>进度计划，</p></li><li><p>7）<strong>职</strong>能组织，</p></li><li><p>8）组织的、环境的和外部的<strong>假</strong>设，</p></li><li><p>9）组织的、环境的和外部的<strong>约</strong>束</p></li><li><p>10）论证项目的业务<strong>方</strong>案，包括投资回报率，</p></li><li><p>11）<strong>概</strong>要预算。</p></li></ul><blockquote><p>　</p><p><strong>关于项目章程详细介绍:</strong></p><p>项目由项目以外的人员批准，例如，发起人（可能不止一个人）、PMO 或项目组合指导委员会。项目启动者或发起人应该具有一定的职权，能为项目提供资金。<strong>他们亲自编制项目章程，或授权项目经理代为编制</strong>。项目章程经启动者签字，即标志着项目获得批准。可能因内部经营需要或外部影响而批准项目，故通常需要编制需求分析、商业论证或情况描述。通过编制项目章程，就可以将项目与组织的战略及日常运营工作联系起来。<br>　　项目章程是整个项目的宪法，PMBOK指南对项目章程的内容做了精简，以更加体现它作为项目宪法的原则性。根据PMBOK指南，项目章程应该包括的主要内容如下：<br>　　1、概括性的项目描述和产品描述。<br>　　2、概括性的项目描述，包括项目的总体范围和总体质量要求。<br>　　3、可测量的项目目标和相关的成功标准。<br>　　4、项目的主要风险，例如，可以列出项目的主要风险类别。<br>　　5、总体里程碑进度计划。<br>　　6、总体预算，可以是一个概算区间，例如，在100万元至130万元之间。<br>　　7、委派的项目经理及其职责和职权。<br>　　8、发起人或其他批准项目章程的人员的姓名和职权。</p><p>​       而信息系统项目管理师教程上说明项目章程的编制过程主要关注于记录建设方的商业需求、项目立项的理由与背景、对客户需求的现有理解和满足这些需求的新产品、服务或结果。项目章程应当包括以下直接列入的内容或援引自其他文件的内容。<br>(1)基于项目干系人的需求和期望提出的要求。<br>(2)项目必须满足的业务要求或产品需求。<br>(3)项目的目的或项目立项的理由。<br>(4)委派的项目经理及项目经理的权限级别。<br>(5)概要的里程碑进度计划。<br>(6)项目干系人的影响。<br>(7)职能组织及其参与。<br>(8)组织的、环境的和外部的假设。<br>(9)组织的、环境的和外部的约束。<br>(10)论证项目的业务方案，包括投资回报率。<br>(11)概要预算。 </p><p>　　由此可知，在项目章程发布时，已经做了一些设计和估算工作。<br>　　要注意的是，虽然项目经理可以参与甚至负责起草项目章程，但项目章程不是由项目经理发布的，而是由项目团队之外的管理层发布的，项目经理只是项目章程的实施者。作为项目的宪法，项目章程中的内容应该是一些原则性的、概括性的问题，通常不会因项目变更而需要修改，除非是发生了非常重要的变更（例如，考虑是否需要终止项目）。如果要修改项目章程（例如，当项目总体目标发生变化时），则只有管理层才有权进行（谁签发，谁修改的原则），也就是说，项目章程的修改不在项目经理的权责范围之内。</p></blockquote><p>项目章程 的编制:  主要关注 记录商业需求,项目论证,对顾客需求的理解,和满足这些需求的新产品,服务或结果.</p><p>工作说明书SOW：对内部项目而言，由项目发起人提出；对外部项目而言，可以作为投标文档一部分从客户那里得到。包括：<strong>爷参战。</strong>业务需求，产品范围描述，战略计划。</p><p>组织过程资产：<strong>叫鸡验指纹。</strong>教训、企业计划、经验、指导方针、文档等。</p><p>项目管理计划内容：<strong>过失工期管制，控制机构责问</strong></p><ul><li>1）所使用的项目管理<strong>过</strong>程，</li><li>2）每个特定项目管理过程的实<strong>施</strong>程度，</li><li>3）完成这些过程的<strong>工</strong>具*和技术的描述，</li><li>4）选择的项目的生命周<strong>期</strong>和相关的项目阶段，</li><li>5）如何用选定的过程来<strong>管</strong>理具体的项目。</li><li>包括过程之间的依赖与交互关系和基本的输入输出等，</li><li>6）如何<strong>执</strong>行工作来完成项目目标，</li><li>7）如何监督和<strong>控制</strong>变更，</li><li>8）如何实施配置管理，</li><li>9）如何维护项目<strong>绩</strong>效基线的完整性，</li><li>10）与项目干系人进行<strong>沟</strong>通的要求和技术，</li><li>11）为项目选<strong>择</strong>的生命周期模型。对于多阶段项目，要包括所定义阶段是如何划分的，</li><li>12）为了解决某些遗留<strong>问</strong>题和未定的决策，对于其内容，严重程度和紧迫程度进行的关键管理评审。</li></ul><p>工作绩效信息包括：进度进展，已（未）完成哪些交付物，已开始（完成）哪些活动，满足质量标准的程度，批准的预算与发生的成本，已开始活动的预计完成日期，当前项目活动所完成的百分比，已记录下的经验教训，资源使用情况。</p><p>变更：分别内部和外部变更。流程：<strong>生平绝食盐蛋。CCB一定要有，CCB不能提出变更申请，PM不担任CCB主席，主席一票否决权，在基准内不用走变更流程，是决策机构不是作业机构，不必是常设机构，可以一个人或者多人，甚至兼职人员，人员组成：高项配车子。CCB的职责之一。（高层经理、项目经理、配置管理负责人、测试负责人、质量保证负责人等），变更控制流程的作用不包括确定要批准还是否决变更请求，它是</strong>（变更申请，评估，决策，实施，验证，沟通存档），</p><p>监理在变更中的工作：1）接受变更申请，2）评估变更，3）参与CCB评审，4）下达变更通知书，与PM共同发布变更，5）监控变更实施，6）对变更结果进行验证。</p><p>变更批准后项目经理工作：1）更新项目管理计划或其他管理计划文件，2）安排相应人员负责新的项目活动，3）更新WBS和WBS字典，4）编制新的或修订成本估算、活动排序、进度日期、资源需求和风险应对方案等。</p><p>项目收尾：包括管理收尾和合同收尾；合同收尾过程涉及产品验收和管理收尾。</p><p><strong>沟通管理：</strong></p><p><strong>勾媳暴干。</strong>(沟通计划编制，信息分发，绩效报告，项目干系人管理)</p><p>高效会议：<strong>定期揭发，发誓归总记账。1）事先制定一个例会制度，2）放弃可开可不开的会议，3）明确会议的目的和期望结果，4）发布会议通知，5）在会议前将会议资料发给参会人员，6）可以借助视频设备，7）明确会议规则，8）会议后要总结，提炼结论，9）会议要有纪要，10）做好会议的后勤保障。</strong></p><p>认知障碍：从源头；语义障碍：传递过程中。</p><p>沟通五个原则：<strong>早接住别生。1）尽早沟通，2）采用对方能接受的沟通风格，3）主动沟通， 4）内外有别， 5）沟通的升级原则。</strong></p><p>绩效报告：1）进度和状态报告（进展报告需要分析原因，突出建议和决策），2）预测。</p><p>项目干系人管理的目的：避免他们在项目进行期间分崩离析，它贯穿始终。</p><p><strong>质量管理：</strong></p><p><strong>鞭暴之，</strong>（质量计划编制，执行质量保证，执行质量控制）</p><p>鞭（<strong>小鸡公爵六十只/效益分析，基准分析，功能展开，过程决策，流程图，实验设计，质量成本）</strong>：成本</p><p>暴（<strong>济公审过鸡</strong>：质量计划工具和技术，质量控制工具和技术，质量审计，过程分析，基准分析）</p><p>之（老七：<strong>贱人只留三排孔6西格玛；新七：相亲数据有火锅：相互关系图、亲和图、树状图、矩形图、优先矩形图、活动网络图、过程决策图）</strong>：检查表、因果图、直方图、流程图、散点图、排列图、控制图；<strong>侧面桶抽六个马</strong>：测试、统计、抽样、</p><p>质量成本：分为一致成本（预防成本、评估成本）和不一致成本（故障成本）。</p><p>质量保证QA：项目经理不能担任QA，针对过程，质量控制QC针对结果。</p><p>QA职责：包括过程指导、过程评审、产品审计、过程改进和过程度量等（前期当导师，辅助PM制定项目计划、项目估算、设定质量目标、培训指导人员等；实施中当警察，选择性地参加项目技术评审，定期对产品和过程进行审计和评审；实施中还当医生，承担收集、统计和分析度量数据的工作，用于支持管理决策。）</p><p>全面质量管理TQM：四全：<strong>元芳过节</strong>（全员、全过程、全面方法、全面结果）；朱兰：<strong>娘子高</strong>（“质量规划、控制、提高”三部曲）；克鲁斯比（零缺陷源于预防）。</p><p>质量审计：是QA工具，可以是有计划的或者随机的，分为内审和外审。</p><p>预防（把错误排除在过程之外）和检查（把错误排除在到达客户之前）；特殊抽样（结果符合或不符合）和变量抽样（结果是在测量符合程度的连续坐标系表示）；特殊原因（异常事件）和随机原因（正常过程偏差）；许可的误差（如果在许可的误差规定范围内，结果是可以被接受的）和控制限度（如果结果是在控制限度内，表明过程是在控制之中）。</p><p>趋势分析图：继续测试，平稳后不用测试。</p><p>CMM5级：<strong>质量要保证，除虫定管用</strong>。初始级，可重复，已定义，已管理，优化级。</p><p>CMMI过程改进目标：保证产品及服务质量，项目时间控制，最低的成本。</p><p>CMMI评估：A类（全面综合的评估法），B类（较少综合，花费也少），C类（快速评估法）。</p><p>OPM3由过程组，知识领域和过程改进组成，其中过程改进四个阶段是标准化，可测量，可控制，持续改进。</p><p>6个质量特性和21个子特性：<strong>功能靠用小护翼（是准用一安，错译成，学姐操，石源，试改定分，应装一T）。</strong></p><p>质量管理重点工作：1）制定切实可行的质量管理计划，2）应安排独立于项目组的QA人员负责质量保证工作，3）实施质量审计，4）注重技术评审工作，5）注重测试工作，6）对发现的缺陷进行统计分析，确保质量，7）为项目组成员提供质量管理要求方面的培训。</p><p>质量管理计划内容：1）描述组织的项目质量管理体系，2）质量控制的方法，工具与重点，3）设计、生产过程、安装、服务、检查和测试程序及文档，4）识别出的测量要求，5）特定阶段的审核要求，6）质量标准或验收标准。</p><p>软件需求：功能，非功能，设计约束。</p><p>软件质量评价：验证和确认，验证满足前面要求，确认是看结果是否正确。</p><p>软件配置：物理性，功能性。</p><p>评审与审计：<strong>评审是质量控制的</strong>，正式的，<strong>评审可以自己评审</strong>，内审和外审。<strong>审计或评估是第三方</strong>，QC和QA不能同时担任，项目经理不能担任QA。</p><p>评审过程包括：管理评审（监控进展）、技术评审（评价软件）、检查（检测异常）和走查（不正式）。</p><p>质量问题三无：无标准、无基线、无质量控制流程。</p><p><strong>成本管理：</strong></p><p><strong>顾欲空，</strong>（成本估算，成本预算，成本控制）</p><p>顾（<strong>下官擂肥卖金子</strong>：自下而上的成本估算，项目管理软件，类别估算法，确定资源费率，卖方投标分析，准备金分析，质量成本）</p><p>欲（<strong>城管掺和</strong>：成本总计，管理储备，参数模型，支出的合理化原则）</p><p>空（<strong>成绩预计偏软</strong>：成本更变控制系统，绩效测量，预测技术，项目绩效评估，偏差管理，项目管理软件）</p><p>应急储备：已知的未知事件，用来处理预期但不确定的事件，项目经理可自由使用，是项目范围和成本基准的一部分。</p><p>管理储备：未计划但可能需要的范围和成本的潜在变化而预留的预算，项目经理使用前要得到批准，不是项目成本基线的一部分，但包含在项目预算中，不是挣值的一部分。</p><p>成本：直接（直接消耗的，涉密安防系统），间接（共同分担），可变，机会，沉没。</p><p>成本基准通常以S曲线形式显示。许多项目，特别是大项目，可能有多个成本基准。</p><p>成本失控的原因：1）对工程项目认识不足，2）组织制度不健全，3）方法问题，4）技术制约。</p><p><strong>人力资源管理：</strong></p><p><strong>记住射里，</strong>（人力资源计划编制，组建项目团队，项目团队建设，管理项目团队）</p><p>记（<strong>组人组人</strong>：组织结构图和职位描述，人力资源模板，组织理论，人际网络）</p><p>住（<strong>仙谈虚构</strong>：事先分派，谈判，虚拟团队，采购）</p><p>射（<strong>公认你赔活鸡</strong>：同地办公，认可奖励，一般管理技能，培训，团队建设活动，基本原则）</p><p>里（<strong>关机图纹</strong>：观察与对话，项目绩效评估，冲突管理，问题日志）</p><p><strong>责任分配矩阵RAM：</strong>工作和人员一一对应的关系，是WBS和OBS结合。</p><p><strong>成功团队特征</strong>：<strong>标致公平女性。1）目标明确，2）组织结构清晰，岗位明确3）规范的工作流程和方法，4）有明确的考核和评价标准，5）组织纪律性强，6）相互信任，善于总结和学习。</strong></p><p><strong>绩效评估范围</strong>：包括进度控制，成本控制，质量控制，范围验证和过程审计的结果。</p><p>冲突的产生和类型：1）项目的高压环境，2）责任模糊，3）多个上级的存在，4）新科技的流行。</p><p>马斯洛需求层次五层：<strong>李安会重现。 生理，安全，社会，受尊重，自我实现。</strong></p><p>双因素理论：一是保健卫生（无激励作用），二是激励需求（有激励作用）。</p><p><strong>风险管理：</strong></p><p><strong>即时性，亮鞭奸。</strong>（风险管理计划编制，风险识别，定性风险分析,定量风险分析，风险应对计划编制，风险监控）</p><p>风险识别工具：文档评审，信息收集技术（<strong>脑儿烦死。 SWOT优劣机危分析），检查表，假设分析，图解技术（因果分析图，系统或过程流程图，影响图）。</strong>头<strong>脑</strong>风暴法，德<strong>尔</strong>菲法，<strong>访</strong>谈法，</p><p>风险属性：随机性、相对性、可变性。</p><p>定性风险分析工具：<strong>故居娘憧憬。</strong>风险概率及影响评<strong>估</strong>，概率及影响<strong>矩</strong>阵，风险数据质<strong>量</strong>评估，风险<strong>种</strong>类，风险<strong>紧</strong>急度评估。</p><p>定量风险分析工具：数据收集和表示技术（<strong>谈改嫁。EMV，决策树分析，建模和仿真）。</strong>访<strong>谈</strong>，<strong>概</strong>率分布，专<strong>家</strong>判断），定量风险分析和建模技术（<strong>灵气车模。</strong>灵敏度分析，期望货币价值分析</p><p>负面风险应对策略：避免（项目早期），转移（外包等），减轻（冗余等）接受(不做任何处理)。</p><p><strong>采购管理：</strong></p><p><strong>鞭同膘，折管收。</strong>（采购计划编制，编制合同，招标，供方选择，合同管理，合同收尾）</p><p>自制/外购分析：技术达不到（外购），组织内长期使用或涉密（自制）。</p><p>采购工作说明书SOW输入：范围说明书，WBS，WBS字典。</p><p>投标人会议：是指在准备建议书之前与潜在供应商的碰头会。</p><p>建议书：是卖方准备的文件，用来说明卖方提供所需产品或服务的能力和意愿。</p><p>采购文件：用于向潜在的供应商征集建议书，由建设方准备。</p><p>采购审计的目标是找出采购过程中的成功和失败之处</p><h3 id="20-1-输入-输出-工具和技术"><a href="#20-1-输入-输出-工具和技术" class="headerlink" title="20.1 输入+输出+工具和技术"></a>20.1 输入+输出+工具和技术</h3><h4 id="20-1-1范围管理"><a href="#20-1-1范围管理" class="headerlink" title="20.1.1范围管理:"></a>20.1.1范围管理:</h4><p>①: 章==计==业组==初范书==,专家==模表==范==需==划——&gt;规划范围管理(范围计划的编制)—-(计: 指的是项目管理计划,需: 指的是需求管理计划)</p><p><strong>首尾相接</strong>②: 范需人划章程==册==,访问观察原标杆,交互引导群决策,需求文件==矩阵==出——&gt;收集需求——(交互: 系统交互图, 矩阵: 需求跟踪矩阵, 册: 干系人登记册)</p><p>③: 章程范划组==变更==,<strong>==产分==</strong>专家==引== 备案==,== 项划==更新出==详书==.——&gt; 定义范围——-(备案: 备选方案生成)</p><p><strong>XX范划开头, 首尾相接</strong>④: 详书范划需业组, <strong>==工分模板==</strong>==分解==术, 范划更新==WBS字典==出基准——-&gt;创建WBS—–(基准: 范围基准)</p><p>⑤:  范书 范划==交==字典,<strong>==检查==</strong>  <strong>==决策==</strong>工具术,  变更绩效==验可交==——&gt;确认范围——(交: 可交付物,   检查:  审查,产品评审,审计,走查,巡检,字典: WBS字典   验可交: 验收的可交付性成果)</p><p>⑦: 变更 范划  ==效==字典,<strong>==偏差分析==</strong>变更控, 计组字典齐更新,变更请求来输出———&gt;控制范围</p><p><strong>注: ①: 范围基准需要 评审和审批;       ②:  范围说明书不能有项目 经理一人编写;    ③: WBS和范围基准应该由项目团队和所有关键干系人一起创建不应该由项目经理一人创建,导致工作遗漏    ④: 要做好整体变更控制,防止范围蔓延,范围变更应该和整体变更相结合,综合评估.     ⑤: 范围变更要有规范的变更控制流程    ⑥: 变更结果一定要得到用户的确认和接受</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.71.png" alt="71"></p><h4 id="20-1-2-进度管理"><a href="#20-1-2-进度管理" class="headerlink" title="20.1.2 进度管理"></a>20.1.2 进度管理</h4><p>①: 章程计划找业组,==分==  ==家== ==会==上==进管子==——-&gt;规划进度管理—-(分: 分析技术;   家: 专家判断;  会: 会议;  进管子: 进度管理计划)</p><p>②: 业组进管炒 ==基范==, ==分== 家==滚==出 ==清==  ==属== ==里==——–&gt;定义活动—-(分: 分解;  基范: 范围基准;  滚: 滚动式规则; 清: 活动清单;  属: 活动属性;  里: 里程碑清单)</p><p>③: 范书进计清属里, 前后紧赖网新文——&gt;排列活动顺序——(==前== 紧前关系绘图法;  后: 提前与滞后;  赖: 确定依赖关系)</p><p>④: 业组进管估成本,==清==  ==属==  ==资历==  有风册,   自选 ==软件== ==算== 专家,  活资 ==分解==  ==新文件==——&gt;估算活动资源—(资历: 资源日历; 风册: 风险登记册;  软件: 项目管理软件;  算: 自下而上估算;  选: 自选方案分析; 分解: 资源分解结构;  新文件: 项目文件更新 )</p><p>⑤: 业组资需分日进,清属范书有风险,==三==  ==类==  专家数 策备, ==时间== 估算新文件.——&gt;估算活动持续时间—(三:  三点估算; 类 :  类比估算活动持续时间估算)</p><p>⑥: 业组资需分日进,清属范书有风险, 人员进,   压缩==网==  ==路== 前后链, 优化建模靠工具,  进划基数日,新文划—–&gt;制定进度计划—(网: 进度网络分析;  路: 关键路径法;  链:关键链法;  )</p><p>⑦:  两数两划组日历, 优化建模需审查,前后压缩需软件,   进度预测 ==5大件==——&gt; 控制进度—(5大件: 项目管理计划更新,组织过程更新,项目文件更新,变更请求,工作绩效信息;,,)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.72.png" alt="72"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.73.png" alt="73"></p><h4 id="20-1-3-整体管理"><a href="#20-1-3-整体管理" class="headerlink" title="20.1.3 整体管理"></a>20.1.3 整体管理</h4><p>①: 工商议事有组织,专家引导出章程——-&gt;制定项目章程—-(工: 项目工作说明书,  专家: 专家判断,  引导: 引导技术)</p><p><strong>首尾相接</strong>②: 章程输出靠业组, 专家引导出计划——-&gt;制定项目管理计划—(输出: 其他过程的输出)</p><p><strong>首字同绩效</strong>③: ==计== 变业组会专==项==,  ==效==  ==果==  变更  新文划——&gt;指导和管理项目的执行—–(变: 批准的变更请求,  项: 项目管理信息系统,  果: 可交付成果  ,效: 工作绩效数据; 变更: 变更请求)</p><p><strong>首字同精确</strong>④: ==进== ==程== 预测计划后,==确认变更==  ==效==业组(都是输入),会议分析项专家,计文更新==效报告==——-&gt;监控项目工作–(效: 工作绩效信息;  效报告: 项目绩效报告)</p><p><strong>收尾相接</strong>⑤: 业组==计划==效变更,批准==日志==新文划——–&gt;实施整体变更控制—(批准: 批准的变更请求)</p><p><strong>首字同宴会</strong>⑥: 验交 ==计划== 无事业,会议分析有专家,组织更新出产品——–&gt;结束项目或阶段—–(验收:  验收的可交付成果)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.70.png" alt="70"></p><h4 id="20-1-4-沟通管理"><a href="#20-1-4-沟通管理" class="headerlink" title="20.1.4 沟通管理"></a>20.1.4 沟通管理</h4><p>①: 章程计划组范书,==沟技== ==沟需==  ==人==分析, 最终输出沟计划——&gt;规划沟通管理(沟通计划的编制)</p><p><strong>首尾相接</strong>②: 沟管计划==效==业组, 组==计== ==文件==齐更新——-&gt;管理沟通(信息分发,绩效报告,干系人管理)</p><p>③: ==问题日志==效计组,专家会议==信管==术,计组 ==文件==齐更新,==变更== ==绩效== 同输出.——&gt;控制沟通</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.77.png" alt="77"></p><h4 id="20-1-5-质量管理"><a href="#20-1-5-质量管理" class="headerlink" title="20.1.5 质量管理"></a>20.1.5 质量管理</h4><p>①: 计干人册风险册,章程范书假日志,需求文件业组入, ==成收==  质成  ==标==  ==实设==,  ==质划==  ==质测==  ==质核==  ==过改划==——&gt;规划质量管理(质量计划编制)—-(标: 基准分析)</p><ul><li>规划质量管理: 是识别项目及其可交付成果的质量要求和标准,并准备对策来确保符合质量要求 的过程.作用: 为整个项目中如何管理和确认质量提供了指南和方向.</li></ul><p><strong>首尾相接</strong>②: 质划 质测  质控  过改划, ==质审==  ==过分==     ==七工具== , 计组 ==文件== 齐更新,变更请求来输出  ——&gt;实施质量保证——-(质审: 质量审计, 过分: 过程分析,七工具: 因果图流程图,帕累托图,核查图,直方图,控制图,散点图;  文件: 项目文件)</p><p>③: 质测 质核, 效计组, ==批变请==  ==交==  ==项文件== ,==统抽==     ,    ==确变==  ==核交==  绩效出, 计组项文齐更新,还有变更请求来输出——–&gt;控制质量——–(批变请: 批准的变更请求, 交: 可交付成果, 项文件: 项目文件)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.75.png" alt="75"></p><h4 id="20-1-6-成本管理"><a href="#20-1-6-成本管理" class="headerlink" title="20.1.6 成本管理"></a>20.1.6 成本管理</h4><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.74.png" alt="74"></p><h3 id="20-1-7-人力资源管理"><a href="#20-1-7-人力资源管理" class="headerlink" title="20.1.7 人力资源管理"></a>20.1.7 人力资源管理</h3><p>①: ==活资需求==  计业组, ==人模==  ==人网==组理论,  人资管划一输出.  ———-规划人力资源管理(人力资源计划的编制)(人模: 人力资源模板,人网: 人迹网络,组理论: 组织理论.)</p><p><strong>首尾相接</strong>②:  ==人资管划==业组入,谈判预派虚团队,招募多标决策术,  人员分派计更新,资源日历来输出—组建项目团队</p><p>③: 计 ==资日历==人分派, 培训团建集办公,认可奖励==人== ==人测评==,团绩评价事业输出——&gt;建设项目团队—(人: 人际关系技能,  人测评:  人事测评工具 )</p><p>④: 人资计划  ==人分派==,问题日志 ==绩报告==,组织过程  ==团绩评==,  观 ==谈== 绩评==冲== 人技. 文计业组齐更新,还有变更请求来输出——管理项目团队.—-(冲: 冲突管理   )</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.76.png" alt="76"></p><h4 id="20-1-8-项目干系人管理"><a href="#20-1-8-项目干系人管理" class="headerlink" title="20.1.8 项目干系人管理:"></a>20.1.8 项目干系人管理:</h4><p>①: 采购文件章业组, 干人分析专会议, 管理沟通人技能,干人登册独输出.———-&gt;识别干系人</p><p><strong>首尾相接</strong>②: ==干人登册==  计业组, 干人管划来输出———–&gt;规划干系人管理</p><p>③: ==干人计划== 沟计划,变更日志 组织入,  变更请求 ==问日志==,计组 ==文件==齐更新——-管理干系人</p><p>④: 计  ==问日志== 绩  ==文件==,文组更新绩变更——-控制干系人参与</p><p><strong>注:  ①: 充分分析干系人的期望和要求   </strong></p><h4 id="20-1-9风险管理"><a href="#20-1-9风险管理" class="headerlink" title="20.1.9风险管理:"></a>20.1.9风险管理:</h4><p>期望货币值–定量风险分析的技术</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.78.png" alt="78"></p><h4 id="20-1-10-采购管理"><a href="#20-1-10-采购管理" class="headerlink" title="20.1.10 采购管理"></a>20.1.10 采购管理</h4><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.79.png" alt="79"></p><h3 id="20-2-总结"><a href="#20-2-总结" class="headerlink" title="20.2 总结:"></a>20.2 总结:</h3><h4 id="20-2-1-文件"><a href="#20-2-1-文件" class="headerlink" title="20.2.1 文件:"></a>20.2.1 文件:</h4><p>项目工作说明书</p><p>项目章程</p><p><strong>项目管理计划</strong></p><p>需求管理计划</p><p>工作绩效报告</p><p>工作绩效数据</p><p>工作绩效信息</p><p>需求文件</p><p>项目文件</p><p><strong>干系人管理计划</strong></p><p>干系人登记册</p><p><strong>范围管理计划</strong></p><p>项目范围说明书</p><p><strong>进度管理计划</strong></p><p>风险登记册</p><p>资源日历</p><p>问题日志</p><p>变更日志</p><p>活动清单</p><p>活动属性</p><p><strong>成本管理计划</strong></p><p><strong>人力资源管理计划</strong></p><p><strong>质量管理计划</strong></p><p>过程改进计划</p><p>质量测量指标</p><p>批准的变更请求</p><p>团队绩效评价</p><p>事业环境因素</p><p>组织过程资产</p><p><strong>采购管理计划</strong></p><p>采购文件</p><p>采购工作说明书</p><p>变更请求</p><h4 id="20-2-2-工具和技术"><a href="#20-2-2-工具和技术" class="headerlink" title="20.2.2 工具和技术"></a>20.2.2 工具和技术</h4><hr><p><strong>范:</strong></p><p>专家判断——-会议——–引导技术——-分析技术——项目管理信息系统—–变更控制工具</p><p>访谈——问卷调查——观察——原型——标杆对照—–系统交互图——引导式研讨会——-群体决策技术=====================&gt;收集需求</p><p>产品分析——-备选方案生成==============================================&gt;定义范围</p><p>分解==============================================&gt;创建WBS</p><p>检查——-群体决策技术==============================================&gt; 确认范围</p><p>偏差分析==============================================&gt;控制范围</p><hr><p><strong>进:</strong></p><p>滚动式规则——分解 ==============================================&gt; 定义活动</p><p>紧前关系绘图法PDM——-确定依赖关系提前量与滞后量============================================&gt;排列活动顺序</p><p>自下而上估算—–备选方案分析——项目管理软件============================================&gt;估算活动资源</p><p>类比估算———三点估算——-储备分析—–参数估算——-群体决策============================================&gt;估算活动持续时间</p><p>进度网络分析–关键路径法—-关键链法—-资源优化技术—建模技术–进度压缩—进度计划编制工具==========================&gt;制定进度计划</p><p>绩效审查==========================================&gt;控制进度</p><hr><p><strong>整:</strong></p><p>专家判断——-会议——–引导技术——-分析技术——项目管理信息系统—–变更控制工具</p><hr><p><strong>沟: </strong></p><p>沟通需求分析—-沟通技术—-沟通模型====================================&gt;规划沟通管理</p><p>报告绩效—–信息管理系统—-沟通方法—-沟通技术—-沟通模型==================================&gt;管理沟通</p><hr><p><strong>质:</strong></p><p>成本效益分析法—-质量成本法—-实验设计–标杆对照—-七种基本质量工具—其他质量规划工具======================================&gt;规划质量管理</p><p>质量管理和控制工具—过程分析—-质量审计====================================&gt;实施质量保证</p><hr><p><strong>成:</strong></p><p>类比估算—-质量成本—–三点估算—卖方投标分析—-储备分析—–参数估算——-群体决策—-自下而上估算============================================&gt;估算成本</p><p>成本汇总—-资源限制平衡—-储备分析—-历史关系==========================================&gt;制定预算</p><p>挣值管理—–完工尚需绩效指数—-绩效审查—–项目管理软件—储备分析==========================================&gt;控制成本</p><hr><p><strong>人:</strong></p><p>责任分配矩阵—–组织图和职位描述—-人际交往—–组织理论—–专家判断—-会议========================================&gt;规划人力资源</p><p>预分派—谈判—招募—-虚拟团队—多标准决策分析======================================&gt; 组建项目团队</p><p>培训——团队建设活动—–基本规则——–集中办公——认可与奖励——-人事评测工具====================================&gt; 建设项目团队</p><p>观察和交谈——项目绩效评估—-冲突管理—-人机关系技能==================================&gt;管理项目团队</p><hr><p><strong>人:</strong></p><p>干系人分析================================&gt; 识别干系人</p><p>沟通方法——人际关系技能—–管理技能================================&gt;管理干系人参与</p><hr><p><strong>风:</strong></p><p>文档审查——-信息收集技术——–假设分析———图解技术———SWOT分析==============================&gt;识别风险</p><p>风险概率和影响评估—概率和影响矩阵—风险数据质量评估—风险分类—风险紧迫性评估============================&gt;实施定性风险分析</p><p>数据收集和展示—–定量风险分析和建模==========================&gt;实施定量风险分析==========================&gt; 实施定量风险分析</p><p>消极风险的应对策略—–积极风险的应对策略—-应急应对策略========================&gt; 规划风险应对</p><p>风险再评估—-风险审计—-偏差与趋势分析—-技术绩效测量======================&gt;控制风险</p><hr><p><strong>采: </strong></p><p>自制和外购分析—-市场调研========================================&gt;规划采购管理</p><p>投标人会议—-建议书评价技术——-建立估算—–广告—-分析技术—-采购谈判========================================&gt;实施采购</p><p>合同变更控制系统—采购绩效审查—检查与审计—-报告绩效—-支付系统—索赔管理—记录管理系统========================================&gt;控制采购</p><p>采购审计—-采购谈判—-记录管理系统======================================&gt;结束采购</p><hr><h2 id="二十一、英语阅读题"><a href="#二十一、英语阅读题" class="headerlink" title="二十一、英语阅读题:"></a>二十一、英语阅读题:</h2><p>词汇: </p><p>Composition: 组成<br>Decomposition: 分解</p><p>precedence : 优先权<br>precedence diagramming method 前导图法</p><p>stakeholder :    利益相关者</p><p>Project stackholder : 项目干系人</p><p><strong>numerical:  数字的</strong></p><p>specification : n. 规格；说明书；详述</p><p>Call: 调用</p><p>extend: 扩展</p><p><strong>generalize: 泛化</strong></p><p>Integration: 整合,集成</p><p><strong>Quantitative : 定量的；量的，数量的</strong></p><p>probability  : n. 可能性；机率；[数] 或然率</p><p><strong>successor: 继承者；后续的事物</strong></p><p><strong>predecessor:  前任，前辈</strong></p><p><strong>program:  程序；计划；大纲</strong></p><p><strong>portfolio:  项目组合</strong></p><p>interconnected:  adj. 连通的；有联系的   v. 互相连接（interconnect的过去式）</p><p>volume: adj. <strong>大量的</strong> n: 体积</p><p><strong>velocity:  n. 【物】速度</strong></p><p><strong>reflect:  反映；反射</strong></p><p><strong>revise  修正；复习；校订</strong></p><p><strong>reissued  再发行</strong></p><p><strong>presentation:  报告</strong>,展示；<strong>描述</strong>，陈述；介绍；赠送</p><p><strong>redundant:  </strong>  adj. 多余的，过剩的；被解雇的，失业的；<strong>冗长的</strong>，累赘的</p><p>mitigation:     n. 减轻；缓和；平静 ——<strong>risk mitigation 风险减轻</strong></p><p><strong>duration: n:持续,持续的时间</strong></p><p><strong>probability: 概率</strong></p><p>possibility:  可能性</p><p><strong>phase: 阶段,时期</strong></p><p>project charter : 项目章程</p><p><strong>confused: 困惑的；混乱的</strong>；糊涂的</p><p><strong>overlap:  重叠；重复</strong></p><p><strong>metrics:  度量</strong></p><p><strong>benchmarking: 基准分析</strong></p><p>look-in:  观察</p><p><strong>check-in : 控制</strong></p><p>inspected-in :  检查</p><p><strong>dissever:  分裂</strong></p><h2 id="二十二、PMP-PMBOK-项目管理知识体系指南第五版-项目管理工具与技术-总表"><a href="#二十二、PMP-PMBOK-项目管理知识体系指南第五版-项目管理工具与技术-总表" class="headerlink" title="二十二、PMP/PMBOK 项目管理知识体系指南第五版 项目管理工具与技术 总表"></a>二十二、PMP/PMBOK 项目管理知识体系指南第五版 项目管理工具与技术 总表</h2><table><thead><tr><th>工具与技术</th><th>过程</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.hihexo.com/pmp/chapter/1103.htm" target="_blank" rel="noopener">专家判断</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8C%87%E5%AF%BC%E4%B8%8E%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">指导与管理项目工作</a> 项目整合管理执行过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E5%BA%94%E5%AF%B9.htm" target="_blank" rel="noopener">规划风险应对</a> 项目风险管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%82%E4%B8%8E.htm" target="_blank" rel="noopener">控制干系人参与</a> 项目干系人管理监控过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%9B%E5%BB%BAWBS.htm" target="_blank" rel="noopener">创建WBS</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E6%95%B4%E4%BD%93%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6.htm" target="_blank" rel="noopener">实施整体变更控制</a> 项目整合管理监控过程组<a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B.htm" target="_blank" rel="noopener">制定项目章程</a> 项目整合管理 启动过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E8%B5%84%E6%BA%90.htm" target="_blank" rel="noopener">估算活动资源</a> 项目时间管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E9%87%8F%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定量风险分析</a> 项目风险管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E5%B9%B2%E7%B3%BB%E4%BA%BA.htm" target="_blank" rel="noopener">识别干系人</a> 项目干系人管理 启动过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划成本管理</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">监控项目工作</a> 项目整合管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E6%B4%BB%E5%8A%A8.htm" target="_blank" rel="noopener">定义活动</a> 项目时间管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">定义范围</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E5%B9%B2%E7%B3%BB%E4%BA%BA%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划干系人管理</a> 项目干系人管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定性风险分析</a> 项目风险管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划人力资源管理</a> 项目人力资源管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.htm" target="_blank" rel="noopener">估算活动持续时间</a> 项目时间管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%BB%93%E6%9D%9F%E9%A1%B9%E7%9B%AE%E6%88%96%E9%98%B6%E6%AE%B5.htm" target="_blank" rel="noopener">结束项目或阶段</a> 项目整合管理收尾过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划范围管理</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划采购管理</a> 项目采购管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">控制沟通</a> 项目沟通管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划风险管理</a> 项目风险管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A2%84%E7%AE%97.htm" target="_blank" rel="noopener">制定预算</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定项目管理计划</a> 项目整合管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划进度管理</a> 项目时间管理 规划过程组</td><td><strong>基于</strong>某应用领域、知识领域、学科和行业等的<strong>专业知识而做出的</strong>，关于当前活动的合理<strong>判断</strong>。这些专业知识可来自具有专业学历、知识、技能、经验或培训经历的任何小组或个人。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/151.htm" target="_blank" rel="noopener">引导技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A1%B9%E7%9B%AE%E7%AB%A0%E7%A8%8B.htm" target="_blank" rel="noopener">制定项目章程</a> 项目整合管理 启动过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定项目管理计划</a> 项目整合管理规划过程组</td><td>引导技术广泛应用于各项目管理过程，可用于<strong>指导项目章程的制定</strong>。头脑风暴、冲突处理、问题解决和会议管理等，都是<strong>引导者可以用来帮助团队和个人完成项目活动的关键技术</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/1095.htm" target="_blank" rel="noopener">项目管理信息系统</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">监控项目工作</a> 项目整合管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E6%8C%87%E5%AF%BC%E4%B8%8E%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">指导与管理项目工作</a> 项目整合管理执行过程组</td><td>由<strong>收集、整合和传播</strong>项目管理过程成果的工具和技术所组成的信息系统。它为项目从<strong>启动到收尾</strong>的所有方面提供支持， 可以包括人工和自动系统。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/175.htm" target="_blank" rel="noopener">会议</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E6%95%B4%E4%BD%93%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6.htm" target="_blank" rel="noopener">实施整体变更控制</a> 项目整合管理监控过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划沟通管理</a> 项目沟通管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划成本管理</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">监控项目工作</a> 项目整合管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E5%B9%B2%E7%B3%BB%E4%BA%BA.htm" target="_blank" rel="noopener">识别干系人</a> 项目干系人管理 启动过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E5%B9%B2%E7%B3%BB%E4%BA%BA%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划干系人管理</a> 项目干系人管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划人力资源管理</a> 项目人力资源管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%BB%93%E6%9D%9F%E9%A1%B9%E7%9B%AE%E6%88%96%E9%98%B6%E6%AE%B5.htm" target="_blank" rel="noopener">结束项目或阶段</a> 项目整合管理收尾过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划采购管理</a> 项目采购管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划范围管理</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">控制沟通</a> 项目沟通管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划进度管理</a> 项目时间管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划风险管理</a> 项目风险管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8C%87%E5%AF%BC%E4%B8%8E%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">指导与管理项目工作</a> 项目整合管理执行过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">控制风险</a> 项目风险管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%82%E4%B8%8E.htm" target="_blank" rel="noopener">控制干系人参与</a> 项目干系人管理监控过程组</td><td>可以通过会议来讨论和解决项目的相关问题。参会者可包括项目经理、项目团队成员，以及与所讨论问题相关或会受该问题影响的干系人。应该明确每个参会者的角色，确保有效参会。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/194.htm" target="_blank" rel="noopener">分析技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划成本管理</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E5%B9%B2%E7%B3%BB%E4%BA%BA%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划干系人管理</a> 项目干系人管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C.htm" target="_blank" rel="noopener">监控项目工作</a> 项目整合管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E7%BB%93%E6%9D%9F%E9%A1%B9%E7%9B%AE%E6%88%96%E9%98%B6%E6%AE%B5.htm" target="_blank" rel="noopener">结束项目或阶段</a> 项目整合管理收尾过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划进度管理</a> 项目时间管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划风险管理</a> 项目风险管理 规划过程组</td><td>在项目管理中，根据可能的项目或环境变量的变化，以及它们与其他变量之间的关系，采用分析技术来<strong>预测潜在的后果</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/290.htm" target="_blank" rel="noopener">变更控制工具</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E6%95%B4%E4%BD%93%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6.htm" target="_blank" rel="noopener">实施整体变更控制</a> 项目整合管理监控过程组</td><td>为了<strong>便于开展配置和变更管理</strong>，可以使用一些<strong>手工或自动化</strong>的工具。工具的选择应基于项目干系人的需要，并考虑组织和环境情况和／或制约因素。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/331.htm" target="_blank" rel="noopener">访谈</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>访谈是通过<strong>与干系人直接交谈</strong>来获取信息的正式或非正式的方法。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/332.htm" target="_blank" rel="noopener">焦点小组</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>焦点小组是<strong>召集预定的干系人和主题专家</strong>，了解他们对所讨论的产品、服务或成果的期望和态度。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/333.htm" target="_blank" rel="noopener">引导式研讨会</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">定义范围</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>引导式研讨会<strong>把主要干系人召集在一起</strong>，通过集中讨论来定义产品需求。研讨会是<strong>快速定义跨职能需求</strong>和<strong>协调干系人差异</strong>的重要技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/334.htm" target="_blank" rel="noopener">群体创新技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>可以<strong>组织一些群体活动</strong>来识别项目和产品需求。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/335.htm" target="_blank" rel="noopener">群体决策技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.htm" target="_blank" rel="noopener">估算活动持续时间</a> 项目时间管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%A1%AE%E8%AE%A4%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">确认范围</a> 项目范围管理 监控过程组</td><td>群体决策技术就是为达成某种期望结果，而<strong>对多个未来行动方案进行评估</strong>的过程。本技术用于生成产品需求，并对产品需求进行<strong>归类</strong>和优先级<strong>排序</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/336.htm" target="_blank" rel="noopener">问卷调查</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>问卷调查是指设计一系列书面问题，向众多受访者快速收集信息。问卷调查方法非常适用于以下情况：受众多样化，需要快速完成调查，受访者地理位置分散，并且适合开展统计分析。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/337.htm" target="_blank" rel="noopener">观察</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>观察是指<strong>直接察看</strong>个人在各自的环境中如何执行工作（或任务）和实施流程。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/338.htm" target="_blank" rel="noopener">原型法</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>原型法是指在实际制造预期产品之前，先造出该产品的实用模型，并据此征求对需求的早期反馈。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/339.htm" target="_blank" rel="noopener">标杆对照</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>标杆对照将<strong>实际或计划</strong>的做法（如流程和操作过程）<strong>与其他可比组织的做法进行比较</strong>，以便识别最佳实践，形成改进意见，并为绩效考核提供依据。标杆对照所采用的可比组织可以是内部的，也可以是外部的。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/342.htm" target="_blank" rel="noopener">系统交互图</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>系统交互图是范围模型的一个例子，它是对产品范围的可视化描绘，显示<strong>业务系统（过程、设备、计算机系统等）及其与人和其他系统（行动者）之间的交互方式</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/343.htm" target="_blank" rel="noopener">文件分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82.htm" target="_blank" rel="noopener">收集需求</a> 项目范围管理 规划过程组</td><td>文件分析就是通过分析现有文档，识别与需求相关的信息，来挖掘需求。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/355.htm" target="_blank" rel="noopener">产品分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">定义范围</a> 项目范围管理 规划过程组</td><td>对于那些<strong>以产品为可交付成果的项目</strong>（区别于提供服务或成果的项目），产品分析是一种有效的工具。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/356.htm" target="_blank" rel="noopener">备选方案生成</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">定义范围</a> 项目范围管理 规划过程组</td><td>备选方案生成是一种用来<strong>制定尽可能多的潜在可选方案</strong>的技术，用于识别执行项目工作的不同方法。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/371.htm" target="_blank" rel="noopener">分解</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%9B%E5%BB%BAWBS.htm" target="_blank" rel="noopener">创建WBS</a> 项目范围管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E6%B4%BB%E5%8A%A8.htm" target="_blank" rel="noopener">定义活动</a> 项目时间管理 规划过程组</td><td>分解是一种<strong>把项目范围和项目可交付成果逐步划分</strong>为更小、更便于管理的组成部分的技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/384.htm" target="_blank" rel="noopener">检查</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%B4%A8%E9%87%8F.htm" target="_blank" rel="noopener">控制质量</a> 项目质量管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E7%A1%AE%E8%AE%A4%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">确认范围</a> 项目范围管理 监控过程组</td><td>检查是指开展<strong>测量、审查与确认</strong>等活动，来判断<strong>工作和可交付成果是否符合需求和产品验收标准</strong>。检查有时也被称为<strong>审查、产品审查、审计和巡检等</strong>。在某些应用领域，这些术语具有独特和具体的含义。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/402.htm" target="_blank" rel="noopener">偏差分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%8C%83%E5%9B%B4.htm" target="_blank" rel="noopener">控制范围</a> 项目范围管理 监控过程组</td><td>偏差分析是一种确定<strong>实际绩效与基准的差异程度及原因</strong>的技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/430.htm" target="_blank" rel="noopener">滚动式规划</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9A%E4%B9%89%E6%B4%BB%E5%8A%A8.htm" target="_blank" rel="noopener">定义活动</a> 项目时间管理 规划过程组</td><td>滚动式规划是一种迭代式规划技术，即<strong>详细规划近期</strong>要完成的工作，同时在较高层级上<strong>粗略规划远期</strong>工作。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/449.htm" target="_blank" rel="noopener">紧前关系绘图法</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%92%E5%88%97%E6%B4%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F.htm" target="_blank" rel="noopener">排列活动顺序</a> 项目时间管理 规划过程组</td><td>紧前关系绘图法（PDM）是创建进度模型的一种技术，<strong>用节点表示活动</strong>，用一种或多种逻辑关系连接活动，以显示活动的实施顺序。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/450.htm" target="_blank" rel="noopener">确定依赖关系</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%92%E5%88%97%E6%B4%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F.htm" target="_blank" rel="noopener">排列活动顺序</a> 项目时间管理 规划过程组</td><td>依赖关系可能是<strong>强制或选择的，内部或外部</strong>的。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/451.htm" target="_blank" rel="noopener">提前量和滞后量</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%92%E5%88%97%E6%B4%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F.htm" target="_blank" rel="noopener">排列活动顺序</a> 项目时间管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td><strong>提前量是相对于紧前活动，紧后活动可以提前的时间量。</strong></td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/467.htm" target="_blank" rel="noopener">备选方案分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E8%B5%84%E6%BA%90.htm" target="_blank" rel="noopener">估算活动资源</a> 项目时间管理 规划过程组</td><td>备选方案分析：很多进度活动都有若干种备选的实施方案，如使用能力或技能水平不同的资源、不同规模或类型的机器、不同的工具（手工或自动的），以及自制、租赁或购买相关资源（见12.1.3.5 节）。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/468.htm" target="_blank" rel="noopener">发布的估算数据</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E8%B5%84%E6%BA%90.htm" target="_blank" rel="noopener">估算活动资源</a> 项目时间管理 规划过程组</td><td>一些组织会定期发布最新的生产率信息与资源单位成本，涉及门类众多的劳务、材料和设备，覆盖许多国家及其所属地区。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/582.htm" target="_blank" rel="noopener">自下而上估算</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E8%B5%84%E6%BA%90.htm" target="_blank" rel="noopener">估算活动资源</a> 项目时间管理 规划过程组</td><td>自下而上估算是对工作组成部分进行估算的一种方法。<strong>首先对单个工作包或活动的成本进行最具体、细致的估算</strong>；然后把这些<strong>细节性成本向上汇总或“滚动”到更高层次</strong>，用于后续报告和跟踪。自下而上估算的准确性及其本身所需的成本，通常取决于单个活动或工作包的规模和复杂程度。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/586.htm" target="_blank" rel="noopener">项目管理软件</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">控制成本</a> 项目成本管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E8%B5%84%E6%BA%90.htm" target="_blank" rel="noopener">估算活动资源</a> 项目时间管理 规划过程组</td><td><strong>项目管理软件：项目管理应用软件、电子表单、模拟和统计工具等，可用来辅助成本估算</strong>。这些工具能简化某些成本估算技术的使用，使人们能快速考虑多种成本估算方案。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/490.htm" target="_blank" rel="noopener">类比估算</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.htm" target="_blank" rel="noopener">估算活动持续时间</a> 项目时间管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组</td><td>类比估算是一种<strong>使用相似活动或项目的历史数据，来估算当前活动</strong>或项目的持续时间或成本的技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/491.htm" target="_blank" rel="noopener">参数估算</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.htm" target="_blank" rel="noopener">估算活动持续时间</a> 项目时间管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组</td><td>参数估算是一种基于历史数据和项目参数，使用某种算法来计算成本或持续时间的估算技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/492.htm" target="_blank" rel="noopener">三点估算</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.htm" target="_blank" rel="noopener">估算活动持续时间</a> 项目时间管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组</td><td>三点估算通过考虑估算中的不确定性与风险，使用三种估算值来<strong>界定活动成本的近似区间</strong>，可以提高估算的准确性</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/1110.htm" target="_blank" rel="noopener">储备分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A2%84%E7%AE%97.htm" target="_blank" rel="noopener">制定预算</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%B4%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4.htm" target="_blank" rel="noopener">估算活动持续时间</a> 项目时间管理规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">控制成本</a> 项目成本管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">控制风险</a> 项目风险管理 监控过程组</td><td>一种分析技术，用来明确项目管理计划各组成部分的基本特征及其相互关系，从而为项目的工期、预算、成本估算或资金需求设定储备。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/514.htm" target="_blank" rel="noopener">进度网络分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td>进度网络分析是<strong>创建项目进度模型的一种技术</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/515.htm" target="_blank" rel="noopener">关键路径法</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td>关键路径法是在进度模型中，估算项目最短工期，确定逻辑网络路径的进度灵活性大小的一种方法。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/516.htm" target="_blank" rel="noopener">关键链法</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td>关键链法（CCM）是一种进度规划方法，允许项目团队在任何项目进度路径上<strong>设置缓冲</strong>， 以应对资源限制和项目不确定性。关键链法( Critical Chain Method ) 是另一种进度网络分析技术，可以<strong>根据有限的资源对项目进度表进行调整</strong>。由艾利·高德拉特(Eliyahu M. Goldratt，1947年3月31日－2011年6月11日)提出，</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/517.htm" target="_blank" rel="noopener">资源优化技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td>资源优化技术是根据资源供需情况，来<strong>调整</strong>进度模型的技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/518.htm" target="_blank" rel="noopener">建模技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td>建模技术包括（但不限于）：假设情景分析；模拟</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/520.htm" target="_blank" rel="noopener">进度压缩</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组</td><td>进度压缩技术是指在<strong>不缩减项目范围的前提下</strong>，<strong>缩短进度工期</strong>，以满足进度制约因素、强制日期或其他进度目标。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/521.htm" target="_blank" rel="noopener">进度计划编制工具</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92.htm" target="_blank" rel="noopener">制定进度计划</a> 项目时间管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组</td><td>自动化的进度计划编制工具包括进度模型，它用活动清单、网络图、资源需求和活动持续时间等作为输入，使用进度网络分析技术，自动生成开始和结束日期，从而可加快进度计划的编制过程。进度计划编制工具可与其他项目管理软件以及手工方法联合使用。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/538.htm" target="_blank" rel="noopener">绩效审查</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%BF%9B%E5%BA%A6.htm" target="_blank" rel="noopener">控制进度</a> 项目时间管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">控制成本</a> 项目成本管理 监控过程组</td><td>绩效审查是指<strong>测量、对比和分析进度绩效</strong>，如实际开始和完成日期、已完成百分比及当前工作的剩余持续时间。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/646.htm" target="_blank" rel="noopener">质量成本（COQ）</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组</td><td>质量成本包括在产品生命周期中为预防不符合要求、为评价产品或服务是否符合要求，以及因未达到要求（返工），而发生的所有成本。失败成本常分内部（项目内部发现的）和外部（客户发现的）两类。失败成本也称为劣质成本。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/587.htm" target="_blank" rel="noopener">卖方投标分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E4%BC%B0%E7%AE%97%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">估算成本</a> 项目成本管理 规划过程组</td><td>在成本估算过程中，可能需要根据合格卖方的投标情况，分析项目成本。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/606.htm" target="_blank" rel="noopener">成本汇总</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A2%84%E7%AE%97.htm" target="_blank" rel="noopener">制定预算</a> 项目成本管理 规划过程组</td><td>成本汇总：先把成本估算汇总到WBS中的工作包，再由工作包汇总至WBS更高层次（如控制账户）， 最终得出整个项目的总成本。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/609.htm" target="_blank" rel="noopener">历史关系</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A2%84%E7%AE%97.htm" target="_blank" rel="noopener">制定预算</a> 项目成本管理 规划过程组</td><td>有关变量之间可能存在一些可据以进行参数估算或类比估算的历史关系。可以基于这些历史关系，利用项目特征（参数）来建立数学模型，预测项目总成本。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/610.htm" target="_blank" rel="noopener">资金限制平衡</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%88%B6%E5%AE%9A%E9%A2%84%E7%AE%97.htm" target="_blank" rel="noopener">制定预算</a> 项目成本管理 规划过程组</td><td>应该根据对项目资金的任何限制，来平衡资金支出。如果发现资金限制与计划支出之间的差异，则可能需要调整工作的进度计划，以平衡资金支出水平。这可以通过在项目进度计划中添加强制日期来实现。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/622.htm" target="_blank" rel="noopener">挣值管理</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">控制成本</a> 项目成本管理 监控过程组</td><td>挣值管理（EVM）是把范围、进度和资源绩效综合起来考虑，以评估项目绩效和进展的方法。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/623.htm" target="_blank" rel="noopener">预测</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">控制成本</a> 项目成本管理 监控过程组</td><td>随着项目进展，项目团队可<strong>根据</strong>项目<strong>绩效</strong>，<strong>对完工估算</strong>（EAC Cost Estimate at Completion）进行<strong>预测</strong>，预测的结果可能与完工预算（BAC）存在差异。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/624.htm" target="_blank" rel="noopener">完工尚需绩效指数（TCPI）</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC.htm" target="_blank" rel="noopener">控制成本</a> 项目成本管理 监控过程组</td><td>完工尚需绩效指数（TCPI）是一种为了实现特定的管理目标，剩余资源的使用必须达到的成本绩效指标，<strong>是完成剩余工作所需的成本与剩余预算之比</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/645.htm" target="_blank" rel="noopener">成本效益分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组</td><td>达到质量要求的主要效益包括减少返工、提高生产率、降低成本、提升干系人满意度及提升赢利能力。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/647.htm" target="_blank" rel="noopener">七种基本质量工具</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%B4%A8%E9%87%8F.htm" target="_blank" rel="noopener">控制质量</a> 项目质量管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组</td><td>七种基本质量工具，也称7QC工具，用于在PDCA循环的框架内解决与质量相关的问题。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/649.htm" target="_blank" rel="noopener">实验设计</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组</td><td>规划质量管理过程中使用，以确定测试的数量和类别，以及这些测试对质量成本的影响。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/650.htm" target="_blank" rel="noopener">统计抽样</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%B4%A8%E9%87%8F.htm" target="_blank" rel="noopener">控制质量</a> 项目质量管理 监控过程组</td><td>统计抽样是指从目标总体中选取部分样本用于检查（如从75张工程图纸中随机抽取10张）。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/651.htm" target="_blank" rel="noopener">其他质量管理工具</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划质量管理</a> 项目质量管理 规划过程组</td><td>为定义质量要求并规划有效的质量管理活动，也可使用其他质量规划工具。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/668.htm" target="_blank" rel="noopener">质量管理和控制工具</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81.htm" target="_blank" rel="noopener">实施质量保证</a> 项目质量管理 执行过程组</td><td>实施质量保证过程使用规划质量管理和控制质量过程的工具和技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/669.htm" target="_blank" rel="noopener">质量审计</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81.htm" target="_blank" rel="noopener">实施质量保证</a> 项目质量管理 执行过程组</td><td>质量审计是用来确定项目活动<strong>是否遵循了组织和项目的政策、过程与程序</strong>的一种结构化的、独立的过程。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/670.htm" target="_blank" rel="noopener">过程分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81.htm" target="_blank" rel="noopener">实施质量保证</a> 项目质量管理 执行过程组</td><td>过程分析是指<strong>按照过程改进计划中概括的步骤来识别所需的改进</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/690.htm" target="_blank" rel="noopener">审查已批准的变更请求</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E8%B4%A8%E9%87%8F.htm" target="_blank" rel="noopener">控制质量</a> 项目质量管理 监控过程组</td><td>对所有已批准的变更请求进行审查，以核实它们是否已按批准的方式得到实施。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/709.htm" target="_blank" rel="noopener">组织图和职位描述</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划人力资源管理</a> 项目人力资源管理规划过程组</td><td>可采用多种格式来<strong>记录团队成员的角色与职责</strong>。大多数格式属于以下三类（见图9-4）： 层级型、矩阵型和文本型。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/710.htm" target="_blank" rel="noopener">人际交往</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划人力资源管理</a> 项目人力资源管理规划过程组</td><td>人际交往是指在组织、行业或职业环境中<strong>与他人的正式或非正式互动</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/711.htm" target="_blank" rel="noopener">组织理论</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划人力资源管理</a> 项目人力资源管理规划过程组</td><td>组织理论阐述个人、团队和组织部门的行为方式。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/722.htm" target="_blank" rel="noopener">预分派</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%BB%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">组建项目团队</a> 项目人力资源管理执行过程组</td><td>如果项目团队成员是事先选定的，他们就是被预分派的。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/723.htm" target="_blank" rel="noopener">谈判</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%BB%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">组建项目团队</a> 项目人力资源管理执行过程组</td><td>在许多项目中，通过谈判完成工作。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/724.htm" target="_blank" rel="noopener">招募</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%BB%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">组建项目团队</a> 项目人力资源管理执行过程组</td><td>如果执行组织不能提供为完成项目所需的人员，就需要从外部获得所需的服务，这可能包括雇佣独立咨询师，或把相关工作分包给其他组织。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/725.htm" target="_blank" rel="noopener">虚拟团队</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%BB%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">组建项目团队</a> 项目人力资源管理执行过程组</td><td>虚拟团队的使用为招募项目团队成员提供了新的可能性。虚拟团队可定义为具有共同目标、在完成角色任务的过程中很少或没有时间面对面工作的一群人。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/726.htm" target="_blank" rel="noopener">多标准决策分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%BB%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">组建项目团队</a> 项目人力资源管理执行过程组</td><td>在组建项目团队过程中，经常需要使用团队成员选择标准。通过多标准决策分析，制定出选择标准，并据此对候选团队成员进行定级或打分。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/1057.htm" target="_blank" rel="noopener">人际关系技能</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">管理项目团队</a> 项目人力资源管理执行过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%82%E4%B8%8E.htm" target="_blank" rel="noopener">管理干系人参与</a> 项目干系人管理执行过程组<a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>项目经理通过项目团队和其他干系人来完成工作。有效的项目经理应在技术、人际关系和概念技能等方面维持均衡，以便正确分析形势并合理应对。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/738.htm" target="_blank" rel="noopener">培训</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>培训包括旨在提高项目团队成员能力的全部活动。培训可以是正式或非正式的。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/739.htm" target="_blank" rel="noopener">团队建设活动</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>团队建设活动既可以是状态审查会上的五分钟议程，也可以是为改善人际关系而设计的、 在非工作场所专门举办的体验活动。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/740.htm" target="_blank" rel="noopener">基本规则</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>用基本规则对项目团队成员的可接受行为做出明确规定。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/741.htm" target="_blank" rel="noopener">集中办公</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>集中办公，也被称为“紧密矩阵”，是指把许多或全部最活跃的项目团队成员安排在同一个物理地点工作，以增强团队工作能力。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/742.htm" target="_blank" rel="noopener">认可与奖励</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>在建设项目团队过程中，需要对成员的优良行为给予认可与奖励。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/743.htm" target="_blank" rel="noopener">人事测评工具</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">建设项目团队</a> 项目人力资源管理执行过程组</td><td>人事评测工具能让项目经理和项目团队洞察成员的优势和劣势。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/756.htm" target="_blank" rel="noopener">观察和交谈</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">管理项目团队</a> 项目人力资源管理执行过程组</td><td>可通过观察和交谈，随时了解项目团队成员的工作和态度。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/757.htm" target="_blank" rel="noopener">项目绩效评估</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">管理项目团队</a> 项目人力资源管理执行过程组</td><td>在项目过程中进行绩效评估的目的包括澄清角色与职责，向团队成员提供建设性反馈，发现未知或未决问题，制定个人培训计划，以及确立未来目标。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/1067.htm" target="_blank" rel="noopener">冲突管理</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F.htm" target="_blank" rel="noopener">管理项目团队</a> 项目人力资源管理执行过程组</td><td>在项目环境中，冲突可能导致项目产生不良结果。但是，如果主动管理，冲突可以帮助团队找到更好的解决方案。项目经理必须能够找到冲突的原因，然后积极地管理冲突，从而最大程度地降低潜在的负面影响。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/774.htm" target="_blank" rel="noopener">沟通需求分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划沟通管理</a> 项目沟通管理 规划过程组</td><td>通过沟通需求分析，确定项目干系人的信息需求，包括所需信息的类型和格式，以及信息对干系人的价值。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/775.htm" target="_blank" rel="noopener">沟通技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划沟通管理</a> 项目沟通管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">管理沟通</a> 项目沟通管理 执行过程组</td><td>可以采用各种技术在项目干系人之间传递信息。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/776.htm" target="_blank" rel="noopener">沟通模型</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划沟通管理</a> 项目沟通管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">管理沟通</a> 项目沟通管理 执行过程组</td><td>用于促进沟通和信息交换的沟通模型，可能因不同项目而异，也可能因同一项目的不同阶段而异。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/777.htm" target="_blank" rel="noopener">沟通方法</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划沟通管理</a> 项目沟通管理 规划过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%82%E4%B8%8E.htm" target="_blank" rel="noopener">管理干系人参与</a> 项目干系人管理执行过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">管理沟通</a> 项目沟通管理 执行过程组</td><td>可以使用多种沟通方法在项目干系人之间共享信息。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/792.htm" target="_blank" rel="noopener">信息管理系统</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%82%E4%B8%8E.htm" target="_blank" rel="noopener">控制干系人参与</a> 项目干系人管理监控过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">管理沟通</a> 项目沟通管理 执行过程组<a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">控制沟通</a> 项目沟通管理 监控过程组</td><td>信息管理系统用来管理和分发项目信息的工具。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/793.htm" target="_blank" rel="noopener">报告绩效</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E6%B2%9F%E9%80%9A.htm" target="_blank" rel="noopener">管理沟通</a> 项目沟通管理 执行过程组</td><td>报告绩效是指收集和发布绩效信息，包括状况报告、进展测量结果及预测结果。应该定期收集基准数据与实际数据，进行对比分析，以便了解和沟通项目进展与绩效，并对项目结果做出预测。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/846.htm" target="_blank" rel="noopener">文档审查</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组</td><td>对项目文档（包括各种计划、假设条件、以往的项目文档、协议和其他信息）进行结构化审查。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/847.htm" target="_blank" rel="noopener">信息收集技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组</td><td>可用于风险识别的信息收集技术包括：头脑风暴，德尔菲技术，访谈，根本原因分析</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/848.htm" target="_blank" rel="noopener">核对单分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组</td><td>可以<strong>根据以往类似项目</strong>和其他来源的<strong>历史信息</strong>与知识<strong>编制</strong>风险识别核对单。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/849.htm" target="_blank" rel="noopener">假设分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组</td><td>每个项目及其计划都是基于一套假想、设想或假设而构建的。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/850.htm" target="_blank" rel="noopener">图解技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组</td><td>风险图解技术可包括：因果图，系统或过程流程图，影响图</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/851.htm" target="_blank" rel="noopener">SWOT 分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">识别风险</a> 项目风险管理 规划过程组</td><td>这种技术从项目的每个<strong>优势（Strength）、劣势（Weakness）、机会（Opportunity）和威胁（Threat）出发</strong>，对项目进行考察，把产生于内部的风险都包括在内，从而更全面地考虑风险。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/863.htm" target="_blank" rel="noopener">风险概率和影响评估</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定性风险分析</a> 项目风险管理规划过程组</td><td>风险概率评估旨在调查每个具体风险发生的可能性。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/864.htm" target="_blank" rel="noopener">概率和影响矩阵</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定性风险分析</a> 项目风险管理规划过程组</td><td>应该基于风险评级结果，对风险进行优先级排序，以便进一步开展定量分析和风险应对规划。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/865.htm" target="_blank" rel="noopener">风险数据质量评估</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定性风险分析</a> 项目风险管理规划过程组</td><td>风险数据质量评估是评估风险数据对风险管理的有用程度的一种技术。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/866.htm" target="_blank" rel="noopener">风险分类</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定性风险分析</a> 项目风险管理规划过程组</td><td>有助于为制定有效的风险应对措施而确定工作包、活动、项目阶段，甚至项目中的角色。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/867.htm" target="_blank" rel="noopener">风险紧迫性评估</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E6%80%A7%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定性风险分析</a> 项目风险管理规划过程组</td><td>可以把近期就需要应对的风险确定为更紧迫的风险。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/880.htm" target="_blank" rel="noopener">数据收集和展示技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E9%87%8F%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定量风险分析</a> 项目风险管理规划过程组</td><td>包括：访谈，概率分布</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/881.htm" target="_blank" rel="noopener">定量风险分析和建模技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E5%AE%9A%E9%87%8F%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90.htm" target="_blank" rel="noopener">实施定量风险分析</a> 项目风险管理规划过程组</td><td>用的技术有面向事件和面向项目的分析方法，包括：敏感性分析，预期货币价值分析，建模和模拟，</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/890.htm" target="_blank" rel="noopener">消极风险或威胁的应对策略</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E5%BA%94%E5%AF%B9.htm" target="_blank" rel="noopener">规划风险应对</a> 项目风险管理 规划过程组</td><td>通常用规避、转移、减轻这三种策略来应对威胁或可能给项目目标带来消极影响的风险，第四种策略，即接受</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/891.htm" target="_blank" rel="noopener">积极风险或机会的应对策略</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E5%BA%94%E5%AF%B9.htm" target="_blank" rel="noopener">规划风险应对</a> 项目风险管理 规划过程组</td><td>包括：开拓，提高，分享，接受</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/892.htm" target="_blank" rel="noopener">应急应对策略</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E5%BA%94%E5%AF%B9.htm" target="_blank" rel="noopener">规划风险应对</a> 项目风险管理 规划过程组</td><td>可以针对某些特定事件，专门设计一些应对措施。对于有些风险，项目团队可以制定应急应对策略，即只有在某些预定条件发生时才能实施的应对计划。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/904.htm" target="_blank" rel="noopener">风险再评估</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">控制风险</a> 项目风险管理 监控过程组</td><td>风险再评估：在控制风险中，经常需要识别新风险，对现有风险进行再评估，以及删去已过时的风险。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/905.htm" target="_blank" rel="noopener">风险审计</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">控制风险</a> 项目风险管理 监控过程组</td><td>风险审计是<strong>检查并记录</strong>风险应对措施在处理已识别风险及其根源方面的有效性，以及风险管理过程的有效性。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/906.htm" target="_blank" rel="noopener">偏差和趋势分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">控制风险</a> 项目风险管理 监控过程组</td><td>很多控制过程都会借助偏差分析来比较计划结果与实际结果。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/907.htm" target="_blank" rel="noopener">技术绩效测量</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%A3%8E%E9%99%A9.htm" target="_blank" rel="noopener">控制风险</a> 项目风险管理 监控过程组</td><td>技术绩效测量是把项目执行期间所取得的技术成果与关于取得技术成果的计划进行比较。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/929.htm" target="_blank" rel="noopener">自制或外购分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划采购管理</a> 项目采购管理 规划过程组</td><td>自制或外购分析是一种通用的管理技术，用来确定某项工作最好由项目团队自行完成，还是应该从外部采购。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/931.htm" target="_blank" rel="noopener">市场调研</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%A7%84%E5%88%92%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86.htm" target="_blank" rel="noopener">规划采购管理</a> 项目采购管理 规划过程组</td><td>市场调研包括考察行业情况和供应商能力。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/952.htm" target="_blank" rel="noopener">投标人会议</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组</td><td>投标人会议（又称承包商会议、供货商会议或投标前会议）就是在<strong>投标书或建议书提交之前</strong>，在买方和所有潜在卖方之间召开的会议。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/953.htm" target="_blank" rel="noopener">建议书评价技术</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组</td><td>对于复杂的采购，如果要基于卖方对既定加权标准的响应情况来选择卖方，则应该根据买方的采购政策，规定一个正式的建议书评审流程。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/954.htm" target="_blank" rel="noopener">独立估算</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组</td><td>对于许多采购，采购组织可以自行编制独立估算，或者邀请外部专业估算师做出成本估算，并将此作为标杆，用来与潜在卖方的应答做比较。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/956.htm" target="_blank" rel="noopener">广告</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组</td><td>在大众出版物（如报纸）或专业出版物上刊登广告，往往可以扩充现有的潜在卖方名单。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/958.htm" target="_blank" rel="noopener">采购谈判</a></td><td><a href="http://www.hihexo.com/pmp/process/%E5%AE%9E%E6%96%BD%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">实施采购</a> 项目采购管理 执行过程组<a href="http://www.hihexo.com/pmp/process/%E7%BB%93%E6%9D%9F%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">结束采购</a> 项目采购管理 收尾过程组</td><td>采购谈判是指在合同签署之前，对合同的结构、要求及其他条款加以澄清，以取得一致意见。最终的合同措辞应该反映双方达成的全部一致意见。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/976.htm" target="_blank" rel="noopener">合同变更控制系统</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组</td><td>合同变更控制系统<strong>规定了修改合同的过程</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/977.htm" target="_blank" rel="noopener">采购绩效审查</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组</td><td>采购绩效审查是一种结构化的审查，依据合同来审查卖方在规定的成本和进度内完成项目范围和达到质量要求的情况。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/978.htm" target="_blank" rel="noopener">检查与审计</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组</td><td>在项目执行过程中，应该根据合同规定，<strong>由买方开展相关的检查与审计</strong>，卖方应对此提供支持。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/980.htm" target="_blank" rel="noopener">支付系统</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组</td><td>通常，先由被授权的项目团队成员证明卖方的工作令人满意，再通过买方的应付账款系统向卖方付款。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/981.htm" target="_blank" rel="noopener">索赔管理</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组</td><td>如果买卖双方不能就变更补偿达成一致意见，甚至对变更是否已经发生都存在分歧，那么被请求的变更就成为有争议的变更或潜在的推定变更。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/982.htm" target="_blank" rel="noopener">记录管理系统</a></td><td><a href="http://www.hihexo.com/pmp/process/%E6%8E%A7%E5%88%B6%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">控制采购</a> 项目采购管理 监控过程组<a href="http://www.hihexo.com/pmp/process/%E7%BB%93%E6%9D%9F%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">结束采购</a> 项目采购管理 收尾过程组</td><td>项目经理采用记录管理系统来管理合同、采购文档和相关记录。它包含一套特定的过程、相关的控制功能，以及作为项目管理信息系统（见4.4.2.3节）一部分的自动化工具。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/994.htm" target="_blank" rel="noopener">采购审计</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%BB%93%E6%9D%9F%E9%87%87%E8%B4%AD.htm" target="_blank" rel="noopener">结束采购</a> 项目采购管理 收尾过程组</td><td>采购审计是指对从规划采购管理过程到控制采购过程的所有采购过程进行结构化审查。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/1008.htm" target="_blank" rel="noopener">干系人分析</a></td><td><a href="http://www.hihexo.com/pmp/process/%E8%AF%86%E5%88%AB%E5%B9%B2%E7%B3%BB%E4%BA%BA.htm" target="_blank" rel="noopener">识别干系人</a> 项目干系人管理 启动过程组</td><td>干系人分析是系统地<strong>收集和分析</strong>各种定量与定性信息，以便确定在整个项目中<strong>应该考虑哪些人的利益</strong>。</td></tr><tr><td><a href="http://www.hihexo.com/pmp/chapter/1034.htm" target="_blank" rel="noopener">管理技能</a></td><td><a href="http://www.hihexo.com/pmp/process/%E7%AE%A1%E7%90%86%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%82%E4%B8%8E.htm" target="_blank" rel="noopener">管理干系人参与</a> 项目干系人管理执行过程组</td><td>项目经理应用管理技能来协调各方以实现项目目标。包括：引导；施加影响；谈判；调整组织行为</td></tr></tbody></table><h2 id="二十三、配置管理"><a href="#二十三、配置管理" class="headerlink" title="二十三、配置管理"></a>二十三、配置管理</h2><p>其中 版本控制的目的是按照一定规则 保存配置项的 所有版本,而不是仅保存基线版本,重要版本等, 这样做为了避免发生版本丢失或混淆,并可快速查找任何版本.</p><h4 id="23-1-第一个过程是"><a href="#23-1-第一个过程是" class="headerlink" title="23.1 第一个过程是"></a>23.1 第一个过程是</h4><p><strong>建方针</strong></p><h4 id="23-2-配置项："><a href="#23-2-配置项：" class="headerlink" title="23.2 配置项："></a>23.2 配置项：</h4><p>1）属于产品组成部分的工作成果，</p><p>2）属于项目管理和机构支撑过程域产生的文档。</p><p>测试报告、会议记要、工作记录不能作为配置项，因为不能修改。</p><h3 id="23-3-配置管理有3种基线："><a href="#23-3-配置管理有3种基线：" class="headerlink" title="23.3 配置管理有3种基线："></a>23.3 配置管理有3种基线：</h3><p>功能、分配和产品基线。</p><p>产品的测试版本也可以看作基线。</p><p>3E审计：<strong>妓女笑。</strong>经济、效率和效果审计。</p><h3 id="23-4-项目配置管理的任务："><a href="#23-4-项目配置管理的任务：" class="headerlink" title="23.4 项目配置管理的任务："></a>23.4 项目配置管理的任务：</h3><p><strong>口诀: 技师变态神经</strong></p><p><strong>1）制定项目配置管理计划，</strong></p><p><strong>2）确定配置标识规则，</strong></p><p><strong>3）实施变更控制措施，</strong></p><p><strong>4）报告配置状态，</strong></p><p><strong>5）进行配置审核，</strong></p><p><strong>6）进行版本管理和发行管理。</strong></p><p>不包括检测配置</p><h4 id="23-5-配置管理活动："><a href="#23-5-配置管理活动：" class="headerlink" title="23.5 配置管理活动："></a>23.5 配置管理活动：</h4><p><strong>口诀: 是童颜。</strong></p><p><strong>1）配置识别（为产品配置的定义和验证、产品的标识和归档；变更的管理及其责任提供了基础），</strong></p><p><strong>2）配置状况统计（收集、存储和访问配置信息，以维护产品的有效性），</strong></p><p><strong>3）配置验证和审核（如相关的功能需求已经被设计文档实现，而且设计文档已纳入配置管理系统）。</strong></p><p>配置管理员CMO才可以删除，CCB、PM、DEV（开发人员）不能删除。</p><p><strong>版本管理与发布 应该由 配置管理员CMO 执行.</strong></p><h4 id="23-6-配置库的主要作用："><a href="#23-6-配置库的主要作用：" class="headerlink" title="23.6 配置库的主要作用："></a>23.6 配置库的主要作用：</h4><p><strong>口诀: 极品区。</strong></p><p><strong>1）记录与配置相关的所有信息，其中存放受控的软件配置项是很重要的内容，</strong></p><p><strong>2）利用库中的信息可评价变更的后果，这对变更控制有着重要的意义，</strong></p><p><strong>3）从库中可提取各种配置管理过程的管理信息，可利用库中的信息查询回答许多配置管理的问题。</strong></p><h4 id="23-7-配置库四类："><a href="#23-7-配置库四类：" class="headerlink" title="23.7 配置库四类："></a>23.7 配置库四类：</h4><p><strong>1）开发库（动态库，较为频繁的修改）</strong></p><p><strong>2) 受控库（主库或系统库，管理基线和变更，二次开发,库内信息的读和写均受限制）</strong></p><p><strong>3) 产品库（静态库，最终产品存入库内）。</strong></p><p><strong>4) 备份库: 重要配置信息的备份,应急时恢复受损的配置库信息</strong></p><h2 id="二十四、组合管理"><a href="#二十四、组合管理" class="headerlink" title="二十四、组合管理"></a>二十四、组合管理</h2><p>可以将组织战略进一步细化到选择哪些项目来实现组织的目标</p><p>选择的主要依据: <strong>平衡风险和收益</strong> </p><h3 id="24-1-DIPP"><a href="#24-1-DIPP" class="headerlink" title="24.1 DIPP"></a>24.1 DIPP</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.116.png" alt="116"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.117.png" alt="117"></p><h2 id="二十五、战略管理"><a href="#二十五、战略管理" class="headerlink" title="二十五、战略管理"></a>二十五、战略管理</h2><h3 id="25-1-战略管理的主要活动："><a href="#25-1-战略管理的主要活动：" class="headerlink" title="25.1 战略管理的主要活动："></a>25.1 战略管理的主要活动：</h3><p><strong>战略制定，战略执行，战略评估。</strong></p><h3 id="25-2-战略五个步骤："><a href="#25-2-战略五个步骤：" class="headerlink" title="25.2 战略五个步骤："></a>25.2 战略五个步骤：</h3><p><strong>口诀: 分离择姑配。</strong></p><p>战略分析，战略梳理，战略选择，战略评估，战略匹配。</p><h3 id="25-3-PEST宏观环境分析："><a href="#25-3-PEST宏观环境分析：" class="headerlink" title="25.3 PEST宏观环境分析："></a>25.3 PEST宏观环境分析：</h3><p><strong>口诀: 震惊社稷</strong>。</p><p>政治，经济，社会和文化，技术。</p><h3 id="25-4-战略层次："><a href="#25-4-战略层次：" class="headerlink" title="25.4 战略层次："></a>25.4 战略层次：</h3><p>公司战略，业务战略，职能战略。</p><h3 id="25-5-战略组织类型："><a href="#25-5-战略组织类型：" class="headerlink" title="25.5 战略组织类型："></a>25.5 战略组织类型：</h3><p>防御型（采用竞争性定价或高质量产品组织竞争对手进入），开拓型（寻找和开发新的产品和市场，声誉比利润更重要），分析型（介于前两者之间），被动反应型（消极无效的组织形态，总是不稳定）。</p><h3 id="25-6-五种基本竞争力量"><a href="#25-6-五种基本竞争力量" class="headerlink" title="25.6 五种基本竞争力量:"></a>25.6 五种基本竞争力量:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.118.png" alt="118"></p><h3 id="25-7-产品与战略联系"><a href="#25-7-产品与战略联系" class="headerlink" title="25.7 产品与战略联系"></a>25.7 产品与战略联系</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.119.png" alt="119"></p><h3 id="25-8-战略组织类型"><a href="#25-8-战略组织类型" class="headerlink" title="25.8 战略组织类型"></a>25.8 战略组织类型</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.120.png" alt="120"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.121.png" alt="121"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.122.png" alt="122"></p><p>防御型: 竞争性定价,高质量产品</p><p>开拓型: 开发新产品</p><p>分析性: 最小风险最大利润</p><p>反应型: 消极的</p><h3 id="25-9-SWOT"><a href="#25-9-SWOT" class="headerlink" title="25.9 SWOT:"></a>25.9 SWOT:</h3><p>从项目的每个<strong>S优势,W劣势,O机会,T威胁</strong>出发,对项目进行考察,从而更全方面的考虑风险.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.123.png" alt="123"></p><h3 id="25-10-战略分析"><a href="#25-10-战略分析" class="headerlink" title="25.10 战略分析"></a>25.10 战略分析</h3><p>①: 内部分析</p><p>②: 外部分析</p><p>③: 内外环境结合分析</p><p>④: 战略提出</p><h3 id="25-11-常见综合战略"><a href="#25-11-常见综合战略" class="headerlink" title="25.11 常见综合战略"></a>25.11 常见综合战略</h3><p>①: 防御</p><p>②: 扩张</p><p>③: 加强</p><h2 id="二十六、知识管理"><a href="#二十六、知识管理" class="headerlink" title="二十六、知识管理"></a>二十六、知识管理</h2><p>隐性知识的共享方法：编码化，面对面交流，人员轮换，网络；隐性知识是“惯例”。</p><h2 id="二十七、需求管理"><a href="#二十七、需求管理" class="headerlink" title="二十七、需求管理"></a>二十七、需求管理</h2><p><strong>需求管理：</strong></p><p>需求工程：包括需求开发和需求管理，前者是主线、目标，后者是支持、保障。</p><p>需求开发四过程：需求捕获（用户访谈，用户调查，现场观摩，文档考古，联合讨论会）—《用户需求说明书》，分析，定义（《需求规格说明书》更详细），验证。</p><p>需求规格说明书SRS：精确地阐述了一个软件系统必须提供的功能和性能，以及它所考虑的限制条件。</p><p>需求跟踪性矩阵保存了需求与后续工作成果的对应关系。</p><p><strong>需求验证后形成需求基线</strong></p><p>需求开发的目的:    是通过调查与分析，获取用户需求并定义产品需求；</p><p>需求管理的目的：</p><ul><li>1）确保各方对需求的一致理解，</li><li>2）管理和控制需求的变更，</li><li>3）从需求到最终产品的双向跟踪；</li></ul><p>范围管理的目的确定项目包含且仅仅只包含项目所必须完成的工作。</p><p>需求管理包括：定义需求基线，处理需求变更，需求跟踪等。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.80.png" alt="80"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.81.png" alt="81"></p><h2 id="二十八、外包管理"><a href="#二十八、外包管理" class="headerlink" title="二十八、外包管理"></a>二十八、外包管理</h2><p>外包是为了达到降低成本，提高效率，充分发挥自身核心竞争力，增强自身应变能力。</p><p>越来越多的企业回归核心业务。</p><p>如何以合适的方式监督供方是项目外包管理的一个重点，监控方式正确的是与供应商先确定评价的频次和方法，列出日程表，按照计划进行评价。</p><p>鞭子效应：是将单一的决策问题多阶段化以回避风险，提高决策效率，类似于分散投资。</p><h2 id="二十九、流程管理"><a href="#二十九、流程管理" class="headerlink" title="二十九、流程管理"></a>二十九、流程管理</h2><h3 id="29-1-组织链-组织学习"><a href="#29-1-组织链-组织学习" class="headerlink" title="29.1 组织链,组织学习,"></a>29.1 组织链,组织学习,</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.124.png" alt="124"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.125.png" alt="125"></p><h3 id="29-2-价值活动"><a href="#29-2-价值活动" class="headerlink" title="29.2 价值活动"></a>29.2 价值活动</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.126.png" alt="126"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.127.png" alt="127"></p><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.128.png" alt="128"></p><h3 id="29-3-评估方法"><a href="#29-3-评估方法" class="headerlink" title="29.3 评估方法"></a>29.3 评估方法</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.129.png" alt="129"></p><h3 id="29-4-BPR的实施3个层次"><a href="#29-4-BPR的实施3个层次" class="headerlink" title="29.4 BPR的实施3个层次"></a>29.4 BPR的实施3个层次</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.130.png" alt="130"></p><h3 id="29-5-BPR原则"><a href="#29-5-BPR原则" class="headerlink" title="29.5 BPR原则"></a>29.5 BPR原则</h3><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.131.png" alt="131"></p><h3 id="29-6-企业的流程管理"><a href="#29-6-企业的流程管理" class="headerlink" title="29.6 企业的流程管理"></a>29.6 企业的流程管理</h3><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.138.png" alt="138"></p><h3 id="29-7-业务流程分类"><a href="#29-7-业务流程分类" class="headerlink" title="29.7 业务流程分类"></a>29.7 业务流程分类</h3><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.132.png" alt="132"></p><h2 id="三十、安全管理"><a href="#三十、安全管理" class="headerlink" title="三十、安全管理"></a>三十、安全管理</h2><h3 id="30-1-基于角色的访问控制"><a href="#30-1-基于角色的访问控制" class="headerlink" title="30.1 基于角色的访问控制"></a>30.1 基于角色的访问控制</h3><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.145.png" alt="145"></p><p> <img src="http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.146.png" alt="146"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.zzwwqq.xyz/static/images/信息系统项目管理师/mspm-1.5.png&quot; alt=&quot;5&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="考证" scheme="https://zzwwqq.xyz/categories/%E8%80%83%E8%AF%81/"/>
    
    
      <category term="信息系统项目管理师" scheme="https://zzwwqq.xyz/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>java网络编程之TCP-UDP</title>
    <link href="https://zzwwqq.xyz/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP.html"/>
    <id>https://zzwwqq.xyz/java网络编程之TCP-UDP/java网络编程之TCP-UDP.html</id>
    <published>2019-04-13T01:49:05.000Z</published>
    <updated>2019-04-13T03:22:20.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网络编程基础"><a href="#一、网络编程基础" class="headerlink" title="一、网络编程基础"></a>一、网络编程基础</h2><h3 id="1-1-网络编程有两个主要的问题"><a href="#1-1-网络编程有两个主要的问题" class="headerlink" title="1.1 网络编程有两个主要的问题:"></a>1.1 网络编程有两个主要的问题:</h3><p>①: 如何准确定位网络上的一台或多台主机<br>②: 定位后如何可靠高效的传输数据</p><a id="more"></a><p>在TCP/IP中,IP层主要负责网络主机的定位,数据传输的路由,由IP地址可以唯一的确定网络上的一台主机.<br>而TCP层提供面向应用的数据传输机制,这是网络编程的主要对象.</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2  基本概念:"></a>1.2  基本概念:</h3><p><strong>端口号:</strong>  网络通信时同一机器上的不同进程的标识（其中0~1023为系统保留的端口号）,<strong>端口范围: 0~65535</strong><br><strong>套接字:</strong>  <strong>IP : 端口号</strong><br><strong>资源名: </strong>是资源的完整地址,包括主机名,端口号,文件名,如<a href="http://www.sun.com" target="_blank" rel="noopener">http://www.sun.com</a> （协议名://主机名）<a href="http://home.netscape.com/home/welcome.html（协议名：/机器名+文件名）" target="_blank" rel="noopener">http://home.netscape.com/home/welcome.html（协议名：//机器名+文件名）</a><br><strong>协议名：</strong>指明获取资源时所使用的传输协议。  如http，ftp,gopher,file</p><h3 id="1-3-关于UDP"><a href="#1-3-关于UDP" class="headerlink" title="1.3 关于UDP:"></a>1.3 关于UDP:</h3><p>UDP: <strong>无连接</strong>的协议,<strong>每个数据报都是一个独立的信息</strong>,<strong>包括完整的源地址或目的地址</strong>,它在网络上任何可能路径传往目的地<br>,<strong>不可靠性</strong>(发送方发送的数据报不一定以相同次序到达接收方),<strong>传输效率高</strong>,<strong>有大小限制</strong>(每个数据报大小不超过64KB),.</p><h3 id="1-4-获取网络信息和资源"><a href="#1-4-获取网络信息和资源" class="headerlink" title="1.4 获取网络信息和资源:"></a>1.4 获取网络信息和资源:</h3><h4 id="1-4-1-非常重要的一个类-InetAddress-IP地址的封装类"><a href="#1-4-1-非常重要的一个类-InetAddress-IP地址的封装类" class="headerlink" title="1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)"></a>1.4.1 非常重要的一个类: InetAddress (IP地址的封装类)</h4><p>java.net中很多类使用到了它,如ServerSocket, Socket , DatagramSocket等</p><h4 id="1-4-2-常用方法"><a href="#1-4-2-常用方法" class="headerlink" title="1.4.2 常用方法:"></a>1.4.2 常用方法:</h4><p><strong>获取本机主机名:</strong> InetAddress.getLocalHost().getHostName()<br><strong>获取本机IP:</strong>  InetAddress.getLocalHost().getHostAddress()<br><strong>获取本机端口: </strong>serverSocket = new ServerSocket(6666); serverSocket.getLocalPort();</p><p><strong>服务器端获取客户端IP: </strong>Socket socket = serverSocket.accept(); socket.getInetAddress().getHostAddress();<br><strong>服务器获取客户端端口: </strong>String.valueOf(socket.getPort())</p><h2 id="二、基于TCP的网络通信"><a href="#二、基于TCP的网络通信" class="headerlink" title="二、基于TCP的网络通信:"></a>二、基于TCP的网络通信:</h2><h3 id="2-1-通过套接字建立连接的过程"><a href="#2-1-通过套接字建立连接的过程" class="headerlink" title="2.1 通过套接字建立连接的过程:"></a>2.1 通过套接字建立连接的过程:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.1.png" alt></p><h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例:"></a>2.2 实例:</h3><p><strong>客户端:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Client();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Socket sock;</span><br><span class="line">    <span class="comment">//界面上显示的组件</span></span><br><span class="line">    JTextField txtMsgServerIP = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JTextField txtMsgServerPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    JButton btnConnect = <span class="keyword">new</span> JButton(<span class="string">"连接服务器"</span>);</span><br><span class="line">    JButton btnDisConnect = <span class="keyword">new</span> JButton(<span class="string">"断开连接"</span>);</span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据输入输出流</span></span><br><span class="line">    DataOutputStream out;</span><br><span class="line">    DataInputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> canWaite = <span class="keyword">true</span>;</span><br><span class="line">    CWaiter waiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器中完成初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//容器</span></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始状态时"连接服务器"按钮可点击</span></span><br><span class="line">        btnConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//初始状态时"断开连接"按钮不可点击</span></span><br><span class="line">        btnDisConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时文本域不可编辑,只能用于显示通话信息</span></span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时发送消息的编辑框不可输入</span></span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//初始状态时发送按钮不可点</span></span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建面板</span></span><br><span class="line">        JPanel jp =  <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER));</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器IP"</span>));</span><br><span class="line">        jp_f1.add(txtMsgServerIP);</span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器端口号"</span>));</span><br><span class="line">        jp_f1.add(txtMsgServerPort);</span><br><span class="line"></span><br><span class="line">        jp_f2.add(btnConnect);</span><br><span class="line">        jp_f2.add(btnDisConnect);</span><br><span class="line"></span><br><span class="line">        jp.add(jp_f1);</span><br><span class="line">        jp.add(jp_f2);</span><br><span class="line">        <span class="comment">//创建面板,并把组件添加到面板</span></span><br><span class="line">        JScrollPane jsp =  <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp2 = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组件添加到面板</span></span><br><span class="line"></span><br><span class="line">        jp2.add(txtMsgSend);</span><br><span class="line">        jp2.add(btnSend);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//面板添加到容器</span></span><br><span class="line">        container.add(jp,<span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp,<span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp2,<span class="string">"South"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口标题</span></span><br><span class="line">        setTitle(<span class="string">"客户端"</span>);</span><br><span class="line">        <span class="comment">//窗口大小</span></span><br><span class="line">        setSize(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//是否可见</span></span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给组件添加监听器</span></span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnConnect.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnDisConnect.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加窗口监听器</span></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//窗口关闭事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    disconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String ServerIP,Integer ServerPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建套接字,用于连接服务器</span></span><br><span class="line">            sock = <span class="keyword">new</span> Socket(ServerIP,ServerPort);</span><br><span class="line">            <span class="comment">//由套接字获取输入输出流</span></span><br><span class="line">            InputStream is = sock.getInputStream();</span><br><span class="line">            OutputStream os = sock.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由输入输出流获取数据输入输出流</span></span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(is);</span><br><span class="line">            out = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向输出流(向服务器端)写数据</span></span><br><span class="line">            out.writeUTF(<span class="string">"客户进来"</span>);</span><br><span class="line">            <span class="comment">//客户端的文本域中显示连接信息</span></span><br><span class="line">            txtMsgArea.append(<span class="string">"连接成功\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//连接服务器按钮 设置为不可点击(因为现在已经连接了服务器,避免重复连接,所以按钮设置为不可点击)</span></span><br><span class="line">            btnConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//断开连接按钮 设置为 可点击</span></span><br><span class="line">            btnDisConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//发送信息按钮 设置为 可点击</span></span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//发送信息的编辑框 设置为可输入</span></span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动线程</span></span><br><span class="line">            waiter = <span class="keyword">new</span> CWaiter();</span><br><span class="line">            waiter.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"连接服务器失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端发送消息到服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发送的消息不为空</span></span><br><span class="line">       <span class="keyword">if</span>(!txtMsgSend.getText().equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//通过输出流向服务器发消息</span></span><br><span class="line">               out.writeUTF(txtMsgSend.getText());</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"发送消息失败!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"不能发送空消息!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置组件权限</span></span><br><span class="line">        btnConnect.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        btnDisConnect.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向服务器发消息,内容为disconnect,表示要断开连接</span></span><br><span class="line">            out.writeUTF(<span class="string">"disconnect"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            canWaite = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭输入输出流</span></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//关闭套接字</span></span><br><span class="line">                    sock.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果点击了发送按钮,就调用sendMsg函数,发送消息到服务器</span></span><br><span class="line">        <span class="keyword">if</span>(e.getSource() == btnSend || e.getSource() == txtMsgSend)&#123;</span><br><span class="line">            sendMsg();</span><br><span class="line">            txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == btnConnect)&#123; <span class="comment">//如果点击了连接按钮,就调用connect函数</span></span><br><span class="line">            <span class="comment">//都不为空</span></span><br><span class="line">            <span class="keyword">if</span>(!(txtMsgServerIP.getText().equals(<span class="string">""</span>) || txtMsgServerPort.getText().equals(<span class="string">""</span>)))&#123;</span><br><span class="line">                canWaite = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> ServerPort = Integer.parseInt(txtMsgServerPort.getText());</span><br><span class="line">                <span class="keyword">if</span>(!(ServerPort &gt; <span class="number">0</span>  &amp;&amp; ServerPort &lt; <span class="number">65535</span>)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"端口值必须在0~65535之间!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                connect(txtMsgServerIP.getText(),Integer.parseInt(txtMsgServerPort.getText()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//不都为空</span></span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"服务器IP或端口号不能为空!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getSource() == btnDisConnect)&#123;</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于接收信息的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CWaiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span>(canWaite) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//从输入流中读取服务器返回的数据</span></span><br><span class="line">                    msg = in.readUTF();</span><br><span class="line">                    <span class="keyword">if</span>(msg.equals(<span class="string">"serverStop"</span>))&#123;</span><br><span class="line">                        txtMsgArea.append(<span class="string">"服务器停止!\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    txtMsgArea.append(<span class="string">"服务器说: "</span>+ msg + <span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            txtMsgArea.append(<span class="string">"客户离开\n"</span>);</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.2.png" alt></p><p><strong>服务器端: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义界面组件</span></span><br><span class="line">    JTextField txtServerPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">    JButton btnStart = <span class="keyword">new</span> JButton(<span class="string">"启动服务器"</span>);</span><br><span class="line">    JButton btnStop = <span class="keyword">new</span> JButton(<span class="string">"停止服务器"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端套接字</span></span><br><span class="line">    ServerSocket serverSocket;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="comment">//数据流</span></span><br><span class="line">    DataOutputStream out;</span><br><span class="line">    DataInputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制线程的逻辑变量</span></span><br><span class="line">    <span class="keyword">boolean</span> canWaiter = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canAccepter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    Accepter accepter;</span><br><span class="line">    SWaiter waiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器中完成界面初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        btnStart.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        btnStop.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网格布局</span></span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//流式布局</span></span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER));</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"服务器端口号"</span>));</span><br><span class="line">        jp_f1.add(txtServerPort);</span><br><span class="line">        jp_f2.add(btnStart);</span><br><span class="line">        jp_f2.add(btnStop);</span><br><span class="line"></span><br><span class="line">        jp.add(jp_f1);</span><br><span class="line">        jp.add(jp_f2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp2 = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        jp2.add(txtMsgSend);</span><br><span class="line">        jp2.add(btnSend);</span><br><span class="line"></span><br><span class="line">        container.add(jp, <span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp, <span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp2, <span class="string">"South"</span>);</span><br><span class="line"></span><br><span class="line">        setTitle(<span class="string">"服务器"</span>);</span><br><span class="line">        setSize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        btnStart.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStop.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                stopServer();</span><br><span class="line">                dispose();</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(Integer txtServerPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(txtServerPort);</span><br><span class="line">            btnStart.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            btnStop.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            accepter = <span class="keyword">new</span> Accepter();</span><br><span class="line">            accepter.start();</span><br><span class="line">            <span class="comment">//System.out.println(InetAddress.getLocalHost().getHostName());</span></span><br><span class="line">            <span class="comment">//System.out.println(InetAddress.getLocalHost().getHostAddress());</span></span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器已成功启动...\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器主机名为: "</span> + InetAddress.getLocalHost().getHostName()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器IP地址为: "</span> + InetAddress.getLocalHost().getHostAddress()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"服务器端口号为: "</span> + serverSocket.getLocalPort()+<span class="string">"\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"启动服务器失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息到客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!txtMsgSend.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//向客户端写数据</span></span><br><span class="line">                out.writeUTF(txtMsgSend.getText());</span><br><span class="line">                txtMsgArea.append(<span class="string">"服务器说: "</span> + txtMsgSend.getText() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"发送消息失败!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"不能发送消息!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置组件的权限</span></span><br><span class="line">        btnStop.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        btnStart.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//停止等待客户端请求的线程</span></span><br><span class="line">        canAccepter = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向输出流写数据,通知客户端服务器已停止.</span></span><br><span class="line">            out.writeUTF(<span class="string">"serverStop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭服务器端套接字</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//断开连接</span></span><br><span class="line">                disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向输出流写数据,通知客户端服务器已停止.</span></span><br><span class="line">            out.writeUTF(<span class="string">"serverStop"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//停止接收信息的线程</span></span><br><span class="line">            canWaiter = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭流</span></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//关闭套接字</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据套接字获得输入输出流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由输入输出流 建立数据输入输出流</span></span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(is);</span><br><span class="line">            out = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从输入流读取客户端写入的数据,并显示</span></span><br><span class="line">            String msg = in.readUTF();</span><br><span class="line">            txtMsgArea.append(msg + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置组件的权限</span></span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line">            canWaiter = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//建立 和 启动线程</span></span><br><span class="line">            waiter = <span class="keyword">new</span> SWaiter();</span><br><span class="line">            waiter.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件(如按钮被点击)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == btnSend || e.getSource() == txtMsgSend) &#123;</span><br><span class="line">            sendMsg();</span><br><span class="line">            <span class="comment">//发送完消息后清空输入框,以便下一次输入</span></span><br><span class="line">            txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">            <span class="comment">//定位焦点到输入框,以便下一次输入</span></span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == btnStart) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(txtServerPort.getText().equals(<span class="string">""</span>)))&#123;</span><br><span class="line">                <span class="keyword">int</span> ServerPort = Integer.parseInt(txtServerPort.getText());</span><br><span class="line">                <span class="keyword">if</span>(!(ServerPort &gt; <span class="number">0</span>  &amp;&amp; ServerPort &lt; <span class="number">65535</span>)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"端口值必须在0~65535之间!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                canAccepter = <span class="keyword">true</span>;</span><br><span class="line">                canWaiter = <span class="keyword">true</span>;</span><br><span class="line">                startServer(ServerPort);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == btnStop) &#123;</span><br><span class="line">            stopServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收客户端请求的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Accepter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (canAccepter) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                    acceptConnect();</span><br><span class="line">                    <span class="comment">//在服务器端窗口显示客户端的IP地址和端口格式为  "/192.168.56.1:9606"</span></span><br><span class="line">                    <span class="comment">//txtMsgArea.append(socket.getRemoteSocketAddress().toString()+"\n");</span></span><br><span class="line">                    <span class="comment">//在服务器端窗口显示客户端的IP地址</span></span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户端IP地址: "</span>+socket.getInetAddress().getHostAddress()+<span class="string">"\n"</span>);</span><br><span class="line">                    <span class="comment">//服务器端窗口显示客户端端口</span></span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户端端口号: "</span>+ String.valueOf(socket.getPort())+<span class="string">"\n"</span>);</span><br><span class="line">                    txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭服务器套接字</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待消息的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SWaiter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (canWaiter) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    msg = in.readUTF();</span><br><span class="line">                    <span class="keyword">if</span> (msg.equals(<span class="string">"disconnect"</span>)) &#123;</span><br><span class="line">                        txtMsgArea.append(<span class="string">"客户离开!\n"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    txtMsgArea.append(<span class="string">"客户说: "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            txtMsgArea.append(<span class="string">"断开连接\n"</span>);</span><br><span class="line">            txtMsgArea.append(<span class="string">"==============================================\n"</span>);</span><br><span class="line">            disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行图: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.3.png" alt></p><p><strong>客户端与服务器通信:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.4.png" alt></p><h2 id="三、基于UDP的网络通信"><a href="#三、基于UDP的网络通信" class="headerlink" title="三、基于UDP的网络通信:"></a>三、基于UDP的网络通信:</h2><h3 id="3-1-实例"><a href="#3-1-实例" class="headerlink" title="3.1 实例:"></a>3.1 实例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostComputer</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HostComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文本域</span></span><br><span class="line">    JTextArea txtMsgArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">    <span class="comment">//输入框</span></span><br><span class="line">    JTextField txtMsgSend = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//对方地址</span></span><br><span class="line">    JTextField txtToAddress = <span class="keyword">new</span> JTextField(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//对方端口</span></span><br><span class="line">    JTextField txtToPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//本地端口</span></span><br><span class="line">    JTextField txtLocalPort = <span class="keyword">new</span> JTextField(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//按钮</span></span><br><span class="line">    JButton btnSend = <span class="keyword">new</span> JButton(<span class="string">"发送"</span>);</span><br><span class="line">    JButton btnStart = <span class="keyword">new</span> JButton(<span class="string">"开始"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">byte</span>[]buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    InetAddress toAddress;</span><br><span class="line">    <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">int</span> toPort;</span><br><span class="line">    <span class="comment">//本地端口</span></span><br><span class="line">    <span class="keyword">int</span> localPort;</span><br><span class="line">    <span class="comment">//数据报套接字</span></span><br><span class="line">    DatagramSocket socket;</span><br><span class="line">    <span class="comment">//控制线程的逻辑变量</span></span><br><span class="line">    <span class="keyword">boolean</span> canWaiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置组件权限</span></span><br><span class="line">        txtMsgArea.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Container container = <span class="keyword">this</span>.getContentPane();</span><br><span class="line">        JPanel jp_G = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        JPanel jp_f1 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JPanel jp_f2 = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(txtMsgArea);</span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"对方地址"</span>));</span><br><span class="line">        jp_f1.add(txtToAddress);</span><br><span class="line">        jp_f1.add(<span class="keyword">new</span> JLabel(<span class="string">"对方端口"</span>));</span><br><span class="line">        jp_f1.add(txtToPort);</span><br><span class="line"></span><br><span class="line">        jp_f2.add(<span class="keyword">new</span> JLabel(<span class="string">"本地端口"</span>));</span><br><span class="line">        jp_f2.add(txtLocalPort);</span><br><span class="line">        jp_f2.add(btnStart);</span><br><span class="line"></span><br><span class="line">        jp_G.add(jp_f1);</span><br><span class="line">        jp_G.add(jp_f2);</span><br><span class="line"></span><br><span class="line">        jp.add(txtMsgSend);</span><br><span class="line">        jp.add(btnSend);</span><br><span class="line"></span><br><span class="line">        txtMsgSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnSend.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStart.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        container.add(jp_G,<span class="string">"North"</span>);</span><br><span class="line">        container.add(jsp,<span class="string">"Center"</span>);</span><br><span class="line">        container.add(jp,<span class="string">"South"</span>);</span><br><span class="line">        setTitle(<span class="string">"基于数据报的UDP通信"</span>);</span><br><span class="line">        setSize(<span class="number">500</span>,<span class="number">300</span>);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   stop();</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e1)&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               dispose();</span><br><span class="line">               System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            toAddress = InetAddress.getByName(txtToAddress.getText());</span><br><span class="line">            toPort = Integer.parseInt(txtToPort.getText());</span><br><span class="line">            localPort = Integer.parseInt(txtLocalPort.getText());</span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(localPort);</span><br><span class="line">            canWaiter = <span class="keyword">true</span>;</span><br><span class="line">            (<span class="keyword">new</span> Waiter()).start();</span><br><span class="line">            <span class="comment">//设置组件权限</span></span><br><span class="line">            txtToAddress.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtToPort.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtLocalPort.setEditable(<span class="keyword">false</span>);</span><br><span class="line">            txtMsgSend.setEditable(<span class="keyword">true</span>);</span><br><span class="line">            btnSend.setEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            btnStart.setText(<span class="string">"停止"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"启动失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置按钮权限</span></span><br><span class="line">       txtMsgSend.setEditable(<span class="keyword">false</span>);</span><br><span class="line">       txtLocalPort.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       txtToPort.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       txtToAddress.setEditable(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//txtMsgArea.setEditable(false);</span></span><br><span class="line">       btnSend.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       canWaiter = <span class="keyword">false</span>;</span><br><span class="line">       toAddress = <span class="keyword">null</span>;</span><br><span class="line">       socket.close();</span><br><span class="line">       btnStart.setText(<span class="string">"开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!txtMsgSend.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = txtMsgSend.getText().getBytes();</span><br><span class="line">            DatagramPacket packet =  <span class="keyword">new</span> DatagramPacket(b,b.length,toAddress,toPort);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                txtMsgArea.append(<span class="string">"发送的数据: "</span>+txtMsgSend.getText()+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgArea.append(<span class="string">"发送到"</span>+toAddress+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgArea.append(<span class="string">"数据长度为: "</span>+packet.getLength()+<span class="string">"\n"</span>);</span><br><span class="line">                txtMsgSend.setText(<span class="string">""</span>);</span><br><span class="line">                txtMsgSend.requestFocus();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"不能发送空消息!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(canWaiter)&#123;</span><br><span class="line">           DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               socket.receive(packet);</span><br><span class="line">               String received = <span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">               txtMsgArea.append(<span class="string">"收到的数据: "</span>+received+<span class="string">"\n"</span>);</span><br><span class="line">               txtMsgArea.append(<span class="string">"数据来自于: "</span>+packet.getAddress()+<span class="string">"\n"</span>);</span><br><span class="line">               txtMsgArea.append(<span class="string">"数据长度为: "</span>+packet.getLength()+<span class="string">"\n"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.getSource() == txtMsgSend || e.getSource() == btnSend)&#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getActionCommand().equals(<span class="string">"开始"</span>))&#123;</span><br><span class="line">            start();</span><br><span class="line">            txtMsgSend.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e.getActionCommand().equals(<span class="string">"停止"</span>))&#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行两次,出现两个窗口,在这两个窗口进行通信**</strong></p><p><strong>运行图: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-6.5.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、网络编程基础&quot;&gt;&lt;a href=&quot;#一、网络编程基础&quot; class=&quot;headerlink&quot; title=&quot;一、网络编程基础&quot;&gt;&lt;/a&gt;一、网络编程基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-网络编程有两个主要的问题&quot;&gt;&lt;a href=&quot;#1-1-网络编程有两个主要的问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 网络编程有两个主要的问题:&quot;&gt;&lt;/a&gt;1.1 网络编程有两个主要的问题:&lt;/h3&gt;&lt;p&gt;①: 如何准确定位网络上的一台或多台主机&lt;br&gt;②: 定位后如何可靠高效的传输数据&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="Java网络编程" scheme="https://zzwwqq.xyz/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android之UI</title>
    <link href="https://zzwwqq.xyz/Android%E4%B9%8BUI.html"/>
    <id>https://zzwwqq.xyz/Android之UI.html</id>
    <published>2019-04-09T04:28:34.000Z</published>
    <updated>2019-04-13T03:14:53.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、如何编写程序界面"><a href="#一、如何编写程序界面" class="headerlink" title="一、如何编写程序界面:"></a>一、如何编写程序界面:</h2><p>Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局.</p><h2 id="二、常见控件的使用方法"><a href="#二、常见控件的使用方法" class="headerlink" title="二、常见控件的使用方法"></a>二、常见控件的使用方法</h2><h3 id="2-1-TextView"><a href="#2-1-TextView" class="headerlink" title="2.1 TextView"></a>2.1 TextView</h3><p>主要用于在界面上显示一段文本信息,设置颜色,文本居中</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line"><span class="comment">//给当前控件定义了一个唯一标识符</span></span><br><span class="line">android:id=<span class="string">"@+id/text_view"</span></span><br><span class="line">         <span class="comment">//所有的控件都具有这两个属性，可选值有三种 match_parent、fill_parent 和 wrap_content</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="comment">//文本居中对齐    </span></span><br><span class="line">         android:gravity=<span class="string">"center"</span></span><br><span class="line">        <span class="comment">//设置字体大小     </span></span><br><span class="line">android:textSize=<span class="string">"24sp"</span></span><br><span class="line">        <span class="comment">//设置字体颜色</span></span><br><span class="line">android:textColor=<span class="string">"#00ff00"</span>   </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">android:text=<span class="string">"This is TextView"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">//match_parent 由父布局来决定当前控件的大小</span></span><br><span class="line"><span class="comment">//wrap_content 由控件内容决定当前控件的大小</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Button"><a href="#2-2-Button" class="headerlink" title="2.2 Button:"></a>2.2 Button:</h3><p>activity_main.xml 中添加代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">....</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>在 MainActivity 中为 Button 的点击事件注册一个监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//  在此处添加逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-EditText"><a href="#2-3-EditText" class="headerlink" title="2.3 EditText"></a>2.3 EditText</h3><p>它允许用户在控件里输入和编辑内容</p><p>修改 布局文件activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">...&gt;</span><br><span class="line">....</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/edit_text"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">       <span class="comment">//输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失     </span></span><br><span class="line">       android:hint=<span class="string">"Type something here"</span>   </span><br><span class="line">       <span class="comment">//通过 android:maxLines 指定了 EditText 的最大行数为两行，这样当输入的内容超过两行时，文本就会向</span></span><br><span class="line">       <span class="comment">//上滚动，而 EditText则不会再继续拉伸</span></span><br><span class="line">       android:maxLines=<span class="string">"2"</span>    </span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过点击按钮来获取EditText 中输入的内容。修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                String inputText = editText.getText().toString();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, inputText,</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ImageView"><a href="#2-4-ImageView" class="headerlink" title="2.4 ImageView"></a>2.4 ImageView</h3><p>修改 activity_main.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">....</span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=<span class="string">"@+id/image_view"</span></span><br><span class="line">         <span class="comment">//将 ImageView 的宽和高都设定为wrap_content，这样保证不管图片的尺寸是多少都可以完整地展示出来</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">          <span class="comment">//使用 android:src 属性给 ImageView指定了一张图片</span></span><br><span class="line">android:src=<span class="string">"@drawable/ic_launcher"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过代码动态地更改 ImageView 中的图片。这里我准备了另外一张图片，jelly_bean.png，将它复制到 res/drawable-hdpi 目录下，然后修改 MainActivity 的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> ImageView imageView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        imageView = (ImageView) findViewById(R.id.image_view);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="comment">//调用 ImageView 的 setImageResource()方法将显示的图片改成 jelly_bean</span></span><br><span class="line">                imageView.setImageResource(R.drawable.jelly_bean);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-ProgressBar"><a href="#2-5-ProgressBar" class="headerlink" title="2.5 ProgressBar"></a>2.5 ProgressBar</h3><p>用于在界面上显示一个进度条</p><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">... &gt;</span><br><span class="line">...</span><br><span class="line">&lt;ProgressBar</span><br><span class="line">android:id=<span class="string">"@+id/progress_bar"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="comment">//指定成水平进度条  </span></span><br><span class="line">         style=<span class="string">"?android:attr/progressBarStyleHorizontal"</span></span><br><span class="line">         <span class="comment">//给进度条设置一个最大值,然后在MainActivity类中动态地更改进度条的进度</span></span><br><span class="line">android:max=<span class="string">"100"</span></span><br><span class="line">     /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>Android控件的可见属性。可以通过android:visibility进行指定，可选值有三种，visible、invisible 和 gone。<br>visible 表示控件是可见的，这个值是默认值<br>invisible 表示控件不可见，但是它仍然占据着原来的位置和大小<br>gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。<br>还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 三种值。</p><p>点击一下按钮让进度条消失，再点击一下按钮让进度条出现的这种效果。修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">private</span> ProgressBar progressBar;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">        progressBar = (ProgressBar) findViewById(R.id.progress_bar);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="keyword">if</span> (progressBar.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    progressBar.setVisibility(View.VISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    progressBar.setVisibility(View.GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 activity_main.xml 中添加 android:max 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="keyword">int</span> progress = progressBar.getProgress();</span><br><span class="line">                progress = progress + <span class="number">10</span>;</span><br><span class="line">                progressBar.setProgress(progress);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-AlertDialog"><a href="#2-6-AlertDialog" class="headerlink" title="2.6 AlertDialog"></a>2.6 AlertDialog</h3><p>在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上,用于提示一些非常重要的内容或者警告信息</p><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                <span class="comment">//通过 AlertDialog.Builder 创建出一个 AlertDialog 的实例</span></span><br><span class="line">                AlertDialog.Builder dialog = <span class="keyword">new</span> AlertDialog.Builder</span><br><span class="line">                    (MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                dialog.setTitle(<span class="string">"This is Dialog"</span>);</span><br><span class="line">                dialog.setMessage(<span class="string">"Something important."</span>);</span><br><span class="line">                dialog.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//调用 setPositiveButton()方法为对话框设置确定按钮的点击事件</span></span><br><span class="line">                dialog.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.</span><br><span class="line">                       OnClickListener() &#123;</span><br><span class="line">                              <span class="meta">@Override</span></span><br><span class="line">                              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                              &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                <span class="comment">//调用 setNegativeButton()方法设置取消按钮的点击事件</span></span><br><span class="line">                dialog.setNegativeButton(<span class="string">"Cancel"</span>, <span class="keyword">new</span> DialogInterface.</span><br><span class="line">                       OnClickListener() &#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                               &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                <span class="comment">//调用 show()方法将对话框显示出来</span></span><br><span class="line">                dialog.show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-ProgressDialog"><a href="#2-7-ProgressDialog" class="headerlink" title="2.7 ProgressDialog"></a>2.7 ProgressDialog</h3><p>在对话框中显示一个进度条,表示当前操作比较耗时，让用户耐心地等待</p><p>修改 MainActivity 中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button:</span><br><span class="line">                ProgressDialog progressDialog = <span class="keyword">new</span> ProgressDialog(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                progressDialog.setTitle(<span class="string">"This is ProgressDialog"</span>);</span><br><span class="line">                progressDialog.setMessage(<span class="string">"Loading..."</span>);</span><br><span class="line"><span class="comment">/*注意如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的   dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                progressDialog.setCancelable(<span class="keyword">true</span>);</span><br><span class="line">                progressDialog.show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、详解四种基本布局"><a href="#三、详解四种基本布局" class="headerlink" title="三、详解四种基本布局"></a>三、详解四种基本布局</h2><p>布局是一种可用于放置很多控件的容器,布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套</p><p>新建一个UILayoutTest项目，并让 ADT 自动帮我们创建好活动，活动名和布局名都使用默认值</p><h3 id="3-1-LinearLayout"><a href="#3-1-LinearLayout" class="headerlink" title="3.1 LinearLayout:"></a>3.1 LinearLayout:</h3><p>称作线性布局，是一种非常常用的布局,它所包含的控件在线性方向上依次排列</p><h4 id="3-1-1-通过-android-orientation-属性指定排列方向-vertical为垂直对齐-horizontal为水平对齐"><a href="#3-1-1-通过-android-orientation-属性指定排列方向-vertical为垂直对齐-horizontal为水平对齐" class="headerlink" title="3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐"></a>3.1.1 通过 android:orientation 属性指定排列方向,vertical为垂直对齐,horizontal为水平对齐</h4><p>修改activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">         <span class="comment">//指定了排列方向是 vertical(垂直方向), orientation(方向；定向；适应；情况介绍)</span></span><br><span class="line">android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">            &lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span> /&gt;              </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><strong>垂直对齐:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.1.png" alt></p><p>android:gravity 是用于指定文字在控件中的对齐方式</p><p>android:layout_gravity 是用于指定控件在布局中的对齐方式</p><p><strong>需要注意，当LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水<br>平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式,同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效.</strong></p><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">         ....</span><br><span class="line">         <span class="comment">/*LinearLayout 的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向(即只能指定上,中,下,而不能指定左右)，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_vertical*/</span></span><br><span class="line">android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Button</span><br><span class="line">....</span><br><span class="line">android:layout_gravity=<span class="string">"top"</span></span><br><span class="line">android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">            &lt;Button</span><br><span class="line">....</span><br><span class="line">android:layout_gravity=<span class="string">"center_vertical"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span> /&gt;              </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.3.png" alt></p><h4 id="3-1-2-android-layout-weight。这个属性允许我们使用比例的方式来指定控件的大小"><a href="#3-1-2-android-layout-weight。这个属性允许我们使用比例的方式来指定控件的大小" class="headerlink" title="3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小"></a>3.1.2 android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小</h4><p>编写一个消息发送界面，需要一个文本编辑框和一个发送按钮</p><p>修改activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    ....</span><br><span class="line">   android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/input_message"</span></span><br><span class="line">        <span class="comment">/*这里竟然将 EditText 和 Button 的宽度都指定成了 0，这样文本编辑框和按钮还能显示出来吗？不用担</span></span><br><span class="line"><span class="comment">         心，由于我们使用了 android:layout_weight 属性，此时控件的宽度,就不应该再android:layout_width </span></span><br><span class="line"><span class="comment">         来决定，这里指定成 0 是一种比较规范的写法 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">android:hint=<span class="string">"Type something"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/send"</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">         <span class="comment">/* EditText 和 Button 里都将 android:layout_weight 属性的值指定为 1，这表示EditText 和 </span></span><br><span class="line"><span class="comment">         Button 将在水平方向平分宽度*/</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">android:text=<span class="string">"Send"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">/*为什么将 android:layout_weight 属性的值同时指定为 1 就会平分屏幕宽度呢？</span></span><br><span class="line"><span class="comment">系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，</span></span><br><span class="line"><span class="comment">然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。</span></span><br><span class="line"><span class="comment">因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的</span></span><br><span class="line"><span class="comment">layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。*/</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.4.png" alt></p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回</span></span><br><span class="line"><span class="comment">wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏</span></span><br><span class="line"><span class="comment">幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且</span></span><br><span class="line"><span class="comment">看起来也更加舒服*/</span></span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....</span><br><span class="line">android:orientation=<span class="string">"horizontal"</span> &gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=<span class="string">"@+id/input_message"</span></span><br><span class="line">android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_weight=<span class="string">"1"</span></span><br><span class="line">...</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/send"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">....</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.5.png" alt></p><h3 id="3-2-RelativeLayout"><a href="#3-2-RelativeLayout" class="headerlink" title="3.2 RelativeLayout"></a>3.2 RelativeLayout</h3><p>通过相对定位的方式让控件出现在布局的任何位置</p><h4 id="3-2-1-每个控件相对于父布局进行定位"><a href="#3-2-1-每个控件相对于父布局进行定位" class="headerlink" title="3.2.1 每个控件相对于父布局进行定位"></a>3.2.1 每个控件相对于父布局进行定位</h4><p>修改 activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">.... &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">         <span class="comment">//Button 1和父布局的左上角对齐</span></span><br><span class="line">android:layout_alignParentLeft=<span class="string">"true"</span></span><br><span class="line">android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">.../&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_alignParentRight=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">        ... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_centerInParent=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button4"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentLeft=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button5"</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//Button 5 和父布局的右下角对齐</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentRight=<span class="string">"true"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.6.png" alt></p><h4 id="3-2-2-控件相对于控件进行定位"><a href="#3-2-2-控件相对于控件进行定位" class="headerlink" title="3.2.2 控件相对于控件进行定位"></a>3.2.2 控件相对于控件进行定位</h4><p>修改 activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button3"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">"true"</span></span><br><span class="line">        android:text=<span class="string">"Button 1"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button1"</span></span><br><span class="line">       ....</span><br><span class="line">        <span class="comment">//android:layout_above属性让一个控件位于另一个控件的上方</span></span><br><span class="line">        <span class="comment">//@id/button3，表示让该控件位于 Button 3 的上方</span></span><br><span class="line">        android:layout_above=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_above=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button4"</span></span><br><span class="line">       ....</span><br><span class="line">        android:layout_below=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button5"</span></span><br><span class="line">        ....</span><br><span class="line">        android:layout_below=<span class="string">"@id/button3"</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">"@id/button3"</span></span><br><span class="line">        .... /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br><span class="line"><span class="comment">/*另外一组相对于控件进行定位的属性</span></span><br><span class="line"><span class="comment">  如android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.7.png" alt></p><h3 id="3-3-FrameLayout"><a href="#3-3-FrameLayout" class="headerlink" title="3.3 FrameLayout"></a>3.3 FrameLayout</h3><p>没有任何的定位方式，所有的控件都会摆放在布局的左上角,它的应用场景并不多</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">....&gt;</span><br><span class="line"><span class="comment">//按钮</span></span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        ....</span><br><span class="line">        /&gt;</span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">        android:id=<span class="string">"@+id/image_view"</span></span><br><span class="line">        ....</span><br><span class="line">        android:src=<span class="string">"@drawable/ic_launcher"</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.8.png" alt></p><h3 id="3-4-TableLayout"><a href="#3-4-TableLayout" class="headerlink" title="3.4 TableLayout"></a>3.4 TableLayout</h3><p>使用表格的方式来排列控件</p><p>设计一个登录界面，用户输入账号密码后登录</p><p>activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    <span class="comment">// TableLayout 中每加入一个 TableRow 就表示在表格中添加了一行</span></span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line"><span class="comment">//在 TableRow中每加入一个控件，就表示在该行中加入了一列</span></span><br><span class="line"><span class="comment">//TableRow 中的控件是不能指定宽度的</span></span><br><span class="line">&lt;TextView</span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Account:"</span> /&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/account"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:hint=<span class="string">"Input your account"</span> /&gt;</span><br><span class="line">&lt;/TableRow&gt;</span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:text=<span class="string">"Password:"</span> /&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/password"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:inputType=<span class="string">"textPassword"</span> /&gt;</span><br><span class="line">&lt;/TableRow&gt;</span><br><span class="line">&lt;TableRow&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">            android:id=<span class="string">"@+id/login"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="comment">//对单元格进行合并</span></span><br><span class="line">            android:layout_span=<span class="string">"2"</span></span><br><span class="line">            android:text=<span class="string">"Login"</span> /&gt;</span><br><span class="line">    &lt;/TableRow&gt;</span><br><span class="line">&lt;/TableLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.9.png" alt></p><p>android:stretchColumns 属性就可以很好地解决这个问题，它允许将 TableLayout 中的某一列<br>进行拉伸，以达到自动适应屏幕宽度的作用</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;TableLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="comment">// android:stretchColumns 的值指定为 1，表示如果表格不能完全占满屏幕宽度，就将第二列进行拉伸</span></span><br><span class="line">    <span class="comment">//指定成 1 就是拉伸第二列，指定成 0 就是拉伸第一列</span></span><br><span class="line">android:stretchColumns=<span class="string">"1"</span></span><br><span class="line">&gt;</span><br><span class="line">....</span><br><span class="line">&lt;/TableLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="四、创建自定义控件"><a href="#四、创建自定义控件" class="headerlink" title="四、创建自定义控件"></a>四、创建自定义控件</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.10.png" alt></p><p>所有控件都是直接或间接继承自 View,<br>所有布局都是直接或间接继承自 ViewGroup </p><p>创建一个 UICustomViews 项目:</p><h3 id="4-1-引入布局"><a href="#4-1-引入布局" class="headerlink" title="4.1 引入布局"></a>4.1 引入布局</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android:background 用于为布局或控件指定一个背景</span></span><br></pre></td></tr></table></figure><p>修改activity_main.xml 中的代码:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//引入标题栏布局    </span></span><br><span class="line">&lt;include layout=<span class="string">"@layout/title"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>别忘了在 MainActivity 中将系统自带的标题栏隐藏掉</p><p>修改MainActivity类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-创建自定义控件"><a href="#4-2-创建自定义控件" class="headerlink" title="4.2 创建自定义控件"></a>4.2 创建自定义控件</h3><p>引入布局确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码,这种情况最好是使用自定义控件的方式来解决</p><p>新建 TitleLayout类 继承自 LinearLayout，让它成为我们自定义的标题栏控件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在布局中引入 TitleLayout</span></span><br><span class="line"><span class="comment">控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借</span></span><br><span class="line"><span class="comment">助 LayoutInflater 来实现了,LayoutInflater 的 from()方法可以构建出一个 LayoutInflater</span></span><br><span class="line"><span class="comment">对象，然后调用 inflate()方法就可以动态加载一个布局文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//第一个参数是要加载的布局文件的 id,第二个参数是给加载好的布局再添加一个父布局,这里我们想要指定为 TitleLayout，于是直接传入 this</span></span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在自定义控件已经创建好了，然后在布局文件中添加这个自定义控件</p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候我们需要指明控件的完整类名，包名在这里是不可以省略的</span></span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;com.example.uicustomviews.TitleLayout</span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>&gt;</span><br><span class="line">&lt;/com.example.uicustomviews.TitleLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>为标题栏中的按钮注册点击事件</p><p>修改 TitleLayout中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// findViewById()方法得到按钮的实例</span></span><br><span class="line">        Button titleBack = (Button) findViewById(R.id.title_back);</span><br><span class="line">        Button titleEdit = (Button) findViewById(R.id.title_edit);</span><br><span class="line">        <span class="comment">//分别调用 setOnClickListener()方法给两个按钮注册了点击事件</span></span><br><span class="line">        titleBack.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                ((Activity) getContext()).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        titleEdit.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getContext(), <span class="string">"You clicked Edit button"</span>,</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、最常用最难用控件ListView"><a href="#五、最常用最难用控件ListView" class="headerlink" title="五、最常用最难用控件ListView"></a>五、最常用最难用控件ListView</h2><p>ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕</p><h3 id="5-1-ListView-的简单用法"><a href="#5-1-ListView-的简单用法" class="headerlink" title="5.1 ListView 的简单用法"></a>5.1 ListView 的简单用法</h3><p>首先新建一个 ListViewTest 项目,都默认</p><p>修改activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    &lt;ListView</span><br><span class="line">android:id=<span class="string">"@+id/list_view"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">    &lt;/ListView&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String[] data = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Watermelon"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Pineapple"</span>, <span class="string">"Strawberry"</span>,<span class="string">"Cherry"</span>, <span class="string">"Mango"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成</span></span><br><span class="line">        <span class="comment">//android.R.layout.simple_list_item_1 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本</span></span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(MainActivity.<span class="keyword">this</span>,                           android.R.layout.simple_list_item_1,data);</span><br><span class="line">ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">       <span class="comment">// setAdapter()方法，将构建好的适配器对象传递进去,这样 ListView和数据之间的关联就建立完成了</span></span><br><span class="line">listView.setAdapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.15.png" alt></p><h3 id="5-2-定制-ListView-的界面"><a href="#5-2-定制-ListView-的界面" class="headerlink" title="5.2 定制 ListView 的界面"></a>5.2 定制 ListView 的界面</h3><p>新建类 Fruit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> imageId;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name, <span class="keyword">int</span> imageId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.imageId = imageId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImageId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 目录下新建fruit_item.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">        <span class="comment">// ImageView 用于显示水果的图片</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=<span class="string">"@+id/fruit_image"</span></span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span> /&gt;</span><br><span class="line">            <span class="comment">//TextView用于显示水果的名称</span></span><br><span class="line">&lt;TextView</span><br><span class="line">        android:id=<span class="string">"@+id/fruit_name"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">"10dip"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建类 FruitAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context, <span class="keyword">int</span> textViewResourceId, List&lt;Fruit&gt; objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, textViewResourceId, objects);</span><br><span class="line">resourceId = textViewResourceId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// getItem()方法得到当前项的 Fruit 实例</span></span><br><span class="line">Fruit fruit = getItem(position); <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line"><span class="comment">//LayoutInflater 来为这个子项加载我们传入的布局，</span></span><br><span class="line">View view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// findViewById()方法分别获取到 ImageView 和 TextView 的实例</span></span><br><span class="line">ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line"><span class="comment">// setImageResource()和 setText()方法来设置显示的图片和文字</span></span><br><span class="line">fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">fruitName.setText(fruit.getName());</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Watermelon"</span>,</span><br><span class="line">                             <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Pineapple"</span>, <span class="string">"Strawberry"</span>, <span class="string">"Cherry"</span>, <span class="string">"Mango"</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initFruits(); <span class="comment">//  初始化水果数据</span></span><br><span class="line">        FruitAdapter adapter = <span class="keyword">new</span> FruitAdapter(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                                                R.layout.fruit_item, fruitList);</span><br><span class="line">        ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFruits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Fruit(<span class="string">"Apple"</span>, R.drawable.apple_pic);</span><br><span class="line">        fruitList.add(apple);</span><br><span class="line">        Fruit banana = <span class="keyword">new</span> Fruit(<span class="string">"Banana"</span>, R.drawable.banana_pic);</span><br><span class="line">        fruitList.add(banana);</span><br><span class="line">        Fruit orange = <span class="keyword">new</span> Fruit(<span class="string">"Orange"</span>, R.drawable.orange_pic);</span><br><span class="line">        fruitList.add(orange);</span><br><span class="line">        Fruit watermelon = <span class="keyword">new</span> Fruit(<span class="string">"Watermelon"</span>, R.drawable.watermelon_pic);</span><br><span class="line">        fruitList.add(watermelon);</span><br><span class="line">        Fruit pear = <span class="keyword">new</span> Fruit(<span class="string">"Pear"</span>, R.drawable.pear_pic);</span><br><span class="line">        fruitList.add(pear);</span><br><span class="line">        Fruit grape = <span class="keyword">new</span> Fruit(<span class="string">"Grape"</span>, R.drawable.grape_pic);</span><br><span class="line">        fruitList.add(grape);</span><br><span class="line">        Fruit pineapple = <span class="keyword">new</span> Fruit(<span class="string">"Pineapple"</span>, R.drawable.pineapple_pic);</span><br><span class="line">        fruitList.add(pineapple);</span><br><span class="line">        Fruit strawberry = <span class="keyword">new</span> Fruit(<span class="string">"Strawberry"</span>, R.drawable.strawberry_pic);</span><br><span class="line">        fruitList.add(strawberry);</span><br><span class="line">        Fruit cherry = <span class="keyword">new</span> Fruit(<span class="string">"Cherry"</span>, R.drawable.cherry_pic);</span><br><span class="line">        fruitList.add(cherry);</span><br><span class="line">        Fruit mango = <span class="keyword">new</span> Fruit(<span class="string">"Mango"</span>, R.drawable.mango_pic);</span><br><span class="line">        fruitList.add(mango);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-提升-ListView-的运行效率"><a href="#5-3-提升-ListView-的运行效率" class="headerlink" title="5.3 提升 ListView 的运行效率"></a>5.3 提升 ListView 的运行效率</h3><p>修改 FruitAdapter中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getView()方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view;</span><br><span class="line">       <span class="comment">//如果 convertView 为空，则使用LayoutInflater 去加载布局，如果不为空则直接对 convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候也可以表现出更好的性能。</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView;</span><br><span class="line">        &#125;</span><br><span class="line">        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">        fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        fruitName.setText(fruit.getName());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然现在已经不会再重复去加载布局，但是每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个 ViewHolder来对这部分性能进行优化</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以继续优化</p><p>修改 FruitAdapter 中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = getItem(position);</span><br><span class="line">        View view;</span><br><span class="line">        ViewHolder viewHolder;</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">            viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">            viewHolder.fruitImage = (ImageView) view.findViewById</span><br><span class="line">                (R.id.fruit_image);</span><br><span class="line">            viewHolder.fruitName = (TextView) view.findViewById</span><br><span class="line">                (R.id.fruit_name);</span><br><span class="line">            view.setTag(viewHolder); <span class="comment">//  将ViewHolder 存储在View 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView;</span><br><span class="line">            viewHolder = (ViewHolder) view.getTag(); <span class="comment">//  重新获取ViewHolder</span></span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">        viewHolder.fruitName.setText(fruit.getName());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ViewHolder，用于对控件的实例进行缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        ImageView fruitImage;</span><br><span class="line">        TextView fruitName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 convertView为空的时候:</span></span><br><span class="line"><span class="comment">创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View的 setTag()方法，将 ViewHolder 对象存储在 View 中。</span></span><br><span class="line"><span class="comment">当 convertView 不为空的时候:</span></span><br><span class="line"><span class="comment">则调用View的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="5-4-ListView-的点击事件"><a href="#5-4-ListView-的点击事件" class="headerlink" title="5.4 ListView 的点击事件"></a>5.4 ListView 的点击事件</h3><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"> <span class="comment">//通过 position 参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来</span></span><br><span class="line">        listView.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">                Fruit fruit = fruitList.get(position);</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, fruit.getName(),</span><br><span class="line">                               Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、单位和尺寸"><a href="#六、单位和尺寸" class="headerlink" title="六、单位和尺寸"></a>六、单位和尺寸</h2><p>布局文件中指定宽高的固定大小有以下常用单位可供选择：px、pt、dp 和 sp</p><p>px 是像素的意思，即屏幕中可以显示的最小元素单元</p><p>pt 是磅数的意思，1 磅等于 1/72 英寸，一般 pt 都会作为字体的单位来使用</p><p>新建好一个 UISizeTest 项目</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button"</span></span><br><span class="line"><span class="comment">// android:layout_width 属性将按钮的宽指定为 200px</span></span><br><span class="line">android:layout_width=<span class="string">"200px"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.16.png" alt></p><p>接着创建一个 240*320 像素的低分辨率模拟器，在这个模拟器上重新运行程序</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.17.png" alt></p><p>dp 是密度无关像素的意思，也被称作 dip，和 px 相比，它在不同密度的屏幕中的显示比例将保持一致。</p><p>sp 是可伸缩像素的意思，它采用了和 dp 同样的设计理念，解决了文字大小的适配问题</p><p>什么叫密度？Android 中的密度就是屏幕每英寸所包含的像素数，通常以 dpi为单位</p><p>比如一个手机屏幕的宽是 2 英寸长是 3 英寸，如果它的分辨率是 320<em>480 像素，那这个屏幕的密度就是 160dpi，如果它的分辨率是 640</em>960，那这个屏幕的密度就是 320dpi</p><p><strong>如何得知当前屏幕的密度值?</strong></p><p>修改 MainActivity 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">float</span> xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line">        <span class="keyword">float</span> ydpi = getResources().getDisplayMetrics().ydpi;</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"xdpi is "</span> + xdpi);</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"ydpi is "</span> + ydpi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Android 的规定，在 160dpi 的屏幕上，1dp 等于 1px，而在 320dpi 的屏幕上，1dp就等于 2px。因此，使用 dp 来指定控件的宽和高，就可以保证控件在不同密度的屏幕中的显示比例保持一致</p><p>修改 activity_main.xml 中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        android:layout_width=<span class="string">"200dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:text=<span class="string">"Button"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="七、编写界面的最佳实践"><a href="#七、编写界面的最佳实践" class="headerlink" title="七、编写界面的最佳实践:"></a>七、编写界面的最佳实践:</h2><p>创建一个 UIBestPractice 项目</p><h3 id="7-1-制作-Nine-Patch-图片"><a href="#7-1-制作-Nine-Patch-图片" class="headerlink" title="7.1 制作 Nine-Patch 图片"></a>7.1 制作 Nine-Patch 图片</h3><p><strong>Nine-Patch 图片,它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸而哪些区域不可以。</strong></p><p>准备一张普通的气泡样式的png图片 message_left.png (google上直接搜索message_left.png就可找到)</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.19.png" alt></p><p>将这张图片设置为一个 LinearLayout 的背景图片,修改 activity_main.xml </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:background=<span class="string">"@drawable/message_left"</span> &gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.20.png" alt></p><p>可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差.</p><p>这时我们就可以使用 Nine-Patch 图片来进行改善</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.21.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.22.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.23.png" alt></p><p>在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。绘制完成后效果如图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.24.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.25.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.26.png" alt></p><p><strong>注意：制作完成后，应该将原始文件删除，否则AS会分不清楚而报错。</strong></p><p>重新运行程序</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.27.png" alt></p><p>这样当图片需要拉伸的时候，就可以只拉伸指定的区域，程序在外观上也是有了很大的改进</p><h3 id="7-2-编写精美的聊天界面"><a href="#7-2-编写精美的聊天界面" class="headerlink" title="7.2 编写精美的聊天界面"></a>7.2 编写精美的聊天界面</h3><p>再制作一张message_right.9.png作为发出消息的背景图</p><p>修改 activity_main.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:background=<span class="string">"#d8e0e8"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line"><span class="comment">// ListView 用于显示聊天的消息内容</span></span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=<span class="string">"@+id/msg_list_view"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_weight=<span class="string">"1"</span></span><br><span class="line"><span class="comment">// android:divider属性，它可以指定 ListView分隔线的颜色，这里#0000 表示将分隔线设为透明色</span></span><br><span class="line">        android:divider=<span class="string">"#0000"</span> &gt;</span><br><span class="line">    &lt;/ListView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span> &gt;</span><br><span class="line"><span class="comment">//EditText用于输入消息</span></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=<span class="string">"@+id/input_text"</span></span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_weight=<span class="string">"1"</span></span><br><span class="line">            android:hint=<span class="string">"Type somthing here"</span></span><br><span class="line">            android:maxLines=<span class="string">"2"</span> /&gt;</span><br><span class="line"><span class="comment">// Button 用于发送消息</span></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=<span class="string">"@+id/send"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:text=<span class="string">"Send"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>定义消息的实体类，新建 Msg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TYPE_RECEIVED 表示这是一条收到的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_RECEIVED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//TYPE_SENT 表示这是一条发出的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SENT = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//content 表示消息的内容</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line">    <span class="comment">//type 表示消息的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Msg</span><span class="params">(String content, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.content = content;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 ListView子项的布局，新建 msg_item.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:padding=<span class="string">"10dp"</span> &gt;</span><br><span class="line"><span class="comment">//让收到的消息居左对齐</span></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">"@+id/left_layout"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"left"</span></span><br><span class="line">        android:background=<span class="string">"@drawable/message_left"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">"@+id/left_msg"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">            android:layout_margin=<span class="string">"10dp"</span></span><br><span class="line">            android:textColor=<span class="string">"#fff"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"><span class="comment">//发出的消息居右对齐</span></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">"@+id/right_layout"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"right"</span></span><br><span class="line">        android:background=<span class="string">"@drawable/message_right"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">"@+id/right_msg"</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">            android:layout_margin=<span class="string">"10dp"</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>创建 ListView 的适配器类，让它继承自 ArrayAdapter，并将泛型指定为 Msg类。新建类 MsgAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Msg</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MsgAdapter</span><span class="params">(Context context, <span class="keyword">int</span> textViewResourceId, List&lt;Msg&gt; objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, textViewResourceId, objects);</span><br><span class="line">resourceId = textViewResourceId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">Msg msg = getItem(position);</span><br><span class="line">View view;</span><br><span class="line">ViewHolder viewHolder;</span><br><span class="line"><span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">view = LayoutInflater.from(getContext()).inflate(resourceId, <span class="keyword">null</span>);</span><br><span class="line">viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">viewHolder.leftLayout = (LinearLayout) view.findViewById(R.id.left_layout);</span><br><span class="line">viewHolder.rightLayout = (LinearLayout) view.findViewById(R.id.right_layout);</span><br><span class="line">viewHolder.leftMsg = (TextView) view.findViewById(R.id.left_msg);</span><br><span class="line">viewHolder.rightMsg = (TextView) view.findViewById(R.id.right_msg);</span><br><span class="line">view.setTag(viewHolder);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">view = convertView;</span><br><span class="line">viewHolder = (ViewHolder) view.getTag();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.getType() == Msg.TYPE_RECEIVED) &#123;</span><br><span class="line"><span class="comment">// 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏</span></span><br><span class="line">viewHolder.leftLayout.setVisibility(View.VISIBLE);</span><br><span class="line">viewHolder.rightLayout.setVisibility(View.GONE);</span><br><span class="line">viewHolder.leftMsg.setText(msg.getContent());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.getType() == Msg.TYPE_SENT) &#123;</span><br><span class="line"><span class="comment">// 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏</span></span><br><span class="line">viewHolder.rightLayout.setVisibility(View.VISIBLE);</span><br><span class="line">viewHolder.leftLayout.setVisibility(View.GONE);</span><br><span class="line">viewHolder.rightMsg.setText(msg.getContent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">LinearLayout leftLayout;</span><br><span class="line">LinearLayout rightLayout;</span><br><span class="line">TextView leftMsg;</span><br><span class="line">TextView rightMsg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码，来为 ListView初始化一些数据，并给发送按钮加入事件响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListView msgListView;</span><br><span class="line"><span class="keyword">private</span> EditText inputText;</span><br><span class="line"><span class="keyword">private</span> Button send;</span><br><span class="line"><span class="keyword">private</span> MsgAdapter adapter;</span><br><span class="line"><span class="keyword">private</span> List&lt;Msg&gt; msgList = <span class="keyword">new</span> ArrayList&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">initMsgs(); <span class="comment">// 初始化消息数据</span></span><br><span class="line">adapter = <span class="keyword">new</span> MsgAdapter(MainActivity.<span class="keyword">this</span>, R.layout.msg_item, msgList);</span><br><span class="line">inputText = (EditText) findViewById(R.id.input_text);</span><br><span class="line">send = (Button) findViewById(R.id.send);</span><br><span class="line">msgListView = (ListView) findViewById(R.id.msg_list_view);</span><br><span class="line">msgListView.setAdapter(adapter);</span><br><span class="line">send.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">//获取 EditText 中的内容</span></span><br><span class="line">String content = inputText.getText().toString();</span><br><span class="line">                <span class="comment">//如果内容不为空则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="string">""</span>.equals(content)) &#123;</span><br><span class="line">Msg msg = <span class="keyword">new</span> Msg(content, Msg.TYPE_SENT);</span><br><span class="line">msgList.add(msg);</span><br><span class="line">                    <span class="comment">//调用了适配器的 notifyDataSetChanged()方法，用于通知列表的数据发生了变化</span></span><br><span class="line">adapter.notifyDataSetChanged(); <span class="comment">// 当有新消息时，刷新ListView中的显示</span></span><br><span class="line">                     <span class="comment">// 将ListView定位到最后一行,以保证一定可以看得到最后发出的一条消息 </span></span><br><span class="line">msgListView.setSelection(msgList.size()); </span><br><span class="line">inputText.setText(<span class="string">""</span>); <span class="comment">// 清空输入框中的内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMsgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化几条数据用于在 ListView 中显示</span></span><br><span class="line">Msg msg1 = <span class="keyword">new</span> Msg(<span class="string">"Hello guy."</span>, Msg.TYPE_RECEIVED);</span><br><span class="line">msgList.add(msg1);</span><br><span class="line">Msg msg2 = <span class="keyword">new</span> Msg(<span class="string">"Hello. Who is that?"</span>, Msg.TYPE_SENT);</span><br><span class="line">msgList.add(msg2);</span><br><span class="line">Msg msg3 = <span class="keyword">new</span> Msg(<span class="string">"This is Tom. Nice talking to you. "</span>, Msg.TYPE_RECEIVED);</span><br><span class="line">msgList.add(msg3);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-2.29.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、如何编写程序界面&quot;&gt;&lt;a href=&quot;#一、如何编写程序界面&quot; class=&quot;headerlink&quot; title=&quot;一、如何编写程序界面:&quot;&gt;&lt;/a&gt;一、如何编写程序界面:&lt;/h2&gt;&lt;p&gt;Android 中有好几种编写程序界面的方式可供你选择。比如使用 DroidDraw,这是一种可视化的界面编辑工具，允许使用拖拽控件的方式来编写布局.&lt;/p&gt;
&lt;h2 id=&quot;二、常见控件的使用方法&quot;&gt;&lt;a href=&quot;#二、常见控件的使用方法&quot; class=&quot;headerlink&quot; title=&quot;二、常见控件的使用方法&quot;&gt;&lt;/a&gt;二、常见控件的使用方法&lt;/h2&gt;&lt;h3 id=&quot;2-1-TextView&quot;&gt;&lt;a href=&quot;#2-1-TextView&quot; class=&quot;headerlink&quot; title=&quot;2.1 TextView&quot;&gt;&lt;/a&gt;2.1 TextView&lt;/h3&gt;&lt;p&gt;主要用于在界面上显示一段文本信息,设置颜色,文本居中&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="Android之UI" scheme="https://zzwwqq.xyz/tags/Android%E4%B9%8BUI/"/>
    
  </entry>
  
  <entry>
    <title>java字符串</title>
    <link href="https://zzwwqq.xyz/java%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://zzwwqq.xyz/java字符串.html</id>
    <published>2019-04-08T10:51:55.000Z</published>
    <updated>2019-05-31T08:37:11.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字符串的特性"><a href="#一、字符串的特性" class="headerlink" title="一、字符串的特性:"></a>一、字符串的特性:</h2><p>String 被声明为 final，因此它不可被继承。</p><h2 id="二、不同JDK版本中String的区别"><a href="#二、不同JDK版本中String的区别" class="headerlink" title="二、不同JDK版本中String的区别:"></a>二、不同JDK版本中String的区别:</h2><p>①: 在 Java 8 中，String 内部使用 <strong>char 数组</strong>存储数据。</p><a id="more"></a><p>②: 在 Java 9 之后，String 类的实现改用 <strong>byte 数组</strong>存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。<br>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2 id="三、String-与StringBuffer-StringBuilder的区别："><a href="#三、String-与StringBuffer-StringBuilder的区别：" class="headerlink" title="三、String 与StringBuffer,StringBuilder的区别："></a>三、String 与StringBuffer,StringBuilder的区别：</h2><h3 id="3-1-可变性"><a href="#3-1-可变性" class="headerlink" title="3.1 可变性:"></a>3.1 可变性:</h3><p>String的长度是<strong>不可变的</strong>，而StringBuffer和StringBuilder长度是<strong>可变的.</strong></p><p>也就是说：对于String而言 例如：有String str = “JavaEE” + “Android”<br><strong>并不是在JavaEE后面直接加上Android, 而是在字符串常量池中重新创建一个JavaEEAndroid，且原来的JavaEE还存在于字符串常量池中.</strong></p><h3 id="3-2-线程安全"><a href="#3-2-线程安全" class="headerlink" title="3.2 线程安全:"></a>3.2 线程安全:</h3><p>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p><p><strong>StringBuffer的常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.1.png" alt></p><p><strong>String常用方法:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-4.4.png" alt></p><p><strong>StringBuffer和StringBuilder和String的效率比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">String text = <span class="string">""</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、字符串与其他数据类型的转换"><a href="#四、字符串与其他数据类型的转换" class="headerlink" title="四、字符串与其他数据类型的转换:"></a>四、字符串与其他数据类型的转换:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/java/java-7.1.png" alt></p><h3 id="4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法"><a href="#4-1-字符串与基本数据类型-包装类的相互转换-总是调用目标类的方法" class="headerlink" title="4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)"></a>4.1 字符串与基本数据类型/包装类的相互转换:(总是调用目标类的方法)</h3><p><strong>A ———&gt; B:      调用B的方法:</strong><br>①: 字符串—–&gt;基本数据类型，包装类：调用相应的包装类的parseXXX(String str)<br>②: 基本数据类型，包装类——&gt;字符串：调用字符串的重载的valueOf()方法</p><h3 id="4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器"><a href="#4-2-字符串与数组的相互转换-总是调用字符串的方法-构造器" class="headerlink" title="4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)"></a>4.2 字符串与数组的相互转换:(总是调用字符串的方法/构造器)</h3><p>字符串———&gt;数组         调用字符串的方法<br>数组————&gt;字符串     调用字符串的构造器</p><p>③: 字符串——-&gt;字节数组 调用字符串的getBytes()<br>④: 字符串——-&gt;字符数组 调用字符串的toCharArray()</p><p>⑤: 字节数组——&gt;字符串  调用字符串的构造器<br>⑥: 字符数组——&gt;字符串   调用字符串的构造器</p><p><strong>字符串to基本数据类型</strong></p><p>（1）基本数据类型对应的包装类的<strong>parseXXX方法</strong></p><p>（2）用字符串构造基本类型的封装对象，再调用封装对象的<strong>xxxValue方法</strong></p><p>例：将字符串”20.5”转成double类型，Double d1 = new Double(“20.5”);　　double d2 = d1.doubleValue();</p><p><strong>基本数据类型to字符串</strong></p><p>（1）String的<strong>valueOf方法</strong></p><p>（2）”<strong>+</strong>“ 号连接</p><p>（3）将基本数据类型封装成相应的封装类型对象，采用 “基本数据类型对应包装类的对象.<strong>toString()</strong>“方法转换成字符串。</p><p>例：将double类型的425.0转成字符串，Double d = new Double(425.0);     String s =d.toString();</p><h2 id="五、字符串常量池（String-Pool）"><a href="#五、字符串常量池（String-Pool）" class="headerlink" title="五、字符串常量池（String Pool）:"></a>五、字符串常量池（String Pool）:</h2><p>①: 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在<strong>编译时期</strong>就确定。<br>还可以使用 String 的 intern() 方法在<strong>运行过程中</strong>将字符串添加到 String Pool 中。</p><p>②: 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>③: 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="六、字符串字面量-和字符串对象"><a href="#六、字符串字面量-和字符串对象" class="headerlink" title="六、字符串字面量 和字符串对象:"></a>六、字符串字面量 和字符串对象:</h2><p>字面量指的是能够使用简单结构和符号创建对象的表达式。<br>如字符串字面量: 使用一个双引号来创建字符串对象，而不需要完整的调用 new String() 语句。</p><h2 id="七、new-String-“abc”-创建了几个对象"><a href="#七、new-String-“abc”-创建了几个对象" class="headerlink" title="七、new String(“abc”)创建了几个对象?"></a>七、new String(“abc”)创建了几个对象?</h2><p><strong>使用这种方式一共会创建两个字符串对象（前提是 字符串常量池 中还没有 “abc” 字符串对象）。</strong></p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 字符串常量池 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h2 id="八、关于”-”-和”equals”和String的intern-方法"><a href="#八、关于”-”-和”equals”和String的intern-方法" class="headerlink" title="八、关于”==” 和”equals”和String的intern()方法:"></a>八、关于”==” 和”equals”和String的intern()方法:</h2><p>①: “==”比较的是地址<br>②: “equals”是Object类中的方法,Object类是任何类的父类,equals方法比较的是地址.<br>所以任何类调用equals方法,那么比较的都是地址,只有类重写了equals方法后,调用equals方法比较的才是值.<br>③: String类重写了equals方法<br>④: 关于intern() 方法: 存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回它的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><p><strong>关于intern():</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String s0= “kvill”; </span><br><span class="line">String s1=<span class="keyword">new</span> String(”kvill”); </span><br><span class="line">String s2=<span class="keyword">new</span> String(“kvill”); </span><br><span class="line">System.out.println( s0==s1 ); </span><br><span class="line">System.out.println( “**********” ); </span><br><span class="line">s1.intern(); </span><br><span class="line">s2=s2.intern(); <span class="comment">//把常量池中“kvill”的引用赋给s2 </span></span><br><span class="line">System.out.println( s0==s1); </span><br><span class="line">System.out.println( s0==s1.intern() ); </span><br><span class="line">System.out.println( s0==s2 );</span><br><span class="line"></span><br><span class="line">结果为： </span><br><span class="line"><span class="keyword">false</span> </span><br><span class="line">********** </span><br><span class="line"><span class="keyword">false</span> <span class="comment">//虽然执行了s1.intern(),但它的返回值没有赋给s1 </span></span><br><span class="line"><span class="keyword">true</span> <span class="comment">//说明s1.intern()返回的是常量池中”kvill”的引用 </span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>几个结论: </strong></p><ol><li><p>直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。</p></li><li><p>new出来的字符串是存放在堆里面。</p></li><li><p>对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</p><ul><li><p>表达式右边是纯字符串常量，那么存放在常量池里面。</p></li><li><p>表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;        <span class="comment">//str1存放的值是字符串常量池中字符串aaa对象的地址.</span></span><br><span class="line">String str2 = <span class="string">"bbb"</span>;</span><br><span class="line">String str3 = <span class="string">"aaabbb"</span>;</span><br><span class="line">String str4 = str1 + str2;  <span class="comment">//str4存放的是堆中字符串aaabbb对象的地址</span></span><br><span class="line">String str5 = <span class="string">"aaa"</span> + <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析:</span></span><br><span class="line">结果：str1、str2、str3、str5都是存在于常量池，str4由于表达式右半边有引用类型，所以str4存在于堆内存，而</span><br><span class="line">str5表达式右边没有引用类型，是纯字符串常量，就存放在了常量池里面。</span><br><span class="line">其实Integer这种包装类型的-<span class="number">128</span> ~ +<span class="number">127</span>也是存放在常量池里面，比如Integer i1 = <span class="number">10</span>;Integer i2 = <span class="number">10</span>; i1 == i2结果是<span class="keyword">true</span>，估计也是为了性能优化。</span><br></pre></td></tr></table></figure><h2 id="九、五个关于字符串的算法题"><a href="#九、五个关于字符串的算法题" class="headerlink" title="九、五个关于字符串的算法题:"></a>九、五个关于字符串的算法题:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="number">1</span>. 模拟一个trim方法，去除字符串两端的空格 。</span><br><span class="line"> * <span class="number">2</span>. 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”。 </span><br><span class="line"> * <span class="number">3</span>. 获取一个字符串在另一个字符串中出现的次数.比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数。</span><br><span class="line"> * <span class="number">4</span>. 获取两个字符串中最大相同字串。比如str1 = “abcweathellooyuiodef” ; str2 = <span class="string">"abcwercvhelloobnm"</span>。</span><br><span class="line"> * <span class="number">5</span>.对字符串中字符进行自然排序</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. 模拟trim方法，去除字符串两端的空格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myTrim</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断字符串str前面是否有空格</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(start) == <span class="string">' '</span>) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(start);</span><br><span class="line"><span class="comment">// 判断字符串str后面是否有空格，如果不加上start &lt;= end，那么在特殊情况下会出现数组下标越界的异常</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; str.charAt(end) == <span class="string">' '</span>) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(end);</span><br><span class="line"> <span class="comment">// 方法一：</span></span><br><span class="line"> <span class="keyword">char</span>[]a = <span class="keyword">new</span> <span class="keyword">char</span>[end-start+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++,j++) &#123;</span><br><span class="line"> System.out.print(i+<span class="string">" "</span>);</span><br><span class="line"> a[j] = str.charAt(i);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println();</span><br><span class="line"> <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line"> String str1 = <span class="keyword">new</span> String(a);</span><br><span class="line"> <span class="keyword">return</span> str1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 方法二：</span></span><br><span class="line"><span class="comment">//return str.substring(start, end + 1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.1 将一个字符串反转，将字符串中指定的部分反转。比如将“abcdefg”反转为“abfedcg”(法一)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverseString</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符串转换为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="keyword">return</span> myreverseArray(c, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myreverseArray</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start,j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line"><span class="keyword">char</span> temp = c[i];</span><br><span class="line">c[i] = c[j];</span><br><span class="line">c[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符数组转换为字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 2.2 将一个字符串进行反转。将字符串中指定的部分进行反转（法二）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">String str1 = str.substring(<span class="number">0</span>,start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            str1 += c;</span><br><span class="line">&#125;</span><br><span class="line">str1 += str.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3. 获取一个字符串在另一个字符串中出现的次数.</span></span><br><span class="line"><span class="comment">// 判断str2 在 str1 中出现的次数</span></span><br><span class="line"><span class="comment">// 比如：获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">while</span> ((length = str1.indexOf(str2)) != -<span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">str1 = str1.substring(length + str2.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 获取两个字符串中最大相同字串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getMaxSubString</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">String maxStr = (str1.length() &gt; str2.length())? str1:str2;</span><br><span class="line">String minStr = (str1.length() &lt; str2.length())? str1:str2;</span><br><span class="line">        <span class="keyword">int</span> length = minStr.length();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = length - i; y &lt;= length; x++,y++) &#123;</span><br><span class="line">String str = minStr.substring(x,y);</span><br><span class="line">   <span class="keyword">if</span> (maxStr.contains(str)) &#123;</span><br><span class="line">   list.add(str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//5.对字符串中字符进行自然排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mySort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[]c = str.toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// @Test-myTrim</span></span><br><span class="line">String testString1 = <span class="string">"    abc  d    "</span>;</span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line">String testString2 = <span class="string">"              "</span>;</span><br><span class="line">        </span><br><span class="line">String str1 = StringDemo.myTrim(testString1);</span><br><span class="line">String str2 = StringDemo.myTrim(testString2);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str1 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str2 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">String str3 = str1.trim();</span><br><span class="line">String str4 = str2.trim();</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str3 + <span class="string">"----"</span>);</span><br><span class="line">System.out.println(<span class="string">"----"</span> + str4 + <span class="string">"----"</span>);</span><br><span class="line"><span class="comment">// @Test-myReverseString and myReverseArray</span></span><br><span class="line">String str5 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str6 = myReverseString(str5, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"原字符串："</span> + str5);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法一："</span> + str6);</span><br><span class="line">String str7 = <span class="string">"abcdefg"</span>;</span><br><span class="line">String str8 = reverseString2(str7, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"指定部分反转-法二："</span> + str8);</span><br><span class="line"><span class="keyword">int</span> count = getTime(<span class="string">"abkkcadkabkebfkabkskab"</span>, <span class="string">"abk"</span>);</span><br><span class="line">System.out.println(<span class="string">"出现次数为："</span> + count);</span><br><span class="line">    List&lt;String&gt; str9 = getMaxSubString(<span class="string">"abcwerathelloyuiodef"</span>, <span class="string">"abcwercvhellobnm"</span>);</span><br><span class="line">    System.out.println(str9);  </span><br><span class="line">    String str10 = <span class="string">"aediewfn"</span>;</span><br><span class="line">    String str11 = mySort(str10);</span><br><span class="line">    System.out.println(str11);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、字符串的特性&quot;&gt;&lt;a href=&quot;#一、字符串的特性&quot; class=&quot;headerlink&quot; title=&quot;一、字符串的特性:&quot;&gt;&lt;/a&gt;一、字符串的特性:&lt;/h2&gt;&lt;p&gt;String 被声明为 final，因此它不可被继承。&lt;/p&gt;
&lt;h2 id=&quot;二、不同JDK版本中String的区别&quot;&gt;&lt;a href=&quot;#二、不同JDK版本中String的区别&quot; class=&quot;headerlink&quot; title=&quot;二、不同JDK版本中String的区别:&quot;&gt;&lt;/a&gt;二、不同JDK版本中String的区别:&lt;/h2&gt;&lt;p&gt;①: 在 Java 8 中，String 内部使用 &lt;strong&gt;char 数组&lt;/strong&gt;存储数据。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://zzwwqq.xyz/categories/java/"/>
    
    
      <category term="java字符串" scheme="https://zzwwqq.xyz/tags/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://zzwwqq.xyz/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/数据链路层.html</id>
    <published>2019-04-07T07:37:34.000Z</published>
    <updated>2019-04-09T13:33:42.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据链路层设备"><a href="#一、数据链路层设备" class="headerlink" title="一、数据链路层设备:"></a>一、数据链路层设备:</h2><p>①: 网桥或桥接器:<br>②: 交换机:<br>　　<strong>实质: </strong>是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器<br>　　<strong>特点:</strong></p><ul><li><strong>全双工:</strong></li><li><strong>并行性: </strong>即能同时连通多对接口，使多对主机能同时通信</li><li><strong>自学习: </strong>即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。</li></ul><a id="more"></a><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.4.png" alt></p><p><strong>优点:</strong></p><p>对于传统的10Mbit/s的共享式以太网，若共有10个用户，则每个用户占有的平均带宽只有1Mbit/s，若使用交换机来连接这些主机，虽然在每个接口到主机的带宽还是10Mbit/s，但是由于一个用户在通性时是独占而不是和其他网络用户共享传输媒体带宽，因此，对于拥有10个接口的交换机的总容量则为100Mbit/s.</p><p>③:  网络适配器又称网络接口卡，网卡</p><p><strong>网络适配器是什么?</strong></p><p>网络适配器又称网卡或网络接口卡(NIC)，英文名NetworkInterfaceCard。它是使计算机联网的设备。平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡(NIC) 插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式，通过网络介质传输。它的主要技术参数为带宽、总线方式、电气接口方式等。</p><p><strong>网络适配器的主要作用：</strong></p><ul><li>它是主机与介质的桥梁设备</li><li>实现主机与介质之间的电信号匹配</li><li>提供数据缓冲能力</li><li>控制数据传送的功能(网卡一方面负责接收网络上传过来的数据包，解包后，将数据通过上的总线传输给本地计算机;另一方面它将本地计算机上的数据打包后送入网络。)</li></ul><p>网络适配器必须具备两大技术： 网卡驱动程序和I/O技术。驱动程序使网卡和网络操作系统兼容，实现PC机与网络的通信。I/O技术可以通过数据总线实现PC和网卡之间的通信。网卡是计算机网络中最基本的元素。在计算机局域网络中，如果有一台计算机没有网卡，那么这台计算机将不能和其他计算机通信，也就是说，这台计算机和网络是孤立的。</p><h2 id="二、数据链路层协议"><a href="#二、数据链路层协议" class="headerlink" title="二、数据链路层协议:"></a>二、数据链路层协议:</h2><h3 id="2-1-PPP协议-Point-to-Point-Protocal-（点到点）"><a href="#2-1-PPP协议-Point-to-Point-Protocal-（点到点）" class="headerlink" title="2.1 PPP协议:  Point-to-Point Protocal; （点到点）"></a>2.1 PPP协议:  Point-to-Point Protocal; （点到点）</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点:"></a>2.1.1 特点:</h3><p>①: 简单<br>②: 只检错,不纠错<br>③: 不使用序号,不进行流量控制</p><h3 id="2-1-2-PPP-的帧格式："><a href="#2-1-2-PPP-的帧格式：" class="headerlink" title="2.1.2 PPP 的帧格式："></a>2.1.2 PPP 的帧格式：</h3><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.3.png" alt></p><h3 id="2-2-PPPoE协议"><a href="#2-2-PPPoE协议" class="headerlink" title="2.2 PPPoE协议:"></a>2.2 PPPoE协议:</h3><p>是为宽带上网的主机使用的链路层协议</p><h3 id="2-3-CSMA-CD协议"><a href="#2-3-CSMA-CD协议" class="headerlink" title="2.3 CSMA/CD协议:"></a>2.3 CSMA/CD协议:</h3><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h3 id="2-4-IEEE-802-3-2协议"><a href="#2-4-IEEE-802-3-2协议" class="headerlink" title="2.4 IEEE 802.3/.2协议"></a>2.4 IEEE 802.3/.2协议</h3><h3 id="2-5-ATM协议"><a href="#2-5-ATM协议" class="headerlink" title="2.5 ATM协议"></a>2.5 ATM协议</h3><h3 id="2-6-HDLC协议"><a href="#2-6-HDLC协议" class="headerlink" title="2.6 HDLC协议"></a>2.6 HDLC协议</h3><h2 id="三、数据链路层基本单元"><a href="#三、数据链路层基本单元" class="headerlink" title="三、数据链路层基本单元:"></a>三、数据链路层基本单元:</h2><p>帧</p><h2 id="四、数据链路层三个基本问题"><a href="#四、数据链路层三个基本问题" class="headerlink" title="四、数据链路层三个基本问题:"></a>四、数据链路层三个基本问题:</h2><h3 id="4-1-封装成帧"><a href="#4-1-封装成帧" class="headerlink" title="4.1 封装成帧:"></a>4.1 封装成帧:</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.1.png" alt></p><h3 id="4-2-透明传输"><a href="#4-2-透明传输" class="headerlink" title="4.2 透明传输:"></a>4.2 透明传输:</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.2.png" alt></p><h3 id="4-3-差错检测"><a href="#4-3-差错检测" class="headerlink" title="4.3 差错检测:"></a>4.3 差错检测:</h3><p>循环冗余检验CRC(检错方法) : 即用模2运算，进行加法时不进位例如 ：1111+1010=0101，减法与加法一样，即按加法规则计算</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.7.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.8.png" alt></p><h2 id="五、数据链路层使用的信道"><a href="#五、数据链路层使用的信道" class="headerlink" title="五、数据链路层使用的信道:"></a>五、数据链路层使用的信道:</h2><h3 id="5-1-点对点信道"><a href="#5-1-点对点信道" class="headerlink" title="5.1 点对点信道:"></a>5.1 点对点信道:</h3><p><strong>一对一通信。</strong><br>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h3 id="5-2-广播信道"><a href="#5-2-广播信道" class="headerlink" title="5.2 广播信道:"></a>5.2 广播信道:</h3><p>①: <strong>一对多通信</strong>，一个节点发送的数据能够被广播信道上所有的节点接收到。<br>②: 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。<br>③: 主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用<strong>CSMA/CD 协议。</strong></p><h2 id="六、数据链路层功能："><a href="#六、数据链路层功能：" class="headerlink" title="六、数据链路层功能："></a>六、数据链路层功能：</h2><p>①: 负责 结点-结点（node-to-node）数据传输:具体来说：解决的是物理链路直接相连的两个相邻结点之间的数据传输<br>②: 组帧（Framing）<br>③: 物理寻址（Physical addressing）:在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端<br>④: 流量控制（Flow control）:避免淹没接收端<br>⑤: 差错控制（Error control）:检测并重传损坏或丢失帧，并避免重复帧<br>⑥: 访问（接入）控制（Access control ）:在任意给定时刻决定哪个设备拥有链路（物理介质）控制使用权</p><h2 id="七、数据链路层任务"><a href="#七、数据链路层任务" class="headerlink" title="七、数据链路层任务:"></a>七、数据链路层任务:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.9.png" alt></p><h2 id="八、MAC-地址"><a href="#八、MAC-地址" class="headerlink" title="八、MAC 地址:"></a>八、MAC 地址:</h2><p>MAC 地址是<strong>链路层地址</strong>，长度为 6 字节（48 位），用于<strong>唯一标识网络适配器（网卡）</strong>。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="九、以太网"><a href="#九、以太网" class="headerlink" title="九、以太网:"></a>九、以太网:</h2><h3 id="9-1-以太网是一种星型拓扑结构局域网。"><a href="#9-1-以太网是一种星型拓扑结构局域网。" class="headerlink" title="9.1 以太网是一种星型拓扑结构局域网。"></a>9.1 以太网是一种星型拓扑结构局域网。</h3><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h3 id="9-2-特点"><a href="#9-2-特点" class="headerlink" title="9.2 特点:"></a>9.2 特点:</h3><p>采用的协议: CSMA/CD<br>采用无连接,半双工通信<br>对数据帧不进行编号<br>尽最大努力交付(不可靠)<br>不要求对方确认<br>发送的数据都以曼彻斯特编码<br>收到错帧就丢弃</p><h3 id="9-3-以太网帧格式："><a href="#9-3-以太网帧格式：" class="headerlink" title="9.3 以太网帧格式："></a>9.3 以太网帧格式：</h3><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.5.png" alt></p><h2 id="十、局域网"><a href="#十、局域网" class="headerlink" title="十、局域网:"></a>十、局域网:</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="http://cdn.zzwwqq.xyz/static/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91-3.6.png" alt></p><h2 id="十一、10BASE-T"><a href="#十一、10BASE-T" class="headerlink" title="十一、10BASE-T:"></a>十一、10BASE-T:</h2><p>10 代表 10Mbit/s<br>BASE : 连接线上的信号为基带信号<br>T: 双绞线</p><h2 id="十二、数据链路层功能"><a href="#十二、数据链路层功能" class="headerlink" title="十二、数据链路层功能:"></a>十二、数据链路层功能:</h2><p>将网络层接收到的数据分割成特定的可被物理层传输的帧</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据链路层设备&quot;&gt;&lt;a href=&quot;#一、数据链路层设备&quot; class=&quot;headerlink&quot; title=&quot;一、数据链路层设备:&quot;&gt;&lt;/a&gt;一、数据链路层设备:&lt;/h2&gt;&lt;p&gt;①: 网桥或桥接器:&lt;br&gt;②: 交换机:&lt;br&gt;　　&lt;strong&gt;实质: &lt;/strong&gt;是一个多接口的网桥,又称以太网交换机，第二层交换机，交换式集线器&lt;br&gt;　　&lt;strong&gt;特点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全双工:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行性: &lt;/strong&gt;即能同时连通多对接口，使多对主机能同时通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自学习: &lt;/strong&gt;即插即用，其内部的帧交换表（又称地址表）是通过自学习算法自动逐渐建立起来的,交换表中存储着 MAC 地址到接口的映射。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数据链路层" scheme="https://zzwwqq.xyz/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Markdown用法</title>
    <link href="https://zzwwqq.xyz/Markdown%E7%94%A8%E6%B3%95.html"/>
    <id>https://zzwwqq.xyz/Markdown用法.html</id>
    <published>2019-04-06T12:23:12.000Z</published>
    <updated>2019-04-23T07:18:11.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常用操作"><a href="#一、常用操作" class="headerlink" title="一、常用操作:"></a>一、常用操作:</h2><h3 id="1-1-代码块"><a href="#1-1-代码块" class="headerlink" title="1.1 代码块:"></a>1.1 代码块:</h3><p><strong>①: 添加代码块 :</strong><br><strong>一行代码时: (也称行内代码)</strong> 使用一对单引号(ESC键下面的单引号键),代码放在这对单引号之间</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.4.png" alt>    </p><p>效果图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.3.png" alt>    </p><p><strong>多行代码:</strong> 连按三个单引号(ESC键下面的单引号键) ,然后回车.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.5.png" alt>   </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.6.png" alt> </p><p>效果图: </p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.2.png" alt>     </p><p><strong>②: 代码快速排版: </strong></p><p>先把光标定位到代码块中，此时右下角会让你输入代码格式（如Java，C，C#等）,比选择Java， 然后Ctrl+ A选中所有代码,  最后  <code>Shift + tab</code></p><p>拍版前:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.7.png" alt>  </p><p> 排版后:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.8.png" alt>  </p><h3 id="1-2-插入图片"><a href="#1-2-插入图片" class="headerlink" title="1.2 插入图片"></a>1.2 插入图片</h3><p>插入互联网上图片:</p><p><code>![这里写图片描述](这里写地址)</code></p><p><code>![这里写图片描述](http://img3.douban.com/mpic/s1108264.jpg)</code></p><h3 id="1-3-超链接"><a href="#1-3-超链接" class="headerlink" title="1.3 超链接"></a>1.3 超链接</h3><p>链接文字都是用 [方括号] 来标记,在方块括号后面紧接着圆括号并插入网址链接即可</p><p><code>[This link](http://example.net/)</code></p><h3 id="1-4-分割线："><a href="#1-4-分割线：" class="headerlink" title="1.4 分割线："></a>1.4 分割线：</h3><p>在一行中输入三个连续的减号:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.9.png" alt></p><p>效果图:</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.10.png" alt></p><h3 id="1-5-换行"><a href="#1-5-换行" class="headerlink" title="1.5 换行"></a>1.5 换行</h3><p>方法1: 连续两个以上空格,  然后   回车</p><p>方法2：使用html语言换行标签：<code>&lt;br&gt;</code></p><h3 id="1-6-首行缩进："><a href="#1-6-首行缩进：" class="headerlink" title="1.6 首行缩进："></a>1.6 首行缩进：</h3><p>首行缩进两个字符：(每个表示一个空格，连续使用两个即可）</p><ul><li><code>&amp;ensp;</code> 半角的空格</li><li><code>&amp;emsp;</code> 全角的空格</li></ul><h3 id="1-7-字体-字体颜色-字体大小"><a href="#1-7-字体-字体颜色-字体大小" class="headerlink" title="1.7 字体,字体颜色,字体大小"></a>1.7 字体,字体颜色,字体大小</h3><p>使用内嵌HTML的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是浅蓝色,黑体,7号字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>我是红色<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3</span><br></pre></td></tr></table></figure><h3 id="1-8-背景色"><a href="#1-8-背景色" class="headerlink" title="1.8 背景色"></a>1.8 背景色</h3><p>Markdown本身不支持背景色设置，需要采用内置html的方式实现</p><p>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">green</span>&gt;</span>背景色是：green<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图:</p><table><tr><td bgcolor="green">背景色是：green</td></tr></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;768px&quot; height=&quot;367px&quot; src=&quot;http://cdn.zzwwqq.xyz/static/images/Markdown/Markdown-1.1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://zzwwqq.xyz/categories/Markdown/"/>
    
    
      <category term="Markdown用法指南" scheme="https://zzwwqq.xyz/tags/Markdown%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>初识Android</title>
    <link href="https://zzwwqq.xyz/%E5%88%9D%E8%AF%86Android.html"/>
    <id>https://zzwwqq.xyz/初识Android.html</id>
    <published>2019-04-05T11:35:08.000Z</published>
    <updated>2019-04-09T13:31:06.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Android系统四大组件"><a href="#一、Android系统四大组件" class="headerlink" title="一、Android系统四大组件:"></a>一、Android系统四大组件:</h2><h3 id="1-1-活动（Activity）"><a href="#1-1-活动（Activity）" class="headerlink" title="1.1 活动（Activity）:"></a>1.1 活动（Activity）:</h3><p>凡是在应用中你看得到的东西，都是放在活动中的。</p><h3 id="1-2-服务（Service）"><a href="#1-2-服务（Service）" class="headerlink" title="1.2 服务（Service）:"></a>1.2 服务（Service）:</h3><p>你无法看到它，但它会一直在后台默默地运行</p><h3 id="1-3-广播接收器（Broadcast-Receiver）"><a href="#1-3-广播接收器（Broadcast-Receiver）" class="headerlink" title="1.3 广播接收器（Broadcast Receiver）:"></a>1.3 广播接收器（Broadcast Receiver）:</h3><p>接收来自各处的广播消息，比如电话、短信等</p><h3 id="1-4-内容提供器（ContentProvider）"><a href="#1-4-内容提供器（ContentProvider）" class="headerlink" title="1.4 内容提供器（ContentProvider）:"></a>1.4 内容提供器（ContentProvider）:</h3><p>为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现</p><h2 id="二、创建并运行HelloWorld程序"><a href="#二、创建并运行HelloWorld程序" class="headerlink" title="二、创建并运行HelloWorld程序:"></a>二、创建并运行HelloWorld程序:</h2><h3 id="2-1-创建程序"><a href="#2-1-创建程序" class="headerlink" title="2.1 创建程序"></a>2.1 创建程序</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.1.png" alt></p><p>Application Name 代表应用名称，此应用安装到手机之后会在手机上显示该名称:<br>Project Name 代表项目名称，在项目创建完成后该名称会显示在 Eclipse 中<br>Minimum Required SDK 是指程序最低兼容的版本<br>Target SDK 是指你在该目标版本上已经做过了充分的测试，系统不会再帮你在这个版本上做向前兼容的操作了<br>Compile With是指程序将使用哪个版本的 SDK 进行编译<br>最后一个 Theme是指程序 UI 所使用的主题，我个人比较喜欢选择 None</p><h4 id="2-1-1-创建活动"><a href="#2-1-1-创建活动" class="headerlink" title="2.1.1 创建活动:"></a>2.1.1 创建活动:</h4><p>选择一个你想创建的活动类型，这里我们就选择 Blank Activity 了</p><h3 id="2-2-启动模拟器"><a href="#2-2-启动模拟器" class="headerlink" title="2.2 启动模拟器:"></a>2.2 启动模拟器:</h3><p>点击 Eclipse 导航栏中的 Window→Open Perspective→DDMS<br>如果你的 Devices 窗口中有一个设备显示是 Online 的，那就说明目前一切正常，你的模拟器是在线的</p><h3 id="2-3-执行程序代码"><a href="#2-3-执行程序代码" class="headerlink" title="2.3 执行程序代码:"></a>2.3 执行程序代码:</h3><p>右击 HelloWorld 项目→Run As→Android Application</p><h2 id="三、程序的目录结构"><a href="#三、程序的目录结构" class="headerlink" title="三、程序的目录结构:"></a>三、程序的目录结构:</h2><h3 id="3-1-gen"><a href="#3-1-gen" class="headerlink" title="3.1 gen"></a>3.1 gen</h3><p>自动生成的，主要有一个 R.java 文件,你在项目中添加的任何资源都会在其中生成一个相应的资源 id,<strong>永远不要手动去修改它。</strong></p><h3 id="3-2-bin"><a href="#3-2-bin" class="headerlink" title="3.2 bin"></a>3.2 bin</h3><p>存放<strong>编译时自动产生</strong>的文件, 目录下有HelloWorld.apk，把这个文件拷到手机上就可以直接安装了</p><h3 id="3-3-libs"><a href="#3-3-libs" class="headerlink" title="3.3 libs"></a>3.3 libs</h3><p>存放第三方 Jar包, 会被<strong>自动添加</strong>到构建路径里去</p><h3 id="3-4-assets"><a href="#3-4-assets" class="headerlink" title="3.4 assets"></a>3.4 assets</h3><p>存放一些<strong>随程序打包的文件</strong>,所有<strong>网页相关的文件</strong>也都存放在这个目录下</p><h3 id="3-5-res-resources即资源目录"><a href="#3-5-res-resources即资源目录" class="headerlink" title="3.5 res: (resources即资源目录)"></a>3.5 res: (resources即资源目录)</h3><p>图片、布局、字符串等资源都要存放在这个目录下<br>图片放在 drawable 目录下<br>布局放在 layout 目录下<br>字符串放在 values 目录下</p><h3 id="3-6-AndroidManifest-xml"><a href="#3-6-AndroidManifest-xml" class="headerlink" title="3.6 AndroidManifest.xml"></a>3.6 AndroidManifest.xml</h3><p>整个 Android 项目的配置文件，四大组件都需要在这个文件里注册,还可以添加权限声明,版本兼容修改</p><h3 id="3-7-project-properties"><a href="#3-7-project-properties" class="headerlink" title="3.7 project.properties"></a>3.7 project.properties</h3><p>指定编译程序时所使用的 SDK 版本</p><h2 id="四、程序的运行流程分析"><a href="#四、程序的运行流程分析" class="headerlink" title="四、程序的运行流程分析:"></a>四、程序的运行流程分析:</h2><h3 id="4-1-AndroidManifest-xml-文件"><a href="#4-1-AndroidManifest-xml-文件" class="headerlink" title="4.1 AndroidManifest.xml 文件:"></a>4.1 AndroidManifest.xml 文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 HelloWorldActivity 这个活动进行注册,没有在 AndroidManifest.xml 里面注册的活动是不能使用的。</span></span><br><span class="line">&lt;activity</span><br><span class="line">　　　android:name=<span class="string">"com.test.helloworld.HelloWorldActivity"</span></span><br><span class="line">　　　android:label=<span class="string">"@string/app_name"</span> &gt;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//主活动，在手机上点击应用图标，首先启动的就是这个活动。</span></span><br><span class="line">　　　&lt;intent-filter&gt;</span><br><span class="line">　　　　　&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">　　　　　&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">　　　&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-再来看src-HelloWorldActivity-java文件"><a href="#4-2-再来看src-HelloWorldActivity-java文件" class="headerlink" title="4.2 再来看src/HelloWorldActivity.java文件"></a>4.2 再来看src/HelloWorldActivity.java文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 调用了setContentView()方法，给当前的活动引入了一个 hello_world_layout 布局</span></span><br><span class="line">        setContentView(R.layout.hello_world_layout);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Activity</strong> 是 Android 系统提供的一个活动基类，项目中<strong>所有的活动都必须要继承它才能拥有活动的特性</strong></p><p><strong>onCreate()方法</strong>是一个<strong>活动被创建时必定要执行的方法</strong></p><p>Android程序的设计讲究逻辑和视图分离,在<strong>布局文件中编写界面</strong>，然后<strong>在活动中引入进来。</strong></p><h3 id="4-3-看-res-layout-hello-world-layout-xml-布局文件"><a href="#4-3-看-res-layout-hello-world-layout-xml-布局文件" class="headerlink" title="4.3 看 res/layout/hello_world_layout.xml 布局文件:"></a>4.3 看 res/layout/hello_world_layout.xml 布局文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">.......</span><br><span class="line">&lt;TextView</span><br><span class="line">android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">......</span><br><span class="line">android:text=<span class="string">"@string/hello_world"</span> /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><strong>TextView</strong>，这是 Android 系统提供的一个控件，用于在<strong>布局中显示文字的</strong><br>hello_world_layout.xml布局文件中就是通过引用了 hello_world这个键，才找到了相应的值</p><h3 id="4-4-查看res-values-strings-xml-文件"><a href="#4-4-查看res-values-strings-xml-文件" class="headerlink" title="4.4 查看res/values/strings.xml 文件:"></a>4.4 查看res/values/strings.xml 文件:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;string name="app_name"&gt;Hello World&lt;/string&gt;</span><br><span class="line">....</span><br><span class="line">&lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p>一 般 是 把 字 符 串 定 义 在res/values/strings.xml 里，然后可以在布局文件或代码中引用<br>Hello world!字符串就是定义在这个文件里的<br>可以在这里通过修改 app_name 对应的值，来改变此应用程序的名称,在哪儿引用了app_name 这个键呢？在AndroidManifest.xml查找.</p><h2 id="五、关于资源目录res"><a href="#五、关于资源目录res" class="headerlink" title="五、关于资源目录res:"></a>五、关于资源目录res:</h2><p>drawable开头的文件夹都是用来放图片的<br>values开头的文件夹都是用来放字符串<br>layout 文件夹是用来放布局文件<br>menu 文件夹是用来放菜单文件</p><p>之所以有这么多 drawable开头的文件夹，是为了让程序能够兼容更多的设备, 最好能够给同一张图片提供几个不同分辨率的副本<br><strong>只有一份图片时,所有图片都放在 drawable-hdpi下即可</strong></p><h2 id="六、如何引用资源"><a href="#六、如何引用资源" class="headerlink" title="六、如何引用资源?"></a>六、如何引用资源?</h2><p> strings.xml 中的 Hello world!字符串，有两种方式引用它：</p><p>①: 代码中通过 <code>R.string.hello_world</code> 可以获得该字符串的引用；<br>②: 在 XML 中通过<code>@string/hello_world</code>可以获得该字符串的引用。</p><p>string 部分是可以替换的,如果是<strong>引用的图片资源就可以替换成 drawable,</strong>如果是引用的布局文件就可以替换成 layout,以此类推</p><h2 id="七、日志"><a href="#七、日志" class="headerlink" title="七、日志:"></a>七、日志:</h2><h3 id="7-1-打印日志"><a href="#7-1-打印日志" class="headerlink" title="7.1 打印日志:"></a>7.1 打印日志:</h3><p>打开 HelloWorldActivity，在 onCreate()方法中添加一行打印日志的语句，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">Log.d(<span class="string">"HelloWorldActivity"</span>, <span class="string">"onCreate execute"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Log.d 第一个参数是 tag，一般传入当前的类名，主要用于对打印信息进行过滤。<br>第二个参数是 msg，即想要打印的具体的内容。</p><h3 id="7-2-日志过滤器"><a href="#7-2-日志过滤器" class="headerlink" title="7.2 日志过滤器:"></a>7.2 日志过滤器:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.3.png" alt></p><p>给过滤器起名叫 data，并且让它对名为 data 的 Tag进行过滤</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.4.png" alt></p><p>在 onCreate()方法中把打印日志的语句改成 Log.d(“data”,”onCreate execute”)，然后再次运行程序，你就会在 data 过滤器下看到这行日志了。</p><h3 id="7-3-日志级别"><a href="#7-3-日志级别" class="headerlink" title="7.3 日志级别:"></a>7.3 日志级别:</h3><p>选中debug级别，这时只有使用 debug 及以上级别方法打印的日志才会显示出来<br>如果你把LogCat 中的级别选中为 info、warn 或者 error 时，我们在 onCreate()方法中打印的语句是不会显示的，因为我们打印日志时使用的是 Log.d()方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Android系统四大组件&quot;&gt;&lt;a href=&quot;#一、Android系统四大组件&quot; class=&quot;headerlink&quot; title=&quot;一、Android系统四大组件:&quot;&gt;&lt;/a&gt;一、Android系统四大组件:&lt;/h2&gt;&lt;h3 id=&quot;1-1-活动（Acti
      
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="初识Android" scheme="https://zzwwqq.xyz/tags/%E5%88%9D%E8%AF%86Android/"/>
    
  </entry>
  
  <entry>
    <title>PV操作</title>
    <link href="https://zzwwqq.xyz/PV%E6%93%8D%E4%BD%9C%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B.html"/>
    <id>https://zzwwqq.xyz/PV操作经典实例.html</id>
    <published>2019-04-04T07:58:18.000Z</published>
    <updated>2019-04-09T13:29:56.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是PV操作"><a href="#一、什么是PV操作" class="headerlink" title="一、什么是PV操作?"></a>一、什么是PV操作?</h2><p>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：<br>P（S）：<br>①将信号量S的值减1，即S=S-1；<br>②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。<br><a id="more"></a></p><p>V（S）：<br>①将信号量S的值加1，即S=S+1；</p><h2 id="二、PV操作的意义："><a href="#二、PV操作的意义：" class="headerlink" title="二、PV操作的意义："></a>二、PV操作的意义：</h2><p>我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。</p><h2 id="三、什么是信号量？"><a href="#三、什么是信号量？" class="headerlink" title="三、什么是信号量？"></a>三、什么是信号量？</h2><p>信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。<br><strong>信号量的值与相应资源的使用情况有关: </strong><br>①: 当信号量的值大于0时，表示当前可用资源的数量<br>②: 当它的值小于0时，其绝对值表示等待使用该资源的进程个数<br><strong>注意，信号量的值仅能由PV操作来改变。</strong></p><h2 id="四、使用PV操作注意事项："><a href="#四、使用PV操作注意事项：" class="headerlink" title="四、使用PV操作注意事项："></a>四、使用PV操作注意事项：</h2><p>①: 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。<br>②: P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。<br>③: 互斥信号量的初值一般为1。</p><h2 id="五、PV操作实例"><a href="#五、PV操作实例" class="headerlink" title="五、PV操作实例:"></a>五、PV操作实例:</h2><h2 id="5-1-例题1-吃苹果问题"><a href="#5-1-例题1-吃苹果问题" class="headerlink" title="5.1 例题1: 吃苹果问题:"></a>5.1 例题1: 吃苹果问题:</h2><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.1.png" alt></p><p><strong>解题过程:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty=<span class="number">2</span>； <span class="comment">//定义empty对应盘子的剩余放水果的位置个数初值为2(      空缓冲区个数       ) </span></span><br><span class="line">    semaphore apple=<span class="number">0</span>； <span class="comment">//定义信号量apple对应盘子里的苹果数量初值为0 </span></span><br><span class="line">    semaphore orange=<span class="number">0</span>； <span class="comment">//定义信号量orange对于盘子里的橘子数量初值为0 </span></span><br><span class="line">    semaphore mutex=<span class="number">1</span>： <span class="comment">//定义信号量mutex来保护盘子被互斥地访问 </span></span><br><span class="line">    father()&#123; <span class="comment">//爸爸进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(empty)； <span class="comment">//盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放苹果</span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            在盘子里放一个苹果 </span><br><span class="line">            V(mutex)； </span><br><span class="line">            V(apple)；<span class="comment">//盘中苹果数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mother()&#123; <span class="comment">//妈妈进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">        P(empty)； <span class="comment">//盘子的剩余放水果的位置减一，如果&gt;=0,说明有位置可以放橘子</span></span><br><span class="line">            P(mutex)； <span class="comment">//互斥变量减一，如果&lt;0，则说明有进程在临界区。则当前进程必须等待。</span></span><br><span class="line">            在盘子里放一个橘子</span><br><span class="line">            V(mutex)； 进程执行完毕，出了临界区，互斥变量值加一。</span><br><span class="line">            V(orange)； <span class="comment">//盘中橘子数加一</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">son()&#123; <span class="comment">//用这段程序产生两个儿子进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">        P(orange)； <span class="comment">//盘中橘子个数减一，如果结果&gt;=0时,说明盘中有橘子，可以取 </span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            从盘子里拿一个橘子</span><br><span class="line">            V(mutex)； </span><br><span class="line">            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123; <span class="comment">//用这段程序产生两个女儿进程 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span> )  &#123; </span><br><span class="line">        P(apple)；   <span class="comment">//盘中苹果个数减一，如果结果&gt;=0时,说明盘中有苹果，可以取</span></span><br><span class="line">            P(mutex)； </span><br><span class="line">            从盘子里拿出一个苹果 </span><br><span class="line">            V(mutex)；</span><br><span class="line">            V(empty)； 取了一个橘子后，盘子的剩余放水果的位置加一</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-和尚打水"><a href="#5-2-和尚打水" class="headerlink" title="5.2 : 和尚打水:"></a>5.2 : 和尚打水:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.2.png" alt></p><p><strong>分析:</strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-2.3.png" alt></p><p><strong>解题过程:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Semaphore   mutexA = <span class="number">1</span>;    <span class="comment">//保护井被互斥地访问 </span></span><br><span class="line">Semaphore   mutexB = <span class="number">1</span>;    <span class="comment">//保护缸被互斥地访问 </span></span><br><span class="line">Semaphore   Count = <span class="number">3</span>；    <span class="comment">//桶总数为3</span></span><br><span class="line">Semaphore   full = <span class="number">0</span>;      <span class="comment">//控制出水，刚开始，缸是空的，能取出0桶水</span></span><br><span class="line">Semaphore   empty = <span class="number">10</span> ;   <span class="comment">//控制入水，刚开始，缸是空的，能倒入10桶水</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小和尚打水：</span></span><br><span class="line">Progress（小和尚）&#123;</span><br><span class="line">          <span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">                   P（empty）  <span class="comment">//判断缸是否满了（结果如果&gt;=0,未满），决定是否需要打水</span></span><br><span class="line">                   P（count）  <span class="comment">//拿桶（判断是否有空闲的桶，结果如果&gt;=0,有桶）</span></span><br><span class="line">                   P（mutexA）&#123;   <span class="comment">//对井互斥访问</span></span><br><span class="line">                    从井中打水；</span><br><span class="line">                    V（mutexA）    <span class="comment">//互斥</span></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                    P（mutexB）&#123;   <span class="comment">//对缸互斥访问</span></span><br><span class="line">                    向缸中倒水；</span><br><span class="line">                    V（mutexB）    <span class="comment">//互斥</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   V（count）<span class="comment">//还桶，空闲桶的数量加一</span></span><br><span class="line">                   V（full）   <span class="comment">//缸中水的数量加一，（通知老和尚取水）</span></span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老和尚取水：</span></span><br><span class="line">progress（老和尚）&#123;</span><br><span class="line">             <span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">                      P（full） <span class="comment">//判断缸中是否有水，（结果如果&gt;=0,说明缸中有水，可取水）</span></span><br><span class="line">                      P（count）<span class="comment">//拿桶</span></span><br><span class="line">                      P（mutexB) <span class="comment">//互斥</span></span><br><span class="line">                      从缸中取水；</span><br><span class="line">                      V（mutexB）<span class="comment">//互斥</span></span><br><span class="line">                      V(count)   <span class="comment">//还桶</span></span><br><span class="line">                      V（empty）<span class="comment">//缸中还能容纳的水数量加一，（通知小和尚打水）</span></span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是PV操作&quot;&gt;&lt;a href=&quot;#一、什么是PV操作&quot; class=&quot;headerlink&quot; title=&quot;一、什么是PV操作?&quot;&gt;&lt;/a&gt;一、什么是PV操作?&lt;/h2&gt;&lt;p&gt;PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：&lt;br&gt;P（S）：&lt;br&gt;①将信号量S的值减1，即S=S-1；&lt;br&gt;②如果S&amp;gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="PV操作" scheme="https://zzwwqq.xyz/tags/PV%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://zzwwqq.xyz/%E6%AD%BB%E9%94%81.html"/>
    <id>https://zzwwqq.xyz/死锁.html</id>
    <published>2019-04-03T07:10:16.000Z</published>
    <updated>2019-04-03T08:40:59.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是死锁"><a href="#一、什么是死锁" class="headerlink" title="一、什么是死锁:"></a>一、什么是死锁:</h2><p>是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种<strong>互相等待</strong>的现象,若无<strong>外力</strong>作用,它们都将无法推进下去.</p><h2 id="二、产生死锁的原因"><a href="#二、产生死锁的原因" class="headerlink" title="二、产生死锁的原因:"></a>二、产生死锁的原因:</h2><a id="more"></a><p>①: 因为系统资源不足<br>②: 进程运行推进顺序不合适<br>③: 资源分配不当等</p><h2 id="三、产生死锁的必要条件"><a href="#三、产生死锁的必要条件" class="headerlink" title="三、产生死锁的必要条件:"></a>三、产生死锁的必要条件:</h2><p>①: 互斥：一个资源每次只能被一个进程使用<br>②: 占有和等待(请求与保持)：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>③:  不剥夺: 进程已获得的资源，在使用完之前，不能强行被抢占,它只能被占有它的进程显式地释放。<br>④: 环路等待: 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p><p><strong>注: 只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong></p><h2 id="四、处理死锁的方法"><a href="#四、处理死锁的方法" class="headerlink" title="四、处理死锁的方法:"></a>四、处理死锁的方法:</h2><p>主要有以下四种方法：</p><h3 id="4-1-鸵鸟策略"><a href="#4-1-鸵鸟策略" class="headerlink" title="4.1 鸵鸟策略"></a>4.1 鸵鸟策略</h3><p><strong>4.1.1 原理: </strong><br>把头埋在沙子里，假装根本没发生问题, 也就是忽略死锁<br><strong>4.1.2 什么时候用?</strong><br>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><h3 id="4-2-死锁检测与死锁恢复"><a href="#4-2-死锁检测与死锁恢复" class="headerlink" title="4.2 死锁检测与死锁恢复"></a>4.2 死锁检测与死锁恢复</h3><p><strong>4.2.1 原理: </strong><br>不试图阻止死锁，而是当<strong>检测到死锁发生时</strong>，<strong>再采取措施</strong>进行恢复。<br><strong>4.2.2 死锁检测:</strong><br><strong>4.2.2.1 每种类型一个资源的死锁检测:</strong><br>通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>4.2.2.2 每种类型多个资源的死锁检测:</strong><br>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。<br>①: 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。<br>②: 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。<br>③: 如果没有这样一个进程，算法终止。</p><h3 id="4-2-3-死锁恢复"><a href="#4-2-3-死锁恢复" class="headerlink" title="4.2.3 死锁恢复:"></a>4.2.3 死锁恢复:</h3><p>①: 利用抢占恢复<br>②: 利用回滚恢复<br>③:     通过杀死进程恢复</p><h3 id="4-3-死锁预防"><a href="#4-3-死锁预防" class="headerlink" title="4.3 死锁预防"></a>4.3 死锁预防</h3><h3 id="4-3-1-原理"><a href="#4-3-1-原理" class="headerlink" title="4.3.1 原理:"></a>4.3.1 原理:</h3><p>在程序<strong>运行之前</strong>预防发生死锁</p><h3 id="4-3-2-采取方法"><a href="#4-3-2-采取方法" class="headerlink" title="4.3.2 采取方法:"></a>4.3.2 采取方法:</h3><p>破坏死锁的四个必要条件<br><strong>①: 破坏互斥：</strong><br><strong>②: 破坏占有和等待(请求与保持):</strong><br>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p><strong>③: 破坏不剥夺:</strong><br><strong>④: 破坏环路等待:</strong><br>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="4-4-死锁避免"><a href="#4-4-死锁避免" class="headerlink" title="4.4 死锁避免"></a>4.4 死锁避免</h3><p>在程序<strong>运行时</strong>避免发生死锁</p><h2 id="五、银行家算法"><a href="#五、银行家算法" class="headerlink" title="五、银行家算法:"></a>五、银行家算法:</h2><p><strong>例题: </strong></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-3.1.png" alt></p><p><img src="http://cdn.zzwwqq.xyz/static/images/操作系统/OS-3.2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是死锁&quot;&gt;&lt;a href=&quot;#一、什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;一、什么是死锁:&quot;&gt;&lt;/a&gt;一、什么是死锁:&lt;/h2&gt;&lt;p&gt;是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种&lt;strong&gt;互相等待&lt;/strong&gt;的现象,若无&lt;strong&gt;外力&lt;/strong&gt;作用,它们都将无法推进下去.&lt;/p&gt;
&lt;h2 id=&quot;二、产生死锁的原因&quot;&gt;&lt;a href=&quot;#二、产生死锁的原因&quot; class=&quot;headerlink&quot; title=&quot;二、产生死锁的原因:&quot;&gt;&lt;/a&gt;二、产生死锁的原因:&lt;/h2&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://zzwwqq.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="https://zzwwqq.xyz/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Android之活动</title>
    <link href="https://zzwwqq.xyz/Android%E4%B9%8B%E6%B4%BB%E5%8A%A8.html"/>
    <id>https://zzwwqq.xyz/Android之活动.html</id>
    <published>2019-04-02T13:31:03.000Z</published>
    <updated>2019-04-03T08:25:55.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、活动的基本用法"><a href="#一、活动的基本用法" class="headerlink" title="一、活动的基本用法:"></a>一、活动的基本用法:</h2><p>项目名可以叫做 ActivityTest ,为了手动创建活动 <strong>不再勾选 Create Activity</strong></p><h3 id="1-1-手动创建活动"><a href="#1-1-手动创建活动" class="headerlink" title="1.1 手动创建活动:"></a>1.1 手动创建活动:</h3><p>src 目录下先添加一个包,使用的默认包名com.example.activitytest<br>新建FirstActivity 类继承自 Activity<br>任何活动都应该重写 Activity 的 onCreate()方法</p><h3 id="1-2-创建布局"><a href="#1-2-创建布局" class="headerlink" title="1.2 创建布局"></a>1.2 创建布局</h3><p>每一个活动对应一个布局，布局就是用来显示界面内容<br>在res/layout 目录下新建 名为first_layout.xml的文件(菜单中点击Android XMLFile),根元素就默认选择为 LinearLayout</p><p><strong>添加一个按钮:</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_1"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>XML 中引用一个 id，就使用@id/id_name 这种语法<br>XML 中定义一个 id，则要使用@+id/id_name 这种语法<br>android:layout_width 指定了当前元素的宽度，match_parent表示让当前元素和父元素一样宽。<br>android:layout_height 指定了高度， wrap_content，表示当前元素的高度只要能刚好包含里面的内容就行。<br>android:text 指定了元素中显示的文字内容</p><h3 id="1-3-在活动中加载这个布局"><a href="#1-3-在活动中加载这个布局" class="headerlink" title="1.3 在活动中加载这个布局:"></a>1.3 在活动中加载这个布局:</h3><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            setContentView(R.layout.first_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中添加的任何资源都会在 R 文件中生成一个相应的资源 id，因此我们刚才创建的 first_layout.xml 布局的 id 现在应该是已经添加到 R 文件中了。<br><strong>在代码中引用布局文件:  R.layout.first_layout </strong><br><strong>注意: </strong>这里我们使用的 R，是com.example.activitytest 包下的 R 文件<br>Android SDK 还会自动提供一个 android 包下的 R 文件，千万别使用错了。</p><h3 id="1-4-在-AndroidManifest-文件中注册"><a href="#1-4-在-AndroidManifest-文件中注册" class="headerlink" title="1.4 在 AndroidManifest 文件中注册:"></a>1.4 在 AndroidManifest 文件中注册:</h3><p>所有的活动都要在 AndroidManifest.xml 中进行注册才能生效    </p><p>在AndroidManifest.xml 来给 FirstActivity 注册:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"com.example.activitytest"</span> &gt;</span><br><span class="line">....</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">....</span><br><span class="line">&lt;activity</span><br><span class="line"><span class="comment">/*.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity 的</span></span><br><span class="line"><span class="comment">缩写由于最外层的&lt;manifest&gt;标签中已经通过 package 属性指定了程序的包名是</span></span><br><span class="line"><span class="comment">             com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">             android:label=<span class="string">"This is FirstActivity"</span> &gt;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果你想让 FirstActivity 作为我们这个程序的主活动，即点击桌面应用程序图标时首先打开的就是这</span></span><br><span class="line"><span class="comment">             个活动，那就一定要加入下面这两句声明。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他的应用在内部进行调用的，如支付宝快捷支付服务。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>活动的注册声明要放在<code>&lt;application&gt;</code>标签内, 通过<code>&lt;activity&gt;</code>标签来对活动进行注册的<br>android:name 来指定具体注册哪一个活动<br>android:label指定活动中标题栏的内容</p><h3 id="1-5-隐藏标题栏"><a href="#1-5-隐藏标题栏" class="headerlink" title="1.5 隐藏标题栏"></a>1.5 隐藏标题栏</h3><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注意这句代码一定要在 setContentView()之前执行，不然会报错</span></span><br><span class="line">    requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-在活动中使用-Toast"><a href="#1-6-在活动中使用-Toast" class="headerlink" title="1.6 在活动中使用 Toast:"></a>1.6 在活动中使用 Toast:</h3><p>toast是什么?<br>界面弹出短小的信息通知给用户，这些信息会在一段时间后自动消失</p><p>首先需要定义一个弹出 Toast 的触发点,    如点击按钮的时候弹出一个 Toast </p><p>FirstActivity类的 onCreate()方法中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// findViewById()方法获取在布局文件中定义的元素，传入 R.id.button_1，来得到按钮的实例</span></span><br><span class="line">        Button button1 = (Button) findViewById(R.id.button_1);<span class="comment">//findViewById返回的是一个 View 对象</span></span><br><span class="line">        <span class="comment">//注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法</span></span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* makeText()创建出一个 Toast对象, show()是将 Toast 显示出来</span></span><br><span class="line"><span class="comment">            第一个参数是 Context，也就是 Toast 要求的上下文，活动本身就是一个 Context 对象</span></span><br><span class="line"><span class="comment">            第二个参数是Toast显示的文本内容</span></span><br><span class="line"><span class="comment">            第三个参数是Toast显示的时长</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Toast.makeText(FirstActivity.<span class="keyword">this</span>, <span class="string">"You clicked Button 1"</span>,</span><br><span class="line">                           Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-在活动中使用-Menu"><a href="#1-7-在活动中使用-Menu" class="headerlink" title="1.7 在活动中使用 Menu"></a>1.7 在活动中使用 Menu</h3><p>在 res 目录下新建一个 menu 文件夹<br>新建一个 main.xml 文件(点击Android XML File)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line"><span class="comment">//&lt;item&gt;标签就是用来创建具体的某一个菜单项</span></span><br><span class="line">    &lt;item</span><br><span class="line">         <span class="comment">//给这个菜单项指定一个唯一标识符，</span></span><br><span class="line">android:id=<span class="string">"@+id/add_item"</span></span><br><span class="line">         <span class="comment">//给这个菜单项指定一个名称</span></span><br><span class="line">android:title=<span class="string">"Add"</span>/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><p>然后打开 FirstActivity类，重写 onCreateOptionsMenu()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* inflate()方法就可以给当前活动创建菜单</span></span><br><span class="line"><span class="comment">    第一个参数:通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main</span></span><br><span class="line"><span class="comment">    第二个参数:用于指定我们的菜单项将添加到哪一个 Menu对象当中，这里直接使用 onCreateOptionsMenu()方法中传</span></span><br><span class="line"><span class="comment">    入的 menu参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="comment">//返回 true，表示允许创建的菜单显示出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义菜单响应事件"><a href="#定义菜单响应事件" class="headerlink" title="定义菜单响应事件:"></a>定义菜单响应事件:</h3><p> FirstActivity 中重写 onOptionsItemSelected()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// item.getItemId()来判断我们点击的是哪一个菜单项</span></span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Add"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Remove"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-销毁一个活动"><a href="#1-8-销毁一个活动" class="headerlink" title="1.8 销毁一个活动:"></a>1.8 销毁一个活动:</h3><p>Activity 类提供了一个 finish()方法:</p><p>打开 FirstActivity类,onCreate方法中, 修改按钮监听器中的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//重新运行程序，这时点击一下按钮，当前的活动就被成功销毁了，效果和按下 Back 键是一样的。</span></span><br></pre></td></tr></table></figure><h2 id="二、使用-Intent-在活动之间穿梭"><a href="#二、使用-Intent-在活动之间穿梭" class="headerlink" title="二、使用 Intent 在活动之间穿梭:"></a>二、使用 Intent 在活动之间穿梭:</h2><h3 id="2-1-使用显式-Intent"><a href="#2-1-使用显式-Intent" class="headerlink" title="2.1 使用显式 Intent:"></a>2.1 使用显式 Intent:</h3><p>Intent的“意图”非常明显，因此我们称之为显式 Intent</p><p>在 ActivityTest 项目中再创建一个活动。新建一个 second_layout.xml 布局文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//定义了一个按钮，按钮上显示 Button 2</span></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_2"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 2"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建活动 SecondActivity 继承自Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 AndroidManifest.xml 中为 SecondActivity 进行注册。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">   ...&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">android:label=<span class="string">"This is FirstActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"><span class="comment">// SecondActivity 不是主活动，因此不需要配置&lt;intent-filter&gt;标签里的内容</span></span><br><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure><p><strong>Intent 一般可被用于启动活动、启动服务、以及发送广播等场景</strong><br>Intent 是 各组件之间进行<strong>交互</strong>的一种重要方式，它可以<strong>指明</strong>当前组件想要<strong>执行的动作</strong>，还可以在不同组件之间<strong>传递数据</strong></p><p>Intent(Context packageContext, Class&lt;?&gt; cls):<br>这个构造函数接收两个参数，第一个参数: 启动活动的上下文，第二个参数 指定想要启动的目标活动</p><p>Activity 类中 startActivity()方法，用于启动活动的，它接收一个Intent参数</p><p>修改 FirstActivity 中按钮的点击事件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在FirstActivity活动的基础上打开 SecondActivity活动,startActivity()方法来执行这个Intent</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-使用隐式-Intent"><a href="#2-2-使用隐式-Intent" class="headerlink" title="2.2 使用隐式 Intent:"></a>2.2 使用隐式 Intent:</h3><p><strong>不明确指出</strong>我们想要启动哪一个活动，而是指定了一系列更为抽象的 action和 category等信息,<strong>由系统去分析Intent</strong>，并找出合适的活动(响应隐式 Intent的活动)去启动</p><p> AndroidManifest.xml添加如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    <span class="comment">//指明当前活动可以响应 ACTION_START这个 action</span></span><br><span class="line">&lt;action android:name=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span><br><span class="line">         <span class="comment">// 精确地指明当前的活动能够响应的 Intent 中还可能带有的 category  </span></span><br><span class="line">&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"><span class="comment">//只有&lt;action&gt;和&lt;category&gt;中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent。</span></span><br></pre></td></tr></table></figure><p>修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用了Intent 的另一个构造函数,传入action的字符串,表明要启动能够响应ACTION_START这个action的活动</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注: &lt;action&gt;和&lt;category&gt;同时匹配上才能响应,而这里没有指定category,这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中</span></span><br></pre></td></tr></table></figure><p><strong>每个 Intent 中只能指定一个 action，但却能指定多个 category</strong></p><p>修改 FirstActivity 中按钮的点击事件,增加一个category</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        <span class="comment">// addCategory()方法来添加一个 category</span></span><br><span class="line">        intent.addCategory(<span class="string">"com.example.activitytest.MY_CATEGORY"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中 SecondActivity的<code>&lt;intent-filter&gt;</code>中再添加一个 category 的声明:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">....</span><br><span class="line">&lt;category android:name=<span class="string">"com.example.activitytest.MY_CATEGORY"</span>/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-更多隐式-Intent-的用法"><a href="#2-3-更多隐式-Intent-的用法" class="headerlink" title="2.3 更多隐式 Intent 的用法"></a>2.3 更多隐式 Intent 的用法</h3><p>修改 FirstActivity 中按钮点击事件的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器来打开这个网页就行了</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Intent.ACTION_VIEW，这是一个 Android 系统内置的动作</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        <span class="comment">// Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以在<code>&lt;intent-filter&gt;</code>标签中再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容:</p><p>android:scheme<br>用于指定数据的协议部分，如上例中的 http 部分</p><p><strong>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data完全一致时，当前活动才能够响应该 Intent。</strong><br>如上面浏览器示例中，其实只需要<strong>指定 android:scheme 为 http，就可以响应所有的 http 协议的 Intent 了</strong>。</p><h3 id="2-4-自己建立一个活动，让它也能响应打开网页的Intent"><a href="#2-4-自己建立一个活动，让它也能响应打开网页的Intent" class="headerlink" title="2.4 自己建立一个活动，让它也能响应打开网页的Intent"></a>2.4 自己建立一个活动，让它也能响应打开网页的Intent</h3><p>新建 third_layout.xml 布局文件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">android:orientation=<span class="string">"vertical"</span> &gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=<span class="string">"@+id/button_3"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">android:text=<span class="string">"Button 3"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>新建活动 ThirdActivity 类继承自 Activity<br>将布局添加到活动中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.third_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 AndroidManifest.xml 中为 ThirdActivity 进行注册</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".ThirdActivity"</span> &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">     &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">          <span class="comment">//数据的协议必须是 http协议</span></span><br><span class="line">          &lt;data android:scheme=<span class="string">"http"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p><strong>调用系统拨号界面</strong></p><p>除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示<br>拨打电话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL);</span><br><span class="line">        <span class="comment">// data部分指定了协议是 tel，号码是 10086</span></span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-5-向下一个活动传递数据"><a href="#2-5-向下一个活动传递数据" class="headerlink" title="2.5 向下一个活动传递数据:"></a>2.5 向下一个活动传递数据:</h3><p> Intent 还可以在启动活动的时候传递数据, </p><p>putExtra()的重载，可把想要传递的数据暂存在 Intent 中，启动另一个活动后，只需把这些数据从Intent 中取出就可</p><p>SecondActivity 类中,修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstActivity 中有一个字符串，现在想把这个字符串传递到SecondActivity中</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String data = <span class="string">"Hello SecondActivity"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">//第一个参数是键,用于后面从 Intent中取值，第二个参数才是真正要传递的数据。</span></span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>, data);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// getIntent()方法获取到用于启动 SecondActivity 的 Intent</span></span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        <span class="comment">//如果传递的是布尔型数据，则使用 getBooleanExtra()方法</span></span><br><span class="line">        <span class="comment">//getStringExtra()方法，传入相应的键值，就可以得到传递的数据了</span></span><br><span class="line">        String data = intent.getStringExtra(<span class="string">"extra_data"</span>);</span><br><span class="line">        Log.d(<span class="string">"SecondActivity"</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-返回数据给上一个活动"><a href="#2-6-返回数据给上一个活动" class="headerlink" title="2.6 返回数据给上一个活动:"></a>2.6 返回数据给上一个活动:</h3><p>Activity 中 <strong>startActivityForResult()</strong>方法也是用于<strong>启动活动</strong>的，但这个方法期望在活动<strong>销毁的时</strong>候能够<strong>返回一个结果给上一个活动</strong>。</p><p>修改 FirstActivity 中按钮的点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">//第一个参数还是 Intent,第二个参数是请求码，用于在之后的回调中判断数据的来源,请求码只要是一个唯一值就可以了</span></span><br><span class="line">        startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SecondActivity 中给按钮注册点击事件并在点击事件中添加返回数据的逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.second_layout);</span><br><span class="line">        Button button2 = (Button) findViewById(R.id.button_2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">                intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">                <span class="comment">//setResult()专门用于向上一个活动返回数据的</span></span><br><span class="line">                <span class="comment">//第一个参数用于向上一个活动返回处理结果,第二个参数则是把带有数据的 Intent 传递回去</span></span><br><span class="line">                setResult(RESULT_OK, intent);</span><br><span class="line">                <span class="comment">//销毁当前活动</span></span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重写这个方法来得到返回的数据，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数 requestCode，启动活动时传入的请求码,</span></span><br><span class="line"><span class="comment">//第二个参数 resultCode，返回数据时传入的处理结果</span></span><br><span class="line"><span class="comment">//第三个参数 data，即携带着返回数据的 Intent</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到 onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作</p><p>如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下Back 键回到 FirstActivity，这样数据不就没法返回了吗？没错，不过这种情况还是很好处理的，我们可以通过重写 onBackPressed()方法来解决这个问题，代码如下所示：</p><p>SecondActivity 类中修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的话，当用户按下 Back 键，就会去执行 onBackPressed()方法中的代码，我们在这里添加返回数据的逻辑就行了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">    setResult(RESULT_OK, intent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-活动的生命周期"><a href="#2-7-活动的生命周期" class="headerlink" title="2.7 活动的生命周期:"></a>2.7 活动的生命周期:</h3><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.5.png" alt></p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期中最多可能会有四种状态。<br>运行状态:位于返回栈的栈顶时<br>暂停状态:不再处于栈顶位置，但仍然可见<br>停止状态:不再处于栈顶位置，并且完全不可见<br>销毁状态:从返回栈中移除后就变成了销毁状态</p><h3 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h3><p>Activity 类中定义了七个回调方法:</p><p>onCreate():<br>每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</p><p>onStart():<br>在活动由不可见变为可见的时候调用</p><p>onResume():<br>在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</p><p>onPause():<br>准备去启动或者恢复另一个活动的时候调用</p><p>onStop():<br>在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。</p><p>onDestroy():<br>活动被销毁之前调用</p><p>onRestart():<br>活动由停止状态变为运行状态之前调用</p><p><img src="http://cdn.zzwwqq.xyz/static/images/Android/Android-1.6.png" alt></p><h3 id="2-6-活动被回收了怎么办"><a href="#2-6-活动被回收了怎么办" class="headerlink" title="2.6 活动被回收了怎么办"></a>2.6 活动被回收了怎么办</h3><p>Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p><p>onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法<br>用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数据，<br>以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，<br>第二个参数是真正要保存的内容。<br>在 MainActivity 中添加如下代码就可以将临时数据进行保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">String tempData = <span class="string">"Something you just typed"</span>;</span><br><span class="line">outState.putString(<span class="string">"data_key"</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我<br>们一直使用的 onCreate()方法其实也有一个 Bundle类型的参数。这个参数在一般情况下都是<br>null，但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参<br>数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。<br>修改 MainActivity 的 onCreate()方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String tempData = savedInstanceState.getString(<span class="string">"data_key"</span>);</span><br><span class="line">        Log.d(TAG, tempData);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-活动的启动模式"><a href="#2-7-活动的启动模式" class="headerlink" title="2.7 活动的启动模式"></a>2.7 活动的启动模式</h3><p>启动模式一共有四种，分别是 standard、singleTop、singleTask 和 singleInstance​    </p><p>AndroidManifest.xml 中通 过给<code>&lt;activity&gt;</code> 标签 指定android:launchMode属性来选择启动模式</p><p>standard</p><p>活动默认的启动模式,系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</p><p>singleTop</p><p>在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</p><p>修改 AndroidManifest.xml 中 FirstActivity 的启动模式，<br>如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">android:launchMode=<span class="string">"singleTop"</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>singleTask</p><p>很好地解决重复创建栈顶活动的问题</p><p>singleInstance</p><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、活动的基本用法&quot;&gt;&lt;a href=&quot;#一、活动的基本用法&quot; class=&quot;headerlink&quot; title=&quot;一、活动的基本用法:&quot;&gt;&lt;/a&gt;一、活动的基本用法:&lt;/h2&gt;&lt;p&gt;项目名可以叫做 ActivityTest ,为了手动创建活动 &lt;strong&gt;不
      
    
    </summary>
    
      <category term="Android" scheme="https://zzwwqq.xyz/categories/Android/"/>
    
    
      <category term="Android之活动" scheme="https://zzwwqq.xyz/tags/Android%E4%B9%8B%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://zzwwqq.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zzwwqq.xyz/设计模式之适配器模式.html</id>
    <published>2019-04-02T08:44:27.000Z</published>
    <updated>2019-04-02T09:10:19.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是适配器模式"><a href="#一、什么是适配器模式" class="headerlink" title="一、什么是适配器模式?"></a>一、什么是适配器模式?</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br>举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><a id="more"></a><h2 id="二、-分类"><a href="#二、-分类" class="headerlink" title="二、 分类:"></a>二、 分类:</h2><h3 id="2-1-类的适配器模式"><a href="#2-1-类的适配器模式" class="headerlink" title="2.1 类的适配器模式:"></a>2.1 类的适配器模式:</h3><p><strong>使用步骤:</strong><br>步骤1： 创建Target接口<br>步骤2： 创建源类（Adaptee）<br>步骤3： 创建适配器类Adapter (适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。)<br>步骤4： 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</p><h3 id="2-2-对象的适配器模式"><a href="#2-2-对象的适配器模式" class="headerlink" title="2.2 对象的适配器模式:"></a>2.2 对象的适配器模式:</h3><p><strong>原理:</strong><br>与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。<br><strong>步骤:</strong><br>①: 创建Target接口<br>②: 创建源类（Adaptee）<br>③: 创建适配器类（Adapter）（不适用继承而是委派）<br>④: 定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</p><h3 id="2-3-对象的适配器模式与类的适配器模式比较"><a href="#2-3-对象的适配器模式与类的适配器模式比较" class="headerlink" title="2.3 对象的适配器模式与类的适配器模式比较:"></a>2.3 对象的适配器模式与类的适配器模式比较:</h3><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。</p><h3 id="2-4-什么时候用类的适配器模式"><a href="#2-4-什么时候用类的适配器模式" class="headerlink" title="2.4 什么时候用类的适配器模式?"></a>2.4 什么时候用类的适配器模式?</h3><p> ①: 仅仅希望使用方便时<br>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。<br>对于对象适配器，需要额外的引用来间接得到Adaptee。<br>②: 需要重新定义Adaptee的部分行为<br>对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。<br>对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</p><h3 id="2-5-什么时候用对象的适配器模式"><a href="#2-5-什么时候用对象的适配器模式" class="headerlink" title="2.5 什么时候用对象的适配器模式?"></a>2.5 什么时候用对象的适配器模式?</h3><p>①: 灵活使用时<br>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。<br>②: 需要同时配源类和其子类<br>对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了；</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结:"></a>2.6 总结:</h3><p>建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。</p><h2 id="三、主要作用"><a href="#三、主要作用" class="headerlink" title="三、主要作用:"></a>三、主要作用:</h2><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p><h2 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点:"></a>三、优点:</h2><p>①: 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。<br>②: 解耦性:    将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码<br>③: 符合开放-关闭原则:  同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类<br>④: 更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。<br>⑤: 透明、简单:  客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接, 过多的使用适配器，会让系统非常零乱，不易整体进行把握</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景:"></a>四、应用场景:</h2><p>系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><h2 id="五、实例"><a href="#五、实例" class="headerlink" title="五、实例:"></a>五、实例:</h2><p>背景：小成买了一个进口的电视机<br>冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容<br>解决方案：设置一个适配器将插头输出的220V转变成110V</p><p><strong>使用类的适配器模式解题:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将220V转换输出110V（原有插头（Adaptee）没有的）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建源类（Adaptee）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerPort220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原有的插口只能输出220V</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OutPut_220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）</span></span><br><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter220V</span> <span class="keyword">extends</span> <span class="title">PowerPort220V</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//期待的插头要求调用Convert_110v()，但原有插头没有</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.OutPut_220V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="comment">//通过Adapter类从而调用所需要的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用户拿着进口机器插上适配器（调用Convert_110v()方法）</span></span><br><span class="line">        <span class="comment">//再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V）</span></span><br><span class="line">        <span class="comment">//适配器只是个外壳，对外提供110V，但本质还是220V进行供电</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter220V();</span><br><span class="line">        target.Convert_110V();</span><br><span class="line">        ImportMachine importMachine =  <span class="keyword">new</span> ImportMachine();</span><br><span class="line">        importMachine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进口机器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImportMachine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进口机器正常工作!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的适配器模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//源类Adapteree没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤2： 创建源类（Adaptee） ；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapteree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤3： 创建适配器类（com.zwq.类的设计模式.Adapter）</span></span><br><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(com.zwq.类的设计模式.Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adapteree</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的</span></span><br><span class="line"><span class="comment">//4.定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的适配器模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapteree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapteree adapteree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接关联被适配类Adapteree</span></span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adapteree adapteree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapteree = adapteree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里是使用委托的方式完成特殊功能</span></span><br><span class="line">        <span class="keyword">this</span>.adapteree.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adapteree());</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是适配器模式&quot;&gt;&lt;a href=&quot;#一、什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是适配器模式?&quot;&gt;&lt;/a&gt;一、什么是适配器模式?&lt;/h2&gt;&lt;p&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。&lt;br&gt;这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。&lt;br&gt;举个真实的例子: 读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zzwwqq.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式之适配器模式" scheme="https://zzwwqq.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="https://zzwwqq.xyz/%E5%BA%94%E7%94%A8%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/应用层.html</id>
    <published>2019-04-02T03:06:32.000Z</published>
    <updated>2019-04-08T08:03:06.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、应用层协议"><a href="#一、应用层协议" class="headerlink" title="一、应用层协议:"></a>一、应用层协议:</h2><p>应用层的许多协议是基于客户服务器方式的</p><h3 id="1-1-DNS"><a href="#1-1-DNS" class="headerlink" title="1.1 DNS:"></a>1.1 DNS:</h3><p><strong>1.1.1 是什么? </strong><br>DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。<br><a id="more"></a></p><p><strong>1.1.2 作用:</strong><br>用于域名解析服务,将域名(机器名) 转换为 IP地址<br><strong>1.1.3 原理: </strong><br>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。<br>客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。<br><strong>1.1.4 特点:</strong><br><strong>基于UDP服务</strong>，该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。<strong>端口号53</strong><br>DNS 可以使用 UDP 或者 TCP 进行传输，大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性<br><strong>1.1.5 在两种情况下会使用 TCP 进行传输：</strong></p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h3 id="1-2-HTTP"><a href="#1-2-HTTP" class="headerlink" title="1.2 : HTTP:"></a>1.2 : HTTP:</h3><p><strong>1.2.1 是什么? </strong><br>这是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页<br><strong>1.2.2 特点: </strong><br>本身是<strong>无连接，无状态的</strong>,使用<strong>TCP</strong>连接进行可靠的传送</p><h3 id="1-3-FTP"><a href="#1-3-FTP" class="headerlink" title="1.3 : FTP:"></a>1.3 : FTP:</h3><p><strong>1.3.1 是什么? </strong><br>文件传输协议<br><strong>1.3.2 特点: </strong><br>提供交互式的访问 ,基于<strong>客户服务器模式</strong>，<strong>面向连接 </strong>,<strong>使用TCP</strong>可靠的运输服务 ,使用<strong>21端口</strong><br><strong>1.3.3 主要功能:</strong><br>减少/消除不同操作系统下文件的不兼容性 </p><p><strong>1.3.4 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</strong></p><ul><li>控制连接：服务器打开<strong>端口号 21</strong>等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。<strong>端口号20</strong></li></ul><p><strong>1.3.5 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</strong></p><ul><li><strong>主动模式：</strong>服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.3.png" alt></p><ul><li><strong>被动模式：</strong>客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.4.png" alt></p><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h3 id="1-4-简单文件传送协议TFTP"><a href="#1-4-简单文件传送协议TFTP" class="headerlink" title="1.4 : 简单文件传送协议TFTP:"></a>1.4 : 简单文件传送协议TFTP:</h3><p><strong>1.4.1 特点: </strong><br>客户服务器模式 ,使用UDP数据报 ,只支持文件传输，不支持交互 ,TFTP代码占内存小 </p><h3 id="1-5-TELNET"><a href="#1-5-TELNET" class="headerlink" title="1.5 : TELNET:"></a>1.5 : TELNET:</h3><p><strong>1.5.1 作用:</strong><br>用于远程登陆<br><strong>1.5.2 特点:</strong><br>客户服务器模式  <strong>使用23端口</strong>，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务,TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h3 id="1-6-简单网络管理协议（SNMP）"><a href="#1-6-简单网络管理协议（SNMP）" class="headerlink" title="1.6 : 简单网络管理协议（SNMP）:"></a>1.6 : 简单网络管理协议（SNMP）:</h3><p><strong>1.6.1 SNMP模型的4个组件：</strong><br>被管理结点、管理站、管理信息、管理协议<br><strong>1.6.2 SNMP代理：</strong><br>运行SNMP管理进程的被管理结点<br>对象：描述设备的变量<br>管理信息库（MIB）：保存所有对象的数据结构 </p><h3 id="1-7-DHCP"><a href="#1-7-DHCP" class="headerlink" title="1.7 : DHCP:"></a>1.7 : DHCP:</h3><p><strong>1.7.1 什么是DHCP?</strong></p><p>动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。<br>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。<br><strong>1.7.2 DHCP 工作过程如下：</strong></p><p>①: 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<br>②: DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。<br>③: 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。<br>④: DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.5.png" alt></p><h3 id="1-8-电子邮件协议"><a href="#1-8-电子邮件协议" class="headerlink" title="1.8 :电子邮件协议:"></a>1.8 :电子邮件协议:</h3><p>一个电子邮件系统由三部分组成：<br>用户代理、邮件服务器以及邮件协议。<br>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h3 id="1-8-1-SMTP"><a href="#1-8-1-SMTP" class="headerlink" title="1.8.1 : SMTP:"></a>1.8.1 : SMTP:</h3><p><strong>1.8.1.1 是什么? </strong><br>简单邮件传输协议<br><strong>1.8.1.2 作用: </strong><br>用于发送邮件。<br><strong>1.8.1.3 特点: </strong><br>Client/Server模式，面向连接 ,服务器开放的是<strong>25号端口。</strong>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。<br><strong>1.8.1.4 基本功能：</strong><br>写信、传送、报告传送情况、显示信件、接收方处理信件 </p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.7.png" alt></p><h3 id="1-8-2-POP3"><a href="#1-8-2-POP3" class="headerlink" title="1.8.2 : POP3:"></a>1.8.2 : POP3:</h3><p><strong>1.8.2.1 是什么? </strong><br>它是和SMTP对应<br><strong>1.8.2.2 作用: </strong><br>用于接收邮件<br><strong>1.8.2.3 特点: </strong><br>①: 只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。<br>②：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”。POP3协议所用的是<strong>110端口。</strong></p><h3 id="1-8-3-IMAP"><a href="#1-8-3-IMAP" class="headerlink" title="1.8.3 : IMAP:"></a>1.8.3 : IMAP:</h3><p><strong>1.8.3.1 作用: </strong><br>读取邮件<br><strong>1.8.3.2 特点: </strong><br>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.6.png" alt></p><h2 id="二、关于域名"><a href="#二、关于域名" class="headerlink" title="二、关于域名:"></a>二、关于域名:</h2><h3 id="2-1-域名规范"><a href="#2-1-域名规范" class="headerlink" title="2.1 域名规范:"></a>2.1 域名规范:</h3><p><strong>DNS规定:</strong><br>①: 域名中标号必须是英文或数字<br>②: 不区分大小写<br>③: 除连字符外不能用其他标点<br>④: 级别最低的域名写在最左边<br>⑤: 域名总长度不超过255个字符. </p><h3 id="2-2-域名分类"><a href="#2-2-域名分类" class="headerlink" title="2.2 域名分类:"></a>2.2 域名分类:</h3><p>顶级域名(TLD: TOP Level Domain):<br>①: 国家顶级域名:<br>　　　　　　　　cn代表中国 ,US代表美国<br>②:通用顶级域名:<br>　　　　　　　　com(公司,企业)<br>　　　　　　　　net(网络服务机构)<br>　　　　　　　　edu(教育机构)</p><p>mail.cctv.com: 其中com为一级域名(即顶级域名), cctv是二级域名,mail是三级域名.<br>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><h3 id="2-3-域名管理"><a href="#2-3-域名管理" class="headerlink" title="2.3 域名管理:"></a>2.3 域名管理:</h3><p>①: 在国家顶级域名下注册的二级域名均由该国家自由确定.<br>②: 各级域名由其上一级域名管理机构管理<br>③: 最高的顶级域名由ICANN管理<br><strong>注: 域名中的点与点分十进制IP地址中的点无一一对应的关系</strong></p><h3 id="2-4-为什么机器在处理IP数据报时要使用IP地址-而不用域名-机器名"><a href="#2-4-为什么机器在处理IP数据报时要使用IP地址-而不用域名-机器名" class="headerlink" title="2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?"></a>2.4 为什么机器在处理IP数据报时要使用IP地址,而不用域名(机器名)?</h3><p><strong>原因: </strong>IP地址长度固定(32位)而域名长度不固定,机器处理起来困难.</p><h2 id="三、关于域名服务器"><a href="#三、关于域名服务器" class="headerlink" title="三、关于域名服务器:"></a>三、关于域名服务器:</h2><p>一个域名服务器所负责管理的范围叫做<strong>区</strong>,每个区 设置相应的权限域名服务器<br>为了减轻根域名服务器的压力,域名服务器中广泛使用<strong>高速缓存.</strong></p><h3 id="3-1-域名服务器分类"><a href="#3-1-域名服务器分类" class="headerlink" title="3.1 域名服务器分类:"></a>3.1 域名服务器分类:</h3><p><strong>①: 根域名服务器: </strong><br>所有根域名服务器都知道所有顶级域名服务器的域名和IP地址<br><strong>②: 顶级域名服务器: </strong><br>管理在该顶级域名服务器下注册的所有二级域名,当收到查询请求,就给出查询结果,或者下一步应当找的域名服务器地址<br><strong>③: 权限域名服务器: </strong><br>负责一个区的域名服务器,当它不能给出最后的查询结果时,就告诉客户下一步应当查找哪个权限域名服务器<br><strong>④: 本地域名服务器: </strong><br>离用户较近,一般不超过几个路由器的距离</p><p><strong>迭代查询: </strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.1.png" alt></p><p><strong>递归查询:</strong><br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-7.2.png" alt></p><h2 id="四、常用端口"><a href="#四、常用端口" class="headerlink" title="四、常用端口:"></a>四、常用端口:</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用</td><td>应用层协议</td><td>端口号</td><td>传输层协议</td><td>备注</td></tr><tr><td>域名解析</td><td><strong>DNS</strong></td><td>53</td><td>UDP/TCP</td><td>长度超过 512 字节时使用 TCP</td></tr><tr><td>动态主机配置协议</td><td>DHCP</td><td>67/68</td><td>UDP</td><td></td></tr><tr><td>简单网络管理协议</td><td>SNMP</td><td>161/162</td><td>UDP</td><td></td></tr><tr><td>文件传送协议</td><td><strong>FTP</strong></td><td>20/21</td><td>TCP</td><td>控制连接 21，数据连接 20</td></tr><tr><td>远程终端协议</td><td><strong>TELNET</strong></td><td>23</td><td>TCP</td><td></td></tr><tr><td>超文本传送协议</td><td>HTTP</td><td>80</td><td>TCP</td><td></td></tr><tr><td></td><td><strong>HTTPS</strong></td><td><strong>443</strong></td><td></td><td></td></tr><tr><td>简单邮件传送协议</td><td><strong>SMTP</strong></td><td>25</td><td>TCP</td><td></td></tr><tr><td>邮件读取协议</td><td><strong>POP3</strong></td><td>110</td><td>TCP</td><td></td></tr><tr><td>网际报文存取协议</td><td><strong>IMAP</strong></td><td>143</td><td>TCP</td></tr></tbody></table><h2 id="五、Web-页面请求过程"><a href="#五、Web-页面请求过程" class="headerlink" title="五、Web 页面请求过程:"></a>五、Web 页面请求过程:</h2><h3 id="5-1-DHCP-配置主机信息"><a href="#5-1-DHCP-配置主机信息" class="headerlink" title="5.1 DHCP 配置主机信息:"></a>5.1 DHCP 配置主机信息:</h3><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。<br>①: <strong>主机生成一个 DHCP 请求报文</strong>，并将这个报文<strong>放入</strong>具有目的端口 67 和源端口 68 的 <strong>UDP 报文段</strong>中。<br>②: 该报文段则被放入在一个具有<strong>广播 IP</strong> 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 <strong>IP 数据报</strong>中。<br>③: 该数据报则被放置在<strong>MAC 帧</strong>中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。<br>④: 连接在交换机的 DHCP 服务器收到广播帧之后，<strong>不断地向上分解</strong>得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。<br>⑤: 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。<br>⑥: 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p><h3 id="5-2-ARP-解析-MAC-地址"><a href="#5-2-ARP-解析-MAC-地址" class="headerlink" title="5.2 ARP 解析 MAC 地址"></a>5.2 ARP 解析 MAC 地址</h3><p>①: 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。<br>②: 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。<br>③: 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中<br>④: 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。<br>⑤: DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。<br>⑥: 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。<br>⑦: 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p><h3 id="5-3-DNS-解析域名"><a href="#5-3-DNS-解析域名" class="headerlink" title="5.3 DNS 解析域名:"></a>5.3 DNS 解析域名:</h3><p>①: 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。<br>②: 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。<br>③: 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。<br>④: 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。<br>⑤: 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p><h3 id="5-4-HTTP-请求页面"><a href="#5-4-HTTP-请求页面" class="headerlink" title="5.4  HTTP 请求页面:"></a>5.4  HTTP 请求页面:</h3><p>①: 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。<br>②: 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。<br>③: HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。<br>④: 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。<br>⑤: HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。<br>⑥: 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p><h2 id="六、应用层功能"><a href="#六、应用层功能" class="headerlink" title="六、应用层功能:"></a>六、应用层功能:</h2><p>负责对软件提供接口以使程序能使用网络服务</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、应用层协议&quot;&gt;&lt;a href=&quot;#一、应用层协议&quot; class=&quot;headerlink&quot; title=&quot;一、应用层协议:&quot;&gt;&lt;/a&gt;一、应用层协议:&lt;/h2&gt;&lt;p&gt;应用层的许多协议是基于客户服务器方式的&lt;/p&gt;
&lt;h3 id=&quot;1-1-DNS&quot;&gt;&lt;a href=&quot;#1-1-DNS&quot; class=&quot;headerlink&quot; title=&quot;1.1 DNS:&quot;&gt;&lt;/a&gt;1.1 DNS:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.1.1 是什么? &lt;/strong&gt;&lt;br&gt;DNS 全名叫 Domain Name Server，中文俗称“域名服务器”,在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="应用层" scheme="https://zzwwqq.xyz/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="https://zzwwqq.xyz/%E4%BC%A0%E8%BE%93%E5%B1%82.html"/>
    <id>https://zzwwqq.xyz/传输层.html</id>
    <published>2019-04-01T13:08:40.000Z</published>
    <updated>2019-04-08T08:05:33.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传输层协议"><a href="#一、传输层协议" class="headerlink" title="一、传输层协议:"></a>一、传输层协议:</h2><p>TCP协议,UDP协议,SPX协议</p><h3 id="10-1-关于TCP协议"><a href="#10-1-关于TCP协议" class="headerlink" title="10.1 关于TCP协议:"></a>10.1 关于TCP协议:</h3><p><strong>特点:</strong><br>①: 面向连接<br>②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点</p><p><strong>使用场合: </strong>一般用于传输数据量少,且对可靠性要求高的场合.</p><a id="more"></a><p><strong>注: 这2个端点并不是主机,也不是主机的IP地址,不是应用进程,也不是运输层协议端口, 而是指 套接字 </strong><br>③: 提供可靠交付服务: 无差错 ,  不丢失  ,   不重复  ,  按序到达<br>④: 全双工<br>⑤: 拥塞控制,流量控制<br>⑥: 检错, 分用复用<br>⑦: 面向字节流: (把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)<br>套接字socket = IP地址  ：端口号</p><h3 id="10-2-使用TCP协议的各种应用层协议："><a href="#10-2-使用TCP协议的各种应用层协议：" class="headerlink" title="10.2 使用TCP协议的各种应用层协议："></a>10.2 使用TCP协议的各种应用层协议：</h3><p>SMTP: 简单邮件传送协议<br>TELNET: 远程终端协议<br>HTTP: 超文本传输协议<br>FTP: 文件传送协议</p><h3 id="10-3-TCP首部格式"><a href="#10-3-TCP首部格式" class="headerlink" title="10.3 TCP首部格式:"></a>10.3 TCP首部格式:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.2.png" alt></p><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="10-4-关于UDP协议"><a href="#10-4-关于UDP协议" class="headerlink" title="10.4 关于UDP协议:"></a>10.4 关于UDP协议:</h3><p><strong>特点:</strong></p><p>①: 无连接: 发数据前不需要建立连接(即不需要使用套接字(即 IP: 端口号)来建立连接)<br>②: 交互通信: 一对多,一对一,多对一,多对多等<br>③: 尽最大努力交付(不可靠)<br>④: 首部开销小,8字节  而TCP是20字节<br>⑤: 无拥塞控制<br>⑥: 检错, 分用复用<br>⑦: 面向报文: UDP一次交付一个完整报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)</p><h3 id="10-5-UDP首部格式"><a href="#10-5-UDP首部格式" class="headerlink" title="10.5 UDP首部格式:"></a>10.5 UDP首部格式:</h3><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.1.png" alt></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><p><strong>使用场合: </strong>一般用于传输数据量大,且对可靠性要求不是很高,但要求速度快的场合.</p><h2 id="二、传输层数据单元"><a href="#二、传输层数据单元" class="headerlink" title="二、传输层数据单元:"></a>二、传输层数据单元:</h2><p>数据段</p><h2 id="三、关于端口"><a href="#三、关于端口" class="headerlink" title="三、关于端口:"></a>三、关于端口:</h2><p>运输层用16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标记本计算机应用层中各个进程在和运输层交互时的层间接口</p><h2 id="四、传输层功能"><a href="#四、传输层功能" class="headerlink" title="四、传输层功能:"></a>四、传输层功能:</h2><p>①: 负责源-目的（端-端）（进程间）完整报文传输<br>②: 分段与重组<br>③: SAP寻址: 确保将完整报文提交给正确进程，如端口号<br>④: 连接控制<br>⑤: 流量控制<br>⑥: 差错控制<br>⑦: 确保数据可靠,顺序,无错地从A点传输到B点</p><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="五、TCP-可靠传输"><a href="#五、TCP-可靠传输" class="headerlink" title="五、TCP 可靠传输:"></a>五、TCP 可靠传输:</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.3.png" alt></p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：<br><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.4.png" alt></p><p>其中 RTTd 为偏差的加权平均值。</p><h2 id="六、TCP-滑动窗口"><a href="#六、TCP-滑动窗口" class="headerlink" title="六、TCP 滑动窗口:"></a>六、TCP 滑动窗口:</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.5.png" alt></p><h2 id="七、TCP-流量控制"><a href="#七、TCP-流量控制" class="headerlink" title="七、TCP 流量控制:"></a>七、TCP 流量控制:</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="八、TCP-拥塞控制"><a href="#八、TCP-拥塞控制" class="headerlink" title="八、TCP 拥塞控制:"></a>八、TCP 拥塞控制:</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br>拥塞窗口的大小取决于网络的拥塞程度<br>判断网络拥塞的依据是出现了超时.<br>发送方的发送窗口 =  拥塞窗口.</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.8.png" alt></p><p><strong>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</strong></p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.6.png" alt></p><h3 id="8-1-慢开始与拥塞避免"><a href="#8-1-慢开始与拥塞避免" class="headerlink" title="8.1 慢开始与拥塞避免"></a>8.1 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="8-2-快重传与快恢复"><a href="#8-2-快重传与快恢复" class="headerlink" title="8.2. 快重传与快恢复"></a>8.2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src="http://cdn.zzwwqq.xyz/static/images/计算机网络/计网-6.7.png" alt></p><p><strong>拥塞控制的具体流程: </strong></p><p>①: 初始拥塞窗口 cwnd  =  1</p><p>②: 发送方每收到一个确认就使cwnd = cwnd + 1;如果按照传输轮次考虑就是指数增长: 第一轮: cwnd =  1, 第二轮: cwnd =  2, 第三轮: cwnd =  4, …….第N轮: cwnd =  2^N</p><p>cwnd &lt; ssthresh 时,使用慢开始</p><p>cwnd = ssthresh 时,既可以使用慢开始,也可以使用拥塞避免算法</p><p>cwnd &gt;= ssthresh 时,使用拥塞避免算法</p><p>③: 网络超时时: 使ssthresh = cwnd / 2<br>然后令 cwnd = 1 </p><p>然后进入慢开始阶段,步骤同上<br>④: 直到连续接收到三个重复确认,启动快重传(立即重传) </p><p>⑤: 启动快恢复算法 ssthresh = cwnd / 2</p><p>和cwnd=ssthresh</p><p>拥塞避免: 拥塞窗口控制为按照线性增长(每个传输轮次结束时,cwnd就增加1)</p><p><strong>快重传优点: </strong></p><p>可以使整个网络的吞吐量提高20%<br>尽早让发送方知道发生了个别报文段的丢失</p><p>规定: 发送方只要一连收到3个重复确认,就知道接收方确实未收到某个报文,应当立即重传(即快重传),这样就不会出现超时,发送方也就不会误认为出现了网络拥塞.</p><p><strong>快恢复: </strong><br>调整ssthresh = cwnd / 2<br>同时设置cwnd = ssthresh;<br>然后执行拥塞避免.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、传输层协议&quot;&gt;&lt;a href=&quot;#一、传输层协议&quot; class=&quot;headerlink&quot; title=&quot;一、传输层协议:&quot;&gt;&lt;/a&gt;一、传输层协议:&lt;/h2&gt;&lt;p&gt;TCP协议,UDP协议,SPX协议&lt;/p&gt;
&lt;h3 id=&quot;10-1-关于TCP协议&quot;&gt;&lt;a href=&quot;#10-1-关于TCP协议&quot; class=&quot;headerlink&quot; title=&quot;10.1 关于TCP协议:&quot;&gt;&lt;/a&gt;10.1 关于TCP协议:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt;&lt;br&gt;①: 面向连接&lt;br&gt;②: 每一条TCP连接只能是点对点的（一对一）也就是每个TCP连接只能有两个端点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场合: &lt;/strong&gt;一般用于传输数据量少,且对可靠性要求高的场合.&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="传输层" scheme="https://zzwwqq.xyz/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>交换机的基本配置</title>
    <link href="https://zzwwqq.xyz/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html"/>
    <id>https://zzwwqq.xyz/交换机的基本配置.html</id>
    <published>2019-04-01T11:05:44.000Z</published>
    <updated>2019-04-01T11:24:00.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、交换机的基本配置与管理："><a href="#一、交换机的基本配置与管理：" class="headerlink" title="一、交换机的基本配置与管理："></a>一、交换机的基本配置与管理：</h2><h3 id="10-1-交换机的管理方式："><a href="#10-1-交换机的管理方式：" class="headerlink" title="10.1 交换机的管理方式："></a>10.1 交换机的管理方式：</h3><p>基本分为两种: 带内管理和带外管理。<br><strong>带外管理: </strong>通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置<br><strong>带内管理: </strong>通过远程Telnet，拨号等方式属于带内管理<br><a id="more"></a></p><h2 id="二、交换机的命令行操作模式分类："><a href="#二、交换机的命令行操作模式分类：" class="headerlink" title="二、交换机的命令行操作模式分类："></a>二、交换机的命令行操作模式分类：</h2><p>①: 用户模式:  <code>Switch&gt;</code><br>②: 特权模式: <code>Switch#</code><br>③: 全局配置模式: <code>Switch(config)#</code><br>④: 端口模式: <code>Switch(config-if)#</code></p><h2 id="三、交换机命令行"><a href="#三、交换机命令行" class="headerlink" title="三、交换机命令行:"></a>三、交换机命令行:</h2><p>进入特权模式: <code>en</code><br>命令自动补齐: <code>Tab</code><br>进入全局配置模式: <code>configure terminal</code><br>命令简写：<code>conf  t</code><br>进入交换机端口视图模式: <code>int f 0/1</code><br>返回上一级操作模式: <code>exit</code><br>从全局以下级别直接返回到特权模式: <code>end</code><br>帮助信息: <code>？，co?  ,copy ?</code><br>修改交换机名称: <code>hostname  X</code><br>配置交换机端口参数: <code>speed，duplex</code><br>查看交换机版本信息: <code>show  version</code><br>查看当前生效的配置信息: <code>show run</code></p><h2 id="四、换机的Telnet远程登录配置"><a href="#四、换机的Telnet远程登录配置" class="headerlink" title="四、换机的Telnet远程登录配置:"></a>四、换机的Telnet远程登录配置:</h2><ol><li>新建packet tracer 拓扑图</li><li>配置交换机管理IP地址</li></ol><p>　　　　switch&gt; <code>enable 回车</code></p><p>　　　　switch#<code>configuration terminal 回车</code></p><p>　　　　switch（config）#<code>interface vlan 1 回车</code></p><p>　　　　默认情况下交换机所有端口都处于VLAN1中</p><p>　　　　switch(config-if) <code>ip address xxxx.xxxx.xxxx.xxxx  回车</code></p><p>　　　　switch(config-if) <code>no shutdown  回车</code></p><p>　　　　开启interface vlan 1的工作状态</p><p>　　　　switch(config-if)# <code>exit</code></p><p>　　　　返回上一级</p><ol start="3"><li>配置用户登录密码</li></ol><p>　　　　Switch(config)# <code>enable password xxxx</code></p><p>　　　　设置进入特权模式的密码</p><p>　　　　Switch(config)# <code>line vty 0 4</code></p><p>　　　　Switch(config-line)# <code>password xxxxxxx</code></p><p>　　　　设置远程登录密码</p><p>　　　　Switch(config-line)# <code>end</code></p><p>　　　　Switch# <code>show run</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、交换机的基本配置与管理：&quot;&gt;&lt;a href=&quot;#一、交换机的基本配置与管理：&quot; class=&quot;headerlink&quot; title=&quot;一、交换机的基本配置与管理：&quot;&gt;&lt;/a&gt;一、交换机的基本配置与管理：&lt;/h2&gt;&lt;h3 id=&quot;10-1-交换机的管理方式：&quot;&gt;&lt;a href=&quot;#10-1-交换机的管理方式：&quot; class=&quot;headerlink&quot; title=&quot;10.1 交换机的管理方式：&quot;&gt;&lt;/a&gt;10.1 交换机的管理方式：&lt;/h3&gt;&lt;p&gt;基本分为两种: 带内管理和带外管理。&lt;br&gt;&lt;strong&gt;带外管理: &lt;/strong&gt;通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，第一次配置交换机必须利用Console端口进行配置&lt;br&gt;&lt;strong&gt;带内管理: &lt;/strong&gt;通过远程Telnet，拨号等方式属于带内管理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://zzwwqq.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="交换机的配置" scheme="https://zzwwqq.xyz/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
