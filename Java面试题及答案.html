<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="google-site-verification" content="eDIkkqgUhVHV4g8TSxIU_BesHpybzZ1nwuDaph8FeFc">
<meta name="baidu-site-verification" content="Q8VWc7bZ6B">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'FBHE0THCTM',
      apiKey: '2a75a572e66ab3792430d09ecb901b80',
      indexName: 'zwq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"我们没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}
    }
  };
</script>


  





 <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0eeeae6f.js","daovoice")
 daovoice('init', {
  app_id: "06289ecd"
});
daovoice('update');
 </script>



  <meta name="description" content="目录结构: [TOC]  一、Java基础、语法1 面向对象的特征有哪些方面?答：面向对象的特征主要有以下几个方面：1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。">
<meta name="keywords" content="java基础面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础面试题及答案">
<meta property="og:url" content="https://zzwwqq.github.io/Java面试题及答案.html">
<meta property="og:site_name" content="zwq">
<meta property="og:description" content="目录结构: [TOC]  一、Java基础、语法1 面向对象的特征有哪些方面?答：面向对象的特征主要有以下几个方面：1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0kmpthpj30fe07qjsi.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ltusboj30fe0alq4j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ohnh1bj30fe07275c.jpg">
<meta property="og:image" content="https://zzwwqq.github.io/">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mut4ubu5j30ss0bywmm.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lozhtgddj324p1llaca.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lp13dy65j32tn2degqx.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lqb5dh8dj30g407yt8k.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lvu9umcrj30db05s41y.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lvuvudilj30fa09pgr1.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lw0h7727j30g60aiq6w.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lw0t8b78j30kr07kdjq.jpg">
<meta property="og:image" content="https://zzwwqq.github.io/![](http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lw5i6gnvj30m307ddmt.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3m21yjd2sj30d8021jr9.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqzh712xj3097039t8k.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mut4ubu5j30ss0bywmm.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mvols8ucj30zu0dsglr.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwtqx3r3j30i60by7b8.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwu91hxsj30cf07pmyx.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mw3bpxdij308w056dg0.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3n07pe84sj30ke09m402.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwdlumfsj30ch01gwea.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwe1vdwaj30fm014dfm.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3n1etqz29j30by06y74l.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3xllf90llj30i00c377y.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqvy1woij30lk06v742.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3wf2fa2s5j30ej01q3y9.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3wf3hryidj30fd09odfq.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g438fru4ufj30o70ctjub.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3x6b6zgerj30rb02wt9h.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3x6b10fpoj30rd02wdha.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3x6apc464j30qg02iabo.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqix8j2ij30jk0dj744.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqjt9g6gj30ii0d83yd.jpg">
<meta property="og:image" content="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kkb1mvoqj30el0cf76h.jpg">
<meta property="og:updated_time" content="2023-05-12T13:00:11.267Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java基础面试题及答案">
<meta name="twitter:description" content="目录结构: [TOC]  一、Java基础、语法1 面向对象的特征有哪些方面?答：面向对象的特征主要有以下几个方面：1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0kmpthpj30fe07qjsi.jpg">



  <link rel="alternate" href="/atom.xml" title="zwq" type="application/atom+xml">




  <link rel="canonical" href="https://zzwwqq.github.io/Java面试题及答案.html">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java基础面试题及答案 | zwq</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9c0c194e5f461cee9d645edaafef8a05";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
	
	
	<!--在这里加:-->
	<!--黑色github带
	<a href="https://github.com/zzwwqq"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
-->
	<a href="https://github.com/zzwwqq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	<!--	<a href="https://github.com/zzwwqq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
蓝色github猫
-->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zwq</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">路漫漫其修远兮,吾将上下而求索!</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-message">

    
    
    
      
    

    

    <a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-comment"></i> <br>留言</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zzwwqq.github.io/Java面试题及答案.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zwq">
      <meta itemprop="description" content="不忘初心,方得始终!">
      <meta itemprop="image" content="http://cdn.cdnjson.com/tva4.sinaimg.cn/large/0064BnmZgy1g9n64jijk8j30dc0dc0tq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zwq">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java基础面试题及答案

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-31 15:15:15" itemprop="dateCreated datePublished" datetime="2019-05-31T15:15:15+08:00">2019-05-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2023-05-12 21:00:11" itemprop="dateModified" datetime="2023-05-12T21:00:11+08:00">2023-05-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试题/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/Java面试题及答案.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Java面试题及答案.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/Java面试题及答案.html" class="leancloud_visitors" data-flag-title="java基础面试题及答案">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">热度：</span>
              
                <span class="leancloud-visitors-count">
				</span>
				<span>℃</span>
            </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">133k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2:01</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>目录结构:</strong></p>
<p>[TOC]</p>
<hr>
<h2 id="一、Java基础、语法"><a href="#一、Java基础、语法" class="headerlink" title="一、Java基础、语法"></a>一、Java基础、语法</h2><h3 id="1-面向对象的特征有哪些方面"><a href="#1-面向对象的特征有哪些方面" class="headerlink" title="1 面向对象的特征有哪些方面?"></a>1 面向对象的特征有哪些方面?</h3><p>答：面向对象的特征主要有以下几个方面：<br>1)抽象：抽象是将<strong>一类对象的共同特征总结出来构造类</strong>的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p>2)继承：继承是<strong>从已有类得到继承信息创建新类</strong>的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</p>
<a id="more"></a>
<p>3)封装：通常认为封装是把<strong>数据和操作数据的方法绑定</strong>起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</p>
<p>4)多态性：多态性是指允许<strong>不同子类型的对象对同一消息作出不同的响应</strong>。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为<strong>编译时的多态性和运行时的多态性</strong>。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。<strong>方法重载</strong>（overload）实现的是<strong>编译时的多态性</strong>（也称为前绑定），而<strong>方法重写</strong>（override）实现的是<strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：<strong>1. 方法重写</strong>（子类继承父类并重写父类中已有的或抽象的方法）；<strong>2. 对象造型</strong>（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<p>多态性的定义：是指允许不同类的对象对同一消息作出不同的响应（不同的对象收到相同的消息时会产生不同的动作），比如同样是绘图（同一消息），圆和矩形将画出不同的结果。</p>
<p>举例：现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。</p>
<p>同一个事件发生在不同的对象上会产生不同的结果。</p>
<p>作用：消除类型之间的耦合关系</p>
<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p>重载和重写都是多态的体现.</p>
<h3 id="2-访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2-访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2 访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2 访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p>答：区别如下：<br>  作用域    当前类  同包 子类 其他<br>  public         √        √       √      √<br>  protected   √        √       √      ×<br>  default       √        √       ×      ×<br>  private       √        ×       ×      ×<br>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</p>
<p>####2.1 类的访问权限只有两种</p>
<p><em>public</em>公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</p>
<p><em>default</em>默认的 可被同一个包中的类访问。</p>
<h4 id="2-2-成员（成员变量或成员方法）访问权限共有四种："><a href="#2-2-成员（成员变量或成员方法）访问权限共有四种：" class="headerlink" title="2.2 成员（成员变量或成员方法）访问权限共有四种："></a>2.2 成员（成员变量或成员方法）访问权限共有四种：</h4><p><em>public</em> 公共的 可以被项目中所有的类访问。(项目可见性)</p>
<p><em>protected</em> 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</p>
<p><em>default</em> 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</p>
<p><em>private</em> 私有的 只能被这个类本身访问。（类可见性）</p>
<h3 id="3-String-是最基本的数据类型吗"><a href="#3-String-是最基本的数据类型吗" class="headerlink" title="3 String 是最基本的数据类型吗?"></a>3 String 是最基本的数据类型吗?</h3><p>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了<strong>基本类型</strong>（primitive type）和<strong>枚举类型</strong>（enumeration type），剩下的都是<strong>引用类型</strong>（reference type）。</p>
<h3 id="4-float-f-3-4-是否正确"><a href="#4-float-f-3-4-是否正确" class="headerlink" title="4 float f=3.4;是否正确?"></a>4 float f=3.4;是否正确?</h3><p>  答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成<strong>精度损失</strong>，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p>
<h3 id="5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?"></a>5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</h3><p>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型,因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。<br>而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有<strong>隐含的强制类型转换</strong>。</p>
<h3 id="6-Java-有没有goto"><a href="#6-Java-有没有goto" class="headerlink" title="6 Java 有没有goto?"></a>6 Java 有没有goto?</h3><p>  答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<h3 id="7-int-和Integer-有什么区别"><a href="#7-int-和Integer-有什么区别" class="headerlink" title="7 int 和Integer 有什么区别?"></a>7 int 和Integer 有什么区别?</h3><p>  答：</p>
<p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即<strong>Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况</strong>，<br><strong>例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer</strong>。<br>在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，<strong>int不适合作为web层的表单数据的类型。</strong></p>
<p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<p>Java是一个近乎纯洁的面向对象编程语言，但是<strong>为了编程的方便还是引入不是对象的基本数据类型</strong>，但是为了能够将这些基本数据类型当成对象操作，<strong>Java为每一个基本数据类型都引入了对应的包装类型</strong>（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了<strong>自动装箱/拆箱机制，使得二者可以相互转换</strong>。<br>Java 为每个原始类型提供了包装类型：<br>  原始类型: boolean，<strong>char</strong>，byte，short，int，long，float，double<br>  包装类型：Boolean，<strong>Character</strong>，Byte，Short，Integer，Long，Float，Double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;              <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">&gt;   </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">&gt;          System.out.println(f1 == f2);</span><br><span class="line">&gt;          System.out.println(f3 == f4);</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p>  如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。</p>
<p><strong>装箱的本质是什么呢？</strong>当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>IntegerCache是Integer的内部类</strong>，其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment">     * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment">     * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment">     * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment">     * sun.misc.VM class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  简单的说，<strong>如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象</strong>，所以上面的面试题中f1f2的结果是true，而f3f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p>
<h3 id="8-amp-和-amp-amp-的区别和联系，-和-的区别和联系"><a href="#8-amp-和-amp-amp-的区别和联系，-和-的区别和联系" class="headerlink" title="8 &amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>8 &amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h3><h4 id="8-1-amp-和-amp-amp-的联系-共同点-："><a href="#8-1-amp-和-amp-amp-的联系-共同点-：" class="headerlink" title="8.1&amp;和&amp;&amp;的联系(共同点)："></a>8.1&amp;和&amp;&amp;的联系(共同点)：</h4><p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</p>
<p>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</p>
<p>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</p>
<p>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p>
<h4 id="8-2-amp-和-amp-amp-的区别-不同点-："><a href="#8-2-amp-和-amp-amp-的区别-不同点-：" class="headerlink" title="8.2 &amp;和&amp;&amp;的区别(不同点)："></a>8.2 &amp;和&amp;&amp;的区别(不同点)：</h4><p>(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</p>
<p>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p>
<p>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p>
<p>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</p>
<p>、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</p>
<p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</p>
<p><strong>注: 很多时候我们可能都需要用&amp;&amp;而不是&amp;</strong>，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，<strong>二者的顺序不能交换，更不能用&amp;运算符</strong>，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</p>
<h3 id="9-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#9-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h3><p>  答：通常我们定义一个<strong>基本数据类型的变量</strong>，一个<strong>对象的引用</strong>，还有就是<strong>函数调用的现场保存</strong>都使用内存中的<strong>栈空间</strong>；而通过new关键字和构造器创建的<strong>对象放在堆空间</strong>；程序中的<strong>字面量</strong>（literal）如直接书写的100、“hello”和<strong>常量都是放在静态存储区</strong>中。<strong>栈空间操作最快但是也很小</strong>，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。<br>  String str = new String(“hello”);<br>  上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。<br>  补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p>
<h3 id="10-Math-round（-11-2）的运行结果是"><a href="#10-Math-round（-11-2）的运行结果是" class="headerlink" title="10 Math.round（-11.2）的运行结果是"></a>10 Math.round（-11.2）的运行结果是</h3><p>答案: -11</p>
<p>分析：</p>
<p><strong>小数点后第一位=5</strong></p>
<p>正数：Math.round(11.5)=12</p>
<p>负数：Math.round(-11.5)=-11</p>
<p><strong>小数点后第一位&lt;5</strong></p>
<p>正数：Math.round(11.46)=11</p>
<p>负数：Math.round(-11.46)=-11</p>
<p><strong>小数点后第一位&gt;5</strong></p>
<p>正数：Math.round(11.68)=12</p>
<p>负数：Math.round(-11.68)=-12</p>
<p>根据上面例子的运行结果，我们还可以按照如下方式<strong>总结</strong>，或许更加容易记忆：</p>
<p>参数的小数点后第一位&lt;5，运算结果为参数整数部分。</p>
<p>参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。</p>
<p>参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分。</p>
<h4 id="Java-中的-Math-round-1-5-等于多少"><a href="#Java-中的-Math-round-1-5-等于多少" class="headerlink" title="Java 中的 Math. round(-1. 5) 等于多少?"></a>Java 中的 Math. round(-1. 5) 等于多少?</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<p><strong>终结：大于五全部加，等于五正数加，小于五全不加。</strong></p>
<h3 id="11-swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#11-swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h3><p>  答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。<strong>长整型（long）是不可以的。</strong></p>
<h3 id="12-用最有效率的方法计算2乘以8"><a href="#12-用最有效率的方法计算2乘以8" class="headerlink" title="12 用最有效率的方法计算2乘以8?"></a>12 用最有效率的方法计算2乘以8?</h3><p>  答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<p>使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数。对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3</p>
<p>  补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num &lt;==&gt; (num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。<br>  <img src="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0kmpthpj30fe07qjsi.jpg" alt><br>  <img src="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ltusboj30fe0alq4j.jpg" alt></p>
<h3 id="13-数组有没有length-方法-String-有没有length-方法？"><a href="#13-数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="13 数组有没有length()方法?String 有没有length()方法？"></a>13 数组有没有length()方法?String 有没有length()方法？</h3><p>  答：<strong>数组没有length()方法</strong>，<strong>有length 的属性</strong>。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</p>
<h3 id="14-在Java-中，如何跳出当前的多重嵌套循环？"><a href="#14-在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14 在Java 中，如何跳出当前的多重嵌套循环？"></a>14 在Java 中，如何跳出当前的多重嵌套循环？</h3><p>  答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ok:</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ok;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果如下: </span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">2</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">3</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">4</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数</span></span><br><span class="line"><span class="comment">组中查找到某个数字。  */</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length &amp;&amp; !found;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">            System.out.println(“i=” + i + “,j=” + j);</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]  == <span class="number">5</span>) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//运行结果如下: </span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span></span><br><span class="line">i=<span class="number">0</span>,j=<span class="number">2</span></span><br><span class="line">i=<span class="number">1</span>,j=<span class="number">0</span></span><br><span class="line">i=<span class="number">1</span>,j=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="15-构造器（constructor）是否可被重写（override）"><a href="#15-构造器（constructor）是否可被重写（override）" class="headerlink" title="15 构造器（constructor）是否可被重写（override）?"></a>15 构造器（constructor）是否可被重写（override）?</h3><p>  答：<strong>构造器不能被继承</strong>，因此不能被重写，但可以被重载。</p>
<h3 id="16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><p>  答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：<br>(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；<br>(2)如果两个对象的hashCode相同，它们并不一定相同。<br>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>  补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足<strong>自反性</strong>（x.equals(x)必须返回true）、<strong>对称性</strong>（x.equals(y)返回true时，y.equals(x)也必须返回true）、<strong>传递性</strong>（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和<strong>一致性</strong>（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。<br>实现高质量的equals方法的诀窍包括：</p>
<ol>
<li>使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. <strong>重写equals时总是要重写hashCode</strong>；6. 不要将equals方法参数中的Object对象替换为其他的类型，在<strong>重写时不要忘掉@Override注解</strong>。</li>
</ol>
<h3 id="17-是否可以继承String-类"><a href="#17-是否可以继承String-类" class="headerlink" title="17 是否可以继承String 类?"></a>17 是否可以继承String 类?</h3><p>  答：<strong>String 类是final类，不可以被继承</strong>。<br>  补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。</p>
<h3 id="18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p>  答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。<br>  补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</p>
<h3 id="19-String-和StringBuilder、StringBuffer-的区别"><a href="#19-String-和StringBuilder、StringBuffer-的区别" class="headerlink" title="19 String 和StringBuilder、StringBuffer 的区别?"></a>19 String 和StringBuilder、StringBuffer 的区别?</h3><p>  答：Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中<strong>String是只读字符串</strong>，也就意味着String引用的字符串内容是不能被改变的。而<strong>StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改</strong>。<strong>StringBuilder</strong>是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在<strong>单线程</strong>环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。<br>  补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。<br>  补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。<br>  <img src="http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ohnh1bj30fe07275c.jpg" alt></p>
<h3 id="20-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><a href="#20-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分" class="headerlink" title="20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?"></a>20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?</h3><p>  答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。<strong>重载发生在一个类中</strong>，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；<strong>重写发生在子类与父类之间</strong>，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。<strong>重载对返回类型没有特殊的要求</strong>。<br>  补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！</p>
<h3 id="21-描述一下JVM-加载class文件的原理机制"><a href="#21-描述一下JVM-加载class文件的原理机制" class="headerlink" title="21 描述一下JVM 加载class文件的原理机制?"></a>21 描述一下JVM 加载class文件的原理机制?</h3><p>  答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>  补充：<br>  1.由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被<strong>加载、连接(验证、准备和解析)和初始化</strong>。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个<strong>字节数组</strong>读入.class文件，然后产生与所加载类对应的<strong>Class对象</strong>。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括<strong>验证、准备(为静态变量分配内存并设置默认的初始值</strong>)和<strong>解析(将符号引用替换为直接引用)</strong>三个步骤。最后JVM对类进行<strong>初始化</strong>，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。<br>  2.类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：<br>  a)Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；<br>  b)Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；<br>  c)System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
<h3 id="22-char-型变量中能不能存贮一个中文汉字-为什么"><a href="#22-char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="22 char 型变量中能不能存贮一个中文汉字?为什么?"></a>22 char 型变量中能不能存贮一个中文汉字?为什么?</h3><p>  答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。<br>  补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</p>
<h3 id="23-抽象类（abstract-class）和接口（interface）有什么异同"><a href="#23-抽象类（abstract-class）和接口（interface）有什么异同" class="headerlink" title="23 抽象类（abstract class）和接口（interface）有什么异同?"></a>23 抽象类（abstract class）和接口（interface）有什么异同?</h3><p>  答：<strong>抽象类和接口都不能够实例化</strong>，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。<strong>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</strong>。</p>
<p>在接口中定义成员变量在声明的时候是必须要初始化的，并且都是 <code>public static final</code> 的。比如你在接口中定义一个变量 <code>i</code>，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的真正代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这是为什么呢？</p>
<p>因为在 Java 中，接口是高层次的抽象，体现的是 <code>OCP</code>（<strong>对修改关闭，对扩展开放</strong>）的设计原则，这也是我们设计中一直追求的。</p>
<p>首先要弄清接口的含义。接口就是提供一种统一的“协议”，而接口中的属性也属于“协议”中的成员。它们是<strong>公共的</strong>，<strong>静态的</strong>,<strong>不可变的</strong>常量，相当于全局常量。</p>
<p>抽象类是“不完全”的类，相当于是接口和具体类的一个中间层，即满足接口的抽象，也满足具体的实现。</p>
<p>如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。</p>
<p>也许你会想，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况：如果接口 <code>A</code> 中有一个 <code>public</code> 访问权限的静态变量 <code>a</code>。按照 java 的语义，我们可以不通过实现接口的对象来访问变量 <code>a</code>，通过 <code>A.a = xxx</code> 就可以改变接口中的变量 <code>a</code> 的值了。正如抽象类中是可以这样做的，那么实现接口 <code>A</code> 的所有对象也都会自动拥有这一改变后的 <code>a</code> 的值了，也就是说一个地方改变了 <code>a</code>，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以<strong>接口中的属性必然是常量，只能读不能改</strong>，这样才能为实现接口的对象提供一个统一的属性。</p>
<p>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。</p>
<p><strong>接口中的方法前面的public abstract ,属性前面的public static final都可以省略的。</strong></p>
<p>总之:  ①: 接口中没有变量,只有常量,且默认修饰符public static final; 另外接口中方法的默认修饰符: public abstract </p>
<p>②: 抽象类可以没有抽象方法,但如果一个类中有抽象方法,那么这个类必须声明为抽象方法.</p>
<h3 id="24-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#24-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h3><p> 答：内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out_x  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Inner1 inner1 = <span class="keyword">new</span> Inner1();</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span>  //在方法体内部定义的内部类</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                out_x = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner2 inner2 = <span class="keyword">new</span> Inner2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span>  //在方法体外面定义的内部类</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：</p>
<p>Outer outer = new Outer();</p>
<p>Outer.Inner1 inner1 = outer.new Innner1();</p>
<p>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。</p>
<p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            <span class="keyword">new</span> Runable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：</p>
<p>Outer.Inner inner = newOuter.Inner();</p>
<p>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。</p>
<p>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</p>
<p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扑克类（一副扑克）</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] suites = &#123;<span class="string">"黑桃"</span>, <span class="string">"红桃"</span>, <span class="string">"草花"</span>, <span class="string">"方块"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] faces = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Card[] cards;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cards = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; faces.length; j++) &#123;</span><br><span class="line">                cards[i * <span class="number">13</span> + j] = <span class="keyword">new</span> Card(suites[i], faces[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 洗牌 （随机乱序）</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = cards.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * len);</span><br><span class="line">            Card temp = cards[index];</span><br><span class="line">            cards[index] = cards[i];</span><br><span class="line">            cards[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 发牌的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Card <span class="title">deal</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cards[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卡片类（一张扑克）</span></span><br><span class="line"><span class="comment">     * [内部类]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String suite;   <span class="comment">// 花色</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> face;       <span class="comment">// 点数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">(String suite, <span class="keyword">int</span> face)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.suite = suite;</span><br><span class="line">            <span class="keyword">this</span>.face = face;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String faceStr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">switch</span>(face) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: faceStr = <span class="string">"A"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">11</span>: faceStr = <span class="string">"J"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">12</span>: faceStr = <span class="string">"Q"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">13</span>: faceStr = <span class="string">"K"</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: faceStr = String.valueOf(face);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> suite + faceStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PokerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Poker poker = <span class="keyword">new</span> Poker();</span><br><span class="line">        poker.shuffle();            <span class="comment">// 洗牌</span></span><br><span class="line">        Poker.Card c1 = poker.deal(<span class="number">0</span>);  <span class="comment">// 发第一张牌</span></span><br><span class="line">        <span class="comment">// 对于非静态内部类Card</span></span><br><span class="line">        <span class="comment">// 只有通过其外部类Poker对象才能创建Card对象</span></span><br><span class="line">        Poker.Card c2 = poker.new Card(<span class="string">"红心"</span>, <span class="number">1</span>);    <span class="comment">// 自己创建一张牌</span></span><br><span class="line">        System.out.println(c1);     <span class="comment">// 洗牌后的第一张</span></span><br><span class="line">        System.out.println(c2);     <span class="comment">// 打印: 红心A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-Java-中会存在内存泄漏吗，请简单描述。"><a href="#25-Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="25 Java 中会存在内存泄漏吗，请简单描述。"></a>25 Java 中会存在内存泄漏吗，请简单描述。</h3><p>  答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：<br>  <img src="/" alt><br>  上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</p>
<h3 id="26-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#26-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h3><p>  答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h3 id="27-静态变量和实例变量的区别？"><a href="#27-静态变量和实例变量的区别？" class="headerlink" title="27 静态变量和实例变量的区别？"></a>27 静态变量和实例变量的区别？</h3><p>  答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p>
<h3 id="28-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#28-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>  答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</p>
<h3 id="29-如何实现对象克隆？"><a href="#29-如何实现对象克隆？" class="headerlink" title="29 如何实现对象克隆？"></a>29 如何实现对象克隆？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：有两种方式：<br>  1.实现Cloneable接口并重写Object类中的clone()方法；<br>  2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</p>
<p>下面是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Car car;        <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", car="</span> + car + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小汽车类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5713945027627603702L</span>;</span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Car [brand="</span> + brand + <span class="string">", maxSpeed="</span> + maxSpeed + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person p1 = <span class="keyword">new</span> Person(<span class="string">"Hao LUO"</span>, <span class="number">33</span>, <span class="keyword">new</span> Car(<span class="string">"Benz"</span>, <span class="number">300</span>));</span><br><span class="line">            Person p2 = MyUtil.clone(p1);   <span class="comment">// 深度克隆</span></span><br><span class="line">            p2.getCar().setBrand(<span class="string">"BYD"</span>);</span><br><span class="line">            <span class="comment">// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span></span><br><span class="line">            <span class="comment">// 原来的Person对象p1关联的汽车不会受到任何影响</span></span><br><span class="line">            <span class="comment">// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span></span><br><span class="line">            System.out.println(p1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</p>
<h3 id="30-GC-是什么？为什么要有GC？"><a href="#30-GC-是什么？为什么要有GC？" class="headerlink" title="30 GC 是什么？为什么要有GC？"></a>30 GC 是什么？为什么要有GC？</h3><p>  答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。<br>  补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：<br>  •    伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。<br>  •    幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。<br>  •    终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。<br>  与垃圾回收相关的JVM参数：<br>  •    -Xms / -Xmx — 堆的初始大小 / 堆的最大大小<br>  •    -Xmn — 堆中年轻代的大小<br>  •    -XX:-DisableExplicitGC — 让System.gc()不产生任何作用<br>  •    -XX:+PrintGCDetail — 打印GC的细节<br>  •    -XX:+PrintGCDateStamps — 打印GC操作的时间戳</p>
<h3 id="31-String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#31-String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="31 String s=new String(“xyz”);创建了几个字符串对象？"></a>31 String s=new String(“xyz”);创建了几个字符串对象？</h3><p>  答：两个对象，一个是静态存储区的”xyz”,一个是用new创建在堆上的对象。</p>
<h3 id="32-接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#32-接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h3><p>  答：接口可以继承接口。抽象类可以实现(implements)接口，<strong>抽象类可继承具体类</strong>，但<strong>前提是具体类必须有明确的构造函数</strong>。</p>
<h3 id="33-一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33-一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><p>  答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p>
<h3 id="34-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#34-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>  答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现<strong>事件监听和回调。</strong></p>
<h3 id="35-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><p>  答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h3 id="36-Java-中的final关键字有哪些用法？"><a href="#36-Java-中的final关键字有哪些用法？" class="headerlink" title="36 Java 中的final关键字有哪些用法？"></a>36 Java 中的final关键字有哪些用法？</h3><p>答: </p>
<p>(1) 修饰类：表示该类不能被继承；</p>
<p>(2) 修饰方法：表示方法不能被重写但是允许重载；</p>
<p>(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）；</p>
<p>(4) 修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。</p>
<h3 id="37-指出下面程序的运行结果"><a href="#37-指出下面程序的运行结果" class="headerlink" title="37 指出下面程序的运行结果:"></a>37 指出下面程序的运行结果:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A ab = <span class="keyword">new</span> B();</span><br><span class="line">        ab = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<p>考点：静态代码块优先级 &gt; 构造方法的优先级如果再加一个普通代码块，优先顺序如下：静态代码块&gt;普通代码块&gt;构造方法</p>
<h3 id="38-说说数据类型之间的转换"><a href="#38-说说数据类型之间的转换" class="headerlink" title="38 说说数据类型之间的转换:"></a>38 说说数据类型之间的转换:</h3><p>  1)如何将字符串转换为基本数据类型？<br>  2)如何将基本数据类型转换为字符串？<br>  答：<br>  1)调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；<br>  2)一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串</p>
<h3 id="39-如何实现字符串的反转及替换？"><a href="#39-如何实现字符串的反转及替换？" class="headerlink" title="39 如何实现字符串的反转及替换？"></a>39 如何实现字符串的反转及替换？</h3><p>  答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String originStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(originStr == <span class="keyword">null</span> || originStr.length() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> originStr;</span><br><span class="line">        <span class="keyword">return</span> reverse(originStr.substring(<span class="number">1</span>)) + originStr.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h3><p>  答：代码如下所示:<br>  String s1 = “你好”;<br>  String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”);</p>
<h3 id="41-日期和时间："><a href="#41-日期和时间：" class="headerlink" title="41 日期和时间："></a>41 日期和时间：</h3><p>  1)如何取得年,月,日、小时,分钟,秒？                        —-&gt;抽象类Calendar的方法<br>  2)如何取得从1970年1月1日0时0分0秒到现在的毫秒数？        —-&gt;两种常用方法<br>  3)如何取得某月的最后一天，第一天？                        —–&gt;也就是获取过去或未来的日期,使用<strong>add方法</strong><br>  4)如何格式化日期？                                    —–&gt;SimpleDateFormat类的format方法<br>  5)如何获取形如Sat Jun 01 10:29:07 CST 2019类型日期?           ——-&gt;Calendar调用getInstance后调用getTime方法, 或者调用Date类的无参构造器<br>  6) add()和roll()的区别                                     ——-&gt; roll方法是在本月内循环. </p>
<p>  答：操作方法如下所示：<br>  1)创建java.util.Calendar 实例，调用getInstance()方法后调用其get()方法传入不同的参数即可获得参数所对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前年份、月份、日期  </span></span><br><span class="line">        Calendar cale = Calendar.getInstance(); <span class="comment">////创建实例 默认是当前时刻  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Calendar类源码: public final static int YEAR = 1;  所以1则代表的是对年份操作，同理2是对月份</span></span><br><span class="line"><span class="comment">        操作，3是对星期操作，5是对日期操作，11是对小时操作，12是对分钟操作，13是对秒操作，14是对毫秒操作。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//其中Calendar.YEAR的值为1,这里也可以换为 int year = cale.get(1);</span></span><br><span class="line">        <span class="keyword">int</span> year = cale.get(Calendar.YEAR);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/*注: 加1是因为MONTH是从零计数,即0--&gt;11对应1月---&gt;12月; 例如:如果当前是2019年6月,则</span></span><br><span class="line"><span class="comment">        cale.get(Calendar.MONTH)的值就是5,要想与月份一致,则加1即可. </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> month = cale.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// DATE是DAY_OF_MONTH的同义词,本月的第一天值为1。</span></span><br><span class="line">        <span class="keyword">int</span> day = cale.get(Calendar.DATE);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hour = cale.get(Calendar.HOUR_OF_DAY);  </span><br><span class="line">        <span class="keyword">int</span> minute = cale.get(Calendar.MINUTE);  </span><br><span class="line">        <span class="keyword">int</span> second = cale.get(Calendar.SECOND);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*注: DAY_OF_WEEK:一个星期中的第几天,从1-7对应 星期日-星期六; 如果想让星期一作为一个星期的第一</span></span><br><span class="line"><span class="comment">             天,则减一即可.例如今天星期一,cale.get(Calendar.DAY_OF_WEEK)得到的值则为2,要想与星期相一致,</span></span><br><span class="line"><span class="comment">             则减1即可.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">int</span> dow = cale.get(Calendar.DAY_OF_WEEK)-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> dom = cale.get(Calendar.DAY_OF_MONTH); </span><br><span class="line">        <span class="keyword">int</span> doy = cale.get(Calendar.DAY_OF_YEAR);  </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Current Date: "</span> + cale.getTime());  </span><br><span class="line">        System.out.println(<span class="string">"Year: "</span> + year);  </span><br><span class="line">        System.out.println(<span class="string">"Month: "</span> + month);  </span><br><span class="line">        System.out.println(<span class="string">"Day: "</span> + day);  </span><br><span class="line">        System.out.println(<span class="string">"Hour: "</span> + hour);  </span><br><span class="line">        System.out.println(<span class="string">"Minute: "</span> + minute);  </span><br><span class="line">        System.out.println(<span class="string">"Second: "</span> + second);  </span><br><span class="line">        System.out.println(<span class="string">"Day of Week: "</span> + dow);  </span><br><span class="line">        System.out.println(<span class="string">"Day of Month: "</span> + dom);  </span><br><span class="line">        System.out.println(<span class="string">"Day of Year: "</span> + doy);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">Current Date: Fri May 31 21:51:04 CST 2019</span></span><br><span class="line"><span class="comment">Year: 2019</span></span><br><span class="line"><span class="comment">Month: 5</span></span><br><span class="line"><span class="comment">Day: 31</span></span><br><span class="line"><span class="comment">Hour: 21</span></span><br><span class="line"><span class="comment">Minute: 51</span></span><br><span class="line"><span class="comment">Second: 4</span></span><br><span class="line"><span class="comment">Day of Week: 6</span></span><br><span class="line"><span class="comment">Day of Month: 31</span></span><br><span class="line"><span class="comment">Day of Year: 151</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>  2)以下方法均可获得该毫秒数:</p>
<p>java.lang.System.currentTimeMillis();—–&gt;通常用来计算时间差.</p>
<p>Calendar.getInstance().getTimeInMillis();</p>
<p>java.util.Date().getTime()——&gt;目前已经弃用</p>
<p>  3)示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*add方法: 在给定的日历字段中添加或减去指定的时间量 c.add(Calendar.DATE, X);//取指定天数的时期，</span></span><br><span class="line"><span class="comment">        取过去天的日期用负数，取未来天数日期用正数，在"X"处 如 c.add(Calendar.DATE, -1)取当前日期前</span></span><br><span class="line"><span class="comment">        一天的日期*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当月第一天和最后一天</span></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        String firstday, lastday;</span><br><span class="line">        Calendar cale = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 获取当前月的第一天</span></span><br><span class="line">        cale = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//add方法就可以解决大部分的功能。比如我们需要得到当前年，月，日，小时，分钟，秒，毫秒的前面时间或</span></span><br><span class="line">        <span class="comment">//者后面时间</span></span><br><span class="line">        cale.add(Calendar.MONTH, <span class="number">0</span>);</span><br><span class="line">        cale.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        firstday = format.format(cale.getTime());</span><br><span class="line">        <span class="comment">// 获取当前月的最后一天</span></span><br><span class="line">        cale = Calendar.getInstance();</span><br><span class="line">        cale.add(Calendar.MONTH, <span class="number">1</span>);</span><br><span class="line">        cale.set(Calendar.DAY_OF_MONTH, <span class="number">0</span>);</span><br><span class="line">        lastday = format.format(cale.getTime());</span><br><span class="line">        System.out.println(<span class="string">"本月第一天和最后一天分别是 ： "</span> + firstday + <span class="string">" and "</span> + lastday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line"><span class="comment">//本月第一天和最后一天分别是 ： 2019-05-01 and 2019-05-31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用: time.getActualMaximum(Calendar.DAY_OF_MONTH);</span></span><br></pre></td></tr></table></figure>
<p>4)利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date ss = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"一般日期输出："</span> + ss);</span><br><span class="line">        System.out.println(<span class="string">"时间戳："</span> + ss.getTime());</span><br><span class="line">        <span class="comment">//Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样</span></span><br><span class="line">        SimpleDateFormat format0 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String time = format0.format(ss.getTime());<span class="comment">//这个就是把时间戳经过处理得到期望格式的时间</span></span><br><span class="line">        System.out.println(<span class="string">"格式化结果0："</span> + time);</span><br><span class="line">        SimpleDateFormat format1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">        time = format1.format(ss.getTime());</span><br><span class="line">        System.out.println(<span class="string">"格式化结果1："</span> + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果: </span></span><br><span class="line"><span class="comment">一般日期输出：Fri May 31 22:18:07 CST 2019</span></span><br><span class="line"><span class="comment">时间戳：1559312287526</span></span><br><span class="line"><span class="comment">格式化结果0：2019-05-31 22:18:07</span></span><br><span class="line"><span class="comment">格式化结果1：2019年05月31日 22时18分07秒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>5) 获取形如Sat Jun 01 10:29:07 CST 2019类型日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Calendar.getInstance().getTime());</span><br><span class="line">或者</span><br><span class="line">System.out.println(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>
<p>6) add与roll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add()方法 </span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>); </span><br><span class="line">Calendar cal=Calendar.getInstance(); </span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2019</span>); <span class="comment">//Calendar.YEAR设值为2019</span></span><br><span class="line">cal.set(Calendar.MONTH,<span class="number">8</span>);<span class="comment">// Calendar.MONTH设值为8,对应的月份为8+1=9月</span></span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>); <span class="comment">//Calendar.DAY_OF_MONTH设为3,即9月的第3天,也就是2019年9月3日</span></span><br><span class="line">cal.add(Calendar.DATE, -<span class="number">4</span>);  <span class="comment">// Calendar.DATE 减 4, 即2019年9月3日向后退4天,就是2019年8月30 </span></span><br><span class="line">Date date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); <span class="comment">//输出为:2019-08-30 </span></span><br><span class="line">cal.add(Calendar.DATE, <span class="number">4</span>); <span class="comment">//上面的结果上Calendar.DATE 加 4, 即2006年8月30日向前4天,就是2006年9月3</span></span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); <span class="comment">//输出为:2019-09-03</span></span><br><span class="line">输出： </span><br><span class="line"><span class="number">2019</span>-<span class="number">08</span>-<span class="number">30</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">03</span> </span><br><span class="line"><span class="comment">//roll方法 </span></span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2019</span>); </span><br><span class="line">cal.set(Calendar.MONTH,<span class="number">8</span>); <span class="comment">// Calendar.MONTH设值为8,对应的月份为8+1=9月 </span></span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>);<span class="comment">//Calendar.DAY_OF_MONTH设为3,即9月的第3天,也就是2019年9月3日</span></span><br><span class="line">cal.roll(Calendar.DATE, -<span class="number">4</span>);<span class="comment">// Calendar.DATE 减 4, 即2019年9月3日向后退4天(在9月循环),就是2019年9月29 </span></span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); </span><br><span class="line">cal.roll(Calendar.DATE, <span class="number">4</span>); <span class="comment">//上面的结果上Calendar.DATE 加 4, 即2019年9月29日向前4天,就是2019年9月3</span></span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); <span class="comment">//输出为: 2019-09-03 </span></span><br><span class="line">输出： </span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">29</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">09</span>-<span class="number">03</span> </span><br><span class="line">可见，roll()方法在本月内循环，一般使用add()方法；</span><br></pre></td></tr></table></figure>
<p>补充: </p>
<p>\1. java中主要使用:三个类来处理日期和时间</p>
<p>a. java.util.Date(日期) ,             ————–是一个具体类，用来表示一个<strong>时间点</strong>，表示的是（GMT即<strong>格林尼治标准时间</strong>）从1970年1月1日00:00:00这一刻开始经历的<strong>毫秒数</strong>,主要用于<strong>创建日期对象并获取</strong>日期</p>
<p>b. java.util.Calendar（日历） ,       ————–是一个抽象类，用来解释和处理时间，<strong>设置和获取日期</strong>数据的特定部分</p>
<p>c. java.text.DateFormat（日期格式化） ————–是一个抽象类，用来对日期格式化，一般用它的一个具体子类java.text.SimpleDateFormat</p>
<p>\2. 月（MM），日（dd），星期(EEEE)，时（HH 24小时制,hh12小时制），分（mm），秒(ss)的大小写，有要求</p>
<p>\3. 具体类<strong>Date的对象调用getTime（）</strong>方法得到的是毫秒数，形如： 1506582000000</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date().getTime());<span class="comment">//1559301422873</span></span><br></pre></td></tr></table></figure>
<p> 抽象类<strong>Calendar的对象调用getInstance方法后,调用getTime（）</strong>方法得到的是形如：Sun Jul 23 12:15:52 PDT 2017</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Calendar.getInstance().getTime());<span class="comment">//Fri May 31 19:27:52 CST 2019</span></span><br><span class="line">System.out.println(Calendar.getInstance());</span><br><span class="line"><span class="comment">/*java.util.GregorianCalendar[time=1559302072601,areFieldsSet=true,areAllFieldsSet=true,lenient=tru</span></span><br><span class="line"><span class="comment">e,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=fal</span></span><br><span class="line"><span class="comment">see,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2019,MONTH</span></span><br><span class="line"><span class="comment">=4,WEEK_OF_YEAR=22,WEEK_OF_MONTH=5,DAY_OF_MONTH=31,DAY_OF_YEAR=151,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MON</span></span><br><span class="line"><span class="comment">TH=5,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,MINUTE=27,SECOND=52,MILLISECOND=601,ZONE_OFFSET=28800000,DST_OFFSET=0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p> 对具体类<strong>Date</strong>和抽象类<strong>Calendar的时间进行格式化后</strong>，得到形如：2017-07-23 12:15:52</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mut4ubu5j30ss0bywmm.jpg" alt></p>
<hr>
<h3 id="42-打印昨天的当前时刻。"><a href="#42-打印昨天的当前时刻。" class="headerlink" title="42 打印昨天的当前时刻。"></a>42 打印昨天的当前时刻。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.add(Calendar.DATE, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(cal.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line">Fri May <span class="number">31</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<h3 id="43-比较一下Java-和JavaSciprt。"><a href="#43-比较一下Java-和JavaSciprt。" class="headerlink" title="43 比较一下Java 和JavaSciprt。"></a>43 比较一下Java 和JavaSciprt。</h3><p>  答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。<br>  下面对两种语言间的异同作如下比较：<br>  1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；<strong>JavaScript</strong>是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种<strong>基于对象（Object-Based）和事件驱动</strong>（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；<br>  2）解释和编译：Java 的源代码在执行之前，必须经过编译；<strong>JavaScript</strong> 是一种解释性编程语言，其<strong>源代码不需经过编译，由浏览器解释执行</strong>；<br>  3）强类型变量和弱类型变量：Java采用强类型变量检查，即所有变量在<strong>编译之前必须作声明</strong>；<strong>JavaScript</strong>中变量声明，采用其弱类型。即<strong>变量在使用前不需作声明</strong>，而是解释器在<strong>运行时检查</strong>其数据类型；<br>  4）代码格式不一样。<br>  补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和<strong>JavaScript</strong>最重要的区别是一个是静态语言，一个是<strong>动态语言</strong>。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</p>
<h3 id="44-什么时候用assert？"><a href="#44-什么时候用assert？" class="headerlink" title="44 什么时候用assert？"></a>44 什么时候用assert？</h3><p>  答：assertion(断言)在软件开发中是一种常用的<strong>调试方式</strong>，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。<br>  断言用于调试目的：<br>  assert(a &gt; 0); // throws an AssertionError if a &lt;= 0<br>  断言可以有两种形式：<br>  assert Expression1;<br>  assert Expression1 : Expression2 ;<br>  Expression1 应该总是产生一个布尔值。<br>  Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。<br>  断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：<br>  javac -source 1.4 Test.java<br>  要在运行时启用断言，可使用-enableassertions 或者-ea 标记。<br>  要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。<br>  要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。<strong>断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</strong></p>
<h3 id="45-Error-和Exception-有什么区别"><a href="#45-Error-和Exception-有什么区别" class="headerlink" title="45 Error 和Exception 有什么区别?"></a>45 Error 和Exception 有什么区别?</h3><p>  答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。<br>  补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</p>
<p>  因此，用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再递归而是回溯了）。</p>
<h3 id="46-try-里-有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#46-try-里-有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="46 try{}里 有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>46 try{}里 有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</h3><p>  答：会执行，<strong>在方法返回调用者前执行</strong>。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = temp5(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"c = "</span>+d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">temp5</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            c = c + <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"执行finally,修改c的值..."</span> +<span class="string">"修改后C为: "</span>+ c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行finally,修改c的值...修改后C为: 2</span></span><br><span class="line"><span class="comment">c = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在异常处理时提供 finally 块来执行任何清除操作。</p>
<p>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</p>
<p><strong>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</strong></p>
<h3 id="47-Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#47-Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><p>  答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，<strong>每个异常都是一个对象</strong>，<strong>它是Throwable 类或其子类的实例</strong>。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；<strong>可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。</strong></p>
<h3 id="48-运行时异常与受检异常有何异同？"><a href="#48-运行时异常与受检异常有何异同？" class="headerlink" title="48 运行时异常与受检异常有何异同？"></a>48 运行时异常与受检异常有何异同？</h3><p>答: 异常表示程序运行过程中可能出现的非正常状态: </p>
<p>运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。</p>
<p>受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。</p>
<p>Java编译器要求方法<strong>必须声明抛出可能发生的受检异常</strong>，但是并<strong>不要求必须声明抛出未被捕获的运行时异常</strong>。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：<br>  •    不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）<br>  •    对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br>  •    避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）<br>  •    优先使用标准的异常<br>  •    每个方法抛出的异常都要有文档<br>  •    保持异常的原子性<br>  •    不要在catch中忽略掉捕获到的异常</p>
<p><strong>异常的分类: 编译异常、运行异常、检查性异常、逻辑异常.</strong></p>
<p><strong>编译异常: 由于程序语法不合规范，编译不通过</strong></p>
<p><strong>非运行时异常: 又称检查性异常也称受检异常，此类异常必须被捕获处理</strong>—&gt;<strong>如IO操作错误,类没找到等</strong></p>
<p><strong>记忆方法: 检查性异常为”IO操作错误”,”类没找到”等,其他基本上是运行时异常.</strong></p>
<h3 id="49-列出一些你常见的运行时异常？"><a href="#49-列出一些你常见的运行时异常？" class="headerlink" title="49 列出一些你常见的运行时异常？"></a>49 列出一些你常见的运行时异常？</h3><p>  答：<br>  ArithmeticException（算术异常）<br>  ClassCastException （类转换异常）<br>  IllegalArgumentException （非法参数异常）<br>  IndexOutOfBoundsException （下表越界异常）<br>  NullPointerException （空指针异常）<br>  SecurityException （安全异常）</p>
<h3 id="50-final-finally-finalize-的区别"><a href="#50-final-finally-finalize-的区别" class="headerlink" title="50 final, finally, finalize 的区别?"></a>50 final, finally, finalize 的区别?</h3><p><em>final</em>修饰符（关键字）如果一个类被声明为final，意味着它<strong>不能再派生出新的子类，不能作为父类被继承</strong>例如：String类、Math类等。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写，但是能够重载。 使用final修饰的对象，对象的引用地址不能变，但是对象的值可以变！</p>
<p><em>finally</em>在异常处理时提供 finally 块来执行任何清除操作。如果有finally的话，则不管是否发生异常，finally语句都会被执行。一般情况下，都把关闭物理连接(IO流、数据库连接、Socket连接)等相关操作，放入到此代码块中。</p>
<p><em>finalize</em>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作。finalize() 方法是在垃圾收集器删除对象之前被调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。 一般情况下，此方法由JVM调用，程序员不要去调用！</p>
<h3 id="51-Java跨平台原理（字节码文件、虚拟机）"><a href="#51-Java跨平台原理（字节码文件、虚拟机）" class="headerlink" title="51 Java跨平台原理（字节码文件、虚拟机）"></a>51 Java跨平台原理（字节码文件、虚拟机）</h3><p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lozhtgddj324p1llaca.jpg" alt></p>
<p>C/C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</p>
<p>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</p>
<p>字节码文件不面向任何具体平台，只面向虚拟机。</p>
<p>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</p>
<p>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。</p>
<p>Java的跨平台原理决定了其性能没有C/C++高</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lp13dy65j32tn2degqx.jpg" alt></p>
<h3 id="52-Java三大版本"><a href="#52-Java三大版本" class="headerlink" title="52 Java三大版本"></a>52 Java三大版本</h3><p>Java2平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本：</p>
<p>Standard Edition(标准版) J2SE 包含那些构成Java语言核心的类。</p>
<p>比如：数据库连接、接口定义、输入/输出、网络编程</p>
<p>Enterprise Edition(企业版) J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。</p>
<p>比如servlet、JSP、XML、事务控制</p>
<p>Micro Edition(微缩版) J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。</p>
<p>比如：呼机、智能卡、手机、PDA、机顶盒</p>
<p>他们的范围是：J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类</p>
<p>应用场合，API的覆盖范围各不相同</p>
<h3 id="53-Java的安全性"><a href="#53-Java的安全性" class="headerlink" title="53. Java的安全性"></a>53. Java的安全性</h3><h4 id="53-1-语言层次的安全性主要体现在："><a href="#53-1-语言层次的安全性主要体现在：" class="headerlink" title="53.1 语言层次的安全性主要体现在："></a>53.1 语言层次的安全性主要体现在：</h4><p>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</p>
<p>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</p>
<p>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p>
<p>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</p>
<h4 id="53-2-底层的安全性可以从以下方面来说明"><a href="#53-2-底层的安全性可以从以下方面来说明" class="headerlink" title="53.2 底层的安全性可以从以下方面来说明"></a>53.2 底层的安全性可以从以下方面来说明</h4><p>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</p>
<p>在运行环境提供了四级安全性保障机制：</p>
<p>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</p>
<h3 id="54-什么是JVM？什么是JDK？-什么是JRE？"><a href="#54-什么是JVM？什么是JDK？-什么是JRE？" class="headerlink" title="54. 什么是JVM？什么是JDK？ 什么是JRE？"></a>54. 什么是JVM？什么是JDK？ 什么是JRE？</h3><h4 id="54-1-JVM"><a href="#54-1-JVM" class="headerlink" title="54.1 JVM :"></a>54.1 JVM :</h4><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</p>
<h4 id="54-2-JRE："><a href="#54-2-JRE：" class="headerlink" title="54.2 JRE："></a>54.2 JRE：</h4><p>JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到<strong>jre目录，里面有两个文件夹bin和lib</strong>,在这里可以认为<strong>bin里的就是jvm</strong>，<strong>lib中则是jvm工作所需要的类库</strong>，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），<strong>JRE的地位就象一台PC机一样</strong>，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 </p>
<h4 id="54-3-JDK："><a href="#54-3-JDK：" class="headerlink" title="54.3 JDK："></a>54.3 JDK：</h4><p>JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：<strong>bin、include、lib、jre</strong>。现在我们可以看出这样一个关系，<strong>JDK包含JRE，而JRE包含JVM</strong>。</p>
<p>bin:最主要的是编译器(javac.exe)</p>
<p>include:java和JVM交互用的头文件</p>
<p>lib：类库      </p>
<p>jre:java运行环境 </p>
<p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说<strong>JDK是用于java程序的开发,而 jre则是只能运行class而没有编译的功能</strong>。</p>
<p><strong>eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。</strong></p>
<h4 id="54-4-JDK-JRE-JVM三者关系概括如下："><a href="#54-4-JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="54.4 JDK,JRE,JVM三者关系概括如下："></a>54.4 JDK,JRE,JVM三者关系概括如下：</h4><p>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDK、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</p>
<h3 id="55-Java三种注释类型"><a href="#55-Java三种注释类型" class="headerlink" title="55 Java三种注释类型"></a>55 Java三种注释类型</h3><p>共有单行注释、多行注释、文档注释3种注释类型。使用如下：</p>
<p>①: 单行注释，采用“//”方式.只能注释一行代码。如：//类成员变量</p>
<p>②: 多行注释，采用“/<em>…</em>/”方式，可注释多行代码，其中不允许出现嵌套。如：</p>
<p>/*System.out.println(“a”);</p>
<p>System.out.println(“b”);</p>
<p>System.out.println(“c”);*/</p>
<p>③: 文档注释，采用“/*<em>…</em>/”方式。如：</p>
<p>/<strong><br>*子类 Dog<br>*@author Administrator<br>\</strong>/<br>public class Dog extends Animal{}</p>
<h3 id="56-i-和-i的异同之处"><a href="#56-i-和-i的异同之处" class="headerlink" title="56. i++和++i的异同之处"></a>56. i++和++i的异同之处</h3><p>####56.1  共同点：</p>
<p>1、i++和++i都是变量自增1，都等价于i=i+1</p>
<p>2、如果i++,++i是一条单独的语句，两者没有任何区别</p>
<p>3、i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</p>
<h4 id="56-2-不同点："><a href="#56-2-不同点：" class="headerlink" title="56.2 不同点："></a>56.2 不同点：</h4><p>如果i++,++i不是一条单独的语句，他们就有区别i++ ：先运算后增1。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=x++;</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x+<span class="string">", y="</span>+y);</span><br><span class="line"><span class="comment">//以上代码运行后输出结果为：x=6, y=5</span></span><br></pre></td></tr></table></figure>
<p>++i ： 先增1后运算。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=++x;</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x+<span class="string">", y="</span>+y);</span><br><span class="line"><span class="comment">//以上代码运行后输出结果为：x=6, y=6</span></span><br></pre></td></tr></table></figure>
<h3 id="57-基本数据类型的类型转换规则"><a href="#57-基本数据类型的类型转换规则" class="headerlink" title="57 基本数据类型的类型转换规则"></a>57 基本数据类型的类型转换规则</h3><p>基本类型转换分为自动转换和强制转换。</p>
<p>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可</p>
<p>以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。</p>
<p>强制转换规则：高级变为低级需要强制转换。</p>
<p>如何转换：</p>
<p>（1）赋值运算符“=”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</p>
<p>（2）赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</p>
<p>(3)可以将整型常量直接赋值给byte, short, char等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</p>
<h3 id="58-if多分支语句和switch多分支语句的异同之处"><a href="#58-if多分支语句和switch多分支语句的异同之处" class="headerlink" title="58 if多分支语句和switch多分支语句的异同之处"></a>58 if多分支语句和switch多分支语句的异同之处</h3><p>相同之处：都是分支语句，多超过一种的情况进行判断处理。</p>
<p>不同之处：</p>
<p>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，<strong>在分支执行完后（如果没有break跳出），不加判断地执行下去</strong>;</p>
<p>而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，<strong>只要一个分支被执行后，后边的分支不再执行</strong>。</p>
<p><strong>switch为等值判断（不允许比如&gt;= &lt;=</strong>），而if为等值和区间都可以，if的使用范围大。</p>
<h3 id="59-while和do-while循环的区别"><a href="#59-while和do-while循环的区别" class="headerlink" title="59. while和do-while循环的区别"></a>59. while和do-while循环的区别</h3><p>while先判断后执行，第一次判断为false,循环体一次都不执行</p>
<p>do while先执行 后判断，最少执行1次。</p>
<p>如果while循环第一次判断为true, 则两种循环没有区别。</p>
<h3 id="60-break和continue的作用"><a href="#60-break和continue的作用" class="headerlink" title="60. break和continue的作用"></a>60. break和continue的作用</h3><p>break: 结束当前循环并退出当前循环体。</p>
<p>break还可以退出switch语句</p>
<p>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。<strong>continue只是结束本次循环</strong>。</p>
<h3 id="61-递归的定义和优缺点"><a href="#61-递归的定义和优缺点" class="headerlink" title="61. 递归的定义和优缺点"></a>61. 递归的定义和优缺点</h3><p>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</p>
<p>递归算法解决问题的特点：</p>
<p>(1) 递归就是在过程或函数里调用自身。</p>
<p>(2) 在使用递归策略时，<strong>必须有一个明确的递归结束条件</strong>，称为递归出口。</p>
<p>(3) 递归算法解题通常显得很简洁，但运行<strong>效率较低</strong>。所以<strong>一般不提倡用递归</strong>算法设计程序。</p>
<p>(4) 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</p>
<h3 id="62-数组的特征"><a href="#62-数组的特征" class="headerlink" title="62. .数组的特征"></a>62. .数组的特征</h3><p>数组是（<strong>相同类型数据</strong>）的（<strong>有序</strong>）（集合）</p>
<p>数组会在内存中开辟<strong>一块连续的空间</strong>，每个空间相当于之前的一个变量，称为数组的元素element</p>
<p>元素的表示 数组名[下标或者索引] scores[7] scores[0] scores[9]</p>
<p><strong>索引从0开始</strong></p>
<p><strong>每个数组元素有默认值</strong>    double 0.0 boolean false int 0</p>
<p><strong>注: 数组元素有序的，不是大小顺序，是索引 的顺序</strong></p>
<p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，<strong>数组的类型是固定的</strong>，只能是一个</p>
<p><strong>没有length方法,但是有length属性</strong>,length是数组长度.</p>
<p>数组的<strong>长度是固定的</strong>，一经定义，不能再发生变化（数组的扩容）</p>
<h3 id="63-请写出冒泡排序代码"><a href="#63-请写出冒泡排序代码" class="headerlink" title="63. 请写出冒泡排序代码"></a>63. 请写出冒泡排序代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层循环，它决定一共走几趟</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;a.length-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//内层循环，它决定每趟走一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;a.length-i-<span class="number">1</span> ; ++j) &#123;</span><br><span class="line">            <span class="comment">//如果后一个大于前一个</span></span><br><span class="line">            <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j]) &#123;</span><br><span class="line">                <span class="comment">//换位</span></span><br><span class="line">                temp = a[j];a[j] = a[j + <span class="number">1</span>];a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;a.length-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;a.length-<span class="number">1</span>-i ; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j]) &#123;</span><br><span class="line">                    temp = a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="64-请写出选择排序的代码"><a href="#64-请写出选择排序的代码" class="headerlink" title="64. 请写出选择排序的代码"></a>64. 请写出选择排序的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 认为目前的数就是最小的, 记录最小数的下标</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 修改最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出for就找到这次的最小值</span></span><br><span class="line">        <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="65-请写出插入排序的代码"><a href="#65-请写出插入排序的代码" class="headerlink" title="65. 请写出插入排序的代码"></a>65. 请写出插入排序的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="66-类和对象的关系"><a href="#66-类和对象的关系" class="headerlink" title="66. 类和对象的关系"></a>66. 类和对象的关系</h3><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p>
<p>类和对象好比图纸和实物的关系，模具和铸件的关系。</p>
<p>比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</p>
<p>小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。</p>
<h3 id="67-面向过程和面向对象的区别"><a href="#67-面向过程和面向对象的区别" class="headerlink" title="67. 面向过程和面向对象的区别"></a>67. 面向过程和面向对象的区别</h3><p>两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lqb5dh8dj30g407yt8k.jpg" alt></p>
<p><strong>比喻</strong></p>
<p>蒋介石和毛泽东分别是面向过程和面向对象的杰出代表，这样充分说明，在解决复制问题时，面向对象有更大的优越性。</p>
<p>面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。</p>
<p><strong>区别</strong></p>
<p>编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</p>
<p>封装性：都具有封装性，但是<strong>面向过程是封装的是功能</strong>，而<strong>面向对象封装的是数据和功能。</strong></p>
<p>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</p>
<h3 id="68-方法重载和方法重写（覆盖）的区别"><a href="#68-方法重载和方法重写（覆盖）的区别" class="headerlink" title="68. 方法重载和方法重写（覆盖）的区别"></a>68. 方法重载和方法重写（覆盖）的区别</h3><table>
<thead>
<tr>
<th></th>
<th>英文</th>
<th>位置不同</th>
<th>作用不同</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载</td>
<td>overload</td>
<td>同一个类中</td>
<td>在一个类里面为一种行为提供多种实现方式并提高可读性</td>
</tr>
<tr>
<td>重写</td>
<td>override</td>
<td>子类和父类间</td>
<td>父类方法无法满足子类的要求，子类通过方法重写满足要求</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>修饰符</th>
<th>返回值</th>
<th>方法名</th>
<th>参数</th>
<th>抛出异常</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载</td>
<td>无关</td>
<td>无关</td>
<td><strong>相同</strong></td>
<td><strong>不同</strong></td>
<td>无关</td>
</tr>
<tr>
<td>重写</td>
<td>大于等于</td>
<td>小于等于</td>
<td><strong>相同</strong></td>
<td><strong>相同</strong></td>
<td>小于等于</td>
</tr>
<tr>
<td>总结</td>
<td></td>
<td><strong>重载只关注方法名和参数即可,其他都无关</strong></td>
<td><strong>重写方法名和参数必须相同,其他三个也有要求</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="69-this和super关键字的作用"><a href="#69-this和super关键字的作用" class="headerlink" title="69. this和super关键字的作用"></a>69. this和super关键字的作用</h3><p>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；<strong>this可以调用成员变量，不能调用局部变量</strong>；this也可以调用成员方法，但是在普通方法中可以省略this，在<strong>构造方法中不允许省略</strong>，必须是构造方法的第一条语句。，而且在<strong>静态方法当中不允许出现this关键字</strong>。</p>
<p>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</p>
<p>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如<strong>不能访问private成员</strong>）；<strong>super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句</strong>。</p>
<h3 id="70-static关键字"><a href="#70-static关键字" class="headerlink" title="70. static关键字"></a>70. static关键字</h3><p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lvu9umcrj30db05s41y.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lvuvudilj30fa09pgr1.jpg" alt></p>
<p>static可以修饰变量、方法、代码块和内部类</p>
<p>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</p>
<p>static变量和非static变量的区别(都是成员变量，不是局部变量)</p>
<p>1.在内存中份数不同</p>
<p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</p>
<p>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</p>
<p>2.在内存中存放的位置不同</p>
<p>3.访问的方式不同</p>
<p>实例变量： 对象名.变量名 stu1.name=”小明明”;</p>
<p>静态变量：对象名.变量名 stu1.schoolName=”西二旗小学”; 不推荐如此使用</p>
<p>类名.变量名 Student.schoolName=”东三旗小学”; 推荐使用</p>
<p>4.在内存中分配空间的时间不同</p>
<p><strong>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</strong></p>
<p>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，<strong>且只被执行一次</strong>，主要作用是实现static属性的初始化。</p>
<p>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</p>
<h3 id="71-final和abstract关键字"><a href="#71-final和abstract关键字" class="headerlink" title="71.final和abstract关键字"></a>71.final和abstract关键字</h3><p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lw0h7727j30g60aiq6w.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lw0t8b78j30kr07kdjq.jpg" alt></p>
<p><img src="![](http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3lw5i6gnvj30m307ddmt.jpg" alt></p>
<p><strong>abstract只能修饰方法和类，不能修饰字段；</strong></p>
<p>final和abstract是功能相反的两个关键字，可以对比记忆</p>
<p><em>abstract</em>可以用来修饰类和方法，<strong>不能用来修饰属性和构造方法</strong>；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</p>
<p><em>final</em>可以用来修饰类、方法和属性，<strong>不能修饰构造方法</strong>。使用final修饰的类<strong>不能被继承</strong>，使用final修饰的方法<strong>不能被重写</strong>，使用final修饰的变量的值<strong>不能被修改</strong>，所以就成了常量。</p>
<p><em>特别注意：</em>final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">package</span>` `com.bjsxt;` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>&#123;``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;``        ``<span class="keyword">final</span>` `Dog dog = ``<span class="keyword">new</span>` `Dog(``<span class="string">"欧欧"</span>``);``        ``dog.name = ``<span class="string">"美美"</span>``;``<span class="comment">//正确``        ``dog = ``new` `Dog(``"亚亚"``);``//错误``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure>
<h3 id="72-写出java-lang-Object类的六个常用方法"><a href="#72-写出java-lang-Object类的六个常用方法" class="headerlink" title="72. 写出java.lang.Object类的六个常用方法"></a>72. 写出java.lang.Object类的六个常用方法</h3><p>(1)public boolean <strong>equals</strong>(java.lang.Object)//比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等；</p>
<p>(2)public native int <strong>hashCode</strong>() 获取哈希码</p>
<p>(3)public java.lang.String <strong>toString</strong>() 把数据转变成字符串</p>
<p>(4)public final native java.lang.Class <strong>getClass</strong>() 获取类结构信息</p>
<p>(5)protected void <strong>finalize</strong>() throws java.lang.Throwable   //垃圾回收前执行的方法</p>
<p>(6)protected native Object <strong>clone</strong>() throws java.lang.CloneNotSupportedException 克隆</p>
<p>(7)public final void <strong>wait</strong>() throws java.lang.InterruptedException   //多线程中等待功能</p>
<p>(8)public final native void <strong>notify</strong>() 多线程中唤醒功能</p>
<p>(9)public final native void <strong>notifyAll</strong>() 多线程中唤醒所有等待线程的功能</p>
<h3 id="73-继承条件下构造方法的执行过程"><a href="#73-继承条件下构造方法的执行过程" class="headerlink" title="73. 继承条件下构造方法的执行过程"></a>73. 继承条件下构造方法的执行过程</h3><p>继承条件下构造方法的调用规则如下：</p>
<p>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</p>
<p>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</p>
<p>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</p>
<p>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</p>
<h3 id="74-和equals的区别和联系"><a href="#74-和equals的区别和联系" class="headerlink" title="74.==和equals的区别和联系"></a>74.==和equals的区别和联系</h3><p>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</p>
<p>“==”使用情况如下：</p>
<p>a) 基本类型，比较的是值</p>
<p>b) 引用类型，比较的是地址</p>
<p>c) 不能比较没有父子关系的两个对象</p>
<p>equals()方法使用如下：</p>
<p>a) 系统类一般已经覆盖了equals()，比较的是内容。</p>
<p>b) 用户自定义类如果没有覆盖equals()，将调用父类的equals （比如是Object），而Object的equals的比较是地址（return (this == obj);）</p>
<p>c) 用户自定义类需要覆盖父类的equals()</p>
<p>注意：Object的==和equals比较的都是地址，作用相同</p>
<h3 id="75-谈谈Java的多态"><a href="#75-谈谈Java的多态" class="headerlink" title="75. 谈谈Java的多态"></a>75. 谈谈Java的多态</h3><p>实现多态的三个条件（前提条件，向上转型、向下转型）</p>
<p>1、继承的存在；（继承是多态的基础，<strong>没有继承就没有多态</strong>）</p>
<p>2、子类重写父类的方法。（多态下会调用子类重写后的方法）</p>
<p>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）</p>
<p>向上转型 Student person = new Student()</p>
<p>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</p>
<p>向下转型 Student stu = (Student)person;</p>
<p>将一个指向子类对象的父类引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，，否则将出现ClassCastException，不是任意的强制转换</p>
<p><strong>向下转型时可以结合使用instanceof运算符进行强制类型转换</strong>，比如出现转换异常—ClassCastException</p>
<h3 id="76-简述Java的垃圾回收机制"><a href="#76-简述Java的垃圾回收机制" class="headerlink" title="76. 简述Java的垃圾回收机制"></a>76. 简述Java的垃圾回收机制</h3><p>传统的C/C++语言，需要程序员负责回收已经分配内存。</p>
<h4 id="76-1显式回收垃圾回收的缺点："><a href="#76-1显式回收垃圾回收的缺点：" class="headerlink" title="76.1显式回收垃圾回收的缺点："></a>76.1显式回收垃圾回收的缺点：</h4><p>1）程序忘记及时回收，从而导致内存泄露，降低系统性能。</p>
<p>2）程序错误回收程序核心类库的内存，导致系统崩溃。</p>
<p>Java语言不需要程序员直接控制内存回收，是由<strong>JRE在后台自动回收</strong>不再使用的内存，称为垃圾回收机制，简称GC；</p>
<p>1）可以提高编程效率。</p>
<p>2）保护程序的完整性。</p>
<p>3）其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。</p>
<h4 id="76-2-垃圾回收机制的-特点"><a href="#76-2-垃圾回收机制的-特点" class="headerlink" title="76.2 垃圾回收机制的 特点"></a>76.2 垃圾回收机制的 特点</h4><p>1）垃圾回收机制<strong>回收JVM堆内存里的对象空间</strong>,<strong>不负责回收栈内存数据。</strong></p>
<p>2）对其他物理连接，比如数据库连接、输入流输出流、Socket连接<strong>无能为力</strong>。</p>
<p>3）垃圾回收发生具有不可预知性，程序<strong>无法精确控制</strong>垃圾回收机制执行。</p>
<p>4）可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</p>
<p>现在的JVM有多种垃圾回收 实现算法，表现各异。</p>
<p>垃圾回收机制回收任何对象之前，<strong>总会先调用它的finalize方法</strong>（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</p>
<p>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。</p>
<p><strong>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</strong></p>
<h3 id="77-基本数据类型和包装类"><a href="#77-基本数据类型和包装类" class="headerlink" title="77. 基本数据类型和包装类"></a>77. 基本数据类型和包装类</h3><p>####77.1 八个基本数据类型的包装类</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody>
</table>
<h4 id="77-2-为什么为基本类型引入包装类"><a href="#77-2-为什么为基本类型引入包装类" class="headerlink" title="77.2 为什么为基本类型引入包装类"></a>77.2 为什么为基本类型引入包装类</h4><p>2.1基本数据类型有方便之处，简单、高效。</p>
<p>2.2但是Java中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是Object）。</p>
<p>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<h4 id="77-3-包装类和基本数据类型之间的转换"><a href="#77-3-包装类和基本数据类型之间的转换" class="headerlink" title="77.3 包装类和基本数据类型之间的转换"></a>77.3 包装类和基本数据类型之间的转换</h4><p>3.1包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</p>
<p>3.2包装类——-new WrapperClass(primitive)</p>
<p>3.2包装类——-new WrapperClass(primitive)</p>
<p>4) 自动装箱和自动拆箱</p>
<p>JDK1.5提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</p>
<p>5) 包装类还<strong>可以实现基本类型变量和字符串之间的转换</strong></p>
<h3 id="78-Integer与int的区别"><a href="#78-Integer与int的区别" class="headerlink" title="78. Integer与int的区别"></a>78. Integer与int的区别</h3><p>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</p>
<p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>
<p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<h3 id="79-java-sql-Date和java-util-Date的联系和区别"><a href="#79-java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="79.java.sql.Date和java.util.Date的联系和区别"></a>79.java.sql.Date和java.util.Date的联系和区别</h3><p>1） java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的<strong>瘦包装器</strong>，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</p>
<p>2）JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.<strong>sql.Timestamp类比java.util.Date类精确度要高</strong>。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</p>
<p>总之，java.util.Date 就是Java的日期对象，<strong>而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分.</strong></p>
<h3 id="80-使用递归算法输出某个目录下所有文件和子目录列表"><a href="#80-使用递归算法输出某个目录下所有文件和子目录列表" class="headerlink" title="80. 使用递归算法输出某个目录下所有文件和子目录列表"></a>80. 使用递归算法输出某个目录下所有文件和子目录列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">"D:/301SXT"</span>;</span><br><span class="line">        test(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(path);</span><br><span class="line">        File[] fs = f.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (File file : fs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(file.getPath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                test(file.getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="81-Java中接口的修饰符可以为（）（选择一项）"><a href="#81-Java中接口的修饰符可以为（）（选择一项）" class="headerlink" title="81. Java中接口的修饰符可以为（）（选择一项）"></a>81. Java中接口的修饰符可以为（）（选择一项）</h3><table>
<thead>
<tr>
<th>A</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>protected</td>
</tr>
<tr>
<td>C.</td>
<td>final</td>
</tr>
<tr>
<td>D.</td>
<td>abstract</td>
</tr>
<tr>
<td>答案：D<br>分析：<strong>接口中的访问权限修饰符只可以是public或default</strong>,接口中的所有的方法必须要实现类实现，所以<strong>不能使用final</strong>,接口中所有的方法默认都是abstract的，所以接口<strong>可以使用abstract修饰</strong>，但通常abstract可以省略不写</td>
</tr>
</tbody>
</table>
<h3 id="82-为什么接口里面的属性必须是常量即final修饰-且静态即static修饰"><a href="#82-为什么接口里面的属性必须是常量即final修饰-且静态即static修饰" class="headerlink" title="82. 为什么接口里面的属性必须是常量即final修饰, 且静态即static修饰"></a>82. 为什么接口里面的属性必须是常量即final修饰, 且静态即static修饰</h3><p>知识点1：一个类，首先他会在内存里面有一个类对象，然后由类对象生成类的对象 </p>
<p>知识点2：为什么接口Interface里面的属性必须是常量呢？ 因为类可以被实例化，实例化的类的对象里面的变量就会被赋初始值。比如String 是 null int是0，double是0.0。但是接口呢？接口不能被实例化，所以接口里面如果是变量的话不会被赋初始值这样就会出问题。所以接口里面的值必须是常量final而且一定是static不管写不写都是</p>
<p>知识点3：那为什么它要是静态的呢？因为static是什么？是所有对象可以访问，而且可以直接通过类名访问。接口有对象么？显然没有,因为接口不能被实例化，必须通过类名来访问所以是要静态的。</p>
<p>补充: </p>
<p>Java的interface中，成员变量的默认修饰符为：<strong>public static final</strong></p>
<p>Java的interface中，方法的默认修饰符是：<strong>public abstract</strong></p>
<p>以上两种都可以，老司机一般都是第二种。既然是静态最终的变量，也就意味着在外面访问的时候不能修改这个成员变量的值。所以在接口中定义成员变量的，一般都是常量。不会修改的。如果要进行修改的话，定义在接口具体实现类中。</p>
<h3 id="83-给定以下代码，程序将输出-（）（选择一项）"><a href="#83-给定以下代码，程序将输出-（）（选择一项）" class="headerlink" title="83. 给定以下代码，程序将输出 （）（选择一项）"></a>83. 给定以下代码，程序将输出 （）（选择一项）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>A</th>
<th>不能通过编译</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>通过编译，输出AB</td>
</tr>
<tr>
<td>C.</td>
<td>通过编译，输出B</td>
</tr>
<tr>
<td>D.</td>
<td>通过编译，输出A</td>
</tr>
<tr>
<td>答案：B<br>分析：在继承关系下，创建子类对象，先执行父类的构造方法，再执行子类的构造方法</td>
</tr>
</tbody>
</table>
<h3 id="84-为什么说静态的不能访问非静态的，而非静态的能访问静态的？"><a href="#84-为什么说静态的不能访问非静态的，而非静态的能访问静态的？" class="headerlink" title="84. 为什么说静态的不能访问非静态的，而非静态的能访问静态的？"></a>84. 为什么说静态的不能访问非静态的，而非静态的能访问静态的？</h3><p>原因：生命周期：静态的执行早于非静态的（也就是说晚生成的能调用早生成的，而早生成的不能调用晚生成的）</p>
<h3 id="85-选出合理的标识符（）（选择两项）"><a href="#85-选出合理的标识符（）（选择两项）" class="headerlink" title="85. 选出合理的标识符（）（选择两项）"></a>85. 选出合理的标识符（）（选择两项）</h3><table>
<thead>
<tr>
<th>A</th>
<th>_sysl_111</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>2 mail</td>
</tr>
<tr>
<td>C.</td>
<td>$change</td>
</tr>
<tr>
<td>D.</td>
<td>class</td>
</tr>
<tr>
<td>答案：AC<br>分析： 标识符的命令规范，可以包含字母、数字、下划线、$，不能以数字开头，不能是Java关键字</td>
</tr>
</tbody>
</table>
<h3 id="86-面向对象的特征有哪些方面？请用生活中的例子来描述"><a href="#86-面向对象的特征有哪些方面？请用生活中的例子来描述" class="headerlink" title="86. 面向对象的特征有哪些方面？请用生活中的例子来描述"></a>86. 面向对象的特征有哪些方面？请用生活中的例子来描述</h3><p>答:    面向对象的三大特征：封装、继承、多态。</p>
<p>举例：（比如设计一个游戏）我现在创建了一个对象，名叫战士。</p>
<p>战士的属性是—性别，年龄，职业，等级，战斗力，血量。</p>
<p>它的方法—战斗，逃跑，吃饭，睡觉，死。</p>
<p>后来，我又建了一个对象，叫人。</p>
<p>属性:性别，年龄，职业，等级，血量</p>
<p>方法:逃跑，吃饭，睡觉，死。</p>
<p>我让人，成为战士的父类，战士可以直接继承人的属性和方法。</p>
<p>战士修改成—</p>
<p>属性:战斗力。</p>
<p>方法:战斗。</p>
<p>看上去战士的资料变少了，实际上没有，我们仍然可以调用方法—战士.死。</p>
<p>而且我们还可以重载战士.死的方法，简称重载死法。</p>
<p>我还建了一个对象—法师，父类也是人。</p>
<p>属性:法力值</p>
<p>方法:施法，泡妞。</p>
<p>你看，用了继承，创建对象变得更方便了。</p>
<p>再后来，我又建立了一个对象，叫怪物。</p>
<p>属性:等级，战力，血量。</p>
<p>方法:战斗，死。</p>
<p>建了个对象，叫白兔怪，父类怪物，可继承怪物所有的属性和方法。</p>
<p>属性:毛色。</p>
<p>方法:卖萌，吃胡萝卜。</p>
<h3 id="87-说明内存泄漏和内存溢出的区别和联系"><a href="#87-说明内存泄漏和内存溢出的区别和联系" class="headerlink" title="87. 说明内存泄漏和内存溢出的区别和联系"></a>87. 说明内存泄漏和内存溢出的区别和联系</h3><p><strong>内存泄漏: </strong>是指你向系统申请分配内存进行使用(new)，可是<strong>使用完了以后却不归还(delete)</strong>，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</p>
<p><strong>内存溢出</strong>：一个盘子用尽各种方法<strong>只能装4个果子，你装了5个</strong>，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错</p>
<p>总结: memory leak会最终会导致out of memory！</p>
<p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>
<p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<h3 id="88-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"><a href="#88-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？" class="headerlink" title="88.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"></a>88.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</h3><p>答：Java中的序列化机制能够将一个实例<strong>对象</strong>（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的<strong>状态信息</strong> <strong>写</strong>入到一个<strong>字节流</strong>中使其可以通过<strong>socket进行传输</strong>、或者<strong>持久化到存储数据库或文件系统</strong>中；然后在需要的时候通过字节流中的信息来重构一个相同的对象。</p>
<p>一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接口即可。</p>
<p>对象的序列化主要有两种用途：</p>
<p>1） 把对象的字节序列永久地<strong>保存到硬盘</strong>上，通常存放在一个文件中；</p>
<p>2） 在<strong>网络上</strong> 传送对象的字节序列。</p>
<p>在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>
<p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p>
<h3 id="89-不通过构造函数也能创建对象吗？"><a href="#89-不通过构造函数也能创建对象吗？" class="headerlink" title="89. 不通过构造函数也能创建对象吗？"></a>89. 不通过构造函数也能创建对象吗？</h3><p>答：Java创建对象的几种方式（重要）：</p>
<p>1、 用<strong>new</strong>语句创建对象，这是最常见的创建对象的方法。</p>
<p>2、 运用<strong>反射</strong>手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</p>
<p>3、 调用对象的<strong>clone()</strong>方法。</p>
<p>4、运用<strong>反序列化</strong>手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<p>(1)和(2)都会明确的<strong>显式的调用构造函数</strong> ；</p>
<p>(3)是在内存上对已有对象的影印，所以<strong>不会调用构造函数</strong> ；(4)是从文件中还原类的对象，也<strong>不会调用构造函数</strong>。</p>
<h3 id="90-匿名内部类可不可以继承或实现接口。为什么？"><a href="#90-匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="90. .匿名内部类可不可以继承或实现接口。为什么？"></a>90. .匿名内部类可不可以继承或实现接口。为什么？</h3><p>答：匿名内部类是没有名字的内部类,<strong>不能继承其它类</strong>,但一个内部类可以作为一个接口,由另一个内部类实现.</p>
<p>1、<strong>由于匿名内部类没有名字，所以它没有构造函数</strong>。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。</p>
<p>2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</p>
<p>3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</p>
<h3 id="91-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#91-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="91. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>91. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h3><p>(1) 在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt; K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt; K, V&gt;可以理解为HashMap&lt; Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。</p>
<p>虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型。</p>
<h3 id="92-简述Java中如何实现多态"><a href="#92-简述Java中如何实现多态" class="headerlink" title="92. 简述Java中如何实现多态"></a>92. 简述Java中如何实现多态</h3><p>实现多态有三个前提条件：</p>
<p>1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。</p>
<p>2、子类重写父类的方法。（多态下会调用子类重写后的方法）。</p>
<p>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</p>
<p>最后使用父类的引用变量调用子类重写的方法即可实现多态。</p>
<h3 id="93-Java-中-Math-random（）-Math-random（）值为？"><a href="#93-Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="93.Java 中 Math.random（）/Math.random（）值为？"></a>93.Java 中 Math.random（）/Math.random（）值为？</h3><p>如果除数与被除数均为0.0的话，则运行结果为NaN（Not a Number的简写），计算错误</p>
<h3 id="94-Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#94-Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="94. Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>94. Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？</h3><p>不是，两者没有任何关联；</p>
<p>Pair是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例化而已；所以，Pair&lt; Manager&gt;和Pair&lt; Employee&gt;不是子类的关系。</p>
<h3 id="95-接口和抽象类的区别"><a href="#95-接口和抽象类的区别" class="headerlink" title="95. 接口和抽象类的区别"></a>95. 接口和抽象类的区别</h3><p>抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现</p>
<p>两者的区别主要体现在两方面：语法方面和设计理念方面</p>
<p>语法方面的区别是比较低层次的，非本质的，主要表现在：</p>
<p>接口中只能定义全局常量(静态常量)，不能定义变量。抽象类中可以定义常量和变量。</p>
<p>接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。</p>
<p>抽象类中可以有构造方法，但不能用来实例化，而在子类实例化时执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。</p>
<p>一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。</p>
<p>一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。</p>
<p>抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a”的关系，即父类和子类在概念本质上应该是相同的。</p>
<p>接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。接口和实现之间可以认为是一种“has-a的关系”</p>
<h3 id="96-同步代码块和同步方法有什么区别"><a href="#96-同步代码块和同步方法有什么区别" class="headerlink" title="96. 同步代码块和同步方法有什么区别"></a>96. 同步代码块和同步方法有什么区别</h3><p>相同点：</p>
<p>同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。</p>
<p>而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。</p>
<p>一般情况下，如果此“目标”为this，同步方法和代码块没有太大的区别。</p>
<p>区别：</p>
<p>同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</p>
<h3 id="97-静态内部类和内部类有什么区别"><a href="#97-静态内部类和内部类有什么区别" class="headerlink" title="97. 静态内部类和内部类有什么区别"></a>97. 静态内部类和内部类有什么区别</h3><p>静态内部类<strong>不需要有指向外部类的引用</strong>。但非静态内部类需要持有对外部类的引用。</p>
<p>静态内部类可以<strong>有静态成员(方法，属性)</strong>，而非静态内部类则不能有静态成员(方法，属性)。</p>
<p>非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。</p>
<p>实例化方式不同：</p>
<p>1) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象</p>
<p>2) 非静态内部类：通过外部类的对象实例生成内部类对象</p>
<h3 id="98-反射的概念与作用"><a href="#98-反射的概念与作用" class="headerlink" title="98.反射的概念与作用"></a>98.反射的概念与作用</h3><p>反射的概念：</p>
<p>反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>Java反射可以于运行时加载,探知和使用编译期间完全未知的类.</p>
<p>程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性;</p>
<p>加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射.</p>
<p>java反射使得我们可以在程序运行时动态加载一个类，动态获取类的基本信息和定义的方法,构造函数,域等。</p>
<p>除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获取类实例的域值。反射使java这种静态语言有了动态的特性。</p>
<p>反射的作用：</p>
<p>通过反射可以使程序代码访问装载到JVM 中的类的内部信息</p>
<p>1) 获取已装载类的属性信息</p>
<p>2) 获取已装载类的方法</p>
<p>3) 获取已装载类的构造方法信息</p>
<p>反射的优点：</p>
<p>增加程序的灵活性。</p>
<p>如struts中。请求的派发控制。</p>
<p>当请求来到时。struts通过查询配置文件。找到该请求对应的action。已经方法。</p>
<p>然后通过反射实例化action。并调用响应method。</p>
<p>如果不适用反射，那么你就只能写死到代码里了。</p>
<p>所以说，一个灵活，一个不灵活。</p>
<p>很少情况下是非用反射不可的。大多数情况下反射是为了提高程序的灵活性。因此一般框架中使用较多。因为框架要适用更多的情况。对灵活性要求较高。</p>
<h3 id="99-Java程序的种类有（）-多选"><a href="#99-Java程序的种类有（）-多选" class="headerlink" title="99.Java程序的种类有（）(多选)"></a>99.Java程序的种类有（）(多选)</h3><table>
<thead>
<tr>
<th>A</th>
<th>类 (Class)</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>Applet</td>
</tr>
<tr>
<td>C.</td>
<td>Application</td>
</tr>
<tr>
<td>D.</td>
<td>Servlet</td>
</tr>
<tr>
<td>答案：BCD<br>分析：是Java中的类，不是程序；内嵌于Web文件中，由浏览器来观看的Applet；可独立运行的 Application；服务器端的 Servlet。</td>
</tr>
</tbody>
</table>
<h3 id="100-下列标识符不合法的有（）-多选"><a href="#100-下列标识符不合法的有（）-多选" class="headerlink" title="100. 下列标识符不合法的有（）(多选)"></a>100. 下列标识符不合法的有（）(多选)</h3><table>
<thead>
<tr>
<th>A</th>
<th>new</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>$Usdollars</td>
</tr>
<tr>
<td>C.</td>
<td>1234</td>
</tr>
<tr>
<td>D.</td>
<td>car.taxi</td>
</tr>
<tr>
<td>答案：ACD<br>分析：new是Java的关键字；C. 数字不能开头；D. 不能有“.”。</td>
</tr>
</tbody>
</table>
<h3 id="101-不能用来修饰interface的有（）-多选"><a href="#101-不能用来修饰interface的有（）-多选" class="headerlink" title="101. 不能用来修饰interface的有（）(多选)"></a>101. 不能用来修饰interface的有（）(多选)</h3><table>
<thead>
<tr>
<th>A</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>public</td>
</tr>
<tr>
<td>C.</td>
<td>protected</td>
</tr>
<tr>
<td>D.</td>
<td>static</td>
</tr>
<tr>
<td>答案：ACD分析：能够修饰interface的只有public、abstract以及默认的三种修饰符。</td>
</tr>
</tbody>
</table>
<h3 id="102-下列说法错误的有（）-多选"><a href="#102-下列说法错误的有（）-多选" class="headerlink" title="102. 下列说法错误的有（）(多选)"></a>102. 下列说法错误的有（）(多选)</h3><table>
<thead>
<tr>
<th>A</th>
<th>在类方法中可用this来调用本类的类办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>在类方法中调用本类的类方法时可以直接调用</td>
</tr>
<tr>
<td>C.</td>
<td>在类方法中只能调用本类中的类方法</td>
</tr>
<tr>
<td>D.</td>
<td>在类方法中绝对不能调用实例方法</td>
</tr>
<tr>
<td>答案：ACD<br>分析：类方法是在类加载时被加载到方法区存储的，此时还没有创建对象，所以不能使用this或者super关键字；C. 在类方法中还可以调用其他类的类方法；D. 在类方法可以通过创建对象来调用实例方法。</td>
</tr>
</tbody>
</table>
<h3 id="103-下列说法错误的有（）-多选"><a href="#103-下列说法错误的有（）-多选" class="headerlink" title="103. 下列说法错误的有（）(多选)"></a>103. 下列说法错误的有（）(多选)</h3><table>
<thead>
<tr>
<th>A</th>
<th>Java面向对象语言容许单独的过栈与函数存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>Java面向对象语言容许单独的方法存在</td>
</tr>
<tr>
<td>C.</td>
<td>Java语言中的方法属于类中的成员（member）</td>
</tr>
<tr>
<td>D.</td>
<td>Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同</td>
</tr>
<tr>
<td>答案：ABC<br>分析：B. Java不允许单独的方法，过程或函数存在，需要隶属于某一类中；C. 静态方法属于类的成员，非静态方法属于对象的成员。</td>
</tr>
</tbody>
</table>
<h3 id="104-下列说法错误的有（）-多选"><a href="#104-下列说法错误的有（）-多选" class="headerlink" title="104. 下列说法错误的有（）(多选)"></a>104. 下列说法错误的有（）(多选)</h3><table>
<thead>
<tr>
<th>A</th>
<th>能被java.exe成功运行的java class文件必须有main()方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>J2SDK就是Java API</td>
</tr>
<tr>
<td>C.</td>
<td>Appletviewer.exe可利用jar选项运行.jar文件</td>
</tr>
<tr>
<td>D.</td>
<td>能被Appletviewer成功运行的java class文件必须有main()方法</td>
</tr>
<tr>
<td>答案：BCD<br>分析：<br>B. J2SDK是sun公司编程工具，API是指的应用程序编程接口；<br>C. Appletviewer.exe就是用来解释执行java applet应用程序的，一种执行HTML文件上的Java小程序类的Java浏览器；<br>D. 能被Appletviewer成功运行的java class文件可以没有main（）方法。</td>
</tr>
</tbody>
</table>
<h3 id="105-不通过-构造函数-也能创建对象么（）"><a href="#105-不通过-构造函数-也能创建对象么（）" class="headerlink" title="105. 不通过 构造函数 也能创建对象么（）"></a>105. 不通过 构造函数 也能创建对象么（）</h3><table>
<thead>
<tr>
<th>A</th>
<th>是</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>否</td>
</tr>
<tr>
<td>答案：A分析：Java创建对象的几种方式：<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。<br>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</td>
</tr>
</tbody>
</table>
<h3 id="106-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><a href="#106-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？" class="headerlink" title="106. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"></a>106. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</h3><p>答: 接口可以继承接口，抽象类可以实现接口，抽象类可以继承实体类。</p>
<h3 id="107-写一个Java正则，能过滤出html中的-lt-a-href-”url”-gt-title-lt-a-gt-形式中的链接地址和标题"><a href="#107-写一个Java正则，能过滤出html中的-lt-a-href-”url”-gt-title-lt-a-gt-形式中的链接地址和标题" class="headerlink" title="107.写一个Java正则，能过滤出html中的&lt; a href=”url”&gt;title&lt; /a&gt;形式中的链接地址和标题."></a>107.写一个Java正则，能过滤出html中的&lt; a href=”url”&gt;title&lt; /a&gt;形式中的链接地址和标题.</h3><p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3m21yjd2sj30d8021jr9.jpg" alt></p>
<table>
<thead>
<tr>
<th>\b</th>
<th>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</th>
</tr>
</thead>
<tbody>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如[^xyz]可以匹配“plain”中的“p”。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
</tbody>
</table>
<h3 id="108-Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#108-Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="108. Class类的getDeclaredFields()方法与getFields()的区别？"></a>108. Class类的getDeclaredFields()方法与getFields()的区别？</h3><p>答:getDeclaredFields(): 可以<strong>获取所有本类自己声明的方法, 不能获取继承的方法</strong></p>
<p>getFields(): 只能<strong>获取所有public声明的方法, 包括继承的方法</strong></p>
<h3 id="109-在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"><a href="#109-在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？" class="headerlink" title="109. 在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"></a>109. 在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？</h3><p>答:不正确。</p>
<p>通常情况下，进行比较判断的处理，switch 和if-else可以互相转换来写；if-else作用的范围比switch-case作用范围要大，但是当switch-case和if-else都可以用的情况下，通常推荐使用switch-case。</p>
<p>比如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        System.out.println(<span class="string">"D"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">        System.out.println(<span class="string">"E"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"other"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换为if-else</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == <span class="string">'a'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"A"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'b'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">'B'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'c'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"C"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'d'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"D"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"E"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Other"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="110-使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#110-使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="110.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>110.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>final修饰基本类型变量，其值不能改变。</p>
<p>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。</p>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog(<span class="string">"欧欧"</span>);</span><br><span class="line">        dog.name = <span class="string">"美美"</span>;<span class="comment">//正确, 因为指向的堆内存中的对象的属性值仍旧可以改变</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"亚亚"</span>);<span class="comment">//错误, 因为栈内存中的引用不能改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="111-请解释以下常用正则含义：-d-D-s-0-9-6-d"><a href="#111-请解释以下常用正则含义：-d-D-s-0-9-6-d" class="headerlink" title="111. 请解释以下常用正则含义：\d,   \D,   \s,     .,      *,     ?,      |,     [0-9]{6},     \d+"></a>111. 请解释以下常用正则含义：\d,   \D,   \s,     .,      *,     ?,      |,     [0-9]{6},     \d+</h3><p>\d: 匹配一个数字字符。等价于[0-9]</p>
<p>\D: 匹配一个非数字字符。等价于[\^0-9]</p>
<p>\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]</p>
<p>.    ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</p>
<p>*：匹配前面的子表达式<strong>*零次或多次</strong>。要匹配 <em> 字符，请使用 \</em>。</p>
<p>+：匹配前面的子表达式<strong>一次或多次</strong>。要匹配 + 字符，请使用 +。</p>
<p>?:  匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</p>
<p>|:将两个匹配条件进行逻辑“或”（Or）运算</p>
<p>[0-9]{6}:匹配连续6个0-9之间的数字</p>
<p>\d+：匹配至少一个0-9之间的数字</p>
<p>{n,m}:  m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</p>
<h3 id="112-下面那些声明是合法的？（）"><a href="#112-下面那些声明是合法的？（）" class="headerlink" title="112 下面那些声明是合法的？（）"></a>112 下面那些声明是合法的？（）</h3><table>
<thead>
<tr>
<th>A</th>
<th>long l = 4990</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>int i = 4L</td>
</tr>
<tr>
<td>C.</td>
<td>float f = 1.1</td>
</tr>
<tr>
<td>D.</td>
<td>double d = 34.4</td>
</tr>
<tr>
<td>答案：AD<br>分析：<br>B int属于整数型应该是int=4 <br>C应该是float f=1.1f</td>
</tr>
</tbody>
</table>
<h3 id="113-重载和重写区别"><a href="#113-重载和重写区别" class="headerlink" title="113. 重载和重写区别"></a>113. 重载和重写区别</h3><p>重载：</p>
<p>方法重载（Overload）：一个类中有多个方法，名字必须相同，<strong>参数不同</strong>（如参数个数，种类，参数顺序不同），<strong>与返回值修饰符无关</strong>；</p>
<p>格式特点：<br>1.方法名必须相同。<br>2.方法的<strong>参数表必须不同</strong><br>如果参数个数不同，就不管它的参数类型了！<br>如果参数个数相同，那么参数的类型必须不同。<br>3.方法的返回类型、修饰符可以相同，也可不同。</p>
<p>重写：</p>
<p>方法重写（Override）：子类重写父类的方法，子类的方法名和参数与父类完全相同，<strong>只是方法的实现不同, 返回值和权限修饰符可相同可不相同</strong></p>
<p>方法重写必须满足下列条件<br>(1) 子类的<strong>方法名、参数列表</strong>必须和覆盖的方法<strong>完全一致</strong><br>(2) 子类的方法<strong>返回类型</strong>[层次]必须<strong>小于等于</strong>所覆盖的方法   (java 5或者以前，必须一样，java 7 java 8可以不同，但是必须是父类返回值的派生类。)<br>(3) 子类的方法<strong>权限修饰符</strong>必须<strong>大于等于</strong>所覆盖的方法<br>(4) 子类抛出的<strong>异常</strong>下<strong>不能超过</strong>父类相应方法抛出的异常(子类异常不能大于父类异常)</p>
<h3 id="114-下面哪个函数是public-void-example-…-的重载函数？（）"><a href="#114-下面哪个函数是public-void-example-…-的重载函数？（）" class="headerlink" title="114. 下面哪个函数是public void example(){….}的重载函数？（）"></a>114. 下面哪个函数是public void example(){….}的重载函数？（）</h3><table>
<thead>
<tr>
<th>A</th>
<th>private void example（int m）{…}</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>public int example（）{…}</td>
</tr>
<tr>
<td>C.</td>
<td>public void example2（）{…}</td>
</tr>
<tr>
<td>D.</td>
<td>public int example（int m.float f）{…}</td>
</tr>
<tr>
<td>答案：AD<br>分析：<br>BC定义的是新函数,因为B中虽然方法名与题目中方法名相同,但参数表和题目中的参数表相同,不符合重载条件</td>
</tr>
</tbody>
</table>
<p>例2下面哪几个函数是public void example（）{….}的重载函数（）</p>
<table>
<thead>
<tr>
<th>A</th>
<th>public void example（int m）{…}</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>public int example（int m）{…}</td>
</tr>
<tr>
<td>C.</td>
<td>public void example2（）{…}</td>
</tr>
<tr>
<td>D.</td>
<td>public int example（int m，float f）{…}</td>
</tr>
<tr>
<td>答案：ABD</td>
</tr>
</tbody>
</table>
<h3 id="115-打印结果："><a href="#115-打印结果：" class="headerlink" title="115. 打印结果："></a>115. 打印结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Test t=<span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span> b = t.get();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果: 2</span></span><br></pre></td></tr></table></figure>
<h3 id="116-指出下列程序的运行结果"><a href="#116-指出下列程序的运行结果" class="headerlink" title="116. .指出下列程序的运行结果"></a>116. .指出下列程序的运行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1: </span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">zero</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2:</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//注意: </span></span><br><span class="line"><span class="string">'在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一</span></span><br><span class="line"><span class="string">'</span>个<span class="keyword">switch</span>块内，都必须包含一个<span class="keyword">default</span>语句并且放在最后，即使它什么代码也没有<span class="string">'</span></span><br></pre></td></tr></table></figure>
<h3 id="117-什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#117-什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="117. 什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>117. 什么是编译型语言，什么是解释型语言？java可以归类到那种？</h3><p>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言<strong>翻译</strong>成机器语言，计算机才能运行高级语言所编写的程序。</p>
<p><strong>翻译的方式有两种，一个是编译，一个是解释。</strong></p>
<p>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为<strong>翻译只做了一次</strong>，运行时不需要翻译，所以一般而言，<strong>编译型语言的程序执行效率高</strong>。</p>
<p>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言<strong>每执行一次就要翻译一次</strong>，<strong>效率比较低</strong>。</p>
<p>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如<strong>JavaScript、VBScript、Perl、Python、Ruby、MATLAB</strong> 等等。</p>
<p><strong>JAVA语言是一种编译型-解释型语言</strong>，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者<strong>注意Java中所谓的“编译”和传统的“编译”的区别</strong>）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</p>
<h3 id="118-下面代码执行后的输出是什么（）"><a href="#118-下面代码执行后的输出是什么（）" class="headerlink" title="118. 下面代码执行后的输出是什么（）"></a>118. 下面代码执行后的输出是什么（）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    inner:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(j + <span class="string">" and "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>A</th>
<th>0 and 00 and 10 and 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>1 and 01 and 11 and 2</td>
</tr>
<tr>
<td>C.</td>
<td>2 and 02 and 12 and 2</td>
</tr>
<tr>
<td>答案：A</td>
</tr>
</tbody>
</table>
<h3 id="119-请问以下代码执行会打印出什么？"><a href="#119-请问以下代码执行会打印出什么？" class="headerlink" title="119. 请问以下代码执行会打印出什么？"></a>119. 请问以下代码执行会打印出什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FatherClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FatherClassCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"ChildClass Create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FatherClass fc = <span class="keyword">new</span> FatherClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//子类构造器第一行默认会有super();所以每次调用子类构造器,都会先执行父类构造器.</span></span><br><span class="line">        ChildClass cc = <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行结果: </span></span><br><span class="line">FatherClassCreate</span><br><span class="line">FatherClassCreate</span><br><span class="line">ChildClass Create</span><br></pre></td></tr></table></figure>
<h3 id="120-如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？"><a href="#120-如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？" class="headerlink" title="120. 如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？"></a>120. 如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？</h3><p>答：因为类A、B不是接口，所以是不可以直接实现的，但可以将A、B类定义成父子类，那么C类就能实现A、B类的功能了。假如A为B的父类，B为C的父类，此时C就能使用A、B的功能。</p>
<p>—–<strong>java中没有多继承但是有多重继承</strong></p>
<h3 id="121-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#121-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="121. 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>121. 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h3><p>答：构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</p>
<p>构造方法不能被继承 和 重写.</p>
<h3 id="122-如何将字符串2013-02-18-10-53-10转换为日期类型且格式化为：2013-02-18-10-53-10？"><a href="#122-如何将字符串2013-02-18-10-53-10转换为日期类型且格式化为：2013-02-18-10-53-10？" class="headerlink" title="122.如何将字符串2013-02-18 10:53:10转换为日期类型且格式化为：2013-02-18 10:53:10？"></a>122.如何将字符串2013-02-18 10:53:10转换为日期类型且格式化为：2013-02-18 10:53:10？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//第一步：将字符串（2013-02-18 10:53:10）转换成日期Date</span></span><br><span class="line">        DateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        String sdate=<span class="string">"2013-02-18 10:53:10"</span>;</span><br><span class="line">        Date date=sdf.parse(sdate);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：将日期Date转换成字符串String</span></span><br><span class="line">        DateFormat  sdf2=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        String sdate2=sdf2.format(date);</span><br><span class="line">        System.out.println(sdate2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">Mon Feb <span class="number">18</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">10</span> CST <span class="number">2013</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="123-下面哪些是对称加密算法（）"><a href="#123-下面哪些是对称加密算法（）" class="headerlink" title="123. 下面哪些是对称加密算法（）"></a>123. 下面哪些是对称加密算法（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>DES</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>MD5</td>
</tr>
<tr>
<td>C.</td>
<td>DSA</td>
</tr>
<tr>
<td>D.</td>
<td>RSA</td>
</tr>
<tr>
<td>答案：A<br>分析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES<br>常用的非对称加密算法有：RSA、DSA、ECC<br>使用单向散列函数的加密算法：MD5、SHA</td>
</tr>
</tbody>
</table>
<h3 id="124-以下Java代码段会产生几个对象"><a href="#124-以下Java代码段会产生几个对象" class="headerlink" title="124. 以下Java代码段会产生几个对象"></a>124. 以下Java代码段会产生几个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicvoid <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String a=<span class="string">"a"</span>;</span><br><span class="line">    String b=<span class="string">"b"</span>;</span><br><span class="line">    String c=<span class="string">"c"</span>;</span><br><span class="line">    c=a+<span class="string">""</span>+b+<span class="string">""</span>+c;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案: 一个对象，因为编译期进行了优化，3个字符串常量直接折叠为一个</p>
<h3 id="125-System-out-println-‘a’-1-的结果是"><a href="#125-System-out-println-‘a’-1-的结果是" class="headerlink" title="125.System.out.println(‘a’+1);的结果是"></a>125.System.out.println(‘a’+1);的结果是</h3><p>分析：’a’是char型，1 是int行，int与char相加，char会被强转为int型，char的ASCII码对应的值是97，所以加一起打印98</p>
<h3 id="126-成员变量用static修饰和不用static修饰有什么区别？"><a href="#126-成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="126. 成员变量用static修饰和不用static修饰有什么区别？"></a>126. 成员变量用static修饰和不用static修饰有什么区别？</h3><p>1、两个变量的生命周期不同。</p>
<p>成员变量随着对象的创建而存在，随着对象的被回收而释放。</p>
<p>静态变量随着类的加载而存在，随着类的消失而消失。</p>
<p>2、调用方式不同。</p>
<p>成员变量只能被对象调用。</p>
<p>静态变量用类名调用 ：Person.country</p>
<p>3、别名不同。</p>
<p>成员变量也称为实例变量。</p>
<p>静态变量称为类变量。 </p>
<p>4、数据存储位置不同。</p>
<p>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</p>
<p>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</p>
<h3 id="127-Java中关于super关键字的作用"><a href="#127-Java中关于super关键字的作用" class="headerlink" title="127. Java中关于super关键字的作用"></a>127. Java中关于super关键字的作用</h3><p>在子类继承父类中，一般有一行super的语句，需要记住三种使用方法：</p>
<p>1、super.变量/对象名；<br>使用这种方法可以直接访问父类中的变量或对象，进行修改赋值等操作</p>
<p>2、super.方法名()；<br>直接访问并调用父类中的方法</p>
<p>3、super();<br>调用父类的初始化方法，其实就是调用父类中的public xxx()方法，通常第三种指代的是super()的省略写法，系统会默认添加此句。</p>
<p>特殊情况：如果父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数，即不能使用系统默认的“super()”，而需要显性写出super(xxx)</p>
<h3 id="128-如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#128-如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="128. 如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>128. 如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h3><p>1、用final修饰的类不能被扩展，也就是说不可能有子类；</p>
<p>2、用final修饰的方法不能被替换或隐藏：</p>
<p>​    ① 使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</p>
<p>​    ② 使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏（hidden）；</p>
<p>3、用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：</p>
<p>​    ① 静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始    化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化表达式完成；</p>
<p>​    ② 实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行；</p>
<p>​    ③ 方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体    （body）结束，在此期间其值不能改变；</p>
<p>​    ④ 构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化，为对应实参值，终止于构造器体结束，在此期间其值不能改变；</p>
<p>​    ⑤ 异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</p>
<p>​    ⑥ 局部变量在其值被访问之前必须被明确赋值；</p>
<h3 id="129-Java反射技术主要实现类有哪些，作用分别是什么？"><a href="#129-Java反射技术主要实现类有哪些，作用分别是什么？" class="headerlink" title="129. Java反射技术主要实现类有哪些，作用分别是什么？"></a>129. Java反射技术主要实现类有哪些，作用分别是什么？</h3><p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</p>
<p>1）Class类：代表一个类</p>
<p>2）Field 类：代表类的成员变量(属性)</p>
<p>3）Method类：代表类的成员方法</p>
<p>4）Constructor 类：代表类的构造方法</p>
<p>5）Array类：提供了动态创建数组，以及访问数组的元素的静态方法</p>
<p>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</p>
<p>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的 结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>示 例</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象名 .getClass()</td>
<td>String str=”bdqn”;<br>Class clazz = str.getClass();</td>
</tr>
<tr>
<td>对象名 .getSuperClass()</td>
<td>Student stu = new Student();<br>Class c1 = stu.getClass();<br>Class c2 = stu.getSuperClass();</td>
</tr>
<tr>
<td>Class.forName()</td>
<td>Class clazz = Class.forName(“java.lang.Object”);<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);</td>
</tr>
<tr>
<td>类名.class</td>
<td>类名.class<br>Class c2 = Student.class;<br>Class c2 = int.class</td>
</tr>
<tr>
<td>包装类.TYPE</td>
<td>包装类.TYPE<br>Class c2 = Boolean.TYPE;</td>
</tr>
</tbody>
</table>
<h3 id="131-反射的使用场合和作用、及其优缺点"><a href="#131-反射的使用场合和作用、及其优缺点" class="headerlink" title="131. 反射的使用场合和作用、及其优缺点"></a>131. 反射的使用场合和作用、及其优缺点</h3><p>1）使用场合</p>
<p>在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。</p>
<p>2）主要作用</p>
<p>通过反射可以使程序代码==访问装载到JVM 中的类的内部信息==，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息</p>
<p>3）反射的优点</p>
<p>反射提高了Java程序的<strong>灵活性和扩展性</strong>，<strong>降低耦合性</strong>，提高自适应能力。它==允许程序创建和控制任何类的对象==，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的</p>
<p>4） Java反射技术应用领域很广，如软件测试等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术</p>
<p>5）反射的缺点</p>
<p><strong>性能问题：</strong>使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</p>
<p>使用反射会模糊程序内部<strong>逻辑</strong>：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码==更复杂。==</p>
<h3 id="132-面向对象设计原则有哪些"><a href="#132-面向对象设计原则有哪些" class="headerlink" title="132.面向对象设计原则有哪些"></a>132.面向对象设计原则有哪些</h3><p>面向对象设计原则是面向对象设计的基石，面向对象设计质量的依据和保障，设计模式是面向对象设计原则的经典应用</p>
<p>1）单一职责原则SRP</p>
<p>2）开闭原则OCP</p>
<p>3）里氏替代原则LSP</p>
<p>4）依赖注入原则DIP</p>
<p>5）接口分离原则ISP</p>
<p>6）迪米特原则LOD</p>
<p>7）组合/聚合复用原则CARP</p>
<p>8）开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他设计原则都可以看作是开闭原则的实现手段或方法</p>
<h3 id="133-接口和抽象类有什么区别？"><a href="#133-接口和抽象类有什么区别？" class="headerlink" title="133 接口和抽象类有什么区别？"></a>133 接口和抽象类有什么区别？</h3><ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<h3 id="134-抽象类能使用-final-修饰吗？"><a href="#134-抽象类能使用-final-修饰吗？" class="headerlink" title="134 抽象类能使用 final 修饰吗？"></a>134 抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqzh712xj3097039t8k.jpg" alt></p>
<h3 id="135-普通类和抽象类有哪些区别？"><a href="#135-普通类和抽象类有哪些区别？" class="headerlink" title="135 普通类和抽象类有哪些区别？"></a>135 普通类和抽象类有哪些区别？</h3><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法,也可以没有抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h3 id="136抽象类必须要有抽象方法吗？"><a href="#136抽象类必须要有抽象方法吗？" class="headerlink" title="136抽象类必须要有抽象方法吗？"></a>136抽象类必须要有抽象方法吗？</h3><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out. println(<span class="string">"hi~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h3 id="137-final-在-Java-中有什么作用？"><a href="#137-final-在-Java-中有什么作用？" class="headerlink" title="137 final 在 Java 中有什么作用？"></a>137 final 在 Java 中有什么作用？</h3><ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h3 id="138-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#138-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="138 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>138 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h3><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>
<p>执行的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h3 id="139-和-equals-的区别是什么？"><a href="#139-和-equals-的区别是什么？" class="headerlink" title="139 == 和 equals 的区别是什么？"></a>139 == 和 equals 的区别是什么？</h3><p><strong>== 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h3 id="140-JDK-和-JRE-有什么区别？"><a href="#140-JDK-和-JRE-有什么区别？" class="headerlink" title="140 JDK 和 JRE 有什么区别？"></a>140 JDK 和 JRE 有什么区别？</h3><p>Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。</p>
<p>Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序</p>
<p>JRE： Java Runtime Environment  </p>
<p>JDK：Java Development Kit</p>
<p>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</p>
<p>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。</p>
<p>如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。</p>
<p>JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本<br>再说说java的跨平台吧:<br>java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行</p>
<p>最后解释下机器码和字节码的区别:<br>一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码 </p>
<p>意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～</p>
<p>二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～</p>
<p>小结: </p>
<ul>
<li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的==开发环境和运行环境==。</li>
<li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的==运行==提供了所需==环境==。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h3 id="141-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#141-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="141 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>141 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h3><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p>
<p>Java中static方法<strong>不能被覆盖</strong>，因为<strong>方法覆盖是基于运行时动态绑定的</strong>，而<strong>static方法是编译时静态绑定的</strong>。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<p>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</p>
<h3 id="142-是否可以在static环境中访问非static变量？"><a href="#142-是否可以在static环境中访问非static变量？" class="headerlink" title="142 是否可以在static环境中访问非static变量？"></a>142 是否可以在static环境中访问非static变量？</h3><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h3 id="143-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#143-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="143 .Java支持的数据类型有哪些？什么是自动拆装箱？"></a>143 .Java支持的数据类型有哪些？什么是自动拆装箱？</h3><p>Java语言支持的8种基本数据类型是：</p>
<p>byte</p>
<p>short</p>
<p>int</p>
<p>long</p>
<p>float</p>
<p>double</p>
<p>boolean</p>
<p>char</p>
<p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱</p>
<p>Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程</p>
<h3 id="144-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？—-68题"><a href="#144-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？—-68题" class="headerlink" title="144 Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？—-68题"></a>144 Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？—-68题</h3><p>Java中的方法重载发生在<strong>同一个类</strong>里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，</p>
<p>方法覆盖是说<strong>子类</strong>重新定义了<strong>父类</strong>的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h3 id="145-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#145-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="145 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>145 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h3><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。<br>Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p>
<h3 id="146-Java支持多继承么？"><a href="#146-Java支持多继承么？" class="headerlink" title="146 Java支持多继承么？"></a>146 Java支持多继承么？</h3><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的接口和抽象类的区别是什么？作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p>
<h3 id="147-接口和抽象类的区别是什么？"><a href="#147-接口和抽象类的区别是什么？" class="headerlink" title="147 接口和抽象类的区别是什么？"></a>147 接口和抽象类的区别是什么？</h3><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。<br>也可以参考JDK8中抽象类和接口的区别</p>
<h3 id="148-什么是值传递和引用传递？"><a href="#148-什么是值传递和引用传递？" class="headerlink" title="148 什么是值传递和引用传递？"></a>148 什么是值传递和引用传递？</h3><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</p>
<p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</p>
<p>一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递</p>
<h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><h3 id="1-下面程序的运行结果是（）（选择一项）"><a href="#1-下面程序的运行结果是（）（选择一项）" class="headerlink" title="1. 下面程序的运行结果是（）（选择一项）"></a>1. 下面程序的运行结果是（）（选择一项）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"hello"</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>A.</th>
<th>true</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>false</td>
</tr>
<tr>
<td>C.</td>
<td>hello</td>
</tr>
<tr>
<td>D.</td>
<td>he</td>
</tr>
<tr>
<td>答案：<br>B分析：str1没有使用new关键字，在堆中没有开辟空间，其值”hello”在常量池中，str2使用new关键字创建了一个对象，在堆中开辟了空间，”==”比较的是对象的引用，即内存地址，所以str1与str2两个对象的内存地址是不相同的.</td>
</tr>
</tbody>
</table>
<h3 id="2-Java语言中，String类中的indexOf-方法返回值的类型是（）"><a href="#2-Java语言中，String类中的indexOf-方法返回值的类型是（）" class="headerlink" title="2. Java语言中，String类中的indexOf( )方法返回值的类型是（）"></a>2. Java语言中，String类中的indexOf( )方法返回值的类型是（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>int16</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>int32</td>
</tr>
<tr>
<td>C.</td>
<td>int</td>
</tr>
<tr>
<td>D.</td>
<td>long</td>
</tr>
<tr>
<td>答案：C</td>
</tr>
</tbody>
</table>
<h3 id="3-给定以下代码，程序的运行结果是-（）（选择一项）——-gt-易错题"><a href="#3-给定以下代码，程序的运行结果是-（）（选择一项）——-gt-易错题" class="headerlink" title="3. 给定以下代码，程序的运行结果是 （）（选择一项）——&gt;易错题"></a>3. 给定以下代码，程序的运行结果是 （）（选择一项）——&gt;易错题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    String str=<span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span> [] ch=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Example ex=<span class="keyword">new</span> Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str+<span class="string">"and"</span>);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String  str,<span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">        str=<span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>]=<span class="string">'g'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>A.</th>
<th>goodandabc</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>goodandgbc</td>
</tr>
<tr>
<td>C.</td>
<td>test okandabc</td>
</tr>
<tr>
<td>D.</td>
<td>test okandgbc</td>
</tr>
<tr>
<td>答案：B<br>分析：在方法调用时，在change方法中对str的值进行修改，是将str指向了常量池中的”test ok”，而主方法中的ex.str仍然指向的是常量池中的”good”。<br>字符型数组在方法调用时，将主方法中ex.ch的引用传递给change方法中的ch，指向是堆中的同一堆空间，所以修改ch[0]的时候,ex.ch可以看到相同的修改后的结果。</td>
</tr>
</tbody>
</table>
<h3 id="4-执行下列代码后，哪个结论是正确的（）（选择两项）"><a href="#4-执行下列代码后，哪个结论是正确的（）（选择两项）" class="headerlink" title="4. 执行下列代码后，哪个结论是正确的（）（选择两项）"></a>4. 执行下列代码后，哪个结论是正确的（）（选择两项）</h3><p>String[] s=new String[10];</p>
<table>
<thead>
<tr>
<th>A.</th>
<th>s[10]为””</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>s[9]为null</td>
</tr>
<tr>
<td>C.</td>
<td>s[0]为未定义</td>
</tr>
<tr>
<td>D.</td>
<td>s.length为10</td>
</tr>
<tr>
<td>答案：BD<br>分析：<br>引用数据类型的默认值均为null<br>s.length数组的长度</td>
</tr>
</tbody>
</table>
<h3 id="5-实现String类的replaceAll方法"><a href="#5-实现String类的replaceAll方法" class="headerlink" title="5. 实现String类的replaceAll方法"></a>5. 实现String类的replaceAll方法</h3><p>思路说明：replaceAll方法的本质是使用正则表达式进行匹配，最终调用的其实是Matcher对象的replaceAll方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringReplaceAll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"a1s2d3f4h5j6k7"</span>;</span><br><span class="line">        <span class="comment">// 将字符串中的数字全部替换为0</span></span><br><span class="line">        System.out.println(replaceAll(str, <span class="string">"\\d"</span>, <span class="string">"0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str:源字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> regex:正则表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStr:替换后的子字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回替换成功后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAll</span><span class="params">(String str, String regex, String newStr)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        Matcher mathcer = pattern.matcher(str);</span><br><span class="line">        String reslut = mathcer.replaceAll(newStr);</span><br><span class="line">        <span class="keyword">return</span> reslut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-在“-”后填写适当的内容："><a href="#6-在“-”后填写适当的内容：" class="headerlink" title="6. 在“=”后填写适当的内容："></a>6. 在“=”后填写适当的内容：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String []a=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">则：</span><br><span class="line">a[<span class="number">0</span>]~a[<span class="number">9</span>]=<span class="keyword">null</span>;</span><br><span class="line">a.length=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">如果是<span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">则：</span><br><span class="line">a[<span class="number">0</span>]~a[<span class="number">9</span>]= <span class="number">0</span></span><br><span class="line">a.length= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">如果为 <span class="keyword">int</span> b;</span><br><span class="line">则System.out.println(b); <span class="comment">//编译不通过,提示变量b未初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="7-是否可以继承String类"><a href="#7-是否可以继承String类" class="headerlink" title="7. 是否可以继承String类?"></a>7. 是否可以继承String类?</h3><p>答:不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。</p>
<p>public final class String implements java.io.Serializable,</p>
<p>Comparable&lt; String&gt;, CharSequence</p>
<h3 id="8-给定两个字符串s和t，-写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。"><a href="#8-给定两个字符串s和t，-写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。" class="headerlink" title="8. 给定两个字符串s和t， 写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。"></a>8. 给定两个字符串s和t， 写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())<span class="comment">//长度不相等,则一定不是重组词</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> bit[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            bit[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--bit[t.charAt(i) - <span class="string">'a'</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-String-s-new-String-“abc”-创建了几个String对象。"><a href="#9-String-s-new-String-“abc”-创建了几个String对象。" class="headerlink" title="9. String s = new String(“abc”);创建了几个String对象。"></a>9. String s = new String(“abc”);创建了几个String对象。</h3><p>答: <strong>两个或一个</strong>，</p>
<p>”abc”对应一个对象，这个对象放在字符串常量缓冲区，常量”abc”不管出现多少遍，都是缓冲区中的那一个。</p>
<p>new String每写一遍，就创建一个新的对象，它依据那个常量”abc”对象的内容来创建出一个新String对象。如果以前就用过’abc’，这句代表就不会创建”abc”自己了，直接从缓冲区拿。</p>
<h3 id="10-输出结果？"><a href="#10-输出结果？" class="headerlink" title="10. 输出结果？"></a>10. 输出结果？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"hello"</span>;</span><br><span class="line">String str2=<span class="string">"he"</span>+<span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">System.out.println(str1==str2);</span><br><span class="line">System.out.println(str1.equal(str2));</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="11-下面哪个是正确的（）"><a href="#11-下面哪个是正确的（）" class="headerlink" title="11. 下面哪个是正确的（）"></a>11. 下面哪个是正确的（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>String temp[ ] = new String{“a”,”b”,”c”};</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>String temp[ ] = {“a”,”b”,”c”};</td>
</tr>
<tr>
<td>C.</td>
<td>String temp= {“a”,”b”,”c”};</td>
</tr>
<tr>
<td>D.</td>
<td>String[ ] temp = {“a”,”b”,”c”};</td>
</tr>
<tr>
<td>答案：BD<br>new 对象时是圆括号()<br>给数组赋值用花括号,给变量赋值不能用花括号</td>
</tr>
</tbody>
</table>
<h3 id="12-已知如下代码：执行结果是什么（）"><a href="#12-已知如下代码：执行结果是什么（）" class="headerlink" title="12. 已知如下代码：执行结果是什么（）"></a>12. 已知如下代码：执行结果是什么（）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.print(s1 == s2);</span><br><span class="line">        String s3 = <span class="string">"Hello"</span>;</span><br><span class="line">        String s4 = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.print(s3 == s4);</span><br><span class="line">        s1 = s3;</span><br><span class="line">        s2 = s4;</span><br><span class="line">        System.out.print(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>A.</th>
<th>false true true</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>true false true</td>
</tr>
<tr>
<td>C.</td>
<td>true true false</td>
</tr>
<tr>
<td>D.</td>
<td>true true false</td>
</tr>
<tr>
<td>答案：A</td>
</tr>
</tbody>
</table>
<h3 id="13-字符串如何转换为int类型"><a href="#13-字符串如何转换为int类型" class="headerlink" title="13. 字符串如何转换为int类型"></a>13. 字符串如何转换为int类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="keyword">int</span> num=Integer.parseInt(<span class="string">"123"</span>);</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        Integer in = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">        <span class="keyword">int</span> a =   in.intValue();</span><br><span class="line">        System.out.println(a);  </span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="keyword">int</span> num2=Integer.valueOf(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(num+<span class="string">"  "</span>+num2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mut4ubu5j30ss0bywmm.jpg" alt></p>
<h3 id="14-写一个方法，实现字符串的反转，如：输入abc，输出cba"><a href="#14-写一个方法，实现字符串的反转，如：输入abc，输出cba" class="headerlink" title="14. 写一个方法，实现字符串的反转，如：输入abc，输出cba"></a>14. 写一个方法，实现字符串的反转，如：输入abc，输出cba</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String result=reverse(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chArra = str.toCharArray();<span class="comment">//字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = chArra.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;<span class="comment">//从后往前取值</span></span><br><span class="line">            <span class="keyword">char</span> ch = chArra[i];</span><br><span class="line">            result.append(ch);<span class="comment">//连接取出的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();<span class="comment">//字符数组转换为字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-编写java，将“I-follow-Bill-Gate-Tom-Gate-John-Gate”中的“Gate”全部替换为“Gates”"><a href="#15-编写java，将“I-follow-Bill-Gate-Tom-Gate-John-Gate”中的“Gate”全部替换为“Gates”" class="headerlink" title="15. 编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”"></a>15. 编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字符串的replaceAll方法</span></span><br><span class="line"><span class="keyword">public</span> classDemo1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s=<span class="string">"I follow Bill Gate.Tom Gate.John Gate"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s=s.replaceAll(<span class="string">"Gate"</span>,<span class="string">"Gates"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-String-是最基本的数据类型吗"><a href="#16-String-是最基本的数据类型吗" class="headerlink" title="16. String 是最基本的数据类型吗?"></a>16. String 是最基本的数据类型吗?</h3><p>答： 不是 。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）—-&gt;(如类(例如String),数组,枚举,接口)。</p>
<h3 id="17-String-和StringBuilder、StringBuffer-的区别"><a href="#17-String-和StringBuilder、StringBuffer-的区别" class="headerlink" title="17. String 和StringBuilder、StringBuffer 的区别?"></a>17. String 和StringBuilder、StringBuffer 的区别?</h3><p>答： Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder</p>
<p>相同点：</p>
<p>它们都可以储存和操作字符串，同时三者都使用final修饰，都属于终结类不能派生子类，操作的相关方法也类似例如获取字符串长度等；</p>
<p>不同点：</p>
<p>其中<strong>String是只读字符串</strong>，也就意味着String引用的字符串内容是不能被改变的，而<strong>StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改</strong>，在修改的同时地址值不会发生改变。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在<strong>单线程</strong>环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的<strong>效率也比StringBuffer略高</strong>。</p>
<p>在此重点说明一下，String、StringBuffer、StringBuilder三者类型不一样，<strong>无法使用equals()方法比较其字符串内容是否一样！</strong></p>
<p>补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。</p>
<p>补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">smallT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"Programming"</span>;</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);</span><br><span class="line">        String c = <span class="string">"Program"</span> + <span class="string">"ming"</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">        System.out.println(a.equals(c));</span><br><span class="line">        System.out.println(a.intern() == b.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mvols8ucj30zu0dsglr.jpg" alt></p>
<p>解析：</p>
<p>String类存在intern()方法，含义如下：返回字符串对象的规范化表示形式.<br>它遵循以下规则:<br>对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。</p>
<p>字符串比较分为两种形式:</p>
<p>一种使用比较运算符”==”比较，他们比较的是各自的字符串在内存当中的地址值是否相同；<br>另一种是使用equals()方法进行比较，比较的是两个字符串的内容是否相同(前提是该类重写了equals方法,否则equals方法还是比较的是地址)！</p>
<h3 id="18-String类为什么是final的"><a href="#18-String类为什么是final的" class="headerlink" title="18. String类为什么是final的"></a>18. String类为什么是final的</h3><p>答：1） <strong>为了效率</strong>。若允许被继承，则其高度的被使用率可能会降低程序的性能。</p>
<p>2）<strong>为了安全</strong>。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性，如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点。</p>
<h3 id="19-String-s-”Hello”-s-s-”world-”-执行后，是否是对前面s指向空间内容的修改？"><a href="#19-String-s-”Hello”-s-s-”world-”-执行后，是否是对前面s指向空间内容的修改？" class="headerlink" title="19. String s=”Hello”;s=s+”world!”;执行后，是否是对前面s指向空间内容的修改？"></a>19. String s=”Hello”;s=s+”world!”;执行后，是否是对前面s指向空间内容的修改？</h3><p>答：不是对前面s指向空间内容的直接修改。</p>
<p><strong>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象</strong>。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。</p>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。</p>
<p>例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">public</span> Demo &#123;</span><br><span class="line">        s = <span class="string">"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非</p>
<p>s = new String(“Initial Value”);</p>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。</p>
<p>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。</p>
<p>至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。</p>
<h3 id="20-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#20-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="20. 下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>20. 下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h3><p>答：对于如下代码：</p>
<p>String s1 = “a”;</p>
<p>String s2 = s1 + “b”;</p>
<p>String s3 = “a” + “b”;</p>
<p>System.out.println(s2 == “ab”);</p>
<p>System.out.println(s3 == “ab”);</p>
<p>第一条语句打印的结果为false，第二条语句打印的结果为true，<br>这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。</p>
<p>题目中的第一行代码被编译器在编译时优化后，相当于直接定义一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。</p>
<p>写如下两行代码: </p>
<p>String s = “a” + “b” + “c” + “d”;</p>
<p>System.out.println(s == “abcd”);</p>
<p>最终打印的结果应该为true。</p>
<h3 id="21-String-类的常用方法都有那些？"><a href="#21-String-类的常用方法都有那些？" class="headerlink" title="21. String 类的常用方法都有那些？"></a>21. String 类的常用方法都有那些？</h3><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="22-如何将字符串反转？"><a href="#22-如何将字符串反转？" class="headerlink" title="22. 如何将字符串反转？"></a>22. 如何将字符串反转？</h3><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>
<h3 id="23-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#23-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="23. String str=”i”与 String str=new String(“i”)一样吗？"></a>23. String str=”i”与 String str=new String(“i”)一样吗？</h3><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h3 id="24-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#24-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="24. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>24. Java 中操作字符串都有哪些类？它们之间有什么区别？</h3><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h3 id="25-String-属于基础的数据类型吗？"><a href="#25-String-属于基础的数据类型吗？" class="headerlink" title="25.  String 属于基础的数据类型吗？"></a>25.  String 属于基础的数据类型吗？</h3><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h2 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h2><h3 id="1-Java集合体系结构（List、Set、Collection、Map的区别和联系）"><a href="#1-Java集合体系结构（List、Set、Collection、Map的区别和联系）" class="headerlink" title="1. Java集合体系结构（List、Set、Collection、Map的区别和联系）"></a>1. Java集合体系结构（List、Set、Collection、Map的区别和联系）</h3><p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwtqx3r3j30i60by7b8.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwu91hxsj30cf07pmyx.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mw3bpxdij308w056dg0.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3n07pe84sj30ke09m402.jpg" alt></p>
<p>1、Collection 接口存储一组不唯一，无序的对象</p>
<p>2、List 接口存储一组不唯一，有序（插入顺序）的对象</p>
<p>3、Set 接口存储一组唯一，无序的对象</p>
<p>4、Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</p>
<h3 id="2-Vector和ArrayList的区别和联系"><a href="#2-Vector和ArrayList的区别和联系" class="headerlink" title="2. Vector和ArrayList的区别和联系"></a>2. Vector和ArrayList的区别和联系</h3><ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<p>相同点：</p>
<p>1）<strong>实现原理</strong>相同—底层都使用数组</p>
<p>2）<strong>功能</strong>相同—实现增删改查等操作的方法相似</p>
<p>3）都是<strong>长度可变</strong>的数组结构，很多情况下可以互用</p>
<p>不同点：</p>
<p>1）Vector是早期JDK版本提供，ArrayList是新版本替代Vector的</p>
<p>2）<strong>Vector线程安全</strong>，ArrayList重速度轻安全，线程非安全长度需增长时，Vector默认增长一倍，ArrayList增长50%</p>
<h3 id="3-ArrayList和LinkedList的区别和联系"><a href="#3-ArrayList和LinkedList的区别和联系" class="headerlink" title="3. ArrayList和LinkedList的区别和联系"></a>3. ArrayList和LinkedList的区别和联系</h3><p>相同点：</p>
<p>两者都实现了List接口，都具有List中元素有序、不唯一的特点。</p>
<p>不同点：</p>
<p>ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwdlumfsj30ch01gwea.jpg" alt></p>
<p>LinkedList采用链表存储方式。插入、删除元素时效率比较高</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3mwe1vdwaj30fm014dfm.jpg" alt></p>
<h3 id="4-Array-和-ArrayList-有何区别？"><a href="#4-Array-和-ArrayList-有何区别？" class="headerlink" title="4. Array 和 ArrayList 有何区别？"></a>4. Array 和 ArrayList 有何区别？</h3><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h3 id="5-HashSet的使用和原理（hashCode-和equals-）"><a href="#5-HashSet的使用和原理（hashCode-和equals-）" class="headerlink" title="5. HashSet的使用和原理（hashCode()和equals()）"></a>5. HashSet的使用和原理（hashCode()和equals()）</h3><p>1）哈希表的查询速度特别快，时间复杂度为O（1）。</p>
<p>2）HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</p>
<p>3）系统类已经覆盖了hashCode方法, 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</p>
<p>4）向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</p>
<p>5）<strong>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()</strong>。<strong>hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</strong></p>
<p>6）    Y=K(X) ：K是函数，X是哈希码，Y是地址</p>
<h3 id="6-TreeSet的原理和使用（Comparable和comparator）"><a href="#6-TreeSet的原理和使用（Comparable和comparator）" class="headerlink" title="6. TreeSet的原理和使用（Comparable和comparator）"></a>6. TreeSet的原理和使用（Comparable和comparator）</h3><p>1）TreeSet集合，元素不允许重复且有序(<strong>自然顺序)</strong></p>
<p>2）TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</p>
<p>3）可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</p>
<p>4）可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</p>
<h3 id="7-集合和数组的比较（为什么引入集合）"><a href="#7-集合和数组的比较（为什么引入集合）" class="headerlink" title="7. 集合和数组的比较（为什么引入集合）"></a>7. 集合和数组的比较（为什么引入集合）</h3><p>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合。具体如下：</p>
<p>1）数组的效率高于集合类.</p>
<p>2）数组能存放基本数据类型和对象，而<strong>集合类中只能放对象</strong>。</p>
<p>3）数组容量固定且无法动态改变，<strong>集合类容量动态改变</strong>。</p>
<p>4）<strong>数组无法判断其中实际存有多少元素</strong>，length只告诉了array的容量。</p>
<p>5）集合有<strong>多种实现方式和不同的适用场合</strong>，而不像数组仅采用顺序表方式。</p>
<p>6）集合<strong>以类的形式存在</strong>，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</p>
<h3 id="8-Collection和Collections的区别"><a href="#8-Collection和Collections的区别" class="headerlink" title="8. Collection和Collections的区别"></a>8. Collection和Collections的区别</h3><p>1）Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</p>
<p>2）Java中还有一个Collections类，专门用来操作集合类 ，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="9-下列说法正确的有（）（选择一项）"><a href="#9-下列说法正确的有（）（选择一项）" class="headerlink" title="9. 下列说法正确的有（）（选择一项）"></a>9. 下列说法正确的有（）（选择一项）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>LinkedList继承自List</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>AbstractSet继承自Set</td>
</tr>
<tr>
<td>C.</td>
<td>HashSet继承自AbstractSet</td>
</tr>
<tr>
<td>D.</td>
<td>TreeMap继承自HashMap</td>
</tr>
<tr>
<td>答案： C<br>分析：<br>A：LinkedList实现List接口<br>B：AbstractSet实现Set接口<br>D：TreeMap继承AbstractMap</td>
</tr>
</tbody>
</table>
<h3 id="10-Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？"><a href="#10-Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？" class="headerlink" title="10. Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？"></a>10. Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？</h3><p>答：HashMap与Hashtable实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</p>
<p>两者的主要区别如下</p>
<p>1、Hashtable是<strong>早期JDK提供的接口</strong>，HashMap是新版JDK提供的接口</p>
<p>2、<strong>Hashtable继承Dictionary类</strong>，HashMap实现Map接口</p>
<p>3、<strong>Hashtable线程安全</strong>，HashMap线程非安全</p>
<p>4、<strong>Hashtable不允许null值</strong>，HashMap允许null值</p>
<p>HashSet与HashMap的区别</p>
<p>1、<strong>HashSet底层是采用HashMap实现的</strong>。HashSet 的实现比较简单，HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。</p>
<p>2、HashMap的<strong>key就是放进HashSet中对象</strong>，<strong>value是Object类型的</strong>。</p>
<p>3、当调用HashSet的add方法时，实际上是向HashMap中增加了一行(key-value对)，该行的key就是向HashSet增加的那个对象，该行的value就是一个Object类型的常量</p>
<h3 id="11-列出Java中的集合类层次结构？"><a href="#11-列出Java中的集合类层次结构？" class="headerlink" title="11. 列出Java中的集合类层次结构？"></a>11. 列出Java中的集合类层次结构？</h3><p>答:Java中集合主要分为两种：Collection和Map。Collection是List和Set接口的父接口；ArrayList和LinkedList是List的实现类；HashSet 和TreeSet是Set的实现类；LinkedHashSet是HashSet的子类。HashMap和TreeMap是Map的实现类；LinkedHashMap是HashMap的子类。</p>
<p>图中：虚线框中为接口，实线框中为类。</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZly1g3n1etqz29j30by06y74l.jpg" alt></p>
<h3 id="12-List，Set，Map各有什么特点"><a href="#12-List，Set，Map各有什么特点" class="headerlink" title="12. List，Set，Map各有什么特点"></a>12. List，Set，Map各有什么特点</h3><p>答:List 接口存储一组可重复，有序（插入顺序）的对象。</p>
<p>Set 接口存储一组不可重复，无序的对象。</p>
<p>Map接口存储一组键值对象，提供key到value的映射。key无序，不可重复。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</p>
<h3 id="13-合并两个有序的链表"><a href="#13-合并两个有序的链表" class="headerlink" title="13.合并两个有序的链表"></a>13.合并两个有序的链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = l1.val &lt; l2.val ? l1 : l2;</span><br><span class="line">        ListNode other = l1.val &gt;= l2.val ? l1 : l2;</span><br><span class="line">        ListNode prevHead = head;</span><br><span class="line">        ListNode prevOther = other;</span><br><span class="line">        <span class="keyword">while</span> (prevHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = prevHead.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.val &gt; prevOther.val) &#123;</span><br><span class="line">                prevHead.next = prevOther;</span><br><span class="line">                prevOther = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prevHead.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                prevHead.next=prevOther;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHead=prevHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-用递归方式实现链表的转置。"><a href="#14-用递归方式实现链表的转置。" class="headerlink" title="14. 用递归方式实现链表的转置。"></a>14. 用递归方式实现链表的转置。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	ListNode next;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	ListNode(int x) &#123; </span></span><br><span class="line"><span class="comment">		val = x;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;<span class="comment">//递归结束条件</span></span><br><span class="line">          	<span class="keyword">return</span> head;  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode prev = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。"><a href="#15-给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。" class="headerlink" title="15. 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。"></a>15. 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets (<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">//排序</span></span><br><span class="line">        dfs(nums, <span class="number">0</span>, item, res);  <span class="comment">//递归调用</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());  <span class="comment">//最后加上一个空集</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            item.add(nums[i]);</span><br><span class="line">            <span class="comment">//item是以整数为元素的动态数组，而res是以数组为元素的数组，在这一步，当item增加完元素后，item</span></span><br><span class="line">           <span class="comment">// 所有元素构成一个完整的子串，再由res纳入</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(item));</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>, item, res);</span><br><span class="line">            item.remove(item.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#16-Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="16. Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>16. Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h3><p>答：1. Map的实现类有HashMap,LinkedHashMap,TreeMap</p>
<p>\2. HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序(即<strong>插入有序</strong>)；TreeMap默认是自然升序(<strong>即自然有序</strong>)）</p>
<p>\3. LinkedHashMap<strong>底层存储结构是哈希表+链表</strong>，<strong>链表记录了添加数据的顺序</strong></p>
<p>\4. TreeMap底层存储结构是<strong>二叉树</strong>，二叉树的<strong>中序遍历保证了数据的有序性</strong></p>
<p>\5. LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</p>
<h3 id="17-下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？"><a href="#17-下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？" class="headerlink" title="17. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？"></a>17. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            list.addLast(x);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> Object <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.removeLast( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：将if( list.size() &lt;= 0 )改成：while( list.size() &lt;= 0 )</p>
<h3 id="18-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#18-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="18. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>18. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h3><p>答：</p>
<p>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小。</p>
<p>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</p>
<p>Collections 工具类的sort方法有两种重载的形式:</p>
<p>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；</p>
<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</p>
<h3 id="19-Java-util-Map的实现类有"><a href="#19-Java-util-Map的实现类有" class="headerlink" title="19. Java.util.Map的实现类有"></a>19. Java.util.Map的实现类有</h3><p>分析：Java中的java.util.Map的实现类</p>
<p>1、HashMap</p>
<p>2、Hashtable</p>
<p>3、LinkedHashMap</p>
<p>4、TreeMap</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3xllf90llj30i00c377y.jpg" alt></p>
<h3 id="20-List里面如何剔除相同的对象？请简单用代码实现一种方法"><a href="#20-List里面如何剔除相同的对象？请简单用代码实现一种方法" class="headerlink" title="20. List里面如何剔除相同的对象？请简单用代码实现一种方法"></a>20. List里面如何剔除相同的对象？请简单用代码实现一种方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; li1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        li1.add(<span class="string">"8"</span>);</span><br><span class="line">        li1.add(<span class="string">"8"</span>);</span><br><span class="line">        li1.add(<span class="string">"9"</span>);</span><br><span class="line">        li1.add(<span class="string">"9"</span>);</span><br><span class="line">        li1.add(<span class="string">"0"</span>);</span><br><span class="line">        System.out.println(li1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法:将List中数据取出来来存到Set中</span></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; li1.size();i++)&#123;</span><br><span class="line">            set.add(li1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-List、Set、Map-是否继承自Collection-接口？"><a href="#21-List、Set、Map-是否继承自Collection-接口？" class="headerlink" title="21. List、Set、Map 是否继承自Collection 接口？"></a>21. List、Set、Map 是否继承自Collection 接口？</h3><p>答：List、Set 的父接口是Collection，Map 不是其子接口，而是与Collection接口是平行关系，互不包含。</p>
<p>Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 </p>
<h3 id="22-说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#22-说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="22. 说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>22. 说出ArrayList、Vector、LinkedList 的存储性能和特性？</h3><p>答：<strong>ArrayList 和Vector都是使用数组方式存储数据</strong>，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，</p>
<p><strong>Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差</strong>，</p>
<p>而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实<strong>对内存的利用率更高</strong>），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以<strong>插入速度较快,查询较慢</strong>。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</p>
<p>补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，<strong>Properties是一个键和值都是字符串的特殊的键值对映射</strong>，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的<strong>Properties直接继承了Hashtable</strong>，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖） 。同理，Stack类继承Vector也是不正确的。</p>
<h3 id="23-List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#23-List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="23. List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>23. List、Map、Set 三个接口，存取元素时，各有什么特点？</h3><p>答：List以<strong>特定索引来存取元素</strong>，可有重复元素。</p>
<p>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复） 。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于<strong>哈希存储和排序树</strong>（<strong>红黑树</strong>）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 </p>
<h3 id="24-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#24-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="24. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>24. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h3><p>答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p>
<p>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而<strong>根据键对元素进行排序</strong>。</p>
<p>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型 （需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用。</p>
<p>例子1：</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;        <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;            <span class="comment">// 年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">//public int compareTo(Student o) &#123;</span></span><br><span class="line">   <span class="comment">//     return this.age - o.age; // 比较年龄(年龄的升序)</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="keyword">this</span>.age - o.age); <span class="comment">// 比较年龄(年龄的降序)</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test01.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();     <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</span><br><span class="line">        <span class="keyword">for</span>(Student stu : set) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      输出结果:</span></span><br><span class="line">        <span class="comment">//      Student [name=Bob YANG, age=22]</span></span><br><span class="line">        <span class="comment">//      Student [name=XJ WANG, age=32]</span></span><br><span class="line">        <span class="comment">//      Student [name=Hao LUO, age=33]</span></span><br><span class="line">        <span class="comment">//      Student [name=Bruce LEE, age=60]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子2：</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取学生姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取学生年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test02.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过sort方法的第二个参数传入一个Comparator接口对象</span></span><br><span class="line">        <span class="comment">// 相当于是传入一个比较对象大小的算法到sort方法中</span></span><br><span class="line">        <span class="comment">// 由于Java中没有函数指针、仿函数、委托这样的概念</span></span><br><span class="line">        <span class="comment">// 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt; () &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">                    Student c1 = (Student) o1;</span><br><span class="line">                    Student c2 = (Student) o2;</span><br><span class="line">                    <span class="comment">//	return c1.getId().compareTo(c2.getId());</span></span><br><span class="line">                    <span class="keyword">int</span> i = c1.getAge().compareTo(c2.getAge());</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">//如果两个对象的ID相同，</span></span><br><span class="line">                        <span class="keyword">return</span> c1.getName().compareTo(c2.getName());<span class="comment">//就接着比较姓名</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> i;          <span class="comment">//如果id不同</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Student stu : list) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-HashMap和Hashtable的区别和联"><a href="#25-HashMap和Hashtable的区别和联" class="headerlink" title="25. HashMap和Hashtable的区别和联"></a>25. HashMap和Hashtable的区别和联</h3><p>相同点：</p>
<p>实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</p>
<p>不同点：</p>
<p>1、Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</p>
<p>2、Hashtable继承Dictionary类，HashMap实现Map接口</p>
<p>3、<strong>Hashtable线程安全</strong>，HashMap线程非安全</p>
<p>4、Hashtable不允许null值，HashMap允许null值</p>
<h3 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a>26. 如何实现数组和 List 之间的转换？</h3><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">"王磊"</span>);</span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"王磊"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>
<h3 id="27-说一下-HashSet-的实现原理？"><a href="#27-说一下-HashSet-的实现原理？" class="headerlink" title="27. 说一下 HashSet 的实现原理？"></a>27. 说一下 HashSet 的实现原理？</h3><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h3 id="28-说一下-HashMap-的实现原理？"><a href="#28-说一下-HashMap-的实现原理？" class="headerlink" title="28. 说一下 HashMap 的实现原理？"></a>28. 说一下 HashMap 的实现原理？</h3><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h3 id="29如何决定使用-HashMap-还是-TreeMap？"><a href="#29如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="29如何决定使用 HashMap 还是 TreeMap？"></a>29如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h3 id="30-HashMap-和-Hashtable-有什么区别？"><a href="#30-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="30 HashMap 和 Hashtable 有什么区别？"></a>30 HashMap 和 Hashtable 有什么区别？</h3><ul>
<li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li>
<li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代</li>
</ul>
<h3 id="31-List、Set、Map-之间的区别是什么？"><a href="#31-List、Set、Map-之间的区别是什么？" class="headerlink" title="31. List、Set、Map 之间的区别是什么？"></a>31. List、Set、Map 之间的区别是什么？</h3><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqvy1woij30lk06v742.jpg" alt></p>
<h3 id="32-Collection-和-Collections-有什么区别？"><a href="#32-Collection-和-Collections-有什么区别？" class="headerlink" title="32. Collection 和 Collections 有什么区别？"></a>32. Collection 和 Collections 有什么区别？</h3><ul>
<li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>
<li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li>
</ul>
<h3 id="33-Java-容器都有哪些？"><a href="#33-Java-容器都有哪些？" class="headerlink" title="33. Java 容器都有哪些？"></a>33. Java 容器都有哪些？</h3><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<ul>
<li>Collection</li>
<li>List<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
<li>Map</li>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
<h3 id="34Java集合类框架的基本接口有哪些？"><a href="#34Java集合类框架的基本接口有哪些？" class="headerlink" title="34Java集合类框架的基本接口有哪些？"></a>34Java集合类框架的基本接口有哪些？</h3><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p>
<h3 id="35-为什么集合类没有实现Cloneable和Serializable接口？"><a href="#35-为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="35 为什么集合类没有实现Cloneable和Serializable接口？"></a>35 为什么集合类没有实现Cloneable和Serializable接口？</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p>
<h3 id="36-什么是迭代器-Iterator-？"><a href="#36-什么是迭代器-Iterator-？" class="headerlink" title="36 什么是迭代器(Iterator)？"></a>36 什么是迭代器(Iterator)？</h3><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的</p>
<p>迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的</p>
<p>remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p>
<h3 id="37-Iterator和ListIterator的区别是什么？"><a href="#37-Iterator和ListIterator的区别是什么？" class="headerlink" title="37 Iterator和ListIterator的区别是什么？"></a>37 Iterator和ListIterator的区别是什么？</h3><p>下面列出了他们的区别：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h3 id="38-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#38-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="38. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>38. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><p>一：快速失败（fail—fast）</p>
<p>​          在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。</p>
<p>​          原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>​      注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<p>​      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
<p>​    二：安全失败（fail—safe）</p>
<p>​      采用安全失败机制的集合容器，<strong>在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</strong></p>
<p>​      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>​      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，<strong>在遍历期间原集合发生的修改迭代器是不知道的</strong>。</p>
<p>​          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h3 id="39-Java中的HashMap的工作原理是什么？"><a href="#39-Java中的HashMap的工作原理是什么？" class="headerlink" title="39. Java中的HashMap的工作原理是什么？"></a>39. Java中的HashMap的工作原理是什么？</h3><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。<strong>HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素</strong>。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<h2 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h2><h3 id="4-1-下面程序的运行结果（）（选择一项）"><a href="#4-1-下面程序的运行结果（）（选择一项）" class="headerlink" title="4.1 下面程序的运行结果（）（选择一项）"></a>4.1 下面程序的运行结果（）（选择一项）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.println(<span class="string">"ping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>A.</th>
<th>pingpong</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>pong<br>ping</td>
</tr>
<tr>
<td>C.</td>
<td>pingpong和pongping都有可能</td>
</tr>
<tr>
<td>D.</td>
<td>都不输出</td>
</tr>
<tr>
<td>答案：B</td>
</tr>
</tbody>
</table>
<p>补充: </p>
<p>1） start方法：</p>
<p>用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</p>
<p>2） run（）：</p>
<p>run()方法只是类的一个普通方法而已，<strong>如果直接调用run方法，程序中依然只有主线程这一个线程</strong>，其程序执行路径还是只有一条，还是要顺序执行，还是要等待，run方法体执行完毕后才可继续执行下面的代码，<strong>这样就没有达到写线程的目的。</strong></p>
<p>总结：<strong>调用start方法方可启动线程</strong>，<strong>而run方法只是thread的一个普通方法调用</strong>，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run( )方法中，start( )方法启动线程将自动调用 run( )方法，这是由jvm的内存机制规定的。并且<strong>run( )方法必须是public访问权限</strong>，<strong>返回值类型为void。</strong></p>
<h3 id="4-2-下列哪个方法可用于创建一个可运行的类（）"><a href="#4-2-下列哪个方法可用于创建一个可运行的类（）" class="headerlink" title="4.2 下列哪个方法可用于创建一个可运行的类（）"></a>4.2 下列哪个方法可用于创建一个可运行的类（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>public class X implements Runnable{public void run() {……}}</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>public class X extends Thread{public void run() {……}}</td>
</tr>
<tr>
<td>C.</td>
<td>public class X extends Thread{public int run() {……}}</td>
</tr>
<tr>
<td>D.</td>
<td>public class X implements Runnable{protected void run() {……}}</td>
</tr>
<tr>
<td>答案：AB分析： 继承Thread和实现Runable接口</td>
</tr>
</tbody>
</table>
<h3 id="4-3-说说乐观锁与悲观锁"><a href="#4-3-说说乐观锁与悲观锁" class="headerlink" title="4.3 说说乐观锁与悲观锁"></a>4.3 说说乐观锁与悲观锁</h3><p>答：悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以<strong>每次在拿数据的时候都会上锁</strong>，这样别人想拿这个数据就会block阻塞,直到它拿到锁。传统的<strong>关系型数据库</strong>里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，<strong>每次去拿数据的时候都认为别人不会修改</strong>，所以<strong>不会上锁</strong>，但是在<strong>更新的时候会判断一下</strong>在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁<strong>适用于多读</strong>的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<h3 id="4-4-在Java中怎么实现多线程-描述线程状态的变化过程。"><a href="#4-4-在Java中怎么实现多线程-描述线程状态的变化过程。" class="headerlink" title="4.4 在Java中怎么实现多线程?描述线程状态的变化过程。"></a>4.4 在Java中怎么实现多线程?描述线程状态的变化过程。</h3><p>答：当多个线程访问同一个数据时，容易出现线程安全问题，需要某种方式来确保资源在某一时刻只被一个线程使用。需要让线程同步，保证数据安全线程同步的实现方案： 同步代码块和同步方法，均需要使用synchronized关键字</p>
<p>同步代码块：public void makeWithdrawal(int amt) {</p>
<p>synchronized (acct) {    }</p>
<p>}</p>
<p>同步方法：public synchronized void makeWithdrawal(int amt) {    }</p>
<p>线程同步的好处：解决了线程安全问题</p>
<p>线程同步的缺点：性能下降，可能会带来死锁</p>
<h3 id="4-5-请写出多线程代码使用Thread或者Runnable，并说出两种的区别。"><a href="#4-5-请写出多线程代码使用Thread或者Runnable，并说出两种的区别。" class="headerlink" title="4.5 请写出多线程代码使用Thread或者Runnable，并说出两种的区别。"></a>4.5 请写出多线程代码使用Thread或者Runnable，并说出两种的区别。</h3><p>方式1：继承Java.lang.Thread类，并覆盖run() 方法。优势：编写简单；劣势：无法继承其它父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MyThread1 t = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"兔子领先了，别骄傲"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"乌龟领先了，加油"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式2：实现Java.lang.Runnable接口，并实现run()方法。优势：可继承其它类，多线程可共享同一个Thread对象；劣势：编程方式稍微复杂，如需访问当前线程，需调用Thread.currentThread()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"兔子领先了，加油"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"乌龟超过了，再接再厉"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-在多线程编程里，wait方法的调用方式是怎样的？"><a href="#4-6-在多线程编程里，wait方法的调用方式是怎样的？" class="headerlink" title="4.6 在多线程编程里，wait方法的调用方式是怎样的？"></a>4.6 在多线程编程里，wait方法的调用方式是怎样的？</h3><p>答:wait方法是线程通信的方法之一，<strong>必须用在 synchronized方法或者synchronized代码块中</strong>，否则会抛出异常，这就涉及到一个“锁”的概念，<strong>而wait方法必须使用上锁的对象来调用</strong>，从而持有该对象的锁进入线程等待状态，直到使用该上锁的对象<strong>调用notify或者notifyAll方法来唤醒</strong>之前进入等待的线程，<strong>以释放持有的锁</strong>。</p>
<h3 id="4-7-Java线程的几种状态"><a href="#4-7-Java线程的几种状态" class="headerlink" title="4.7 Java线程的几种状态"></a>4.7 Java线程的几种状态</h3><p>答:线程是一个动态执行的过程，它有一个从产生到死亡的过程，共五种状态：</p>
<p>①: 新建（new Thread）</p>
<p>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）</p>
<p>例如：<code>Thread t1=new Thread();</code></p>
<p>②: 就绪（runnable）</p>
<p>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：<code>t1.start();</code></p>
<p>③: 运行（running）</p>
<p>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p>④: 死亡（dead）</p>
<p>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<p>自然终止：正常运行<strong>run()方法</strong>后终止</p>
<p>异常终止：调用<strong>stop()方法</strong>让一个线程终止运行</p>
<p>⑤: 堵塞（blocked）</p>
<p>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</p>
<p>正在睡眠：用<strong>sleep(long t) 方法</strong>可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</p>
<p>正在等待：调用<strong>wait()方法</strong>。（调用motify()方法回到就绪状态）</p>
<p>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）</p>
<h3 id="4-8-在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（）"><a href="#4-8-在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（）" class="headerlink" title="4.8 在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（）"></a>4.8 在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>sleep()</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>Suspend()</td>
</tr>
<tr>
<td>C.</td>
<td>wait()</td>
</tr>
<tr>
<td>D.</td>
<td>yield()</td>
</tr>
<tr>
<td>答案：D分析：yield会是线程进入就绪状态</td>
</tr>
</tbody>
</table>
<h3 id="4-9-volatile关键字是否能保证线程安全？"><a href="#4-9-volatile关键字是否能保证线程安全？" class="headerlink" title="4.9 volatile关键字是否能保证线程安全？"></a>4.9 volatile关键字是否能保证线程安全？</h3><p>答:不能。虽然volatile提供了同步的机制，但是只是一种弱的同步机制，如需要强线程安全，还需要使用synchronized。</p>
<p>Java语言提供了一种<strong>稍弱的同步机制</strong>，即<strong>volatile变量，用来确保将变量的更新操作通知到其他线程</strong>。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是<strong>共享的</strong>，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>一、volatile的内存语义是：</p>
<p>当<strong>写</strong>一个volatile变量时，JMM会把该线程对应的<strong>本地内存中的共享变量值立即刷新到主内存中</strong>。</p>
<p>当<strong>读</strong>一个volatile变量时，JMM会把该线程对应的<strong>本地内存设置为无效</strong>，<strong>直接从主内存中读取共享变量</strong>。</p>
<p>二、volatile底层的实现机制</p>
<p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p>
<p>1 、重排序时不能把后面的指令重排序到内存屏障之前的位置</p>
<p>2、使得本CPU的Cache写入内存</p>
<p>3、写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p>
<h3 id="4-10-请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？"><a href="#4-10-请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？" class="headerlink" title="4.10 请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？"></a>4.10 请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？</h3><p>(1) 继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java_thread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> java_thread().run();</span><br><span class="line">        System.out.println(<span class="string">"main thread run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sub thread run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) 实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java_thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> java_thread()).start();</span><br><span class="line">        System.out.println(<span class="string">"main thread run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sub thread run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Executor框架下，利用Executors的静态方法可以创建三种类型的常用线程池：</p>
<p>1）FixedThreadPool这个线程池可以<strong>创建固定线程数</strong>的线程池。</p>
<p>2）SingleThreadExecutor是<strong>使用单个worker线程</strong>的Executor。</p>
<p>3）CachedThreadPool是一个<strong>”无限“容量的线程池</strong>，它会根据需要创建新线程。</p>
<h3 id="4-11-关于sleep-和wait-，以下描述错误的一项是（）"><a href="#4-11-关于sleep-和wait-，以下描述错误的一项是（）" class="headerlink" title="4.11 关于sleep()和wait()，以下描述错误的一项是（）"></a>4.11 关于sleep()和wait()，以下描述错误的一项是（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>sleep是线程类（Thread）的方法，wait是Object类的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>Sleep不释放对象锁，wait放弃对象锁</td>
</tr>
<tr>
<td>C.</td>
<td>Sleep暂停线程、但监控状态任然保持，结束后会自动恢复</td>
</tr>
<tr>
<td>D.</td>
<td>Wait后进入等待锁定池，只针对此对象发出notify方法后获取对象锁进入运行状态。</td>
</tr>
<tr>
<td>答案：D分析：针对此对象的notify方法后获取对象锁并进入就绪状态，而不是运行状态。另外针对此对象的notifyAll方法后也可能获取对象锁并进入就绪状态，而不是运行状态</td>
</tr>
</tbody>
</table>
<h3 id="4-12-进程和线程的区别是什么？"><a href="#4-12-进程和线程的区别是什么？" class="headerlink" title="4.12 进程和线程的区别是什么？"></a>4.12 进程和线程的区别是什么？</h3><p>进程是<strong>具有一定独立功能的程序关于某个数据集合上的一次运行活动</strong>,进程是<strong>系统进行资源分配和调度的一个独立单位.</strong></p>
<p>线程是进程的一个实体,是<strong>CPU调度和分派的基本单位</strong>,它是比进程更小的能独立运行的基本单位.<strong>线程自己基本上不拥有系统资源</strong>,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它<strong>可与同属一个进程的其他的线程共享进程所拥有的全部资源.</strong></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>根本区别</td>
<td>系统进行资源分配的单位</td>
<td>是CPU调度和执行的单位</td>
</tr>
<tr>
<td>开销</td>
<td>每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。</td>
<td>线程可以看成时轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。</td>
</tr>
<tr>
<td>分配内存</td>
<td>系统在运行的时候会为每个进程分配不同的内存区域</td>
<td>除了CPU之外，不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源</td>
</tr>
<tr>
<td>包含关系</td>
<td>没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。</td>
<td>线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。</td>
</tr>
</tbody>
</table>
<h3 id="4-13-以下锁机机制中，不能保证线程安全的是（）"><a href="#4-13-以下锁机机制中，不能保证线程安全的是（）" class="headerlink" title="4.13 以下锁机机制中，不能保证线程安全的是（）"></a>4.13 以下锁机机制中，不能保证线程安全的是（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>Synchronized</td>
</tr>
<tr>
<td>C.</td>
<td>Volatile</td>
</tr>
<tr>
<td>答案：C</td>
</tr>
</tbody>
</table>
<h3 id="4-14-创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#4-14-创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="4.14 创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>4.14 创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h3><p>答：用一个for循环创建线程对象，同时调用wait()方法，让所有线程等待；直到最后一个线程也准备就绪后，调用notifyAll(), 同时启动所有线程。</p>
<p>比如：给你n个赛车，让他们都在起跑线上就绪后，同时出发，Java多线程如何写代码？</p>
<p>思路是，来一辆赛车就加上一把锁，并修改对应的操作数，如果没有全部就绪就等待，并释放锁，直到最后一辆赛车到场后唤醒所有的赛车线程。代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarCompetion</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参赛赛车的数量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> totalCarNum = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 当前在起跑线的赛车数量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> nowCarNum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carNum;</span><br><span class="line">    <span class="keyword">private</span> CarCompetion competion = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> carNum, CarCompetion competion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carNum = carNum;</span><br><span class="line">        <span class="keyword">this</span>.competion = competion;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (competion) &#123;</span><br><span class="line">            competion.nowCarNum++;</span><br><span class="line">            <span class="keyword">while</span> (competion.nowCarNum &lt; competion.totalCarNum) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    competion.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            competion.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        startCar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Car num "</span> + <span class="keyword">this</span>.carNum + <span class="string">" start to run."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Car num "</span> + <span class="keyword">this</span>.carNum + <span class="string">" get to the finish line."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CarCompetion carCompetion = <span class="keyword">new</span> CarCompetion();</span><br><span class="line">    <span class="keyword">final</span> ExecutorService carPool =</span><br><span class="line">        Executors.newFixedThreadPool(carCompetion.totalCarNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; carCompetion.totalCarNum; i++) &#123;</span><br><span class="line">        carPool.execute(<span class="keyword">new</span> Car(i, carCompetion));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-15-同步和异步有何异同，在什么情况下分别使用它们？"><a href="#4-15-同步和异步有何异同，在什么情况下分别使用它们？" class="headerlink" title="4.15 同步和异步有何异同，在什么情况下分别使用它们？"></a>4.15 同步和异步有何异同，在什么情况下分别使用它们？</h3><p>答：1.如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是<strong>共享数据，必须进行同步存取</strong>。</p>
<p>2.当应用程序在对象上<strong>调用了一个需要花费很长时间来执行的方法</strong>，<strong>并且不希望让程序等待方法的返回时</strong>，就应该使用异步编程，在很多情况下采用<strong>异步途径往往更有效率。</strong></p>
<p>3.举个例子: 打电话是同步 发消息是异步</p>
<h3 id="4-16-Java线程中，sleep-和wait-区别"><a href="#4-16-Java线程中，sleep-和wait-区别" class="headerlink" title="4.16 Java线程中，sleep()和wait()区别"></a>4.16 Java线程中，sleep()和wait()区别</h3><p>答：<strong>sleep是线程类(Thread)的静态方法</strong>；作用是导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复；调用sleep()<strong>不会释放对象锁</strong>。</p>
<p><strong>wait是Object类的方法</strong>；对此对象调用wait方法导致本线程<strong>放弃对象锁</strong>，进入等待此对象的<strong>等待锁定池队列</strong>。只有针对此对象发出notify方法(或notifyAll)后本线程才进入<strong>对象锁定池</strong>，准备<strong>获得对象锁</strong>后<strong>进入就绪状态</strong>。</p>
<h3 id="4-17-sleep-和yield-有什么区别"><a href="#4-17-sleep-和yield-有什么区别" class="headerlink" title="4.17 sleep()和yield()有什么区别?"></a>4.17 sleep()和yield()有什么区别?</h3><p>答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；<strong>yield()方法只会给相同优先级或更高优先级的线程以运行的机会</strong>；</p>
<p>② 运行态的线程执行sleep()方法后转入阻塞（blocked）状态，<strong>而执行yield()方法后转入就绪（ready）状态</strong>；</p>
<p>③ sleep()方法声明抛出InterruptedException，而<strong>yield()方法没有声明任何异常；</strong></p>
<p>④ sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。 </p>
<h3 id="4-18-下面所述步骤中，是创建进程做必须的步骤是（）"><a href="#4-18-下面所述步骤中，是创建进程做必须的步骤是（）" class="headerlink" title="4.18 下面所述步骤中，是创建进程做必须的步骤是（）"></a>4.18 下面所述步骤中，是创建进程做必须的步骤是（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>由调度程序为进程分配CPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>建立一个进程控制块</td>
</tr>
<tr>
<td>C.</td>
<td>为进程分配内存</td>
</tr>
<tr>
<td>D.</td>
<td>为进程分配文件描述符</td>
</tr>
<tr>
<td>答案：BC</td>
</tr>
</tbody>
</table>
<h3 id="4-19-无锁化编程有哪些常见方法？（）"><a href="#4-19-无锁化编程有哪些常见方法？（）" class="headerlink" title="4.19 无锁化编程有哪些常见方法？（）"></a>4.19 无锁化编程有哪些常见方法？（）</h3><table>
<thead>
<tr>
<th>A.</th>
<th>针对计数器，可以使用原子加</th>
</tr>
</thead>
<tbody>
<tr>
<td>B.</td>
<td>只有一个生产者和一个消费者，那么就可以做到免锁访问环形缓冲区（Ring Buffer）</td>
</tr>
<tr>
<td>C.</td>
<td>RCU（Read-Copy-Update），新旧副本切换机制，对于旧副本可以采用延迟释放的做法</td>
</tr>
<tr>
<td>D.</td>
<td>CAS（Compare-and-Swap），如无锁栈，无锁队列等待</td>
</tr>
<tr>
<td>答案：D分析：A 这方法虽然不太好，但是常见B ProducerConsumerQueue就是这个，到处都是C linux kernel里面大量使用D 本质上其实就是乐观锁，操作起来很困难。。单生产者多消费者或者多生产者单消费者的情况下比较常见，也不容易遇到ABA问题。</td>
</tr>
</tbody>
</table>
<h3 id="4-20-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？"><a href="#4-20-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？" class="headerlink" title="4.20 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？"></a>4.20 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？</h3><p>答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。 只有等待当前线程执行完毕释放锁资源之后，其他线程才有可能进行执行该同步方法！</p>
<p>延伸:</p>
<p>对象锁分为三种：共享资源、this、当前类的字节码文件对象</p>
<h3 id="4-21-请说出与线程同步相关的方法。"><a href="#4-21-请说出与线程同步相关的方法。" class="headerlink" title="4.21 请说出与线程同步相关的方法。"></a>4.21 请说出与线程同步相关的方法。</h3><p>答：\1. wait():使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
<p>\2. sleep():使一个正在运行的线程处于睡眠状态，是一个<strong>静态方法</strong>，<strong>调用此方法要捕捉InterruptedException 异常；</strong></p>
<p>\3. notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，**而且与优先级无关；</p>
<p>\4. notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，<strong>而是让它们竞争；</strong></p>
<p>\5. JDK 1.5通过Lock接口提供了显式(explicit)的锁机制，增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁(unlock())的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；</p>
<p>\6. JDK 1.5还提供了信号量(semaphore)机制，信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</p>
<p>下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。</p>
<p>银行账户类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;     <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存款</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 存入金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> newBalance = balance + money;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);   <span class="comment">// 模拟此业务需要一段处理时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存钱线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存钱线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxt李端阳</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;    <span class="comment">// 存入账户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;       <span class="comment">// 存入金额</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddMoneyThread</span><span class="params">(Account account, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        account.deposit(money);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> AddMoneyThread(account, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="keyword">while</span>(!service.isTerminated()) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">"账户余额: "</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案：</p>
<p>\1. 在银行账户的存款（deposit）方法上同步（synchronized）关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SXT李端阳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;     <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存款</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 存入金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> newBalance = balance + money;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);   <span class="comment">// 模拟此业务需要一段处理时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在线程调用存款方法时对银行账户进行同步</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存钱线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SXT</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;    <span class="comment">// 存入账户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;       <span class="comment">// 存入金额</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddMoneyThread</span><span class="params">(Account account, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>通过JDK 1.5显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SXT李端阳</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock accountLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance; <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     *            存入金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        accountLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> newBalance = balance + money;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>); <span class="comment">// 模拟此业务需要一段处理时间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            accountLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。 </p>
<h3 id="4-22-编写多线程程序有几种实现方式？"><a href="#4-22-编写多线程程序有几种实现方式？" class="headerlink" title="4.22 编写多线程程序有几种实现方式？"></a>4.22 编写多线程程序有几种实现方式？</h3><p>答：Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，同时也可以实现资源共享，显然使用Runnable接口更为灵活。</p>
<p>补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> upperBounds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> upperBounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.upperBounds = upperBounds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= upperBounds; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(service.submit(<span class="keyword">new</span> MyTask((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Integer&gt; future : list) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!future.isDone()) ;</span><br><span class="line">            sum += future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-23-synchronized关键字的用法？"><a href="#4-23-synchronized关键字的用法？" class="headerlink" title="4.23 synchronized关键字的用法？"></a>4.23 synchronized关键字的用法？</h3><p>答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。</p>
<h3 id="4-24-启动一个线程是用run-还是start-方法"><a href="#4-24-启动一个线程是用run-还是start-方法" class="headerlink" title="4.24 启动一个线程是用run()还是start()方法?"></a>4.24 启动一个线程是用run()还是start()方法?</h3><p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 </p>
<p>API解释如下：</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3wf2fa2s5j30ej01q3y9.jpg" alt></p>
<h3 id="4-25-什么是线程池（thread-pool）？"><a href="#4-25-什么是线程池（thread-pool）？" class="headerlink" title="4.25 什么是线程池（thread pool）？"></a>4.25 什么是线程池（thread pool）？</h3><p>答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>
<p>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<p>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<p>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>有通过Executors工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。 </p>
<h3 id="4-26-线程的基本状态以及状态之间的关系？"><a href="#4-26-线程的基本状态以及状态之间的关系？" class="headerlink" title="4.26 线程的基本状态以及状态之间的关系？"></a>4.26 线程的基本状态以及状态之间的关系？</h3><p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3wf3hryidj30fd09odfq.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g438fru4ufj30o70ctjub.jpg" alt></p>
<p>除去<strong>起始</strong>（new）状态和<strong>结束</strong>（finished）状态，线程有三种状态:</p>
<p>分别是：<strong>就绪</strong>（ready）、<strong>运行</strong>（running）和<strong>阻塞</strong>（blocked）。</p>
<ul>
<li>其中就绪状态代表线程<strong>具备了运行的所有条件</strong>，只等待CPU调度（万事俱备，只欠东风）；</li>
<li>处于运行状态的线程可能因为CPU调度（时间片用完了）的原因回到就绪状态，也有可能因为调用了线程的yield方法回到就绪状态，此时线程不会释放它占有的资源的锁，坐等CPU以继续执行；运行状态的线程可能因为I/O中断、线程休眠、调用了对象的wait方法而进入阻塞状态（有的地方也称之为等待状态）；</li>
<li>而进入阻塞状态的线程会因为休眠结束、调用了对象的notify方法或notifyAll方法或其他线程执行结束而进入就绪状态。注意：调用wait方法会让线程进入等待池中等待被唤醒，notify方法或notifyAll方法会让等待锁中的线程从等待池进入等锁池，在没有得到对象的锁之前，线程仍然无法获得CPU的调度和执行。</li>
</ul>
<h3 id="4-27-简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#4-27-简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="4.27 简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>4.27 简述synchronized 和java.util.concurrent.locks.Lock的异同？</h3><p>答：Lock是Java 5以后引入的新的API，和关键字synchronized相比</p>
<p>主要相同点：</p>
<ul>
<li>Lock 能完成synchronized所实现的所有功能；</li>
</ul>
<p>主要不同点：</p>
<ul>
<li>Lock 有比synchronized 更精确的线程语义和更好的性能。<strong>synchronized 会自动释放锁，而Lock 一定要求程序员手工释放</strong>，并且<strong>必须在finally 块中释放</strong>（这是释放外部资源的最好的地方）。 </li>
</ul>
<h3 id="4-28-创建线程的两种方式分别是什么-优缺点是什么？"><a href="#4-28-创建线程的两种方式分别是什么-优缺点是什么？" class="headerlink" title="4.28 创建线程的两种方式分别是什么,优缺点是什么？"></a>4.28 创建线程的两种方式分别是什么,优缺点是什么？</h3><p>方式1：继承Java.lang.Thread类，并覆盖run() 方法。</p>
<p>优势：编写简单；</p>
<p>劣势：单继承的限制—-无法继承其它父类，同时不能实现资源共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MyThread1 t = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"兔子领先了，别骄傲"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"乌龟领先了，加油"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式2：实现Java.lang.Runnable接口，并实现run()方法。</p>
<p>优势：可继承其它类，多线程可共享同一个Thread对象；</p>
<p>劣势：编程方式稍微复杂，如需访问当前线程，需调用Thread.currentThread()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"兔子领先了，加油"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"乌龟超过了，再接再厉"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-29-Java创建线程后，调用start-方法和run-的区别"><a href="#4-29-Java创建线程后，调用start-方法和run-的区别" class="headerlink" title="4.29 Java创建线程后，调用start( )方法和run( )的区别"></a>4.29 Java创建线程后，调用start( )方法和run( )的区别</h3><p>两种方法的区别</p>
<p>1） start方法：</p>
<p>用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</p>
<p>2） run（）：</p>
<p>run()方法只是类的一个普通方法而已，如果直接调用run方法，程序中<strong>依然只有主线程这一个线程</strong>，其程序执行路径还是只有一条，还是要顺序执行，还是要等待，run方法体执行完毕后才可继续执行下面的代码，这样就<strong>没有达到写线程的目的。</strong></p>
<p>总结：<strong>调用start方法方可启动线程</strong>，<strong>而run方法只是thread的一个普通方法调用</strong>，<strong>还是在主线程里执行</strong>。这两个方法应该都比较熟悉，把需要并行处理的代码放在run( )方法中，start( )方法启动线程将自动调用 run( )方法，这是由jvm的内存机制规定的。并且run( )方法必须是public访问权限，返回值类型为void。</p>
<p>两种方式的比较 ：</p>
<p>实际中往往采用实现Runable接口，一方面因为java只支持单继承，继承了Thread类就无法再继续继承其它类，而且Runable接口只有一个run方法；另一方面通过结果可以看出实现Runable接口才是真正的多线程。</p>
<h3 id="4-30-线程的生命周期"><a href="#4-30-线程的生命周期" class="headerlink" title="4.30 线程的生命周期"></a>4.30 线程的生命周期</h3><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>生命周期的五种状态: </p>
<p>新建（new Thread）</p>
<p>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）</p>
<p>例如：<code>Thread t1=new Thread();</code></p>
<p>就绪（runnable）</p>
<p>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：<code>t1.start();</code></p>
<p>运行（running）</p>
<p>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p>死亡（dead）</p>
<p>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<p>自然终止：正常运行run()方法后终止</p>
<p>异常终止：调用stop()方法让一个线程终止运行</p>
<p>堵塞（blocked）</p>
<p>由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。</p>
<p>正在睡眠：用<code>sleep(long t)</code>方法.  不释放锁  ,使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</p>
<p>正在等待：调用<code>wait()</code>方法。释放锁（调用<code>notify()</code>方法回到就绪状态）</p>
<p><strong>被另一个线程所阻塞</strong>：调用<code>suspend()</code>方法。（调用<code>resume()</code>方法恢复）</p>
<h3 id="4-31-如何实现线程同步？"><a href="#4-31-如何实现线程同步？" class="headerlink" title="4.31 如何实现线程同步？"></a>4.31 如何实现线程同步？</h3><p>当多个线程访问同一个数据时，容易出现线程安全问题，需要某种方式来确保资源在某一时刻只被一个线程使用。需要让线程同步，保证数据安全</p>
<p>线程同步的实现方案：</p>
<p>1）同步代码块，使用synchronized关键字</p>
<p>同步代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (同步锁) &#123;</span><br><span class="line">	授课代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步方法：synchronized关键字标记在方法的返回值之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">makeWithdrawal</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程同步的好处：<strong>解决了线程安全问题</strong></p>
<p>线程同步的缺点：<strong>性能下降，可能会带来死锁</strong></p>
<p>注意： 同步代码块，所使用的同步锁可以是三种，</p>
<p>1、this 2、 共享资源 3、 字节码文件对象</p>
<p><strong>同步方法所使用的同步锁，默认的是this</strong></p>
<h3 id="4-32-说说关于同步锁的更多细节"><a href="#4-32-说说关于同步锁的更多细节" class="headerlink" title="4.32 说说关于同步锁的更多细节"></a>4.32 说说关于同步锁的更多细节</h3><p>答：Java中每个对象都有一个内置锁。</p>
<p><strong>同步:  一个访问完后,下一个访问, 不存在同时的并发访问.</strong>—-&gt;也就是顺序访问,串行访问</p>
<p>当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。</p>
<p>当程序运行到synchronized同步方法或代码块时该对象锁才起作用。</p>
<p>一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。</p>
<p><strong>释放锁</strong>是指持<strong>锁线程退出了synchronized同步方法或代码块</strong>。</p>
<p>关于锁和同步，有以下几个要点：</p>
<p>1）<strong>只能同步方法或同步一部分代码即同步代码块</strong>，而不能同步变量和类；</p>
<p>2）<strong>每个对象只有一个锁</strong>；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？</p>
<p>3）<strong>不必同步类中所有的方法</strong>，类可以同时拥有同步和非同步方法。</p>
<p>4）如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。</p>
<p>5）如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。</p>
<p>6）<strong>线程睡眠(调用sleep方法)时，它所持的任何锁都不会释放。</strong></p>
<p>7）线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。</p>
<p>8）<strong>同步损害并发性</strong>，应该尽可能缩小同步范围。同步不但可以<strong>同步整个方法</strong>，还可以同步一个方法中的<strong>一部分代码块</strong>。</p>
<p>9）在<strong>使用同步代码块时候</strong>，<strong>应该指定在哪个对象上同步</strong>，也就是说要获取哪个对象的锁。</p>
<h3 id="4-33-Java中实现线程通信的三个方法的作用是什么？"><a href="#4-33-Java中实现线程通信的三个方法的作用是什么？" class="headerlink" title="4.33  Java中实现线程通信的三个方法的作用是什么？"></a>4.33  Java中实现线程通信的三个方法的作用是什么？</h3><p>Java提供了3个方法(<strong>wait,notify,notifyall</strong>)<strong>解决线程之间的通信问题</strong>，<strong>均是java.lang.Object类的方法</strong>，都<strong>只能在同步方法或者同步代码块中使用</strong>，<strong>否则会抛出异常</strong>。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>final void wait()</td>
<td>表示<strong>线程一直等待，直到其它线程通知唤醒它</strong></td>
</tr>
<tr>
<td>void wait(long timeout)</td>
<td>线程等待指定毫秒参数的时间</td>
</tr>
<tr>
<td>final void wait(long timeout,int nanos)</td>
<td>线程等待指定毫秒、微妙的时间</td>
</tr>
<tr>
<td>final void notify()</td>
<td>唤醒一个处于等待状态的线程。<strong>注意</strong>的是:  在调用此方法的时候，<strong>并不能确切的唤醒某一个等待状态的线程</strong>，而是由<strong>JVM确定唤醒哪个线程</strong>，<strong>而且不是按优先级</strong>。</td>
</tr>
<tr>
<td>final void notifyAll()</td>
<td>唤醒<strong>同一个对象上</strong>所有调用wait()方法的线程，<strong>注意</strong>:  <strong>并不是给所有唤醒线程一个对象的锁</strong>，<strong>而是让它们竞争.</strong></td>
</tr>
</tbody>
</table>
<h3 id="4-44-进程和线程的区别是什么？"><a href="#4-44-进程和线程的区别是什么？" class="headerlink" title="4.44 进程和线程的区别是什么？"></a>4.44 进程和线程的区别是什么？</h3><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<p><strong>线程与进程的区别归纳：</strong></p>
<p><strong>a.地址空间和其它资源</strong>：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p>
<p><strong>b.通信：</strong>进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
<p><strong>c.调度和切换</strong>：线程上下文切换比进程上下文切换要快得多。</p>
<p>d.在多线程OS中，进程不是一个可执行的实体。</p>
<h3 id="4-45-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#4-45-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="4.45 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>4.45 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>有4种方式可以用来创建线程：</p>
<p>继承Thread类</p>
<p>实现Runnable接口</p>
<p>应用程序可以使用Executor框架来创建线程池</p>
<p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>
<p>还有一种方式是实现Callable接口</p>
<h3 id="4-46-同步方法和同步代码块的区别是什么？"><a href="#4-46-同步方法和同步代码块的区别是什么？" class="headerlink" title="4.46 同步方法和同步代码块的区别是什么？"></a>4.46 同步方法和同步代码块的区别是什么？</h3><p>区别：</p>
<p>同步方法默认用this或者当前类class对象作为锁；</p>
<p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p>
<p>同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；</p>
<h3 id="4-47-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#4-47-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="4.47 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>4.47 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h3 id="4-48什么是死锁-deadlock-？"><a href="#4-48什么是死锁-deadlock-？" class="headerlink" title="4.48什么是死锁(deadlock)？"></a>4.48什么是死锁(deadlock)？</h3><p>所谓死锁是指<strong>多个进程因竞争资源</strong>而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</p>
<ul>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在<strong>一段时间内某 资源仅为一个进程所占有</strong>。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不剥夺条件：进程所获得的资源在<strong>未使用完毕之前，不能被其他进程强行夺走</strong>，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了<strong>新的资源请求</strong>，而该资源 已被其他进程占有，此时请求进程<strong>被阻塞</strong>，但对自己<strong>已获得的资源保持不放</strong>。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中<strong>每一个进程已获得的资源同时被 链中下一个进程所请求</strong>。</li>
</ul>
<h3 id="4-49-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#4-49-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="4.49 如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>4.49 如何确保N个线程可以访问N个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h2 id="五、IO流"><a href="#五、IO流" class="headerlink" title="五、IO流"></a>五、IO流</h2><h3 id="5-1-说说BIO、NIO和AIO的区别"><a href="#5-1-说说BIO、NIO和AIO的区别" class="headerlink" title="5.1 说说BIO、NIO和AIO的区别"></a>5.1 说说BIO、NIO和AIO的区别</h3><p>Java <strong>AIO</strong>： <strong>异步     非阻塞</strong>，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<strong>——————-&gt;爱亦菲</strong></p>
<p>Java <strong>BIO： 同步  并   阻塞</strong>，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<strong>————–&gt;不同祖</strong></p>
<p>Java <strong>NIO： 同步      非阻塞</strong>，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<strong>—————&gt;</strong> <strong>辣痛扉</strong></p>
<p><strong>NIO比BIO的改善之处是把一些无效的连接挡在了启动线程之前</strong>，减少了这部分资源的浪费（因为我们都知道每创建一个线程，就要为这个线程分配一定的内存空间）</p>
<p>AIO比NIO的进一步改善之处是将一些暂时可能无效的请求挡在了启动线程之前，比如在NIO的处理方式中，当一个请求来的话，开启线程进行处理，但这个请求所需要的资源还没有就绪，此时必须等待后端的应用资源，这时线程就被阻塞了。</p>
<p>适用场景分析：</p>
<p><strong>AIO方式使用于连接数目多且连接比较长</strong>（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持，在成长中，Netty曾经使用过，后来放弃。</p>
<p><strong>BIO方式适用于连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解，如之前在Apache中使用。</p>
<p><strong>NIO方式适用于连接数目多且连接比较短</strong>（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持，如在 Nginx，Netty中使用。</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3x6b6zgerj30rb02wt9h.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3x6b10fpoj30rd02wdha.jpg" alt></p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g3x6apc464j30qg02iabo.jpg" alt></p>
<p>简言之:     阻塞: 什么事都不干,干等着</p>
<p>​               同步: 主动观察</p>
<pre><code>异步: 等别人通知
</code></pre><p>注: 这里的同步 和  线程中的同步是不一样的.</p>
<p>AIO——–&gt;爱亦菲</p>
<p>BIO——–&gt;不同祖</p>
<p>NIO——–&gt;辣痛扉</p>
<h3 id="5-2-Files的常用方法都有哪些？"><a href="#5-2-Files的常用方法都有哪些？" class="headerlink" title="5.2 Files的常用方法都有哪些？"></a>5.2 Files的常用方法都有哪些？</h3><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h3 id="5-3-BIO、NIO、AIO-有什么区别？"><a href="#5-3-BIO、NIO、AIO-有什么区别？" class="headerlink" title="5.3 BIO、NIO、AIO 有什么区别？"></a>5.3 BIO、NIO、AIO 有什么区别？</h3><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h3 id="5-4-Java-中-IO-流分为几种？"><a href="#5-4-Java-中-IO-流分为几种？" class="headerlink" title="5.4 Java 中 IO 流分为几种？"></a>5.4 Java 中 IO 流分为几种？</h3><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h2 id="六、堆和栈"><a href="#六、堆和栈" class="headerlink" title="六、堆和栈"></a>六、堆和栈</h2><h3 id="6-1-简述堆和栈的区别"><a href="#6-1-简述堆和栈的区别" class="headerlink" title="6.1 简述堆和栈的区别"></a>6.1 简述堆和栈的区别</h3><p>在说堆和栈之前，我们先说一下JVM（虚拟机）内存的划分：</p>
<p> Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p>
<p>  JVM内存的划分有五片：</p>
<ol>
<li><p>寄存器；</p>
</li>
<li><p>本地方法区；</p>
</li>
<li><p>方法区；</p>
</li>
<li><p>栈内存；</p>
</li>
<li><p>堆内存。</p>
<p>我们重点来说一下堆和栈：</p>
<p>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p>
<p>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p>
</li>
</ol>
<p>下面我们通过一个图例详细讲一下堆和栈：</p>
<p>  比如主函数里的语句   int [] arr=new int [3];在内存中是怎么被定义的：</p>
<p>  主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：</p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqix8j2ij30jk0dj744.jpg" alt></p>
<p>那么堆和栈是怎么联系起来的呢?</p>
<p>我们刚刚说过给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。（可以理解为c或c++的指针，Java成长自c++和c++很像，优化了c++）                   </p>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kqjt9g6gj30ii0d83yd.jpg" alt></p>
<p> 如果当int [] arr=null;</p>
<p>  arr不做任何指向，null的作用就是取消引用数据类型的指向。</p>
<p> 当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。</p>
<p><strong>堆(Heap)</strong></p>
<ul>
<li>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建；</li>
<li>Java虚拟机规范描述:所有的对象实例及数组都要在堆上分配；</li>
<li>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可;</li>
<li>(线程共享)堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问;</li>
<li>(异常提示)如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.==OutOfMemoryError==；</li>
<li>(内存分配)动态分配内存</li>
</ul>
<p>栈(Stack)</p>
<ul>
<li><p>存放基本类型的数据和对象的引用，即存放变量;</p>
<ul>
<li>如果存放的是基本类型数据（非静态变量），则直接将变量名和值存入stack中的内存中</li>
<li>如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）;</li>
</ul>
</li>
<li><p>(线程私有)栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存;</p>
</li>
<li>(内存分配)栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题</li>
<li>(异常提示)如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.==StackOverFlowError==；</li>
<li>(内存分配)内存分配固定；</li>
<li>存取速度比堆要快，仅次于寄存器，栈数据可以共享；</li>
</ul>
<p><img src="http://cdn.cdnjson.com/ws1.sinaimg.cn/large/0064BnmZgy1g4kkb1mvoqj30el0cf76h.jpg" alt></p>
<h3 id="6-2-小结："><a href="#6-2-小结：" class="headerlink" title="6.2 小结："></a>6.2 小结：</h3><p>  堆和栈的区别可以用如下的比喻来看出：    </p>
<p>  使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就<br>  走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小.</p>
<p>  使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。   (经典！)  </p>
<p><strong>所以堆与栈的区别很明显：</strong></p>
<p>1.(存储内容)栈内存存储的是局部变量而堆内存存储的是实体；</p>
<p>2.(更新速度)栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>
<p>3.(回收机制)栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收</p>
<p>4.(线程共享)堆内存中的对象对所有线程可见。(线程私有)栈内存归属于单个线程，每个线程都会有一个栈内存</p>
<p>5.(内存分配)堆内存:动态分配内存;栈内存分配固定；</p>
<p>6.(异常提示)如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.==OutOfMemoryError==；(异常提示)如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.==StackOverFlowError==；</p>

      
    </div>

    
	
	
	
	

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>
<div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/Java面试题及答案.html">java基础面试题及答案</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 zwq 的个人博客">zwq</a></p>
  <p><span>发布时间:</span>2019年05月31日 - 15:15</p>
  <p><span>最后更新:</span>2023年05月12日 - 21:00</p>
  <p><span>原始链接:</span><a href="/Java面试题及答案.html" title="java基础面试题及答案">https://zzwwqq.github.io/Java面试题及答案.html</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://zzwwqq.github.io/Java面试题及答案.html" aria-label="复制成功！"></i></span>
  </p>
  <p><span>版权声明:</span>本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"><i class="fa fa-creative-commons"></i>BY-NC-SA </a>许可协议。转载请注明出处!</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
      $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
        });
    });  
</script>

      
</div>

    
    
    

    
      <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="http://cdn.cdnjson.com/tvax2.sinaimg.cn/large/0064BnmZgy1g9n7zzvn32j3076076q3f.jpg" alt="zwq wechat" style="width: 200px; max-width: 100%;">
  <div>欢迎您扫一扫关注我的微信公众号！</div>
</div>

    

    
      
    
    

    


	
	
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java基础面试题/" rel="tag"><i class="fa fa-tag"></i> java基础面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/信息系统项目管理师之论文部分.html" rel="next" title="信息系统项目管理师之论文部分">
                <i class="fa fa-chevron-left"></i> 信息系统项目管理师之论文部分
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/信息系统项目管理师案例分析知识点.html" rel="prev" title="信息系统项目管理师案例分析知识点">
                信息系统项目管理师案例分析知识点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://cdn.cdnjson.com/tva4.sinaimg.cn/large/0064BnmZgy1g9n64jijk8j30dc0dc0tq.jpg" alt="zwq">
            
              <p class="site-author-name" itemprop="name">zwq</p>
              <div class="site-description motion-element" itemprop="description">不忘初心,方得始终!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">64</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">58</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zzwwqq" title="GitHub &rarr; https://github.com/zzwwqq" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:zwq13264860490@gmail.com" title="E-Mail &rarr; mailto:zwq13264860490@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/u/5564810309/home?wvr=5" title="Weibo &rarr; https://weibo.com/u/5564810309/home?wvr=5" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities" title="知乎 &rarr; https://www.zhihu.com/people/shen-qiu-wu-hen-66/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-snapchat"></i>知乎</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://me.csdn.net/weixin_44815733" title="CSDN &rarr; https://me.csdn.net/weixin_44815733" rel="noopener" target="_blank"><i class="fa fa-fw fa-angellist"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/01892c1f80f8" title="简书 &rarr; https://www.jianshu.com/u/01892c1f80f8" rel="noopener" target="_blank"><i class="fa fa-fw fa-leanpub"></i>简书</a>
                </span>
              
            </div>
          

          

		  
		  
		  
		  
		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=38592976&auto=0&height=66"></iframe>
		  
		  
		  
          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/" title="https://www.cnblogs.com/" rel="noopener" target="_blank">博客园</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、Java基础、语法"><span class="nav-text">一、Java基础、语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-面向对象的特征有哪些方面"><span class="nav-text">1 面向对象的特征有哪些方面?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-访问修饰符public-private-protected-以及不写（默认）时的区别？"><span class="nav-text">2 访问修饰符public,private,protected,以及不写（默认）时的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-成员（成员变量或成员方法）访问权限共有四种："><span class="nav-text">2.2 成员（成员变量或成员方法）访问权限共有四种：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-String-是最基本的数据类型吗"><span class="nav-text">3 String 是最基本的数据类型吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-float-f-3-4-是否正确"><span class="nav-text">4 float f=3.4;是否正确?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><span class="nav-text">5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Java-有没有goto"><span class="nav-text">6 Java 有没有goto?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-int-和Integer-有什么区别"><span class="nav-text">7 int 和Integer 有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-amp-和-amp-amp-的区别和联系，-和-的区别和联系"><span class="nav-text">8 &amp;和&amp;&amp;的区别和联系，|和||的区别和联系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-amp-和-amp-amp-的联系-共同点-："><span class="nav-text">8.1&amp;和&amp;&amp;的联系(共同点)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-amp-和-amp-amp-的区别-不同点-："><span class="nav-text">8.2 &amp;和&amp;&amp;的区别(不同点)：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><span class="nav-text">9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Math-round（-11-2）的运行结果是"><span class="nav-text">10 Math.round（-11.2）的运行结果是</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-中的-Math-round-1-5-等于多少"><span class="nav-text">Java 中的 Math. round(-1. 5) 等于多少?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><span class="nav-text">11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-用最有效率的方法计算2乘以8"><span class="nav-text">12 用最有效率的方法计算2乘以8?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-数组有没有length-方法-String-有没有length-方法？"><span class="nav-text">13 数组有没有length()方法?String 有没有length()方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-在Java-中，如何跳出当前的多重嵌套循环？"><span class="nav-text">14 在Java 中，如何跳出当前的多重嵌套循环？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-构造器（constructor）是否可被重写（override）"><span class="nav-text">15 构造器（constructor）是否可被重写（override）?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><span class="nav-text">16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-是否可以继承String-类"><span class="nav-text">17 是否可以继承String 类?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><span class="nav-text">18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-String-和StringBuilder、StringBuffer-的区别"><span class="nav-text">19 String 和StringBuilder、StringBuffer 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><span class="nav-text">20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-描述一下JVM-加载class文件的原理机制"><span class="nav-text">21 描述一下JVM 加载class文件的原理机制?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-char-型变量中能不能存贮一个中文汉字-为什么"><span class="nav-text">22 char 型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-抽象类（abstract-class）和接口（interface）有什么异同"><span class="nav-text">23 抽象类（abstract class）和接口（interface）有什么异同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><span class="nav-text">24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Java-中会存在内存泄漏吗，请简单描述。"><span class="nav-text">25 Java 中会存在内存泄漏吗，请简单描述。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><span class="nav-text">26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-静态变量和实例变量的区别？"><span class="nav-text">27 静态变量和实例变量的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><span class="nav-text">28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-如何实现对象克隆？"><span class="nav-text">29 如何实现对象克隆？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-GC-是什么？为什么要有GC？"><span class="nav-text">30 GC 是什么？为什么要有GC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-String-s-new-String-“xyz”-创建了几个字符串对象？"><span class="nav-text">31 String s=new String(“xyz”);创建了几个字符串对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><span class="nav-text">32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><span class="nav-text">33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><span class="nav-text">34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><span class="nav-text">35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Java-中的final关键字有哪些用法？"><span class="nav-text">36 Java 中的final关键字有哪些用法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-指出下面程序的运行结果"><span class="nav-text">37 指出下面程序的运行结果:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-说说数据类型之间的转换"><span class="nav-text">38 说说数据类型之间的转换:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-如何实现字符串的反转及替换？"><span class="nav-text">39 如何实现字符串的反转及替换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><span class="nav-text">40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-日期和时间："><span class="nav-text">41 日期和时间：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-打印昨天的当前时刻。"><span class="nav-text">42 打印昨天的当前时刻。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-比较一下Java-和JavaSciprt。"><span class="nav-text">43 比较一下Java 和JavaSciprt。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-什么时候用assert？"><span class="nav-text">44 什么时候用assert？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-Error-和Exception-有什么区别"><span class="nav-text">45 Error 和Exception 有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-try-里-有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><span class="nav-text">46 try{}里 有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><span class="nav-text">47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-运行时异常与受检异常有何异同？"><span class="nav-text">48 运行时异常与受检异常有何异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-列出一些你常见的运行时异常？"><span class="nav-text">49 列出一些你常见的运行时异常？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-final-finally-finalize-的区别"><span class="nav-text">50 final, finally, finalize 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-Java跨平台原理（字节码文件、虚拟机）"><span class="nav-text">51 Java跨平台原理（字节码文件、虚拟机）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-Java三大版本"><span class="nav-text">52 Java三大版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-Java的安全性"><span class="nav-text">53. Java的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#53-1-语言层次的安全性主要体现在："><span class="nav-text">53.1 语言层次的安全性主要体现在：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-2-底层的安全性可以从以下方面来说明"><span class="nav-text">53.2 底层的安全性可以从以下方面来说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-什么是JVM？什么是JDK？-什么是JRE？"><span class="nav-text">54. 什么是JVM？什么是JDK？ 什么是JRE？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#54-1-JVM"><span class="nav-text">54.1 JVM :</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-2-JRE："><span class="nav-text">54.2 JRE：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-3-JDK："><span class="nav-text">54.3 JDK：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-4-JDK-JRE-JVM三者关系概括如下："><span class="nav-text">54.4 JDK,JRE,JVM三者关系概括如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-Java三种注释类型"><span class="nav-text">55 Java三种注释类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-i-和-i的异同之处"><span class="nav-text">56. i++和++i的异同之处</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#56-2-不同点："><span class="nav-text">56.2 不同点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-基本数据类型的类型转换规则"><span class="nav-text">57 基本数据类型的类型转换规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-if多分支语句和switch多分支语句的异同之处"><span class="nav-text">58 if多分支语句和switch多分支语句的异同之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-while和do-while循环的区别"><span class="nav-text">59. while和do-while循环的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-break和continue的作用"><span class="nav-text">60. break和continue的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-递归的定义和优缺点"><span class="nav-text">61. 递归的定义和优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-数组的特征"><span class="nav-text">62. .数组的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-请写出冒泡排序代码"><span class="nav-text">63. 请写出冒泡排序代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-请写出选择排序的代码"><span class="nav-text">64. 请写出选择排序的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-请写出插入排序的代码"><span class="nav-text">65. 请写出插入排序的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-类和对象的关系"><span class="nav-text">66. 类和对象的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-面向过程和面向对象的区别"><span class="nav-text">67. 面向过程和面向对象的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-方法重载和方法重写（覆盖）的区别"><span class="nav-text">68. 方法重载和方法重写（覆盖）的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-this和super关键字的作用"><span class="nav-text">69. this和super关键字的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-static关键字"><span class="nav-text">70. static关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-final和abstract关键字"><span class="nav-text">71.final和abstract关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-写出java-lang-Object类的六个常用方法"><span class="nav-text">72. 写出java.lang.Object类的六个常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-继承条件下构造方法的执行过程"><span class="nav-text">73. 继承条件下构造方法的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-和equals的区别和联系"><span class="nav-text">74.==和equals的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-谈谈Java的多态"><span class="nav-text">75. 谈谈Java的多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-简述Java的垃圾回收机制"><span class="nav-text">76. 简述Java的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#76-1显式回收垃圾回收的缺点："><span class="nav-text">76.1显式回收垃圾回收的缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#76-2-垃圾回收机制的-特点"><span class="nav-text">76.2 垃圾回收机制的 特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-基本数据类型和包装类"><span class="nav-text">77. 基本数据类型和包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#77-2-为什么为基本类型引入包装类"><span class="nav-text">77.2 为什么为基本类型引入包装类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77-3-包装类和基本数据类型之间的转换"><span class="nav-text">77.3 包装类和基本数据类型之间的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-Integer与int的区别"><span class="nav-text">78. Integer与int的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-java-sql-Date和java-util-Date的联系和区别"><span class="nav-text">79.java.sql.Date和java.util.Date的联系和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-使用递归算法输出某个目录下所有文件和子目录列表"><span class="nav-text">80. 使用递归算法输出某个目录下所有文件和子目录列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81-Java中接口的修饰符可以为（）（选择一项）"><span class="nav-text">81. Java中接口的修饰符可以为（）（选择一项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-为什么接口里面的属性必须是常量即final修饰-且静态即static修饰"><span class="nav-text">82. 为什么接口里面的属性必须是常量即final修饰, 且静态即static修饰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83-给定以下代码，程序将输出-（）（选择一项）"><span class="nav-text">83. 给定以下代码，程序将输出 （）（选择一项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-为什么说静态的不能访问非静态的，而非静态的能访问静态的？"><span class="nav-text">84. 为什么说静态的不能访问非静态的，而非静态的能访问静态的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85-选出合理的标识符（）（选择两项）"><span class="nav-text">85. 选出合理的标识符（）（选择两项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-面向对象的特征有哪些方面？请用生活中的例子来描述"><span class="nav-text">86. 面向对象的特征有哪些方面？请用生活中的例子来描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#87-说明内存泄漏和内存溢出的区别和联系"><span class="nav-text">87. 说明内存泄漏和内存溢出的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"><span class="nav-text">88.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89-不通过构造函数也能创建对象吗？"><span class="nav-text">89. 不通过构造函数也能创建对象吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-匿名内部类可不可以继承或实现接口。为什么？"><span class="nav-text">90. .匿名内部类可不可以继承或实现接口。为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><span class="nav-text">91. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-简述Java中如何实现多态"><span class="nav-text">92. 简述Java中如何实现多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-Java-中-Math-random（）-Math-random（）值为？"><span class="nav-text">93.Java 中 Math.random（）/Math.random（）值为？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><span class="nav-text">94. Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#95-接口和抽象类的区别"><span class="nav-text">95. 接口和抽象类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-同步代码块和同步方法有什么区别"><span class="nav-text">96. 同步代码块和同步方法有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97-静态内部类和内部类有什么区别"><span class="nav-text">97. 静态内部类和内部类有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-反射的概念与作用"><span class="nav-text">98.反射的概念与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#99-Java程序的种类有（）-多选"><span class="nav-text">99.Java程序的种类有（）(多选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100-下列标识符不合法的有（）-多选"><span class="nav-text">100. 下列标识符不合法的有（）(多选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-不能用来修饰interface的有（）-多选"><span class="nav-text">101. 不能用来修饰interface的有（）(多选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-下列说法错误的有（）-多选"><span class="nav-text">102. 下列说法错误的有（）(多选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103-下列说法错误的有（）-多选"><span class="nav-text">103. 下列说法错误的有（）(多选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-下列说法错误的有（）-多选"><span class="nav-text">104. 下列说法错误的有（）(多选)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-不通过-构造函数-也能创建对象么（）"><span class="nav-text">105. 不通过 构造函数 也能创建对象么（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><span class="nav-text">106. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-写一个Java正则，能过滤出html中的-lt-a-href-”url”-gt-title-lt-a-gt-形式中的链接地址和标题"><span class="nav-text">107.写一个Java正则，能过滤出html中的&lt; a href=”url”&gt;title&lt; /a&gt;形式中的链接地址和标题.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-Class类的getDeclaredFields-方法与getFields-的区别？"><span class="nav-text">108. Class类的getDeclaredFields()方法与getFields()的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？"><span class="nav-text">109. 在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><span class="nav-text">110.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-请解释以下常用正则含义：-d-D-s-0-9-6-d"><span class="nav-text">111. 请解释以下常用正则含义：\d,   \D,   \s,     .,      *,     ?,      |,     [0-9]{6},     \d+</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-下面那些声明是合法的？（）"><span class="nav-text">112 下面那些声明是合法的？（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-重载和重写区别"><span class="nav-text">113. 重载和重写区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-下面哪个函数是public-void-example-…-的重载函数？（）"><span class="nav-text">114. 下面哪个函数是public void example(){….}的重载函数？（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#115-打印结果："><span class="nav-text">115. 打印结果：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-指出下列程序的运行结果"><span class="nav-text">116. .指出下列程序的运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#117-什么是编译型语言，什么是解释型语言？java可以归类到那种？"><span class="nav-text">117. 什么是编译型语言，什么是解释型语言？java可以归类到那种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#118-下面代码执行后的输出是什么（）"><span class="nav-text">118. 下面代码执行后的输出是什么（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119-请问以下代码执行会打印出什么？"><span class="nav-text">119. 请问以下代码执行会打印出什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？"><span class="nav-text">120. 如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><span class="nav-text">121. 一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-如何将字符串2013-02-18-10-53-10转换为日期类型且格式化为：2013-02-18-10-53-10？"><span class="nav-text">122.如何将字符串2013-02-18 10:53:10转换为日期类型且格式化为：2013-02-18 10:53:10？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-下面哪些是对称加密算法（）"><span class="nav-text">123. 下面哪些是对称加密算法（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124-以下Java代码段会产生几个对象"><span class="nav-text">124. 以下Java代码段会产生几个对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-System-out-println-‘a’-1-的结果是"><span class="nav-text">125.System.out.println(‘a’+1);的结果是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#126-成员变量用static修饰和不用static修饰有什么区别？"><span class="nav-text">126. 成员变量用static修饰和不用static修饰有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-Java中关于super关键字的作用"><span class="nav-text">127. Java中关于super关键字的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><span class="nav-text">128. 如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129-Java反射技术主要实现类有哪些，作用分别是什么？"><span class="nav-text">129. Java反射技术主要实现类有哪些，作用分别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-反射的使用场合和作用、及其优缺点"><span class="nav-text">131. 反射的使用场合和作用、及其优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#132-面向对象设计原则有哪些"><span class="nav-text">132.面向对象设计原则有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-接口和抽象类有什么区别？"><span class="nav-text">133 接口和抽象类有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#134-抽象类能使用-final-修饰吗？"><span class="nav-text">134 抽象类能使用 final 修饰吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#135-普通类和抽象类有哪些区别？"><span class="nav-text">135 普通类和抽象类有哪些区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#136抽象类必须要有抽象方法吗？"><span class="nav-text">136抽象类必须要有抽象方法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#137-final-在-Java-中有什么作用？"><span class="nav-text">137 final 在 Java 中有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#138-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><span class="nav-text">138 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-和-equals-的区别是什么？"><span class="nav-text">139 == 和 equals 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#140-JDK-和-JRE-有什么区别？"><span class="nav-text">140 JDK 和 JRE 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><span class="nav-text">141 ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-是否可以在static环境中访问非static变量？"><span class="nav-text">142 是否可以在static环境中访问非static变量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#143-Java支持的数据类型有哪些？什么是自动拆装箱？"><span class="nav-text">143 .Java支持的数据类型有哪些？什么是自动拆装箱？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？—-68题"><span class="nav-text">144 Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？—-68题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><span class="nav-text">145 Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-Java支持多继承么？"><span class="nav-text">146 Java支持多继承么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#147-接口和抽象类的区别是什么？"><span class="nav-text">147 接口和抽象类的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-什么是值传递和引用传递？"><span class="nav-text">148 什么是值传递和引用传递？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、String"><span class="nav-text">二、String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-下面程序的运行结果是（）（选择一项）"><span class="nav-text">1. 下面程序的运行结果是（）（选择一项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Java语言中，String类中的indexOf-方法返回值的类型是（）"><span class="nav-text">2. Java语言中，String类中的indexOf( )方法返回值的类型是（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-给定以下代码，程序的运行结果是-（）（选择一项）——-gt-易错题"><span class="nav-text">3. 给定以下代码，程序的运行结果是 （）（选择一项）——&gt;易错题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-执行下列代码后，哪个结论是正确的（）（选择两项）"><span class="nav-text">4. 执行下列代码后，哪个结论是正确的（）（选择两项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-实现String类的replaceAll方法"><span class="nav-text">5. 实现String类的replaceAll方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-在“-”后填写适当的内容："><span class="nav-text">6. 在“=”后填写适当的内容：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-是否可以继承String类"><span class="nav-text">7. 是否可以继承String类?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-给定两个字符串s和t，-写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。"><span class="nav-text">8. 给定两个字符串s和t， 写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-String-s-new-String-“abc”-创建了几个String对象。"><span class="nav-text">9. String s = new String(“abc”);创建了几个String对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-输出结果？"><span class="nav-text">10. 输出结果？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-下面哪个是正确的（）"><span class="nav-text">11. 下面哪个是正确的（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-已知如下代码：执行结果是什么（）"><span class="nav-text">12. 已知如下代码：执行结果是什么（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-字符串如何转换为int类型"><span class="nav-text">13. 字符串如何转换为int类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-写一个方法，实现字符串的反转，如：输入abc，输出cba"><span class="nav-text">14. 写一个方法，实现字符串的反转，如：输入abc，输出cba</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-编写java，将“I-follow-Bill-Gate-Tom-Gate-John-Gate”中的“Gate”全部替换为“Gates”"><span class="nav-text">15. 编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-String-是最基本的数据类型吗"><span class="nav-text">16. String 是最基本的数据类型吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-String-和StringBuilder、StringBuffer-的区别"><span class="nav-text">17. String 和StringBuilder、StringBuffer 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-String类为什么是final的"><span class="nav-text">18. String类为什么是final的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-String-s-”Hello”-s-s-”world-”-执行后，是否是对前面s指向空间内容的修改？"><span class="nav-text">19. String s=”Hello”;s=s+”world!”;执行后，是否是对前面s指向空间内容的修改？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><span class="nav-text">20. 下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-String-类的常用方法都有那些？"><span class="nav-text">21. String 类的常用方法都有那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-如何将字符串反转？"><span class="nav-text">22. 如何将字符串反转？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-String-str-”i”与-String-str-new-String-“i”-一样吗？"><span class="nav-text">23. String str=”i”与 String str=new String(“i”)一样吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-Java-中操作字符串都有哪些类？它们之间有什么区别？"><span class="nav-text">24. Java 中操作字符串都有哪些类？它们之间有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-String-属于基础的数据类型吗？"><span class="nav-text">25.  String 属于基础的数据类型吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、集合"><span class="nav-text">三、集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Java集合体系结构（List、Set、Collection、Map的区别和联系）"><span class="nav-text">1. Java集合体系结构（List、Set、Collection、Map的区别和联系）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Vector和ArrayList的区别和联系"><span class="nav-text">2. Vector和ArrayList的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ArrayList和LinkedList的区别和联系"><span class="nav-text">3. ArrayList和LinkedList的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Array-和-ArrayList-有何区别？"><span class="nav-text">4. Array 和 ArrayList 有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-HashSet的使用和原理（hashCode-和equals-）"><span class="nav-text">5. HashSet的使用和原理（hashCode()和equals()）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-TreeSet的原理和使用（Comparable和comparator）"><span class="nav-text">6. TreeSet的原理和使用（Comparable和comparator）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-集合和数组的比较（为什么引入集合）"><span class="nav-text">7. 集合和数组的比较（为什么引入集合）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Collection和Collections的区别"><span class="nav-text">8. Collection和Collections的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-下列说法正确的有（）（选择一项）"><span class="nav-text">9. 下列说法正确的有（）（选择一项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？"><span class="nav-text">10. Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-列出Java中的集合类层次结构？"><span class="nav-text">11. 列出Java中的集合类层次结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-List，Set，Map各有什么特点"><span class="nav-text">12. List，Set，Map各有什么特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-合并两个有序的链表"><span class="nav-text">13.合并两个有序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-用递归方式实现链表的转置。"><span class="nav-text">14. 用递归方式实现链表的转置。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。"><span class="nav-text">15. 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><span class="nav-text">16. Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？"><span class="nav-text">17. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><span class="nav-text">18. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Java-util-Map的实现类有"><span class="nav-text">19. Java.util.Map的实现类有</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-List里面如何剔除相同的对象？请简单用代码实现一种方法"><span class="nav-text">20. List里面如何剔除相同的对象？请简单用代码实现一种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-List、Set、Map-是否继承自Collection-接口？"><span class="nav-text">21. List、Set、Map 是否继承自Collection 接口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-说出ArrayList、Vector、LinkedList-的存储性能和特性？"><span class="nav-text">22. 说出ArrayList、Vector、LinkedList 的存储性能和特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-List、Map、Set-三个接口，存取元素时，各有什么特点？"><span class="nav-text">23. List、Map、Set 三个接口，存取元素时，各有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><span class="nav-text">24. TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-HashMap和Hashtable的区别和联"><span class="nav-text">25. HashMap和Hashtable的区别和联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-如何实现数组和-List-之间的转换？"><span class="nav-text">26. 如何实现数组和 List 之间的转换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-说一下-HashSet-的实现原理？"><span class="nav-text">27. 说一下 HashSet 的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-说一下-HashMap-的实现原理？"><span class="nav-text">28. 说一下 HashMap 的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29如何决定使用-HashMap-还是-TreeMap？"><span class="nav-text">29如何决定使用 HashMap 还是 TreeMap？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-HashMap-和-Hashtable-有什么区别？"><span class="nav-text">30 HashMap 和 Hashtable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-List、Set、Map-之间的区别是什么？"><span class="nav-text">31. List、Set、Map 之间的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-Collection-和-Collections-有什么区别？"><span class="nav-text">32. Collection 和 Collections 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-Java-容器都有哪些？"><span class="nav-text">33. Java 容器都有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34Java集合类框架的基本接口有哪些？"><span class="nav-text">34Java集合类框架的基本接口有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-为什么集合类没有实现Cloneable和Serializable接口？"><span class="nav-text">35 为什么集合类没有实现Cloneable和Serializable接口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-什么是迭代器-Iterator-？"><span class="nav-text">36 什么是迭代器(Iterator)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-Iterator和ListIterator的区别是什么？"><span class="nav-text">37 Iterator和ListIterator的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><span class="nav-text">38. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Java中的HashMap的工作原理是什么？"><span class="nav-text">39. Java中的HashMap的工作原理是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、多线程"><span class="nav-text">四、多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-下面程序的运行结果（）（选择一项）"><span class="nav-text">4.1 下面程序的运行结果（）（选择一项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-下列哪个方法可用于创建一个可运行的类（）"><span class="nav-text">4.2 下列哪个方法可用于创建一个可运行的类（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-说说乐观锁与悲观锁"><span class="nav-text">4.3 说说乐观锁与悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-在Java中怎么实现多线程-描述线程状态的变化过程。"><span class="nav-text">4.4 在Java中怎么实现多线程?描述线程状态的变化过程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-请写出多线程代码使用Thread或者Runnable，并说出两种的区别。"><span class="nav-text">4.5 请写出多线程代码使用Thread或者Runnable，并说出两种的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-在多线程编程里，wait方法的调用方式是怎样的？"><span class="nav-text">4.6 在多线程编程里，wait方法的调用方式是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-Java线程的几种状态"><span class="nav-text">4.7 Java线程的几种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（）"><span class="nav-text">4.8 在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-volatile关键字是否能保证线程安全？"><span class="nav-text">4.9 volatile关键字是否能保证线程安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？"><span class="nav-text">4.10 请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-关于sleep-和wait-，以下描述错误的一项是（）"><span class="nav-text">4.11 关于sleep()和wait()，以下描述错误的一项是（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-进程和线程的区别是什么？"><span class="nav-text">4.12 进程和线程的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-13-以下锁机机制中，不能保证线程安全的是（）"><span class="nav-text">4.13 以下锁机机制中，不能保证线程安全的是（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-14-创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><span class="nav-text">4.14 创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-15-同步和异步有何异同，在什么情况下分别使用它们？"><span class="nav-text">4.15 同步和异步有何异同，在什么情况下分别使用它们？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-16-Java线程中，sleep-和wait-区别"><span class="nav-text">4.16 Java线程中，sleep()和wait()区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-17-sleep-和yield-有什么区别"><span class="nav-text">4.17 sleep()和yield()有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-18-下面所述步骤中，是创建进程做必须的步骤是（）"><span class="nav-text">4.18 下面所述步骤中，是创建进程做必须的步骤是（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-19-无锁化编程有哪些常见方法？（）"><span class="nav-text">4.19 无锁化编程有哪些常见方法？（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-20-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？"><span class="nav-text">4.20 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-21-请说出与线程同步相关的方法。"><span class="nav-text">4.21 请说出与线程同步相关的方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-22-编写多线程程序有几种实现方式？"><span class="nav-text">4.22 编写多线程程序有几种实现方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-23-synchronized关键字的用法？"><span class="nav-text">4.23 synchronized关键字的用法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-24-启动一个线程是用run-还是start-方法"><span class="nav-text">4.24 启动一个线程是用run()还是start()方法?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-25-什么是线程池（thread-pool）？"><span class="nav-text">4.25 什么是线程池（thread pool）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-26-线程的基本状态以及状态之间的关系？"><span class="nav-text">4.26 线程的基本状态以及状态之间的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-27-简述synchronized-和java-util-concurrent-locks-Lock的异同？"><span class="nav-text">4.27 简述synchronized 和java.util.concurrent.locks.Lock的异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-28-创建线程的两种方式分别是什么-优缺点是什么？"><span class="nav-text">4.28 创建线程的两种方式分别是什么,优缺点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-29-Java创建线程后，调用start-方法和run-的区别"><span class="nav-text">4.29 Java创建线程后，调用start( )方法和run( )的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-30-线程的生命周期"><span class="nav-text">4.30 线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-31-如何实现线程同步？"><span class="nav-text">4.31 如何实现线程同步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-32-说说关于同步锁的更多细节"><span class="nav-text">4.32 说说关于同步锁的更多细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-33-Java中实现线程通信的三个方法的作用是什么？"><span class="nav-text">4.33  Java中实现线程通信的三个方法的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-44-进程和线程的区别是什么？"><span class="nav-text">4.44 进程和线程的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-45-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><span class="nav-text">4.45 创建线程有几种不同的方式？你喜欢哪一种？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-46-同步方法和同步代码块的区别是什么？"><span class="nav-text">4.46 同步方法和同步代码块的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-47-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><span class="nav-text">4.47 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-48什么是死锁-deadlock-？"><span class="nav-text">4.48什么是死锁(deadlock)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-49-如何确保N个线程可以访问N个资源同时又不导致死锁？"><span class="nav-text">4.49 如何确保N个线程可以访问N个资源同时又不导致死锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、IO流"><span class="nav-text">五、IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-说说BIO、NIO和AIO的区别"><span class="nav-text">5.1 说说BIO、NIO和AIO的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Files的常用方法都有哪些？"><span class="nav-text">5.2 Files的常用方法都有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-BIO、NIO、AIO-有什么区别？"><span class="nav-text">5.3 BIO、NIO、AIO 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Java-中-IO-流分为几种？"><span class="nav-text">5.4 Java 中 IO 流分为几种？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、堆和栈"><span class="nav-text">六、堆和栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-简述堆和栈的区别"><span class="nav-text">6.1 简述堆和栈的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-小结："><span class="nav-text">6.2 小结：</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zwq</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">714k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">10:49</span>
  
</div>


<!--

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div>

-->


<div>





<div>
<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
  本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
</span>
<span id="busuanzi_container_site_pv">
    &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
</div>
</div>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
<div class="BbeiAn-info" style="color:#4dfc23">
   	鄂ICP备 -
    <a target="_blank" href="http://www.beian.miit.gov.cn/" style="color:#4dfc23;" rel="nofollow">18025394</a> <!--a标签中增加nofollow属性，避免爬虫出站。-->| 
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42090202000295" style="text-decoration:none;color:#4dfc23;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">鄂公网安备 42090202000295</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>
        








        
      </div>
    </div></footer>

    

    

    

    
      <div>
        <div class="addthis_inline_share_toolbox">
  <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c8a5801582888d6" async="async"></script>
</div>

      </div>
    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: false,
    appId: 'BMBxkYUDumKWDR3FTQCAY7R1-gzGzoHsz',
    appKey: 'yd7o7KS9MjFPCTGAGOpErnWy',
    placeholder: 'Hello !',
    avatar: 'wavatar',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  
  
  
  <script src="/lib/bookmark/bookmark.min.js?v=1.0"></script>
  <script>
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

  
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/click-love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":70,"height":120},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
